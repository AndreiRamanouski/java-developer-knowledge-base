## Overview

Master Git's branching and merging capabilities to manage complex Java projects effectively. This guide covers real-world workflows used in professional software development.

```
┌────────────────────────────────────────────────────────┐
│              BRANCHING STRATEGIES                      │
├────────────────────────────────────────────────────────┤
│                                                        │
│  Git Flow:        Multiple long-lived branches        │
│  main ──────────────────────────────────────→         │
│    ↑                                                   │
│    └── release ────────────→                          │
│           ↑                                            │
│           └── develop ──────────────────→             │
│                  ↑      ↑                              │
│                  │      └── feature-2 ──→             │
│                  └── feature-1 ──→                    │
│                                                        │
│  GitHub Flow:     Simple, main + features             │
│  main ──────────────────────────────────────→         │
│    ↑      ↑      ↑                                    │
│    │      │      └── feature-3 ──→                   │
│    │      └── feature-2 ──→                          │
│    └── feature-1 ──→                                 │
│                                                        │
│  Trunk-Based:     Very short-lived branches           │
│  main ──────────────────────────────────────→         │
│    ↑  ↑  ↑  ↑                                        │
│    │  │  │  └── fix-4 (1 day)                       │
│    │  │  └── feature-3 (2 days)                     │
│    │  └── feature-2 (1 day)                         │
│    └── feature-1 (3 hours)                          │
│                                                        │
└────────────────────────────────────────────────────────┘
```

---

## 1. Branching Strategies

### Git Flow (Feature, Develop, Release, Hotfix, Main)

Git Flow is a comprehensive branching model with multiple long-lived branches.

**Branch structure:**

```
┌─────────────────────────────────────────────────────────┐
│                    GIT FLOW MODEL                       │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  main (production)                                      │
│  ─────●─────────────────────●─────────────────●──→     │
│        ↑                     ↑                 ↑        │
│        │                     │                 │        │
│  hotfix-1.2.1 ──●           │                 │        │
│        └────────┘            │                 │        │
│                              │                 │        │
│  release/1.2.0 ──────────────●                │        │
│        ↑                     │                 │        │
│        │                     │                 │        │
│  develop                     │                 │        │
│  ──●───●───●───●───●───●────●───●───●───●────●──→     │
│     ↑   ↑   ↑   ↑   ↑   ↑       ↑   ↑   ↑             │
│     │   │   │   │   │   │       │   │   │             │
│  feature/auth ──●───●──┘│       │   │   │             │
│                          │       │   │   │             │
│  feature/payment ────────●───●──┘   │   │             │
│                                      │   │             │
│  feature/dashboard ──────────────────●──┘             │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

**Branch types:**

1. **main** (or master)
    
    - Production-ready code
    - Every commit is a release
    - Tagged with version numbers (v1.0.0, v1.1.0)
    - Never commit directly to main
2. **develop**
    
    - Integration branch for features
    - Latest delivered development changes
    - Base for feature branches
    - Nightly builds run from here
3. **feature/** branches
    
    - New features or enhancements
    - Branch from: develop
    - Merge back to: develop
    - Naming: feature/user-authentication, feature/payment-gateway
    - Lifetime: Days to weeks
4. **release/** branches
    
    - Preparation for production release
    - Branch from: develop
    - Merge to: main AND develop
    - Naming: release/1.2.0
    - Lifetime: Hours to days
    - Only bug fixes, no new features
5. **hotfix/** branches
    
    - Emergency fixes for production
    - Branch from: main
    - Merge to: main AND develop
    - Naming: hotfix/1.2.1
    - Lifetime: Hours

**Git Flow workflow:**

```bash
# Initial setup
git checkout -b develop main

# ─────────────────────────────────────────
# Starting a feature
# ─────────────────────────────────────────
git checkout -b feature/user-authentication develop

# Work on feature
vim src/main/java/auth/AuthService.java
git add .
git commit -m "feat: Implement JWT authentication"

# Continue development
git commit -m "feat: Add login endpoint"
git commit -m "test: Add authentication tests"

# Finish feature
git checkout develop
git merge --no-ff feature/user-authentication
git branch -d feature/user-authentication
git push origin develop

# ─────────────────────────────────────────
# Starting a release
# ─────────────────────────────────────────
git checkout -b release/1.2.0 develop

# Make release-specific changes
vim pom.xml  # Update version to 1.2.0
git commit -m "chore: Bump version to 1.2.0"

# Bug fixes during release
git commit -m "fix: Handle null pointer in auth"

# Finish release
git checkout main
git merge --no-ff release/1.2.0
git tag -a v1.2.0 -m "Release version 1.2.0"

git checkout develop
git merge --no-ff release/1.2.0
git branch -d release/1.2.0

git push origin main
git push origin develop
git push origin v1.2.0

# ─────────────────────────────────────────
# Hotfix for production
# ─────────────────────────────────────────
git checkout -b hotfix/1.2.1 main

# Fix critical bug
vim src/main/java/payment/PaymentService.java
git commit -m "fix: Prevent duplicate payments"

# Update version
vim pom.xml  # Change to 1.2.1
git commit -m "chore: Bump version to 1.2.1"

# Finish hotfix
git checkout main
git merge --no-ff hotfix/1.2.1
git tag -a v1.2.1 -m "Hotfix 1.2.1"

git checkout develop
git merge --no-ff hotfix/1.2.1
git branch -d hotfix/1.2.1

git push origin main
git push origin develop
git push origin v1.2.1
```

**Java project example with Git Flow:**

```xml
<!-- pom.xml version management -->
<project>
    <groupId>com.example</groupId>
    <artifactId>myapp</artifactId>
    <version>1.2.0-SNAPSHOT</version>  <!-- develop branch -->
    <!-- or -->
    <version>1.2.0</version>           <!-- main branch -->
</project>
```

**When to use Git Flow:**

- ✅ Large teams (10+ developers)
- ✅ Scheduled releases (every sprint, monthly)
- ✅ Multiple versions in production (support old versions)
- ✅ Strict QA process before release
- ✅ Desktop software, mobile apps
- ❌ Continuous deployment
- ❌ Small teams
- ❌ Web applications with frequent deployments

---

### GitHub Flow (Simplified: Main + Feature Branches)

GitHub Flow is a simplified workflow with only main and feature branches.

**Branch structure:**

```
┌─────────────────────────────────────────────────────────┐
│                  GITHUB FLOW MODEL                      │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  main (always deployable)                               │
│  ──●───────●────────●───────●────────●──────●──→       │
│     ↑       ↑        ↑       ↑        ↑      ↑         │
│     │       │        │       │        │      │         │
│  feature/A ●──●─────┘│       │        │      │         │
│               (PR)    │       │        │      │         │
│                       │       │        │      │         │
│  feature/B ───────────●──●───┘        │      │         │
│                       (PR)             │      │         │
│                                        │      │         │
│  hotfix/urgent ────────────────────────●─────┘         │
│                                        (PR)             │
│                                                         │
│  feature/C ────────────────────────────────────●───→   │
│                                               (PR)      │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

**Workflow:**

```bash
# ─────────────────────────────────────────
# 1. Create feature branch from main
# ─────────────────────────────────────────
git checkout main
git pull origin main
git checkout -b feature/add-payment-gateway

# ─────────────────────────────────────────
# 2. Work on feature with frequent commits
# ─────────────────────────────────────────
git add .
git commit -m "feat: Add Stripe integration"

git commit -m "feat: Implement payment webhook"

git commit -m "test: Add payment integration tests"

# ─────────────────────────────────────────
# 3. Push and create Pull Request
# ─────────────────────────────────────────
git push origin feature/add-payment-gateway

# Create PR on GitHub
# - Add description
# - Request reviewers
# - Link to issue (#123)
# - CI/CD runs automatically

# ─────────────────────────────────────────
# 4. Address review comments
# ─────────────────────────────────────────
# Make changes based on feedback
git add .
git commit -m "refactor: Extract payment logic to service"
git push origin feature/add-payment-gateway

# ─────────────────────────────────────────
# 5. Merge to main (via PR)
# ─────────────────────────────────────────
# Once approved and CI passes:
# - Merge pull request (GitHub UI)
# - Choose merge strategy (merge commit, squash, rebase)
# - Delete feature branch

# ─────────────────────────────────────────
# 6. Deploy to production
# ─────────────────────────────────────────
# Automatic deployment from main branch
# Or manual deployment trigger

# ─────────────────────────────────────────
# 7. Clean up local branch
# ─────────────────────────────────────────
git checkout main
git pull origin main
git branch -d feature/add-payment-gateway
```

**Pull Request best practices:**

```markdown
## Pull Request Template

### Description
Brief description of changes

### Type of Change
- [ ] Bug fix
- [ ] New feature
- [ ] Breaking change
- [ ] Documentation update

### Related Issues
Closes #123
Related to #456

### Changes Made
- Added Stripe payment integration
- Implemented webhook handler
- Added integration tests

### Testing
- [ ] Unit tests pass
- [ ] Integration tests pass
- [ ] Manual testing completed

### Screenshots (if applicable)
[Add screenshots here]

### Checklist
- [ ] Code follows project style guidelines
- [ ] Self-review completed
- [ ] Comments added for complex code
- [ ] Documentation updated
- [ ] No new warnings generated
```

**When to use GitHub Flow:**

- ✅ Small to medium teams
- ✅ Continuous deployment
- ✅ Web applications
- ✅ SaaS products
- ✅ Fast iteration needed
- ✅ Single version in production
- ❌ Need to support multiple production versions
- ❌ Scheduled releases
- ❌ Long QA cycles

---

### Trunk-Based Development (Short-lived Branches)

Trunk-Based Development emphasizes keeping branches very short-lived (hours to a couple of days).

**Branch structure:**

```
┌─────────────────────────────────────────────────────────┐
│            TRUNK-BASED DEVELOPMENT MODEL                │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  main (trunk) - Always deployable                       │
│  ──●─●─●─●─●─●─●─●─●─●─●─●─●─●─●─●─●─●─●─●──→         │
│     ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑                               │
│     │ │ │ │ │ │ │ │ │ │                               │
│  Small feature branches (merge same day)                │
│     │ │ │ │ │ │ │ │ │ │                               │
│  feature-1 ●─┘│ │ │ │ │ │ │ │ (3 hours)              │
│  feature-2 ──●─┘ │ │ │ │ │ │ (5 hours)              │
│  fix-1 ────────●─┘ │ │ │ │ │ (1 hour)               │
│  feature-3 ──────●─┘ │ │ │ │ (4 hours)              │
│  feature-4 ────────●─┘ │ │ │ (6 hours)              │
│  fix-2 ──────────────●─┘ │ │ (2 hours)              │
│  feature-5 ────────────●─┘ │ (8 hours)              │
│  feature-6 ──────────────●─┘ (1 day)                 │
│                                                         │
│  Feature Flags: Deploy incomplete features disabled     │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

**Key principles:**

1. **Commit to trunk frequently** (multiple times per day)
2. **Short-lived branches** (< 1 day)
3. **Feature flags** for incomplete features
4. **Comprehensive automated testing**
5. **Continuous integration**

**Workflow:**

```bash
# ─────────────────────────────────────────
# 1. Pull latest from trunk
# ─────────────────────────────────────────
git checkout main
git pull origin main

# ─────────────────────────────────────────
# 2. Create short-lived branch
# ─────────────────────────────────────────
git checkout -b add-user-validation

# ─────────────────────────────────────────
# 3. Make small, focused change
# ─────────────────────────────────────────
vim src/main/java/User.java
git add .
git commit -m "feat: Add email validation to User"

# ─────────────────────────────────────────
# 4. Push and create PR immediately
# ─────────────────────────────────────────
git push origin add-user-validation
# Create PR (should be merged within hours)

# ─────────────────────────────────────────
# 5. Merge quickly (same day)
# ─────────────────────────────────────────
# After CI passes and quick review
git checkout main
git pull origin main
git branch -d add-user-validation

# ─────────────────────────────────────────
# Alternative: Commit directly to main
# ─────────────────────────────────────────
# For very small changes
git checkout main
git pull origin main

# Make change
vim src/main/java/Constants.java
git add .
git commit -m "chore: Update API endpoint URL"
git push origin main
```

**Feature flags for trunk-based development:**

```java
// Use feature flags to hide incomplete features
@Service
public class PaymentService {
    
    @Value("${features.new-payment-flow.enabled}")
    private boolean newPaymentFlowEnabled;
    
    public PaymentResult processPayment(PaymentRequest request) {
        if (newPaymentFlowEnabled) {
            // New implementation (in development)
            return processPaymentV2(request);
        } else {
            // Old implementation (stable)
            return processPaymentV1(request);
        }
    }
}
```

```yaml
# application.yml
features:
  new-payment-flow:
    enabled: false  # Disable in production until ready

# application-dev.yml
features:
  new-payment-flow:
    enabled: true   # Enable in development
```

**When to use Trunk-Based Development:**

- ✅ Elite engineering teams
- ✅ Strong automated testing
- ✅ Fast deployment pipeline
- ✅ Continuous deployment
- ✅ Small, cohesive teams
- ✅ High trust environment
- ❌ Junior developers without good practices
- ❌ Weak CI/CD pipeline
- ❌ No automated testing
- ❌ Large, distributed teams

---

### When to Use Which Strategy

**Decision matrix:**

|Factor|Git Flow|GitHub Flow|Trunk-Based|
|---|---|---|---|
|**Team Size**|Large (10+)|Small-Medium (2-10)|Small (2-8)|
|**Release Cycle**|Scheduled (sprint, monthly)|Continuous|Continuous|
|**Deployment**|Manual, scheduled|Automated on merge|Automated, multiple/day|
|**Testing**|Manual QA + Automated|Automated + Review|Comprehensive automated|
|**Branch Lifetime**|Days to weeks|Days to week|Hours to 1-2 days|
|**Complexity**|High|Medium|Low|
|**Production Versions**|Multiple|Single|Single|
|**Best For**|Enterprise software|Web apps, SaaS|High-performance teams|

**Recommendation for Java projects:**

```
Small team (< 5), web application:
→ GitHub Flow

Medium team (5-15), scheduled releases:
→ Git Flow

Large team (15+), microservices, CI/CD:
→ Trunk-Based with feature flags

Enterprise, multiple versions:
→ Git Flow
```

---

## 2. Branch Operations

### Creating and Switching Branches

**Basic branch operations:**

```bash
# ─────────────────────────────────────────
# Creating branches
# ─────────────────────────────────────────

# Create branch (don't switch)
git branch feature/authentication

# Create and switch to branch
git checkout -b feature/authentication

# Modern way (Git 2.23+)
git switch -c feature/authentication

# Create branch from specific commit
git branch feature/fix 9a8b7c6
git checkout -b feature/fix 9a8b7c6

# Create branch from tag
git checkout -b hotfix/1.2.1 v1.2.0

# ─────────────────────────────────────────
# Switching branches
# ─────────────────────────────────────────

# Old way
git checkout main
git checkout feature/authentication

# New way (Git 2.23+)
git switch main
git switch feature/authentication

# Switch to previous branch
git checkout -
git switch -

# ─────────────────────────────────────────
# List branches
# ─────────────────────────────────────────

# Local branches
git branch
git branch -l

# All branches (local + remote)
git branch -a

# Remote branches only
git branch -r

# Verbose (show last commit)
git branch -v
# * main        a1b2c3d Update README
#   feature/auth 9a8b7c6 Add JWT auth

# Very verbose (show tracking branches)
git branch -vv
# * main        a1b2c3d [origin/main] Update README
#   feature/auth 9a8b7c6 [origin/feature/auth: ahead 2] Add JWT

# Branches with specific pattern
git branch --list "feature/*"
# feature/authentication
# feature/payment
# feature/dashboard
```

**Branch naming conventions:**

```bash
# Good naming patterns:

# Feature branches
feature/user-authentication
feature/payment-gateway
feature/email-notifications

# Bug fix branches
fix/null-pointer-exception
fix/memory-leak
bugfix/login-error

# Hotfix branches
hotfix/1.2.1
hotfix/security-patch

# Release branches
release/1.2.0
release/2024-Q1

# Experiment branches
experiment/new-algorithm
experiment/redis-cache
spike/performance-test

# Refactoring branches
refactor/extract-service
refactor/simplify-controller

# Documentation branches
docs/api-documentation
docs/deployment-guide

# Issue-based naming (with ticket number)
feature/JIRA-123-user-profile
fix/JIRA-456-payment-bug
```

### Tracking Remote Branches

**Understanding remote branches:**

```bash
# Fetch remote branches
git fetch origin

# List remote branches
git branch -r
# origin/main
# origin/develop
# origin/feature/authentication

# Create local branch tracking remote
git checkout -b feature/authentication origin/feature/authentication
# or shorter (Git auto-tracks)
git checkout feature/authentication

# Modern way
git switch -c feature/authentication origin/feature/authentication
git switch feature/authentication  # Auto-tracks

# Set upstream for existing branch
git branch --set-upstream-to=origin/main main
# or
git branch -u origin/main main

# Push and set upstream
git push -u origin feature/authentication

# View tracking relationships
git branch -vv
# * main                a1b2c3d [origin/main] Latest
#   feature/auth        9a8b7c6 [origin/feature/auth: ahead 2] Work
#   feature/payment     7a6b5c4 [origin/feature/payment: behind 1]

# Sync with remote (fetch + merge)
git pull origin main

# Sync all branches
git fetch --all
git pull --all
```

**Working with remote branches:**

```bash
# Fetch updates from remote
git fetch origin

# View what changed
git log main..origin/main
git diff main origin/main

# Update local branch
git checkout main
git pull origin main

# Or rebase instead of merge
git pull --rebase origin main

# Push local branch to remote
git push origin feature/authentication

# Push all branches
git push origin --all

# Push with force (dangerous!)
git push --force origin feature/authentication
# Better: force with lease (safer)
git push --force-with-lease origin feature/authentication

# Delete remote branch (after merge)
git push origin --delete feature/authentication

# Prune deleted remote branches
git fetch --prune
git fetch -p

# Or configure automatic pruning
git config --global fetch.prune true
```

### Deleting Branches

**Deleting local branches:**

```bash
# Delete merged branch
git branch -d feature/authentication
# error: The branch 'feature/authentication' is not fully merged.

# Force delete (even if not merged)
git branch -D feature/authentication

# Delete multiple branches
git branch -d feature/auth feature/payment

# Delete all merged branches except main
git branch --merged main | grep -v "main" | xargs git branch -d

# Delete all branches matching pattern
git branch | grep "feature/*" | xargs git branch -d

# Delete branches older than X days (requires script)
git for-each-ref --format='%(refname:short) %(committerdate:unix)' refs/heads/ |
  awk -v date=$(date -d "30 days ago" +%s) '$2 < date {print $1}' |
  xargs git branch -D
```

**Deleting remote branches:**

```bash
# Delete remote branch
git push origin --delete feature/authentication

# Alternative syntax
git push origin :feature/authentication

# Delete multiple remote branches
git push origin --delete feature/auth feature/payment

# Clean up remote-tracking references
git fetch --prune
git remote prune origin

# List remote branches that are merged
git branch -r --merged origin/main
# origin/feature/auth
# origin/feature/payment

# Delete merged remote branches (manual)
git push origin --delete feature/auth
git push origin --delete feature/payment
```

**Safe deletion workflow:**

```bash
# 1. Check if branch is merged
git branch --merged main
# feature/authentication  (safe to delete)

# 2. Delete local branch
git branch -d feature/authentication

# 3. Delete remote branch
git push origin --delete feature/authentication

# 4. Verify deletion
git branch -a
# Should not show deleted branch

# 5. Clean up remote references
git fetch --prune
```

### Renaming Branches

**Rename local branch:**

```bash
# Rename current branch
git branch -m new-name

# Rename another branch
git branch -m old-name new-name

# Example: Rename feature branch
git checkout feature/auth
git branch -m feature/authentication

# Or from another branch
git branch -m feature/auth feature/authentication
```

**Rename remote branch:**

```bash
# Steps to rename remote branch:

# 1. Rename local branch
git branch -m old-name new-name

# 2. Delete old remote branch
git push origin --delete old-name

# 3. Push new branch and set upstream
git push origin -u new-name

# Example workflow:
git branch -m feature/auth feature/user-authentication
git push origin --delete feature/auth
git push origin -u feature/user-authentication
```

**Rename main branch:**

```bash
# Rename local main branch
git branch -m master main

# Update upstream
git push -u origin main

# Update HEAD reference on remote
git push origin --delete master

# Update all developers
# Each developer needs to run:
git checkout master
git branch -m master main
git fetch origin
git branch -u origin/main main
git remote set-head origin -a
```

---

## 3. Merging Strategies

### Fast-Forward Merge (When Possible)

Fast-forward merge moves the branch pointer forward without creating a merge commit.

**When fast-forward is possible:**

```
Before merge:
main:     A---B---C
                   \
feature:            D---E

After fast-forward merge:
main:     A---B---C---D---E
feature:                  ↑ (both point here)
```

**Fast-forward example:**

```bash
# Create and work on feature
git checkout -b feature/add-logging
git commit -m "Add logging framework"
git commit -m "Add log statements"

# Meanwhile, no commits to main

# Merge with fast-forward
git checkout main
git merge feature/add-logging
# Output: Updating a1b2c3d..9a8b7c6
# Fast-forward
#  pom.xml                    | 5 +++++
#  src/main/java/Logger.java  | 15 +++++++++++++++
#  2 files changed, 20 insertions(+)

# History is linear
git log --oneline --graph
# * 9a8b7c6 (HEAD -> main, feature/add-logging) Add log statements
# * 8a7b6c5 Add logging framework
# * a1b2c3d Initial commit
```

**Advantages:**

- ✅ Clean, linear history
- ✅ Easy to understand
- ✅ No extra merge commit

**Disadvantages:**

- ❌ Loses information about feature branch
- ❌ Can't see logical grouping of commits

**Force no fast-forward:**

```bash
# Create merge commit even when fast-forward is possible
git merge --no-ff feature/add-logging

# History shows merge commit
git log --oneline --graph
# *   b1c2d3e (HEAD -> main) Merge branch 'feature/add-logging'
# |\  
# | * 9a8b7c6 (feature/add-logging) Add log statements
# | * 8a7b6c5 Add logging framework
# |/  
# * a1b2c3d Initial commit

# Benefits:
# - Preserves feature branch history
# - Shows logical grouping
# - Easy to revert entire feature
```

---

### Recursive Merge (Three-Way Merge)

When branches have diverged, Git performs a three-way merge and creates a merge commit.

**When three-way merge happens:**

```
Before merge:
main:     A---B---C---D
               \
feature:        E---F---G

After three-way merge:
main:     A---B---C---D---M
               \         /
feature:        E---F---G
                
M = merge commit (has two parents)
```

**Three-way merge example:**

```bash
# Scenario: Feature branch and main both have new commits

# On feature branch
git checkout -b feature/user-profile
vim src/main/java/UserProfile.java
git commit -m "Add user profile page"
git commit -m "Add profile validation"

# Meanwhile, main branch gets updates
git checkout main
vim src/main/java/Home.java
git commit -m "Update homepage"
git commit -m "Fix navigation bug"

# Merge feature into main
git checkout main
git merge feature/user-profile

# Git creates merge commit
# Output: Merge made by the 'recursive' strategy.
#  src/main/java/UserProfile.java | 50 ++++++++++++++++++++
#  1 file changed, 50 insertions(+)

# View history
git log --oneline --graph
# *   c1d2e3f (HEAD -> main) Merge branch 'feature/user-profile'
# |\  
# | * b1c2d3e (feature/user-profile) Add profile validation
# | * a1b2c3d Add user profile page
# * | 9a8b7c6 Fix navigation bug
# * | 8a7b6c5 Update homepage
# |/  
# * 7a6b5c4 Initial commit

# Merge commit has two parents
git show c1d2e3f
# commit c1d2e3f
# Merge: 9a8b7c6 b1c2d3e  ← Two parents
# Author: John Doe <john@example.com>
```

**Customizing merge commit message:**

```bash
# Edit merge commit message
git merge feature/user-profile --edit

# Default message:
# Merge branch 'feature/user-profile'

# Custom message:
git merge feature/user-profile -m "Merge user profile feature

Adds user profile page with validation.
Resolves #123"
```

---

### Squash Merge (Clean History)

Squash merge combines all commits from feature branch into a single commit.

**Squash merge visualization:**

```
Before squash merge:
main:     A---B---C
               \
feature:        D---E---F---G
                ↓ ↓ ↓ ↓ (squash all)

After squash merge:
main:     A---B---C---S
                     (single commit with all changes)
feature:  D---E---F---G (unchanged)
```

**Squash merge example:**

```bash
# Feature branch with multiple commits
git checkout -b feature/authentication
git commit -m "WIP: Add auth skeleton"
git commit -m "WIP: Implement JWT"
git commit -m "Fix typo"
git commit -m "Add tests"
git commit -m "Fix failing test"
git commit -m "Update docs"

# Squash merge into main
git checkout main
git merge --squash feature/authentication

# All changes staged, but not committed
git status
# On branch main
# Changes to be committed:
#   new file:   src/main/java/AuthService.java
#   new file:   src/test/java/AuthServiceTest.java
#   modified:   README.md

# Create single commit
git commit -m "feat: Add JWT authentication

Implements JWT-based authentication with:
- Token generation and validation
- Login endpoint
- Comprehensive tests
- Updated documentation

Resolves #123"

# View history (single commit)
git log --oneline
# d1e2f3g (HEAD -> main) feat: Add JWT authentication
# c1d2e3f Update homepage
# b1c2d3e Initial commit

# Feature branch still exists with all commits
git log --oneline feature/authentication
# g6f5e4d Update docs
# f5e4d3c Fix failing test
# e4d3c2b Add tests
# d3c2b1a Fix typo
# c2b1a9s Implement JWT
# b1a9s8d Add auth skeleton
```

**Advantages:**

- ✅ Clean, linear history on main
- ✅ One commit per feature (easy to revert)
- ✅ Hides messy development history
- ✅ Clear commit messages

**Disadvantages:**

- ❌ Loses individual commit history
- ❌ Makes it harder to understand development process
- ❌ Can hide useful debugging information

**When to use squash merge:**

- ✅ Feature branches with many small commits
- ✅ Want clean main branch history
- ✅ Each feature = one commit
- ✅ Using GitHub Flow
- ❌ Need detailed commit history
- ❌ Using Git Flow (want to preserve branch structure)

---

### Rebase Merge (Linear History)

Rebase rewrites history by moving commits to a new base.

**Rebase visualization:**

```
Before rebase:
main:     A---B---C---D
               \
feature:        E---F---G

After rebase:
main:     A---B---C---D
                       \
feature:                E'---F'---G'
                        (commits rewritten)

Then fast-forward merge:
main:     A---B---C---D---E'---F'---G'
```

**Rebase example:**

```bash
# Feature branch needs updates from main
git checkout feature/authentication

# Rebase onto main
git rebase main
# or
git rebase main feature/authentication

# If conflicts occur, resolve and continue
git rebase --continue

# Or abort rebase
git rebase --abort

# View history (linear)
git log --oneline --graph
# * g6f5e4d (HEAD -> feature/authentication) Add password reset
# * f5e4d3c Add login endpoint
# * e4d3c2b Add JWT validation
# * d3c2b1a (main) Update database schema
# * c2b1a9s Fix security issue
# * b1a9s8d Initial commit

# Merge into main (fast-forward)
git checkout main
git merge feature/authentication
# Fast-forward (no merge commit)
```

**Interactive rebase (clean up history before merge):**

```bash
# Clean up last 5 commits
git rebase -i HEAD~5

# Opens editor with commits:
# pick e4d3c2b Add JWT validation
# pick f5e4d3c Add login endpoint
# pick g6f5e4d Fix typo
# pick h7g6f5e Add tests
# pick i8h7g6f Update docs

# Commands:
# pick   = keep commit
# reword = keep commit but edit message
# edit   = keep commit and stop to amend
# squash = combine with previous commit
# fixup  = like squash but discard message
# drop   = remove commit

# Example: Clean up history
# pick e4d3c2b Add JWT validation
# reword f5e4d3c Add login endpoint
# fixup g6f5e4d Fix typo
# pick h7g6f5e Add tests
# squash i8h7g6f Update docs

# Result: 3 commits instead of 5
```

**Rebase vs Merge:**

```bash
# Merge approach (preserves history)
git checkout feature/auth
git merge main

git log --oneline --graph
# *   m1n2o3p Merge branch 'main' into feature/auth
# |\  
# | * d1e2f3g (main) Update schema
# * | c1d2e3f Add auth logic
# |/  

# Rebase approach (linear history)
git checkout feature/auth
git rebase main

git log --oneline --graph
# * c1d2e3f' (HEAD -> feature/auth) Add auth logic
# * d1e2f3g (main) Update schema
```

**When to use rebase:**

- ✅ Cleaning up local commits before pushing
- ✅ Keeping feature branch up-to-date with main
- ✅ Want linear history
- ✅ Private branches (not shared)
- ❌ Public branches (shared with others)
- ❌ Already pushed commits
- ❌ Want to preserve merge history

**Golden rule of rebasing:**

> Never rebase commits that have been pushed to a shared repository!

---

### When to Use Each Strategy

**Merge strategy decision matrix:**

|Scenario|Strategy|Reason|
|---|---|---|
|Feature complete, no main changes|Fast-forward|Simple, linear history|
|Need to preserve feature context|Merge --no-ff|Shows feature as unit|
|Feature + main both changed|Recursive merge|Preserves all history|
|Messy feature commits|Squash merge|Clean main history|
|Want linear history|Rebase + merge|No merge commits|
|Shared public branch|Merge (not rebase)|Safe, preserves history|
|Local feature branch|Rebase|Clean, linear|
|Release preparation|Merge --no-ff|Clear release point|

**Real-world examples:**

```bash
# Scenario 1: Simple feature, no conflicts
git merge --ff-only feature/typo-fix

# Scenario 2: Important feature to preserve
git merge --no-ff feature/payment-integration

# Scenario 3: Many small commits in feature
git merge --squash feature/refactoring

# Scenario 4: Keep feature branch updated
git checkout feature/long-running
git rebase main

# Scenario 5: Clean up before PR
git rebase -i main
```

---

## 4. Merge Conflicts

### Why Conflicts Happen

Conflicts occur when Git can't automatically determine which changes to keep.

**Common conflict scenarios:**

```
1. Same line modified in both branches:
   main:    print("Hello World")
   feature: print("Hello, World!")
   
2. File modified in one branch, deleted in another:
   main:    User.java modified
   feature: User.java deleted
   
3. Same file created in both branches:
   main:    Logger.java (version A)
   feature: Logger.java (version B)
   
4. Overlapping changes in nearby lines:
   main:    Line 10-15 changed
   feature: Line 12-17 changed
```

**Example conflict scenario:**

```java
// main branch - User.java
public class User {
    private String name;
    private String email;
    
    public void validate() {
        if (email == null || !email.contains("@")) {
            throw new ValidationException("Invalid email");
        }
    }
}

// feature branch - User.java
public class User {
    private String name;
    private String email;
    private String phone;
    
    public boolean isValid() {
        return email != null && email.matches("^[A-Za-z0-9+_.-]+@(.+)$");
    }
}

// Merging these creates conflict!
```

### Conflict Markers

When a conflict occurs, Git adds markers to show conflicting sections.

**Conflict marker syntax:**

```
<<<<<<< HEAD (current branch)
Your changes
=======
Their changes
>>>>>>> feature-branch (incoming branch)
```

**Real Java example with conflict:**

```java
// After merge conflict in User.java
public class User {
    private String name;
    private String email;
<<<<<<< HEAD
    
    public void validate() {
        if (email == null || !email.contains("@")) {
            throw new ValidationException("Invalid email");
        }
=======
    private String phone;
    
    public boolean isValid() {
        return email != null && email.matches("^[A-Za-z0-9+_.-]+@(.+)$");
>>>>>>> feature/enhanced-validation
    }
}
```

**Conflict marker explanation:**

```
<<<<<<< HEAD
    Code from current branch (main)
    This is what's in the branch you're merging INTO
=======
    Code from incoming branch (feature)
    This is what's in the branch you're merging FROM
>>>>>>> feature/enhanced-validation
```

**Multiple conflicts in same file:**

```java
public class PaymentService {
    
<<<<<<< HEAD
    public void processPayment(Payment payment) {
        // Main branch implementation
        stripeService.charge(payment);
=======
    public PaymentResult processPayment(PaymentRequest request) {
        // Feature branch implementation
        return paypalService.process(request);
>>>>>>> feature/paypal-integration
    }
    
    private void notifyUser(User user) {
<<<<<<< HEAD
        emailService.send(user.getEmail(), "Payment successful");
=======
        notificationService.notify(user, "Payment complete");
>>>>>>> feature/paypal-integration
    }
}
```

---

### Resolving Conflicts (Manual)

**Step-by-step conflict resolution:**

```bash
# 1. Attempt merge
git merge feature/enhanced-validation
# Auto-merging src/main/java/User.java
# CONFLICT (content): Merge conflict in src/main/java/User.java
# Automatic merge failed; fix conflicts and then commit the result.

# 2. Check status
git status
# On branch main
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#   (use "git merge --abort" to abort the merge)
# 
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#         both modified:   src/main/java/User.java

# 3. Open file and resolve
vim src/main/java/User.java

# Original file with conflicts:
# public class User {
#     private String name;
#     private String email;
# <<<<<<< HEAD
#     
#     public void validate() {
#         if (email == null || !email.contains("@")) {
#             throw new ValidationException("Invalid email");
#         }
# =======
#     private String phone;
#     
#     public boolean isValid() {
#         return email != null && email.matches("^[A-Za-z0-9+_.-]+@(.+)$");
# >>>>>>> feature/enhanced-validation
#     }
# }

# 4. Resolution options:

# Option A: Keep HEAD (main branch)
public class User {
    private String name;
    private String email;
    
    public void validate() {
        if (email == null || !email.contains("@")) {
            throw new ValidationException("Invalid email");
        }
    }
}

# Option B: Keep incoming (feature branch)
public class User {
    private String name;
    private String email;
    private String phone;
    
    public boolean isValid() {
        return email != null && email.matches("^[A-Za-z0-9+_.-]+@(.+)$");
    }
}

# Option C: Combine both (best solution)
public class User {
    private String name;
    private String email;
    private String phone;  // From feature branch
    
    public boolean isValid() {  // From feature branch
        return email != null && 
               email.matches("^[A-Za-z0-9+_.-]+@(.+)$") &&
               phone != null &&
               phone.matches("\\d{10}");
    }
}

# 5. Mark as resolved
git add src/main/java/User.java

# 6. Check status
git status
# On branch main
# All conflicts fixed but you are still merging.
#   (use "git commit" to conclude merge)

# 7. Complete merge
git commit
# Default merge message appears in editor
# Merge branch 'feature/enhanced-validation'
# 
# Conflicts:
#         src/main/java/User.java

# Or provide custom message
git commit -m "Merge feature/enhanced-validation

Combined email and phone validation.
Resolved conflicts in User.java by merging both validation methods."

# 8. Verify merge
git log --oneline --graph -5
# *   a1b2c3d (HEAD -> main) Merge feature/enhanced-validation
# |\  
# | * 9a8b7c6 (feature/enhanced-validation) Add regex validation
# * | 8a7b6c5 Add validation exception
# |/  
# * 7a6b5c4 Add User class
```

**Conflict resolution strategies:**

```bash
# Keep ours (current branch)
git checkout --ours src/main/java/User.java
git add src/main/java/User.java

# Keep theirs (incoming branch)
git checkout --theirs src/main/java/User.java
git add src/main/java/User.java

# Manually resolve specific files
git add src/main/java/User.java
git add src/test/java/UserTest.java
```

---

### Resolving Conflicts (Tool-based)

**Configure merge tool:**

```bash
# IntelliJ IDEA
git config --global merge.tool idea
git config --global mergetool.idea.cmd 'idea merge "$LOCAL" "$REMOTE" "$BASE" "$MERGED"'

# VS Code
git config --global merge.tool vscode
git config --global mergetool.vscode.cmd 'code --wait --merge $REMOTE $LOCAL $BASE $MERGED'

# Meld (GUI tool)
git config --global merge.tool meld

# Beyond Compare
git config --global merge.tool bc
git config --global mergetool.bc.trustExitCode true

# KDiff3
git config --global merge.tool kdiff3

# Vim (built-in)
git config --global merge.tool vimdiff

# View current merge tool
git config --get merge.tool
```

**Using git mergetool:**

```bash
# Start merge
git merge feature/enhanced-validation
# CONFLICT: Merge conflict in User.java

# Launch merge tool
git mergetool

# For each conflicted file, tool shows:
# LOCAL  = Your version (current branch)
# REMOTE = Their version (incoming branch)
# BASE   = Common ancestor
# MERGED = Result (what you're creating)

# Tool opens with 3-way view:
# ┌──────────┬──────────┬──────────┐
# │  LOCAL   │   BASE   │  REMOTE  │
# │ (yours)  │(ancestor)│ (theirs) │
# ├──────────┴──────────┴──────────┤
# │         MERGED RESULT           │
# │     (combined version)          │
# └─────────────────────────────────┘

# Make selections and save
# Tool automatically adds resolved file

# After resolving all conflicts
git commit
```

**IntelliJ IDEA merge tool example:**

```bash
# When conflict occurs
git merge feature/payment

# Launch IDEA merge tool
git mergetool

# IDEA opens with 4 panes:
# Left:   Your changes (current branch)
# Center: Base (common ancestor)
# Right:  Their changes (incoming branch)
# Bottom: Result (your resolution)

# Actions in IDEA:
# - Accept Left: Keep your changes
# - Accept Right: Keep their changes
# - Accept Both: Merge both changes
# - Manual edit: Type in bottom pane

# After resolution, save and close
# Git automatically stages the file
```

---

### git mergetool Options

```bash
# Use merge tool for all conflicts
git mergetool

# Use merge tool for specific file
git mergetool src/main/java/User.java

# Use specific tool for this merge
git mergetool --tool=idea

# Don't prompt for each file
git mergetool --no-prompt

# Keep backup files (.orig)
git mergetool --no-prompt
# Creates User.java.orig backup

# Don't create backup files
git config --global mergetool.keepBackup false

# List available merge tools
git mergetool --tool-help

# View merge tool configuration
git config --get-regexp merge.*
```

**Merge tool file cleanup:**

```bash
# After resolving, remove backup files
find . -name "*.orig" -delete

# Or configure Git to not create them
git config --global mergetool.keepBackup false

# Temporarily delete backup files
git clean -f
```

---

### Aborting Merges

**Abort merge in progress:**

```bash
# Abort merge (go back to before merge)
git merge --abort

# This:
# - Discards all merge changes
# - Returns to pre-merge state
# - Removes conflict markers
# - Restores HEAD position

# Example
git merge feature/conflict-branch
# CONFLICT: Merge conflict in User.java

# Oh no, I want to start over
git merge --abort

git status
# On branch main
# nothing to commit, working tree clean
```

**When you should abort:**

```
1. Too many conflicts to resolve now
2. Realized you merged wrong branch
3. Need to prepare differently
4. Want to rebase instead
5. Found critical bug during merge
```

**Alternative: Reset after merge commit:**

```bash
# If you already committed the merge but want to undo
git reset --hard HEAD^

# Or if you pushed the bad merge
git revert -m 1 HEAD
# Creates a new commit that undoes the merge
```

---

### Preventing Conflicts

**Best practices to avoid conflicts:**

1. **Small, frequent commits**

```bash
# Bad: One huge commit
git commit -m "Refactor entire authentication system"

# Good: Multiple small commits
git commit -m "Extract auth logic to service"
git commit -m "Add JWT token generation"
git commit -m "Add login endpoint"
git commit -m "Add authentication tests"
```

2. **Pull frequently**

```bash
# Pull main before starting work
git checkout main
git pull origin main

# Pull regularly during development
git checkout feature/my-work
git merge main
# or
git rebase main

# Before pushing
git pull --rebase origin feature/my-work
```

3. **Communicate with team**

```bash
# Before working on shared files
# - Check who else is working on them
# - Coordinate changes
# - Use separate branches for different features

# Bad: Two people editing User.java simultaneously
# Good: One works on User.java, other on Order.java
```

4. **Use feature flags**

```java
// Instead of long-lived branches, use feature flags
@Service
public class OrderService {
    @Value("${features.new-checkout.enabled}")
    private boolean newCheckoutEnabled;
    
    public Order checkout(Cart cart) {
        if (newCheckoutEnabled) {
            return newCheckout(cart);  // In development
        } else {
            return oldCheckout(cart);  // Stable
        }
    }
}
```

5. **Modular code structure**

```java
// Bad: Everything in one class (high conflict risk)
public class UserController {
    // 500 lines of code
    // Multiple people editing same file
}

// Good: Separate concerns (low conflict risk)
public class UserController {
    // 50 lines
}
public class UserService {
    // 100 lines
}
public class UserValidator {
    // 50 lines
}
```

6. **Automated formatting**

```bash
# Configure auto-formatting to prevent style conflicts
# .editorconfig
[*.java]
indent_style = space
indent_size = 4
end_of_line = lf

# Use Prettier, Black, or language-specific formatters
# Commit formatting changes separately
git commit -m "chore: Apply code formatting"
```

7. **Clear ownership**

```bash
# CODEOWNERS file
# Each file/directory has clear owners

# Java services
/src/main/java/auth/          @auth-team
/src/main/java/payment/       @payment-team
/src/main/java/order/         @order-team

# Requires approval from owners before merge
```

8. **Short-lived branches**

```bash
# Keep branches short-lived (< 3 days)
# Merge or rebase frequently

# Bad: Feature branch alive for 3 weeks
# Good: Break into smaller features, merge each

# Example: Payment integration
# Instead of one big branch:
feature/payment-integration (3 weeks)

# Break into:
feature/payment-api-client (2 days) → merge
feature/payment-webhook (1 day) → merge
feature/payment-ui (2 days) → merge
feature/payment-tests (1 day) → merge
```

---

## Summary

### Branching Strategies

- ✅ **Git Flow**: Complex, multiple long-lived branches, scheduled releases
- ✅ **GitHub Flow**: Simple, main + features, continuous deployment
- ✅ **Trunk-Based**: Short-lived branches, feature flags, high frequency
- ✅ **Choose based on**: Team size, release cycle, testing maturity

### Branch Operations

- ✅ **Create/Switch**: `git switch -c`, `git checkout -b`
- ✅ **Track remote**: `git branch -u origin/main`
- ✅ **Delete**: `git branch -d`, `git push --delete`
- ✅ **Rename**: `git branch -m new-name`

### Merging Strategies

- ✅ **Fast-forward**: Simple, linear history
- ✅ **Recursive**: Preserves all history, merge commits
- ✅ **Squash**: Clean history, one commit per feature
- ✅ **Rebase**: Linear history, rewrites commits
- ✅ **Choose based on**: History preference, feature complexity

### Conflict Resolution

- ✅ **Understand markers**: `<<<<<<<`, `=======`, `>>>>>>>`
- ✅ **Resolve manually**: Edit file, remove markers, test
- ✅ **Use tools**: `git mergetool`, IDE integration
- ✅ **Prevent**: Small commits, frequent pulls, good communication
- ✅ **Abort**: `git merge --abort` if needed

**Key Takeaways for Java Developers:**

- Choose workflow that matches team and project
- Keep branches short-lived when possible
- Communicate with team about file changes
- Use automated testing before merging
- Understand different merge strategies
- Master conflict resolution techniques
