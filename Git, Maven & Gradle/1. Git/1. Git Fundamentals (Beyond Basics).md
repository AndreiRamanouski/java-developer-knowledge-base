
### Git Internals

#### How Git Stores Data

Git is fundamentally a content-addressable filesystem with a version control system built on top. It stores everything as **objects**.

**Four types of Git objects:**

1. **Blob (Binary Large Object)**
    
    - Stores file contents
    - Contains NO filename, NO metadata
    - Just the raw file data
    - Identified by SHA-1 hash of content
2. **Tree**
    
    - Represents a directory
    - Contains pointers to blobs and other trees
    - Stores filenames and permissions
    - Like a filesystem snapshot
3. **Commit**
    
    - Points to a tree (snapshot of your project)
    - Contains metadata: author, date, message
    - Points to parent commit(s)
    - Creates the version history
4. **Tag**
    
    - Points to a commit
    - Adds a human-readable name
    - Can include a message
    - Used for releases (v1.0.0, v2.0.0)

**Object relationship example:**

```
Commit Object (abc123)
├── tree: def456
├── parent: xyz789
├── author: John Doe
├── date: 2024-01-15
└── message: "Add user service"

Tree Object (def456)
├── blob 111222 pom.xml
├── tree 333444 src/
└── blob 555666 README.md

Tree Object (333444) [src/]
├── tree 777888 main/
└── tree 999000 test/

Blob Object (111222) [pom.xml]
└── Content: <?xml version="1.0"?>...
```

#### Viewing Git Objects

```bash
# List all objects
find .git/objects -type f

# View object type
git cat-file -t <SHA-1>

# View object content
git cat-file -p <SHA-1>

# Example: View a commit
git cat-file -p HEAD
# Output:
# tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904
# parent a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0
# author John Doe <john@example.com> 1705334400 +0000
# committer John Doe <john@example.com> 1705334400 +0000
#
# Add user authentication service

# View the tree
git cat-file -p 4b825dc642cb6eb9a060e54bf8d69288fbee4904
# Output:
# 100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391    .gitignore
# 100644 blob 5f7e3a7c4d3b2a1f9e8d7c6b5a4f3e2d1c0b9a8    pom.xml
# 040000 tree 9a8b7c6d5e4f3g2h1i0j9k8l7m6n5o4p3q2r1s0    src
```

#### .git Directory Structure

```
.git/
├── HEAD                 # Points to current branch (ref: refs/heads/main)
├── config               # Repository configuration
├── description          # Repository description (for GitWeb)
├── index                # Staging area (binary file)
├── hooks/               # Client/server-side scripts
│   ├── pre-commit
│   ├── post-commit
│   └── pre-push
├── objects/             # Object database (all content)
│   ├── 00/
│   ├── 01/
│   ├── ...
│   ├── ff/
│   ├── info/
│   └── pack/            # Packed objects (optimized storage)
├── refs/                # References (pointers to commits)
│   ├── heads/           # Local branches
│   │   ├── main
│   │   ├── develop
│   │   └── feature-123
│   ├── remotes/         # Remote branches
│   │   └── origin/
│   │       ├── main
│   │       └── develop
│   └── tags/            # Tags
│       ├── v1.0.0
│       └── v2.0.0
└── logs/                # Reflog (history of HEAD movements)
    ├── HEAD
    └── refs/
```

**Key files explained:**

```bash
# HEAD - Current branch pointer
cat .git/HEAD
# Output: ref: refs/heads/main

# Branch reference - Points to a commit
cat .git/refs/heads/main
# Output: a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0

# Config - Repository settings
cat .git/config
# Output:
# [core]
#     repositoryformatversion = 0
#     filemode = true
#     bare = false
# [remote "origin"]
#     url = https://github.com/user/repo.git
#     fetch = +refs/heads/*:refs/remotes/origin/*
# [branch "main"]
#     remote = origin
#     merge = refs/heads/main
```

#### SHA-1 Hashes (Content Addressing)

Git uses SHA-1 hashes to identify all objects. The hash is based on the content, ensuring integrity.

**How SHA-1 is calculated:**

```bash
# For a blob, Git calculates:
# SHA-1("blob " + <content_size> + "\0" + <content>)

# Example: Calculate SHA-1 for a file
echo -n "Hello, World!" | git hash-object --stdin
# Output: 8ab686eafeb1f44702738c8b0f24f2567c36da6d

# Verify by storing it
echo "Hello, World!" > test.txt
git hash-object -w test.txt
# Output: 8ab686eafeb1f44702738c8b0f24f2567c36da6d

# View the object
git cat-file -p 8ab686e
# Output: Hello, World!
```

**Important characteristics:**

- **Deterministic**: Same content = same hash
- **Collision resistant**: Nearly impossible to find two different contents with same hash
- **Integrity check**: Any corruption changes the hash
- **Short form**: Git allows abbreviated hashes (first 7+ characters)

```bash
# Full hash
git log -1 --format=%H
# Output: a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0

# Short hash (Git automatically uses minimum unique length)
git log -1 --format=%h
# Output: a1b2c3d
```

#### Git as a Directed Acyclic Graph (DAG)

Git's commit history forms a DAG where:

- **Nodes** = Commits
- **Edges** = Parent relationships
- **Directed** = Edges point from child to parent
- **Acyclic** = No loops (you can't be your own ancestor)

**Visualizing the DAG:**

```
                    A---B---C  (main)
                   /         \
                  /           \
        D---E---F---G---H---I---J  (develop)
                     \
                      \
                       K---L  (feature)
```

**In Git's internal representation:**

```
Commit J
├── tree: <snapshot at J>
├── parent: I
├── parent: C  (merge commit has 2 parents)
└── message: "Merge main into develop"

Commit I
├── tree: <snapshot at I>
├── parent: H
└── message: "Add feature X"

Commit H
├── tree: <snapshot at H>
├── parent: G
└── message: "Fix bug Y"
```

**Why DAG matters:**

1. **Branching is cheap**: Just create a new pointer
2. **Merging is deterministic**: Follow the graph to find common ancestor
3. **History is immutable**: Can't change history without changing hashes
4. **Reachability**: Can determine what commits are ancestors of others

```bash
# View the DAG
git log --graph --oneline --all

# Example output:
# *   a1b2c3d (HEAD -> develop) Merge main into develop
# |\  
# | * 9a8b7c6 (main) Update README
# | * 8a7b6c5 Fix security issue
# * | 7a6b5c4 Add new feature
# * | 6a5b4c3 Refactor service layer
# |/  
# * 5a4b3c2 Initial commit

# Check if commit A is ancestor of commit B
git merge-base --is-ancestor <commit-A> <commit-B>
echo $?  # 0 if true, 1 if false

# Find common ancestor (merge base)
git merge-base main develop
# Output: 5a4b3c2d1e0f9g8h7i6j5k4l3m2n1o0p9q8r7s6t5
```

#### Refs, HEAD, and Branches

**Refs (References)**: Human-readable names for commits

```bash
# Refs are just files containing commit SHA-1

# Local branch ref
cat .git/refs/heads/main
# Output: a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0

# Remote branch ref
cat .git/refs/remotes/origin/main
# Output: 9a8b7c6d5e4f3g2h1i0j9k8l7m6n5o4p3q2r1s0

# Tag ref
cat .git/refs/tags/v1.0.0
# Output: 5a4b3c2d1e0f9g8h7i6j5k4l3m2n1o0p9q8r7s6t5

# List all refs
git show-ref
# Output:
# a1b2c3d refs/heads/main
# 7a6b5c4 refs/heads/develop
# 6a5b4c3 refs/heads/feature-123
# 9a8b7c6 refs/remotes/origin/main
# 5a4b3c2 refs/tags/v1.0.0
```

**HEAD**: Pointer to the current commit (usually via a branch)

```bash
# HEAD points to current branch
cat .git/HEAD
# Output: ref: refs/heads/main

# In detached HEAD state (not on any branch)
git checkout a1b2c3d
cat .git/HEAD
# Output: a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0

# View HEAD history (reflog)
git reflog
# Output:
# a1b2c3d HEAD@{0}: commit: Add authentication
# 9a8b7c6 HEAD@{1}: checkout: moving from develop to main
# 7a6b5c4 HEAD@{2}: commit: Implement user service
```

**Branches**: Just movable pointers to commits

```bash
# Create a branch = create a new ref file
git branch feature-auth
# This creates .git/refs/heads/feature-auth
# containing the current commit SHA-1

# What is a branch internally?
# It's literally just a 41-byte file containing a SHA-1 hash

# Switching branches = updating HEAD
git checkout feature-auth
# .git/HEAD now contains: ref: refs/heads/feature-auth

# Committing advances the current branch pointer
git commit -m "Add auth logic"
# The SHA-1 in .git/refs/heads/feature-auth gets updated
# to point to the new commit
```

**Special refs:**

```bash
# HEAD^  = Parent of HEAD (1 commit back)
# HEAD~  = Same as HEAD^ (parent)
# HEAD^^ = Grandparent (2 commits back)
# HEAD~2 = Same as HEAD^^ (2 commits back)
# HEAD~3 = Great-grandparent (3 commits back)

# For merge commits (multiple parents):
# HEAD^1 = First parent (main line)
# HEAD^2 = Second parent (merged branch)

# Examples
git show HEAD^      # Show parent commit
git show HEAD~3     # Show commit 3 generations back
git show HEAD^2     # Show second parent of merge commit

# Relative refs in commands
git reset HEAD~1    # Reset to parent commit
git checkout HEAD^  # Checkout parent commit
git diff HEAD~2 HEAD  # Compare current with 2 commits ago
```

---

## 2. The Three Areas

### Understanding Git's Three-Stage Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                    THE THREE AREAS                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. WORKING DIRECTORY                                       │
│  ┌───────────────────────────────────────────────────┐    │
│  │  Your actual files on disk                        │    │
│  │  - pom.xml (modified)                             │    │
│  │  - src/main/java/User.java (modified)            │    │
│  │  - target/ (untracked)                            │    │
│  └───────────────────────────────────────────────────┘    │
│                      │                                      │
│                 git add                                     │
│                      ↓                                      │
│  2. STAGING AREA (INDEX)                                   │
│  ┌───────────────────────────────────────────────────┐    │
│  │  Snapshot of what will be in next commit          │    │
│  │  - pom.xml (staged)                               │    │
│  │  - src/main/java/User.java (staged)              │    │
│  └───────────────────────────────────────────────────┘    │
│                      │                                      │
│                 git commit                                  │
│                      ↓                                      │
│  3. REPOSITORY (.git)                                      │
│  ┌───────────────────────────────────────────────────┐    │
│  │  Permanent snapshots (commits)                     │    │
│  │  - commit a1b2c3d: "Add user authentication"      │    │
│  │  - commit 9a8b7c6: "Update dependencies"          │    │
│  └───────────────────────────────────────────────────┘    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 1. Working Directory

The working directory is your actual project folder with all files.

**File states in working directory:**

```bash
# Check working directory status
git status

# Possible states:
# 1. Untracked - Never been in Git before
# 2. Unmodified - In Git, hasn't changed since last commit
# 3. Modified - In Git, changed since last commit
# 4. Deleted - In Git, removed from working directory
```

**Java project example:**

```bash
# Initial state
git status
# On branch main
# nothing to commit, working tree clean

# Modify pom.xml
vim pom.xml  # Add new dependency

git status
# On branch main
# Changes not staged for commit:
#   modified:   pom.xml

# Create new file
touch src/main/java/service/AuthService.java

git status
# On branch main
# Changes not staged for commit:
#   modified:   pom.xml
# 
# Untracked files:
#   src/main/java/service/AuthService.java
```

**Working directory operations:**

```bash
# Discard changes in working directory
git checkout -- pom.xml
# or
git restore pom.xml

# Discard all changes
git checkout -- .
# or
git restore .

# Remove untracked files
git clean -n  # Dry run (preview)
git clean -f  # Force remove untracked files
git clean -fd # Remove untracked files and directories

# Remove untracked files including ignored ones
git clean -fdx

# Stash working directory changes
git stash
git stash push -m "WIP: auth feature"

# View working directory changes
git diff  # Shows unstaged changes
```

### 2. Staging Area (Index)

The staging area is a file (`.git/index`) that stores information about what will go into your next commit.

**What the index contains:**

```bash
# View index contents
git ls-files --stage

# Example output:
# 100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	.gitignore
# 100644 5f7e3a7c4d3b2a1f9e8d7c6b5a4f3e2d1c0b9a8 0	pom.xml
# 100644 3a2b1c9d8e7f6g5h4i3j2k1l0m9n8o7p6q5r4s3 0	src/main/java/App.java

# Format: <mode> <object> <stage> <path>
# mode: File permissions (100644 = regular file)
# object: SHA-1 of blob in object database
# stage: 0 (used during merge conflicts)
# path: File path
```

**Staging area behavior:**

```bash
# Stage a file
git add pom.xml
# This:
# 1. Compresses file content into blob object
# 2. Stores blob in .git/objects/
# 3. Updates .git/index with blob SHA-1

# Stage part of a file (interactive)
git add -p pom.xml
# Git shows each change (hunk) and asks:
# Stage this hunk [y,n,q,a,d,s,e,?]?

# Stage all changes
git add .
git add -A  # Includes deletions
git add -u  # Only updates tracked files

# Unstage a file
git reset HEAD pom.xml
# or
git restore --staged pom.xml

# View staged changes
git diff --staged
# or
git diff --cached

# Commit only staged changes
git commit -m "Update dependencies"
```

**Example: Staging workflow for Java project**

```bash
# Scenario: You modified 3 files but want to commit them separately

# 1. View all changes
git status
# On branch feature-auth
# Changes not staged for commit:
#   modified:   pom.xml
#   modified:   src/main/java/User.java
#   modified:   src/test/java/UserTest.java

# 2. Stage only pom.xml
git add pom.xml

git status
# On branch feature-auth
# Changes to be committed:
#   modified:   pom.xml
#
# Changes not staged for commit:
#   modified:   src/main/java/User.java
#   modified:   src/test/java/UserTest.java

# 3. Commit dependency update
git commit -m "chore: Update Spring Boot to 3.2.0"

# 4. Stage and commit code changes
git add src/main/java/User.java src/test/java/UserTest.java
git commit -m "feat: Add email validation to User"

# Now both changes are in separate commits
git log --oneline -2
# a1b2c3d feat: Add email validation to User
# 9a8b7c6 chore: Update Spring Boot to 3.2.0
```

### 3. Repository (.git)

The repository is the `.git` directory containing all commits, branches, tags, and history.

**What's stored in the repository:**

```bash
# Object database
.git/objects/
├── 00/ to ff/  # 256 directories (first 2 chars of SHA-1)
└── pack/       # Compressed packs of objects

# Example: Object with SHA-1 starting with "a1b2c3..."
# is stored at .git/objects/a1/b2c3d4e5f6...

# List all commits
git log --all --oneline

# List all branches
git branch -a

# List all tags
git tag

# View repository size
du -sh .git
# 45M	.git
```

**Repository operations:**

```bash
# Add to repository (commit)
git commit -m "Add authentication service"
# This:
# 1. Creates tree object from staging area
# 2. Creates commit object pointing to tree
# 3. Advances current branch pointer
# 4. Updates reflog

# View commit details
git show HEAD
git show a1b2c3d

# View commit tree
git ls-tree HEAD
git ls-tree -r HEAD  # Recursive (all files)

# Verify repository integrity
git fsck
# Checking object directories: 100% (256/256), done.
# Checking objects: 100% (1234/1234), done.

# Garbage collect (clean up)
git gc
# This:
# - Removes unreachable objects
# - Packs loose objects
# - Optimizes repository

# Prune old objects
git prune
git prune --expire="30 days ago"
```

### How Data Moves Between Areas

```
Working Directory → Staging Area → Repository
        ↓                 ↓              ↓
   git add        git commit      permanent
   git restore    git restore    
                  --staged

┌─────────────────────────────────────────────────────────┐
│  COMPLETE WORKFLOW                                      │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. Modify files in working directory                  │
│     ├─ Edit pom.xml                                    │
│     └─ Edit User.java                                  │
│                                                         │
│  2. Stage changes                                      │
│     ├─ git add pom.xml                                 │
│     └─ Files copied to staging area                    │
│                                                         │
│  3. Commit changes                                     │
│     ├─ git commit -m "message"                         │
│     ├─ Staging area → Tree object                      │
│     ├─ Tree object → Commit object                     │
│     └─ Branch pointer advanced                         │
│                                                         │
│  4. Working directory matches repository               │
│     └─ git status: "working tree clean"                │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

**Moving data backward:**

```bash
# Repository → Staging area
git reset --soft HEAD^
# Moves branch pointer back one commit
# Leaves staging area and working directory unchanged

# Repository → Working directory (skip staging)
git reset --mixed HEAD^  # Default behavior
# Moves branch pointer back
# Updates staging area to match
# Leaves working directory unchanged

# Repository → Nothing (discard everything)
git reset --hard HEAD^
# Moves branch pointer back
# Updates staging area to match
# Updates working directory to match
# ⚠️ DANGEROUS: Loses uncommitted changes

# Example: Undo last commit but keep changes
git reset --soft HEAD^
git status
# On branch main
# Changes to be committed:
#   (all files from the undone commit)
```

---

## 3. Core Commands Deep Dive

### git add - What Actually Happens

When you run `git add`, Git performs several operations:

**Process breakdown:**

```bash
# 1. Calculate content hash
echo "Hello" > test.txt
git hash-object test.txt
# Output: e965047ad7c57865823c7d992b1d046ea66edf78

# 2. Compress and store content
git add test.txt
# Git does:
# - Compresses content with zlib
# - Stores in .git/objects/e9/65047ad7c57865823c7d992b1d046ea66edf78
# - Updates .git/index with file path and blob SHA-1

# 3. Verify storage
git ls-files --stage test.txt
# 100644 e965047ad7c57865823c7d992b1d046ea66edf78 0	test.txt

# View the stored blob
git cat-file -p e965047
# Hello
```

**git add variations:**

```bash
# Add specific file
git add pom.xml

# Add directory
git add src/main/java/

# Add all files in current directory
git add .

# Add all changes (including deletions)
git add -A
git add --all

# Add only tracked files (no new files)
git add -u
git add --update

# Interactive staging
git add -i
# Options:
#   1: status       - Show paths with changes
#   2: update       - Stage changes
#   3: revert       - Unstage changes
#   4: add untracked - Add new files
#   5: patch        - Stage parts of files
#   6: diff         - View diff
#   7: quit
#   8: help

# Stage parts of a file (patch mode)
git add -p pom.xml
# For each change (hunk), choose:
# y - stage this hunk
# n - do not stage this hunk
# q - quit; do not stage this or remaining hunks
# a - stage this and all remaining hunks
# d - do not stage this or remaining hunks
# s - split the hunk into smaller hunks
# e - manually edit the hunk
# ? - print help
```

**Example: Selective staging in Java project**

```java
// User.java - You made two changes:
// 1. Added email validation
// 2. Added phone validation

public class User {
    private String email;
    private String phone;
    
    // Change 1: Email validation
    public void setEmail(String email) {
        if (!email.contains("@")) {
            throw new IllegalArgumentException("Invalid email");
        }
        this.email = email;
    }
    
    // Change 2: Phone validation
    public void setPhone(String phone) {
        if (!phone.matches("\\d{10}")) {
            throw new IllegalArgumentException("Invalid phone");
        }
        this.phone = phone;
    }
}
```

```bash
# Stage only email validation
git add -p src/main/java/User.java

# Git shows first hunk (email validation):
# Stage this hunk [y,n,q,a,d,s,e,?]? y

# Git shows second hunk (phone validation):
# Stage this hunk [y,n,q,a,d,s,e,?]? n

# Now only email validation is staged
git status
# Changes to be committed:
#   modified:   src/main/java/User.java
#
# Changes not staged for commit:
#   modified:   src/main/java/User.java

# Commit only email validation
git commit -m "feat: Add email validation"

# Stage and commit phone validation separately
git add src/main/java/User.java
git commit -m "feat: Add phone validation"
```

### git commit - Creating Snapshots

**What git commit does:**

```bash
# 1. Creates a tree object from staging area
# 2. Creates a commit object
# 3. Advances the current branch pointer
# 4. Updates reflog

# Basic commit
git commit -m "Add user authentication"

# Commit with detailed message
git commit
# Opens editor for multi-line message:
# 
# feat: Add user authentication
# 
# - Implement JWT token generation
# - Add login endpoint
# - Add password hashing with BCrypt
# - Update dependencies
# 
# Resolves: #123

# Commit all tracked changes (skip staging)
git commit -a -m "Quick fix"
# Equivalent to:
git add -u
git commit -m "Quick fix"

# Amend last commit (change message or add files)
git commit --amend
git commit --amend -m "New message"
git commit --amend --no-edit  # Keep same message

# Commit with author override
git commit --author="John Doe <john@example.com>" -m "Message"

# Create empty commit (useful for CI/CD)
git commit --allow-empty -m "Trigger CI pipeline"

# Sign commit with GPG
git commit -S -m "Signed commit"
```

**Commit message best practices:**

```bash
# Good commit message structure:
# 
# <type>(<scope>): <subject>
# 
# <body>
# 
# <footer>

# Examples:
git commit -m "feat(auth): Add JWT authentication

Implement token generation and validation using Spring Security.
Tokens expire after 24 hours and include user roles.

Resolves: #123
Breaking change: Old session-based auth is removed"

# Conventional commit types:
# feat:     New feature
# fix:      Bug fix
# docs:     Documentation changes
# style:    Code style changes (formatting)
# refactor: Code refactoring
# test:     Adding/updating tests
# chore:    Build process, dependencies
# perf:     Performance improvements
# ci:       CI/CD changes
```

**Viewing commits:**

```bash
# View commit details
git show HEAD
git show a1b2c3d

# View commit message only
git log -1 --format=%B

# View commit as a tree
git show HEAD --format=raw
# Output:
# tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904
# parent 5a4b3c2d1e0f9g8h7i6j5k4l3m2n1o0p9q8r7s6t5
# author John Doe <john@example.com> 1705334400 +0000
# committer John Doe <john@example.com> 1705334400 +0000
# 
# Add user authentication

# View files in commit
git show HEAD --name-only
git show HEAD --name-status
# M	pom.xml
# A	src/main/java/AuthService.java
# D	src/main/java/OldAuth.java

# View diff in commit
git show HEAD
git show HEAD -- pom.xml  # Only pom.xml changes
```

### git status - Understanding Output

**Full status output explained:**

```bash
git status

# Output:
# On branch feature-auth
# Your branch is ahead of 'origin/feature-auth' by 2 commits.
#   (use "git push" to publish your local commits)
# 
# Changes to be committed:
#   (use "git restore --staged <file>..." to unstage)
#	modified:   pom.xml
#	new file:   src/main/java/AuthService.java
# 
# Changes not staged for commit:
#   (use "git add <file>..." to update what will be committed)
#   (use "git restore <file>..." to discard changes in working directory)
#	modified:   src/main/java/User.java
# 
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#	src/main/java/TempFile.java
#	target/

# Explanation:
# 1. "On branch feature-auth"
#    - Current branch is feature-auth
# 
# 2. "Your branch is ahead by 2 commits"
#    - Local branch has 2 commits not pushed to remote
# 
# 3. "Changes to be committed" (Staged changes)
#    - pom.xml: Modified and staged
#    - AuthService.java: New file, staged
# 
# 4. "Changes not staged for commit" (Unstaged changes)
#    - User.java: Modified but not staged
# 
# 5. "Untracked files" (Not in Git)
#    - TempFile.java: New file, not staged
#    - target/: Build directory, not staged
```

**Status options:**

```bash
# Short format
git status -s
git status --short
# Output:
# M  pom.xml
# A  src/main/java/AuthService.java
#  M src/main/java/User.java
# ?? src/main/java/TempFile.java
# ?? target/

# Format explanation:
# Left column  = Staging area status
# Right column = Working directory status
# M  = Modified and staged
#  M = Modified but not staged
# A  = Added (new file staged)
# ?? = Untracked
# D  = Deleted
# R  = Renamed
# C  = Copied

# Branch info
git status -b
git status --branch

# Show ignored files
git status --ignored

# Porcelain format (for scripts)
git status --porcelain
git status --porcelain=v2

# Verbose (show diff in staging area)
git status -v
git status -vv  # Show diff for staged and unstaged
```

### git log - Powerful Options

**Basic log commands:**

```bash
# View commit history
git log

# One line per commit
git log --oneline
# a1b2c3d Add authentication
# 9a8b7c6 Update dependencies
# 8a7b6c5 Fix bug in user service

# Graph view (ASCII art)
git log --graph
git log --graph --oneline
# * a1b2c3d (HEAD -> main) Add authentication
# * 9a8b7c6 Update dependencies
# *   8a7b6c5 Merge branch 'develop'
# |\  
# | * 7a6b5c4 (develop) Feature complete
# * | 6a5b4c3 Fix bug
# |/  
# * 5a4b3c2 Initial commit

# Show all branches
git log --all --graph --oneline

# Limit number of commits
git log -5              # Last 5 commits
git log -n 5            # Same
git log --max-count=5   # Same
```

**Advanced formatting:**

```bash
# Custom format
git log --format="%h - %an, %ar : %s"
# a1b2c3d - John Doe, 2 hours ago : Add authentication
# 9a8b7c6 - Jane Smith, 1 day ago : Update dependencies

# Format placeholders:
# %H  - Commit hash (full)
# %h  - Commit hash (abbreviated)
# %T  - Tree hash
# %t  - Tree hash (abbreviated)
# %P  - Parent hashes
# %p  - Parent hashes (abbreviated)
# %an - Author name
# %ae - Author email
# %ad - Author date
# %ar - Author date, relative
# %cn - Committer name
# %ce - Committer email
# %cd - Committer date
# %cr - Committer date, relative
# %s  - Subject (commit message)
# %b  - Body

# Pretty formats
git log --pretty=oneline
git log --pretty=short
git log --pretty=medium
git log --pretty=full
git log --pretty=fuller

# Example: Detailed format
git log --format="%C(yellow)%h%C(reset) - %C(cyan)%an%C(reset), %C(green)%ar%C(reset) : %s"
# With colors for better readability
```

**Filtering logs:**

```bash
# By date
git log --since="2024-01-01"
git log --after="2024-01-01"
git log --until="2024-12-31"
git log --before="2024-12-31"

# Relative dates
git log --since="2 weeks ago"
git log --since="yesterday"
git log --until="1 month ago"

# By author
git log --author="John Doe"
git log --author="john@example.com"

# By committer
git log --committer="Jane Smith"

# By commit message
git log --grep="authentication"
git log --grep="fix" --grep="bug"  # OR
git log --grep="fix" --grep="bug" --all-match  # AND

# By file
git log -- pom.xml
git log -- src/main/java/User.java

# By content (pickaxe)
git log -S"AuthService"  # Commits that add/remove "AuthService"
git log -G"Auth.*Service"  # Regex version

# By code change
git log -L :functionName:src/main/java/App.java  # Changes to function
```

**Diff in log:**

```bash
# Show patch (diff) for each commit
git log -p
git log --patch

# Show only files changed
git log --name-only
git log --name-status

# Show file stats
git log --stat
# Output:
# commit a1b2c3d
# Author: John Doe <john@example.com>
# Date:   Mon Jan 15 10:30:00 2024 +0000
# 
#     Add authentication
# 
#  pom.xml                        |  12 ++++++
#  src/main/java/AuthService.java |  45 ++++++++++++++++++++
#  2 files changed, 57 insertions(+)

# Show file stats with graph
git log --stat --graph --oneline

# Show word diff (useful for markdown, text files)
git log -p --word-diff
```

**Branch and merge history:**

```bash
# Show merge commits
git log --merges

# Hide merge commits
git log --no-merges

# Show first parent only (main line)
git log --first-parent

# Show commits in branch A not in branch B
git log branchB..branchA
git log ^branchB branchA  # Same

# Show commits in either A or B but not both
git log branchA...branchB

# Example: Commits in develop not in main
git log main..develop --oneline
```

**Java project specific examples:**

```bash
# View all commits that changed dependencies
git log --oneline -- pom.xml
git log --oneline -- build.gradle

# View all commits by specific developer
git log --author="jane@example.com" --oneline --graph

# View release history
git log --oneline --grep="release" --grep="version"

# View all bug fixes
git log --oneline --grep="fix" --since="1 month ago"

# View changes to a specific package
git log --oneline -- src/main/java/com/example/service/

# View who changed a line (blame)
git blame src/main/java/User.java
git blame -L 10,20 src/main/java/User.java  # Lines 10-20

# Find who deleted code
git log -S"deletedCode" --all --source --full-history

# View changes between releases
git log v1.0.0..v2.0.0 --oneline
```

### git diff - Working vs Staged vs Committed

**Understanding git diff:**

```bash
# Working directory vs Staging area
git diff
# Shows: Changes you made but haven't staged

# Staging area vs Last commit
git diff --staged
git diff --cached  # Same
# Shows: Changes you staged and will commit

# Working directory vs Last commit
git diff HEAD
# Shows: All changes since last commit (staged + unstaged)

# Specific file
git diff pom.xml
git diff --staged pom.xml
git diff HEAD pom.xml
```

**Comparing commits:**

```bash
# Between two commits
git diff a1b2c3d 9a8b7c6

# Between branches
git diff main develop
git diff main..develop  # Same

# Changes in develop not in main
git diff main...develop

# Between HEAD and parent
git diff HEAD^ HEAD
git diff HEAD~1 HEAD  # Same

# Between tags
git diff v1.0.0 v2.0.0
```

**Diff output explained:**

```bash
git diff pom.xml

# Output:
# diff --git a/pom.xml b/pom.xml
# index 5f7e3a7..3a2b1c9 100644
# --- a/pom.xml
# +++ b/pom.xml
# @@ -15,7 +15,7 @@
#      <dependency>
#          <groupId>org.springframework.boot</groupId>
#          <artifactId>spring-boot-starter-web</artifactId>
# -        <version>3.1.0</version>
# +        <version>3.2.0</version>
#      </dependency>

# Explanation:
# 1. "diff --git a/pom.xml b/pom.xml"
#    - Comparing file pom.xml
# 
# 2. "index 5f7e3a7..3a2b1c9 100644"
#    - Old blob: 5f7e3a7
#    - New blob: 3a2b1c9
#    - Mode: 100644 (regular file)
# 
# 3. "--- a/pom.xml" and "+++ b/pom.xml"
#    - --- = old version
#    - +++ = new version
# 
# 4. "@@ -15,7 +15,7 @@"
#    - Line numbers affected
#    - -15,7 = Old: starting at line 15, 7 lines
#    - +15,7 = New: starting at line 15, 7 lines
# 
# 5. Lines:
#    - Lines starting with '-' are removed
#    - Lines starting with '+' are added
#    - Lines with no prefix are context
```

**Diff options:**

```bash
# Show only file names
git diff --name-only
git diff --name-status
# M	pom.xml
# A	src/main/java/AuthService.java

# Show statistics
git diff --stat
#  pom.xml                           |  2 +-
#  src/main/java/AuthService.java    | 45 ++++++++++++++++++++++++
#  2 files changed, 46 insertions(+), 1 deletion(-)

# Show word diff (better for prose, documentation)
git diff --word-diff
# old version: spring-boot-starter-web:[-3.1.0-]
# new version: spring-boot-starter-web:{+3.2.0+}

# Ignore whitespace
git diff -w
git diff --ignore-all-space

# Ignore whitespace at line end
git diff --ignore-space-at-eol

# Ignore blank lines
git diff --ignore-blank-lines

# Show function/class context
git diff -p
git diff --show-function  # Show Java method names

# Side-by-side comparison (use with difftool)
git diff --no-index file1 file2  # Compare any two files
```

**Diff for Java projects:**

```bash
# Compare Maven dependencies between branches
git diff main develop -- pom.xml

# Compare Gradle configuration
git diff -- build.gradle

# Compare specific Java package
git diff HEAD~1 HEAD -- src/main/java/com/example/service/

# Ignore generated files
git diff -- . ':(exclude)target/*'
git diff -- . ':(exclude)*.class'

# Compare test files only
git diff -- src/test/java/

# See changes in properties files
git diff -- src/main/resources/*.properties
git diff -- src/main/resources/application.yml

# Binary files (JARs, images)
git diff --binary
```

**Using external diff tools:**

```bash
# Configure diff tool (IntelliJ, VS Code, etc.)
git config --global diff.tool idea
git config --global difftool.idea.cmd 'idea diff "$LOCAL" "$REMOTE"'

# Use diff tool
git difftool
git difftool main develop

# Configure merge tool
git config --global merge.tool idea
git config --global mergetool.idea.cmd 'idea merge "$LOCAL" "$REMOTE" "$BASE" "$MERGED"'
```

---

## Summary

### Git Internals

- ✅ **Four object types**: Blob (file), Tree (directory), Commit (snapshot), Tag (pointer)
- ✅ **.git structure**: objects/, refs/, HEAD, index, config
- ✅ **SHA-1 hashing**: Content-addressed storage, integrity checking
- ✅ **DAG**: Directed acyclic graph of commits
- ✅ **Refs**: Branches, tags, HEAD - just pointers to commits

### Three Areas

- ✅ **Working Directory**: Your actual files on disk
- ✅ **Staging Area**: Index file, prepared for next commit
- ✅ **Repository**: .git directory, permanent storage

### Core Commands

- ✅ **git add**: Hash content, store blob, update index
- ✅ **git commit**: Create tree and commit objects, advance branch
- ✅ **git status**: Show state of all three areas
- ✅ **git log**: View history with powerful filtering and formatting
- ✅ **git diff**: Compare working directory, staging area, and commits

**Key Takeaways for Java Developers:**

- Understand what happens when you commit (tree → commit → branch advance)
- Use staging area strategically (commit logical changes separately)
- Use `.gitignore` for target/, .class files, IDE files
- Write good commit messages (conventional commits)
- Use `git log` to understand project history and find changes
- Use `git diff` to review changes before committing
