
## Overview

Master Git's advanced operations to handle complex scenarios in Java development. These tools are your safety net and power tools for sophisticated Git workflows.

```
┌────────────────────────────────────────────────────────┐
│              ADVANCED GIT OPERATIONS                   │
├────────────────────────────────────────────────────────┤
│                                                        │
│  STASH: Temporary storage for work in progress        │
│  ────────────────────────────────────────────         │
│  Working Directory → Stash → Working Directory        │
│  (save changes)      (store)  (restore later)         │
│                                                        │
│  CHERRY-PICK: Copy specific commits                   │
│  ─────────────────────────────────────                │
│  Branch A: A---B---C---D                              │
│  Branch B: X---Y---C'  (C' = copy of C)               │
│                                                        │
│  REVERT: Safe undo (creates new commit)               │
│  ────────────────────────────────────────             │
│  A---B---C---D---E  (E reverses D)                    │
│                                                        │
│  RESET: Dangerous undo (moves HEAD)                   │
│  ───────────────────────────────────                  │
│  Before: A---B---C---D---E (HEAD)                     │
│  After:  A---B---C (HEAD)                             │
│          D---E (orphaned, can recover via reflog)     │
│                                                        │
│  REFLOG: Safety net (tracks HEAD movements)           │
│  ────────────────────────────────────────             │
│  HEAD@{0}: commit: Add feature                        │
│  HEAD@{1}: reset: moving to HEAD~3                    │
│  HEAD@{2}: commit: Bad commit                         │
│  (Can recover any state)                               │
│                                                        │
│  BISECT: Binary search for bugs                       │
│  ───────────────────────────────────                  │
│  good → mid → mid → mid → bad (found bug commit)      │
│                                                        │
└────────────────────────────────────────────────────────┘
```

---

## 1. Stashing

### git stash (Save Work in Progress)

Stash temporarily saves your uncommitted changes so you can switch branches or work on something else.

**What stash does:**

```bash
# Before stash:
Working directory: Modified files
Staging area: Some staged files
Repository: Clean commits

# After git stash:
Working directory: CLEAN (like last commit)
Staging area: CLEAN
Stash: Saved your changes

# Your changes are safely stored in stash
# You can now switch branches, pull, etc.
```

**Basic stashing:**

```bash
# You're working on a feature
vim src/main/java/User.java
vim src/main/java/AuthService.java
git add src/main/java/User.java

git status
# On branch feature/authentication
# Changes to be committed:
#   modified:   src/main/java/User.java
# Changes not staged for commit:
#   modified:   src/main/java/AuthService.java

# Urgent: Need to switch to main to fix bug
# But don't want to commit half-done work

# Stash your changes
git stash
# or
git stash save "WIP: authentication feature"

# Output:
# Saved working directory and index state WIP on feature/authentication: a1b2c3d Add user model
# HEAD is now at a1b2c3d Add user model

# Working directory is now clean
git status
# On branch feature/authentication
# nothing to commit, working tree clean

# Switch to main and fix bug
git checkout main
# Make fix
git commit -m "fix: Critical security bug"

# Return to feature branch
git checkout feature/authentication

# Restore stashed changes
git stash pop

# Continue working
```

**Stash visualization:**

```
Timeline of stash usage:

1. Working on feature
   Working dir: Modified files
   ↓

2. git stash
   Working dir: Clean
   Stash: Contains your changes
   ↓

3. Switch branches, fix bug, etc.
   Working dir: Clean (different branch)
   Stash: Still contains your changes
   ↓

4. Return to original branch
   Working dir: Clean
   Stash: Still contains your changes
   ↓

5. git stash pop
   Working dir: Your changes restored
   Stash: Empty (changes removed from stash)
```

---

### git stash list, show, apply, pop

Managing multiple stashes and viewing their contents.

#### List stashes

```bash
# View all stashes
git stash list

# Output:
# stash@{0}: WIP on feature/auth: a1b2c3d Add authentication
# stash@{1}: WIP on feature/payment: 9a8b7c6 Add payment processing
# stash@{2}: On main: Fix critical bug

# Stash naming:
# stash@{0} = most recent
# stash@{1} = second most recent
# stash@{2} = third most recent
# etc.
```

#### Show stash contents

```bash
# Show what's in latest stash
git stash show

# Output:
#  src/main/java/User.java        | 10 +++++++---
#  src/main/java/AuthService.java | 25 +++++++++++++++++++++++++
#  2 files changed, 32 insertions(+), 3 deletions(-)

# Show detailed diff
git stash show -p
# or
git stash show --patch

# Output:
# diff --git a/src/main/java/User.java b/src/main/java/User.java
# index a1b2c3d..9a8b7c6 100644
# --- a/src/main/java/User.java
# +++ b/src/main/java/User.java
# @@ -10,6 +10,9 @@ public class User {
#      private String email;
# +    private String password;
# +
# +    public void authenticate() { }
#  }

# Show specific stash
git stash show stash@{1}
git stash show stash@{1} -p
```

#### Apply stash

```bash
# Apply latest stash (keep it in stash list)
git stash apply

# Apply specific stash
git stash apply stash@{1}

# Apply creates potential conflicts
git stash apply
# Auto-merging src/main/java/User.java
# CONFLICT (content): Merge conflict in src/main/java/User.java

# Resolve conflicts
vim src/main/java/User.java
git add src/main/java/User.java

# Note: apply doesn't remove from stash list
git stash list
# stash@{0}: WIP on feature/auth: a1b2c3d Add authentication
# (still there)
```

#### Pop stash

```bash
# Apply and remove latest stash
git stash pop

# Equivalent to:
git stash apply
git stash drop  # Remove from stash list

# Pop specific stash
git stash pop stash@{1}

# If pop fails due to conflicts:
git stash pop
# Auto-merging src/main/java/User.java
# CONFLICT (content): Merge conflict in src/main/java/User.java
# The stash entry is kept in case you need it again.

# Stash is NOT removed if there are conflicts
# Resolve conflicts, then manually drop:
git stash drop
```

#### Drop stash

```bash
# Remove latest stash without applying
git stash drop

# Remove specific stash
git stash drop stash@{1}

# Remove all stashes
git stash clear
# ⚠️ WARNING: Cannot be undone!
```

**Complete stash workflow:**

```bash
# Scenario: Multiple WIP features

# Feature 1: Authentication
git checkout -b feature/auth
# Make changes
vim src/main/java/User.java
git stash save "WIP: Add User authentication"

# Feature 2: Payment
git checkout -b feature/payment
# Make changes
vim src/main/java/Payment.java
git stash save "WIP: Payment processing"

# Hotfix on main
git checkout main
# Make changes
vim src/main/java/Security.java
git stash save "Hotfix: Security patch"

# View all stashes
git stash list
# stash@{0}: On main: Hotfix: Security patch
# stash@{1}: On feature/payment: WIP: Payment processing
# stash@{2}: On feature/auth: WIP: Add User authentication

# Complete hotfix first
git stash pop stash@{0}
git add .
git commit -m "fix: Security vulnerability"

# Return to payment feature
git checkout feature/payment
git stash pop stash@{0}  # Now @{0} is payment (hotfix was removed)
# Continue work

# Return to auth feature
git checkout feature/auth
git stash pop
# Continue work
```

---

### git stash branch (Create Branch from Stash)

Create a new branch from a stash, useful when stash conflicts with current branch.

**Use case:**

```bash
# You stashed changes on main
git checkout main
# Make changes
git stash save "WIP: New feature"

# Main branch changed significantly
git pull origin main
# Many changes that conflict with your stash

# Applying stash would create conflicts
git stash pop
# CONFLICT (content): Merge conflict in src/main/java/User.java

# Solution: Create new branch from stash
git stash branch feature/new-feature

# This does:
# 1. Creates new branch from commit where stash was created
# 2. Checks out that branch
# 3. Applies stash
# 4. Drops stash if successful

# Now you have:
# - New branch with your changes
# - No conflicts (because branch is at original commit)
# - Clean starting point for feature
```

**Example workflow:**

```bash
# Working on main
git checkout main

# Started implementing feature
vim src/main/java/User.java
vim src/main/java/AuthService.java

# Realize feature is too big for main
# Stash work
git stash save "Feature: User authentication"

# Create branch from stash
git stash branch feature/authentication

# Output:
# Switched to a new branch 'feature/authentication'
# On branch feature/authentication
# Changes not staged for commit:
#   modified:   src/main/java/User.java
#   modified:   src/main/java/AuthService.java
# Dropped refs/stash@{0} (abc123...)

# Now commit in proper feature branch
git add .
git commit -m "feat: Add user authentication"

# Main branch is still clean
git checkout main
git status
# On branch main
# nothing to commit, working tree clean
```

---

### Stashing Untracked Files (git stash -u)

By default, stash only saves tracked files. Use `-u` to include untracked files.

**Stash options:**

```bash
# Default: stash only tracked files
git stash

# Include untracked files
git stash -u
git stash --include-untracked

# Include everything (even ignored files)
git stash -a
git stash --all

# Keep index (staged changes remain staged after stash)
git stash --keep-index
```

**Example with untracked files:**

```bash
# Modify tracked file
vim src/main/java/User.java

# Create new untracked file
vim src/main/java/NewService.java

# Add to .gitignore but want to stash anyway
echo "*.log" > debug.log

git status
# On branch feature/auth
# Changes not staged for commit:
#   modified:   src/main/java/User.java
# Untracked files:
#   src/main/java/NewService.java
#   debug.log

# Regular stash (only saves User.java)
git stash
git status
# On branch feature/auth
# Untracked files:
#   src/main/java/NewService.java  ← Still here
#   debug.log                       ← Still here

# Stash with untracked files
git stash -u
git status
# On branch feature/auth
# Untracked files:
#   debug.log  ← Still here (in .gitignore)

# Stash everything including ignored
git stash -a
git status
# On branch feature/auth
# nothing to commit, working tree clean  ← All clean!
```

**Stash with partial staging:**

```bash
# Stage some changes
git add src/main/java/User.java

# Keep staged changes staged after stash
git stash --keep-index

git status
# On branch feature/auth
# Changes to be committed:
#   modified:   src/main/java/User.java  ← Still staged
# (Other changes are stashed)

# Commit staged changes
git commit -m "feat: Add user validation"

# Restore stashed changes
git stash pop
# Now you have unstaged changes back
```

**Interactive stashing:**

```bash
# Stash only specific files
git stash push -m "Partial stash" src/main/java/User.java

# Stash with patch mode (choose hunks)
git stash push -p
# For each change, choose:
# y - stash this hunk
# n - don't stash this hunk
# q - quit
# a - stash this and all remaining hunks
# d - don't stash this or any remaining hunks
# s - split hunk into smaller hunks
```

---

## 2. Cherry-picking

### git cherry-pick (Apply Specific Commit)

Cherry-pick copies a commit from one branch to another.

**What cherry-pick does:**

```
Before cherry-pick:

main:     A---B---C
               \
feature:        D---E---F

You want commit E on main, but not D or F

After cherry-pick:

main:     A---B---C---E'
               \
feature:        D---E---F

E' = copy of E (same changes, different SHA-1)
```

**Basic cherry-pick:**

```bash
# You're on main branch
git checkout main

# Find commit you want (from feature branch)
git log --oneline feature/payment
# f6g7h8i Add payment validation
# e5f6g7h Add PayPal integration  ← Want this one
# d4e5f6g Add payment model

# Cherry-pick specific commit
git cherry-pick e5f6g7h

# Output:
# [main a1b2c3d] Add PayPal integration
#  Date: Mon Jan 15 10:30:00 2024 +0000
#  1 file changed, 50 insertions(+)
#  create mode 100644 src/main/java/payment/PayPalService.java

# Verify
git log --oneline -2
# a1b2c3d (HEAD -> main) Add PayPal integration
# 9a8b7c6 Previous commit on main

# Note: a1b2c3d is NEW commit (different SHA than e5f6g7h)
```

**Cherry-pick multiple commits:**

```bash
# Cherry-pick range of commits
git cherry-pick d4e5f6g..f6g7h8i

# Cherry-pick multiple specific commits
git cherry-pick commit1 commit2 commit3

# Example:
git cherry-pick e5f6g7h f6g7h8i
```

**Cherry-pick options:**

```bash
# Cherry-pick without committing (stage changes only)
git cherry-pick -n e5f6g7h
git cherry-pick --no-commit e5f6g7h

# Cherry-pick and edit commit message
git cherry-pick -e e5f6g7h
git cherry-pick --edit e5f6g7h

# Cherry-pick with different author
git cherry-pick e5f6g7h --signoff

# Cherry-pick and add "cherry picked from" message
git cherry-pick -x e5f6g7h
# Commit message will include:
# (cherry picked from commit e5f6g7h...)
```

---

### When to Use (Hotfixes, Selective Merging)

**Use case 1: Hotfix to multiple branches**

```bash
# Bug exists in multiple release branches

# Fix on main
git checkout main
vim src/main/java/Security.java
git commit -m "fix: Prevent SQL injection"
# Commit SHA: abc123d

# Apply to release-1.0
git checkout release-1.0
git cherry-pick abc123d

# Apply to release-2.0
git checkout release-2.0
git cherry-pick abc123d

# Now all branches have the fix
```

**Use case 2: Selective feature migration**

```bash
# Feature branch has 10 commits
# Only need 3 specific features for release

git checkout release/1.0

# Pick only needed commits
git cherry-pick commit-1  # User authentication
git cherry-pick commit-5  # Email validation
git cherry-pick commit-8  # Password reset

# Skip other commits (not needed for this release)
```

**Use case 3: Undoing a merge**

```bash
# Merged feature branch with 5 commits
# Only 1 commit was bad

# Revert the merge
git revert -m 1 merge-commit

# Cherry-pick the good commits back
git cherry-pick good-commit-1
git cherry-pick good-commit-2
git cherry-pick good-commit-3
git cherry-pick good-commit-4
# Skip bad-commit-5
```

**Use case 4: Backporting**

```bash
# New feature in develop
# Customer needs it in their custom branch

git checkout customer-branch
git cherry-pick commit-from-develop

# Feature is now in customer branch
# Without merging all of develop
```

---

### Cherry-pick Conflicts

Handle conflicts when cherry-picking commits.

**Conflict during cherry-pick:**

```bash
# Cherry-pick commit
git cherry-pick e5f6g7h

# Conflict!
# error: could not apply e5f6g7h... Add PayPal integration
# hint: after resolving the conflicts, mark the corrected paths
# hint: with 'git add <paths>' or 'git rm <paths>'
# hint: and commit the result with 'git commit'

# Check status
git status
# On branch main
# You are currently cherry-picking commit e5f6g7h.
#   (fix conflicts and run "git cherry-pick --continue")
#   (use "git cherry-pick --skip" to skip this patch)
#   (use "git cherry-pick --abort" to cancel the cherry-pick operation)
#
# Unmerged paths:
#   both modified:   src/main/java/payment/PaymentService.java

# Resolve conflict
vim src/main/java/payment/PaymentService.java
git add src/main/java/payment/PaymentService.java

# Continue cherry-pick
git cherry-pick --continue

# Or skip this commit
git cherry-pick --skip

# Or abort entire cherry-pick
git cherry-pick --abort
```

**Cherry-pick multiple commits with conflicts:**

```bash
# Cherry-pick range
git cherry-pick commit1..commit5

# First commit succeeds
# [main abc123] Commit 1
#  1 file changed, 10 insertions(+)

# Second commit conflicts
# CONFLICT (content): Merge conflict in User.java

# Resolve and continue
vim src/main/java/User.java
git add src/main/java/User.java
git cherry-pick --continue

# Third commit succeeds
# Fourth commit conflicts
# Resolve again...
# Fifth commit succeeds

# Result: All 5 commits cherry-picked
```

**Cherry-pick strategies:**

```bash
# Use 'ours' strategy (keep current version on conflict)
git cherry-pick -X ours e5f6g7h

# Use 'theirs' strategy (use incoming version on conflict)
git cherry-pick -X theirs e5f6g7h

# Use 'patience' algorithm (better conflict detection)
git cherry-pick -X patience e5f6g7h
```

---

## 3. Reverting and Resetting

### git revert (Safe, Creates New Commit)

Revert creates a new commit that undoes changes from a previous commit.

**What revert does:**

```
Before revert:

A---B---C---D (HEAD, main)
            ↑
         Bad commit

After revert D:

A---B---C---D---E (HEAD, main)
                ↑
            Revert commit (undoes D)

• D still exists in history
• E is new commit that reverses D's changes
• Safe for shared branches
```

**Basic revert:**

```bash
# View history
git log --oneline
# d4e5f6g (HEAD -> main) Add payment feature
# c3d4e5f Update user model
# b2c3d4e Fix authentication bug
# a1b2c3d Initial commit

# Last commit broke production
# Revert it
git revert HEAD

# Or revert specific commit
git revert d4e5f6g

# Git opens editor for commit message:
# Revert "Add payment feature"
# 
# This reverts commit d4e5f6g.

# Save and close

# View history
git log --oneline
# e5f6g7h (HEAD -> main) Revert "Add payment feature"
# d4e5f6g Add payment feature
# c3d4e5f Update user model
# b2c3d4e Fix authentication bug
# a1b2c3d Initial commit

# Both commits exist in history!
```

**Revert options:**

```bash
# Revert without committing (stage changes only)
git revert -n HEAD
git revert --no-commit HEAD

# Revert and edit message
git revert -e HEAD
git revert --edit HEAD

# Revert multiple commits
git revert HEAD~3..HEAD

# Revert merge commit (specify parent)
git revert -m 1 merge-commit
# -m 1 = keep first parent (usually main branch)
# -m 2 = keep second parent (usually feature branch)
```

**Revert vs Reset:**

```
REVERT:
───────
• Creates new commit
• Preserves history
• Safe for shared branches
• Can be reverted again
• Good for fixing public mistakes

RESET:
──────
• Moves HEAD pointer
• Rewrites history
• DANGEROUS for shared branches
• Cannot easily undo
• Good for local cleanup
```

---

### git reset --soft (Move HEAD, Keep Changes)

Reset --soft moves HEAD but keeps changes staged.

**What reset --soft does:**

```
Before reset --soft:

Commits:    A---B---C---D---E (HEAD)
Working:    Clean
Staging:    Clean

After reset --soft HEAD~2:

Commits:    A---B---C (HEAD)
Working:    Clean
Staging:    Changes from D and E (staged)

• HEAD moved back 2 commits
• Changes from D and E are in staging area
• Can re-commit differently
```

**Using reset --soft:**

```bash
# View history
git log --oneline
# e5f6g7h (HEAD -> main) Commit 5
# d4e5f6g Commit 4
# c3d4e5f Commit 3
# b2c3d4e Commit 2
# a1b2c3d Commit 1

# Move HEAD back 2 commits, keep changes
git reset --soft HEAD~2

# View history (commits gone)
git log --oneline
# c3d4e5f (HEAD -> main) Commit 3
# b2c3d4e Commit 2
# a1b2c3d Commit 1

# View status (changes from D and E are staged)
git status
# On branch main
# Changes to be committed:
#   (all changes from commits 4 and 5)

# Can now create single commit instead
git commit -m "Combined commits 4 and 5"

# Or split differently
git reset HEAD  # Unstage all
git add file1.java
git commit -m "Commit 4 changes"
git add file2.java
git commit -m "Commit 5 changes"
```

**Use cases for --soft:**

```bash
# Use case 1: Combine last 3 commits
git reset --soft HEAD~3
git commit -m "Combined feature implementation"

# Use case 2: Fix last commit message
git reset --soft HEAD^
git commit -m "Better commit message"
# (But git commit --amend is easier)

# Use case 3: Split last commit
git reset --soft HEAD^
git reset  # Unstage all
# Stage and commit separately
```

---

### git reset --mixed (Default, Unstage Changes)

Reset --mixed (default) moves HEAD and unstages changes.

**What reset --mixed does:**

```
Before reset --mixed:

Commits:    A---B---C---D---E (HEAD)
Working:    Clean
Staging:    Clean

After reset --mixed HEAD~2:

Commits:    A---B---C (HEAD)
Working:    Changes from D and E (unstaged)
Staging:    Clean

• HEAD moved back 2 commits
• Changes from D and E in working directory
• Nothing in staging area
```

**Using reset --mixed:**

```bash
# Default behavior (no flag needed)
git reset HEAD~2
# Same as:
git reset --mixed HEAD~2

# View status
git status
# On branch main
# Changes not staged for commit:
#   (all changes from commits 4 and 5)

# Can now stage selectively
git add file1.java
git commit -m "Part 1"
git add file2.java file3.java
git commit -m "Part 2"
```

**Common use cases:**

```bash
# Unstage files
git add .
git reset HEAD file.java  # Unstage specific file
git reset HEAD  # Unstage all

# Undo last commit, keep changes
git reset HEAD^
# Now can modify and re-commit

# Undo multiple commits
git reset HEAD~5
# All changes from last 5 commits are unstaged
```

---

### git reset --hard (Discard Changes) ⚠️

Reset --hard moves HEAD and **DISCARDS ALL CHANGES**. **DANGEROUS!**

**What reset --hard does:**

```
Before reset --hard:

Commits:    A---B---C---D---E (HEAD)
Working:    Modified files
Staging:    Staged files

After reset --hard HEAD~2:

Commits:    A---B---C (HEAD)
Working:    Clean (matches C)
Staging:    Clean

• HEAD moved back 2 commits
• All changes DISCARDED
• Working directory matches commit C
• Cannot easily recover D and E
```

**⚠️ WARNING:**

```bash
# ⚠️ DANGEROUS: Destroys uncommitted work
git reset --hard

# ⚠️ DANGEROUS: Destroys commits and changes
git reset --hard HEAD~3

# These operations:
# - Delete uncommitted changes
# - Can lose work permanently
# - Should be used very carefully
```

**Safe use of --hard:**

```bash
# Scenario 1: Discard all local changes
git status
# Lots of changes you don't want
git reset --hard HEAD
# Working directory is clean

# Scenario 2: Abandon branch and start over
git reset --hard origin/main
# Local main now matches remote exactly

# Scenario 3: Get specific commit state
git reset --hard abc123
# Working directory now matches commit abc123

# Scenario 4: Undo bad merge
git merge feature/broken
# Merge created problems
git reset --hard HEAD~1
# Back to before merge
```

**Before using --hard:**

```bash
# Create backup branch first
git branch backup-before-reset

# Then reset
git reset --hard HEAD~5

# If you made a mistake:
git checkout backup-before-reset
# Or
git reset --hard backup-before-reset
```

---

### Recovering from Reset (Reflog)

Even after reset --hard, commits can be recovered using reflog.

**Recovery process:**

```bash
# Accidentally destroyed commits
git log --oneline
# c3d4e5f (HEAD -> main) Commit 3
# b2c3d4e Commit 2
# a1b2c3d Commit 1

# Oh no! Had commits 4 and 5

# Check reflog
git reflog
# c3d4e5f HEAD@{0}: reset: moving to HEAD~2
# e5f6g7h HEAD@{1}: commit: Commit 5
# d4e5f6g HEAD@{2}: commit: Commit 4
# c3d4e5f HEAD@{3}: commit: Commit 3

# Found them! Commit 5 was at e5f6g7h

# Recover by resetting to that SHA
git reset --hard e5f6g7h

# Or use HEAD@{1}
git reset --hard HEAD@{1}

# Verify recovery
git log --oneline
# e5f6g7h (HEAD -> main) Commit 5
# d4e5f6g Commit 4
# c3d4e5f Commit 3
# b2c3d4e Commit 2
# a1b2c3d Commit 1

# All commits recovered!
```

---

## 4. Reflog

### git reflog (Reference Log, Safety Net)

Reflog tracks every movement of HEAD, providing a safety net.

**What reflog records:**

```bash
# View reflog
git reflog

# Output:
# a1b2c3d HEAD@{0}: commit: Add user validation
# 9a8b7c6 HEAD@{1}: commit: Add user model
# 8a7b6c5 HEAD@{2}: checkout: moving from main to feature/auth
# 7a6b5c4 HEAD@{3}: pull: Fast-forward
# 6a5b4c3 HEAD@{4}: commit: Fix bug
# 5a4b3c2 HEAD@{5}: reset: moving to HEAD~2
# 4a3b2c1 HEAD@{6}: commit: Bad commit 2
# 3a2b1c9 HEAD@{7}: commit: Bad commit 1

# Reflog tracks:
# - Commits
# - Checkouts
# - Merges
# - Rebases
# - Resets
# - Pulls
# - Cherry-picks
# - Everything that moves HEAD
```

**Reflog commands:**

```bash
# View reflog
git reflog

# View reflog with dates
git reflog --date=iso

# View reflog for specific branch
git reflog show main
git reflog show feature/auth

# View reflog with relative dates
git reflog --date=relative
# a1b2c3d HEAD@{5 minutes ago}: commit: Add feature
# 9a8b7c6 HEAD@{2 hours ago}: reset: moving to HEAD~1
# 8a7b6c5 HEAD@{3 days ago}: commit: Old commit

# View detailed reflog
git reflog show --all

# Limit reflog entries
git reflog -5  # Last 5 entries
git reflog -n 10  # Last 10 entries
```

---

### Recovering Lost Commits

**Scenario 1: Accidental reset --hard**

```bash
# Working on feature
git log --oneline
# f6g7h8i (HEAD -> main) Feature complete
# e5f6g7h Add tests
# d4e5f6g Add implementation
# c3d4e5f Add model

# Accidentally reset
git reset --hard HEAD~3
# HEAD is now at c3d4e5f Add model

# Lost 3 commits!
git log --oneline
# c3d4e5f (HEAD -> main) Add model

# Use reflog to find lost commits
git reflog
# c3d4e5f HEAD@{0}: reset: moving to HEAD~3
# f6g7h8i HEAD@{1}: commit: Feature complete  ← Here!
# e5f6g7h HEAD@{2}: commit: Add tests
# d4e5f6g HEAD@{3}: commit: Add implementation

# Recover
git reset --hard f6g7h8i
# or
git reset --hard HEAD@{1}

# Verify
git log --oneline
# f6g7h8i (HEAD -> main) Feature complete
# e5f6g7h Add tests
# d4e5f6g Add implementation
# c3d4e5f Add model

# Recovered!
```

**Scenario 2: Deleted branch**

```bash
# Delete branch accidentally
git branch -D feature/important
# Deleted branch feature/important (was abc123d).

# Oh no! Had uncommitted work

# Find in reflog
git reflog
# Find last commit on that branch

# Recreate branch
git branch feature/important abc123d
# or
git checkout -b feature/important abc123d

# Branch recovered with all commits
```

**Scenario 3: Bad rebase**

```bash
# Rebase went wrong
git rebase main
# Lots of conflicts, giving up

git rebase --abort  # Too late, already continued

# Find state before rebase
git reflog
# abc123d HEAD@{0}: rebase finished
# def456e HEAD@{5}: checkout: moving from feature to main  ← Before rebase
# ghi789f HEAD@{6}: commit: Last good commit  ← Here!

# Reset to before rebase
git reset --hard ghi789f

# Back to pre-rebase state
```

---

### Undoing Bad Rebase/Reset

**Complete undo workflow:**

```bash
# 1. Check current state
git log --oneline -5
git status

# 2. View reflog to find desired state
git reflog
# or with better formatting
git reflog --format='%C(auto)%h%d %C(yellow)%ci%C(reset) %s'

# 3. Identify commit to restore
# Look for entry before the bad operation

# 4. Create backup of current state (just in case)
git branch backup-current

# 5. Reset to good state
git reset --hard <commit-sha>
# or
git reset --hard HEAD@{N}

# 6. Verify recovery
git log --oneline
git status

# 7. If wrong, use backup
git reset --hard backup-current

# 8. Clean up backup when satisfied
git branch -d backup-current
```

**Example: Undo bad interactive rebase**

```bash
# Interactive rebase messed up commits
git rebase -i HEAD~10
# Squashed wrong commits, history is broken

# Check reflog
git reflog
# abc123d HEAD@{0}: rebase -i (finish)
# def456e HEAD@{1}: rebase -i (start)  ← Good state before rebase

# Undo rebase
git reset --hard def456e

# History restored
```

**Reflog expiration:**

```bash
# Reflog keeps entries for 90 days by default
# After that, commits may be garbage collected

# View reflog expiration config
git config gc.reflogExpire
# 90.days.ago

# Change expiration
git config gc.reflogExpire "180 days"

# Never expire
git config gc.reflogExpire never

# Force garbage collection (be careful!)
git reflog expire --expire=now --all
git gc --prune=now
```

---

## 5. Bisect

### git bisect (Binary Search for Bugs)

Bisect uses binary search to find the commit that introduced a bug.

**How bisect works:**

```
Commit history (100 commits):

1---2---3---4---5---6---7---8---9---10...[90 more]...100
                                                        ↑
                                                    Bug exists

Binary search:
───────────────

1. Test commit 50 (middle)
   → Bug exists, search 1-50

2. Test commit 25
   → No bug, search 25-50

3. Test commit 37
   → Bug exists, search 25-37

4. Test commit 31
   → No bug, search 31-37

5. Test commit 34
   → Bug exists, found! Commit 34 introduced the bug

Instead of testing all 100 commits, only tested ~7!
```

**Basic bisect workflow:**

```bash
# Bug exists in current version, but worked in v1.0.0

# Start bisect
git bisect start

# Mark current commit as bad (has bug)
git bisect bad

# Mark known good commit
git bisect good v1.0.0

# Git checks out middle commit
# Bisecting: 50 revisions left to test after this (roughly 6 steps)
# [abc123d] Middle commit

# Test the code
mvn clean test
# Tests fail - bug exists

# Mark as bad
git bisect bad

# Git checks out another commit
# Bisecting: 25 revisions left to test after this (roughly 5 steps)
# [def456e] Another commit

# Test again
mvn clean test
# Tests pass - no bug

# Mark as good
git bisect good

# Continue until found
# Bisecting: 12 revisions left to test after this (roughly 4 steps)
# Test, mark good/bad
# Bisecting: 6 revisions left to test after this (roughly 3 steps)
# Test, mark good/bad
# Bisecting: 3 revisions left to test after this (roughly 2 steps)
# Test, mark good/bad
# Bisecting: 1 revisions left to test after this (roughly 1 step)
# Test, mark good/bad

# Found!
# abc123d is the first bad commit
# commit abc123d
# Author: John Doe <john@example.com>
# Date:   Mon Jan 15 10:30:00 2024 +0000
# 
#     feat: Add user authentication
# 
#  src/main/java/AuthService.java | 50 ++++++++++++++++++++++++++

# End bisect
git bisect reset
# Returns to original branch
```

---

### Finding Which Commit Introduced a Bug

**Real Java example:**

```bash
# Production bug: NullPointerException in payment processing
# Worked in v2.0.0 (released last month)
# Broken now

# Start bisect
git bisect start

# Current version is bad
git bisect bad HEAD

# v2.0.0 was good
git bisect good v2.0.0

# Git checks out middle commit
# Bisecting: 45 revisions left to test after this

# Run application and test payment
./mvnw spring-boot:run
# Test payment endpoint
curl -X POST http://localhost:8080/api/payment \
  -H "Content-Type: application/json" \
  -d '{"amount": 100.00, "currency": "USD"}'

# NullPointerException! Bug exists
git bisect bad

# Next commit
# Bisecting: 22 revisions left to test
# Test again... No bug!
git bisect good

# Continue testing
# Bisecting: 11 revisions left
# Test... Bug!
git bisect bad

# Bisecting: 5 revisions left
# Test... Bug!
git bisect bad

# Bisecting: 2 revisions left
# Test... No bug!
git bisect good

# Bisecting: 1 revisions left
# Test... Bug!
git bisect bad

# Found!
# f6g7h8i is the first bad commit
# commit f6g7h8i
# Author: Jane Smith <jane@example.com>
# Date:   Wed Jan 10 14:20:00 2024 +0000
# 
#     refactor: Simplify payment validation
# 
#  src/main/java/payment/PaymentService.java | 15 +++++----------

# View the problematic commit
git show f6g7h8i

# End bisect
git bisect reset
```

---

### Automated Bisect with Scripts

Automate bisect by providing a test script.

**Test script example:**

```bash
# Create test script
cat > test-payment.sh << 'EOF'
#!/bin/bash

# Build project
./mvnw clean package -DskipTests || exit 125

# Run specific test
./mvnw test -Dtest=PaymentServiceTest#testProcessPayment

# Exit codes:
# 0 = tests pass (good commit)
# 1 = tests fail (bad commit)
# 125 = can't test (skip this commit)
EOF

chmod +x test-payment.sh
```

**Run automated bisect:**

```bash
# Start bisect
git bisect start HEAD v2.0.0

# Run automated bisect
git bisect run ./test-payment.sh

# Git automatically tests each commit
# Output:
# running ./test-payment.sh
# [build output]
# Bisecting: 22 revisions left to test after this
# running ./test-payment.sh
# [build output]
# Bisecting: 11 revisions left to test after this
# running ./test-payment.sh
# [build output]
# ...
# f6g7h8i is the first bad commit
# commit f6g7h8i
# ...
# bisect run success

# Automatically found the bad commit!
```

**Complex test script:**

```bash
# test-script.sh
#!/bin/bash

# Build
echo "Building project..."
./mvnw clean install -DskipTests
if [ $? -ne 0 ]; then
    echo "Build failed, skipping commit"
    exit 125
fi

# Start application
echo "Starting application..."
./mvnw spring-boot:run > /dev/null 2>&1 &
APP_PID=$!
sleep 10

# Wait for startup
timeout=30
while [ $timeout -gt 0 ]; do
    curl -s http://localhost:8080/actuator/health > /dev/null
    if [ $? -eq 0 ]; then
        break
    fi
    sleep 1
    ((timeout--))
done

if [ $timeout -eq 0 ]; then
    echo "Application failed to start"
    kill $APP_PID
    exit 125
fi

# Test payment endpoint
echo "Testing payment..."
response=$(curl -s -w "%{http_code}" -X POST \
    http://localhost:8080/api/payment \
    -H "Content-Type: application/json" \
    -d '{"amount": 100.00, "currency": "USD"}')

status_code="${response: -3}"

# Stop application
kill $APP_PID

# Check result
if [ "$status_code" == "200" ]; then
    echo "Test passed"
    exit 0
else
    echo "Test failed with status $status_code"
    exit 1
fi
```

**Bisect with Maven test:**

```bash
# test-with-maven.sh
#!/bin/bash

# Run specific test class
./mvnw test -Dtest=PaymentServiceTest

# Maven returns:
# 0 if tests pass
# Non-zero if tests fail
# Pass through Maven's exit code
exit $?
```

```bash
# Use the script
git bisect start HEAD v2.0.0
git bisect run ./test-with-maven.sh
```

**Bisect tips:**

```bash
# View bisect log
cat .git/BISECT_LOG

# Skip commit that can't be tested
git bisect skip
# Git will test a nearby commit instead

# Visualize bisect progress
git bisect visualize
# or
git bisect view

# Reset if you make mistake
git bisect reset

# Start over with different good/bad commits
git bisect reset
git bisect start HEAD v1.0.0
```

---

## Summary

### Stashing

- ✅ **git stash**: Temporarily save work in progress
- ✅ **Stash operations**: list, show, apply, pop, drop, clear
- ✅ **Stash branch**: Create branch from stash
- ✅ **Untracked files**: Use -u or -a flags

### Cherry-picking

- ✅ **git cherry-pick**: Apply specific commit to current branch
- ✅ **Use cases**: Hotfixes, selective merging, backporting
- ✅ **Conflicts**: Resolve with --continue, --skip, --abort

### Reverting and Resetting

- ✅ **git revert**: Safe undo (creates new commit)
- ✅ **git reset --soft**: Move HEAD, keep changes staged
- ✅ **git reset --mixed**: Move HEAD, unstage changes
- ✅ **git reset --hard**: ⚠️ Discard all changes
- ✅ **Recovery**: Use reflog to recover from mistakes

### Reflog

- ✅ **Safety net**: Tracks all HEAD movements
- ✅ **Recovery**: Restore lost commits and branches
- ✅ **Undo operations**: Reverse bad rebase/reset

### Bisect

- ✅ **Binary search**: Find bug-introducing commit efficiently
- ✅ **Manual testing**: Mark commits good/bad
- ✅ **Automated**: Use scripts for automatic testing

**Key Takeaways:**

- Stash is perfect for context switching
- Cherry-pick for selective commit application
- Revert for safe undo on shared branches
- Reset for local history cleanup (careful with --hard)
- Reflog is your safety net - use it!
- Bisect saves hours of debugging

**Safety Rules:**

- Always check reflog before panic
- Create backup branches before risky operations
- Use reset --hard with extreme caution
- Prefer revert over reset for shared branches
- Test bisect scripts before running
