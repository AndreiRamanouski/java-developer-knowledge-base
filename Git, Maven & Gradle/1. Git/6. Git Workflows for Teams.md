## Overview

Effective team collaboration requires well-defined Git workflows. This guide covers pull request workflows, code review best practices, and branch protection rules used in professional Java development teams.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              TEAM COLLABORATION WORKFLOW               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                        â”‚
â”‚  1. CREATE FEATURE BRANCH                             â”‚
â”‚     main â†’ feature/add-auth                           â”‚
â”‚                                                        â”‚
â”‚  2. MAKE COMMITS                                       â”‚
â”‚     feat: Add User model                              â”‚
â”‚     feat: Add authentication service                  â”‚
â”‚     test: Add auth tests                              â”‚
â”‚                                                        â”‚
â”‚  3. PUSH TO REMOTE                                     â”‚
â”‚     git push origin feature/add-auth                  â”‚
â”‚                                                        â”‚
â”‚  4. OPEN PULL REQUEST                                  â”‚
â”‚     GitHub/GitLab UI â†’ Create PR                      â”‚
â”‚                                                        â”‚
â”‚  5. CODE REVIEW                                        â”‚
â”‚     Reviewers: Comment, Request changes               â”‚
â”‚     Author: Address feedback, Push updates            â”‚
â”‚                                                        â”‚
â”‚  6. CI/CD CHECKS                                       â”‚
â”‚     âœ“ Tests pass                                      â”‚
â”‚     âœ“ Build succeeds                                  â”‚
â”‚     âœ“ Code coverage meets threshold                  â”‚
â”‚     âœ“ Security scan passes                           â”‚
â”‚                                                        â”‚
â”‚  7. MERGE PR                                           â”‚
â”‚     Squash & merge â†’ main                             â”‚
â”‚                                                        â”‚
â”‚  8. DELETE FEATURE BRANCH                              â”‚
â”‚     Clean up merged branch                            â”‚
â”‚                                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 1. Pull Request Workflow

### Creating Feature Branches

Start with a well-named feature branch from the latest main.

**Branch naming conventions:**

```bash
# Format: <type>/<description>
# Types: feature, bugfix, hotfix, refactor, docs, test

# Good branch names:
feature/user-authentication
feature/payment-integration
feature/JIRA-123-add-email-validation
bugfix/null-pointer-in-user-service
bugfix/JIRA-456-fix-payment-timeout
hotfix/security-vulnerability
refactor/extract-auth-service
docs/update-api-documentation
test/add-integration-tests

# Bad branch names:
new-feature  â† Too vague
fix  â† No context
johns-work  â† Who's John? What work?
temp  â† Not descriptive
branch1  â† No meaning
```

**Creating feature branch workflow:**

```bash
# 1. Ensure main is up to date
git checkout main
git pull origin main

# 2. Create feature branch
git checkout -b feature/user-authentication

# Or modern syntax
git switch -c feature/user-authentication

# 3. Verify branch
git branch
# * feature/user-authentication
#   main

# 4. Set upstream tracking (optional, but recommended)
git push -u origin feature/user-authentication

# Now ready to work!
```

**Best practices for branch creation:**

```bash
# âœ… DO: Always branch from latest main
git checkout main
git pull origin main
git checkout -b feature/new-feature

# âŒ DON'T: Branch from outdated main
git checkout main
# (main is 2 weeks old)
git checkout -b feature/new-feature

# âœ… DO: Use descriptive names
git checkout -b feature/JIRA-123-payment-integration

# âŒ DON'T: Use generic names
git checkout -b new-stuff

# âœ… DO: One feature per branch
git checkout -b feature/add-email-validation

# âŒ DON'T: Multiple unrelated features
git checkout -b feature/add-email-and-payment-and-notifications
```

---

### Making Commits

Create logical, well-documented commits following conventions.

**Conventional Commits format:**

```
<type>(<scope>): <subject>

<body>

<footer>
```

**Commit types:**

```
feat:     New feature
fix:      Bug fix
docs:     Documentation changes
style:    Code style changes (formatting, no logic change)
refactor: Code refactoring (no behavior change)
perf:     Performance improvements
test:     Adding or updating tests
build:    Build system changes (pom.xml, gradle)
ci:       CI/CD configuration changes
chore:    Other changes (dependencies, config)
revert:   Revert previous commit
```

**Example commits:**

```bash
# Feature commit
git commit -m "feat(auth): Add JWT token generation

Implements JWT token generation for user authentication:
- Token expires after 24 hours
- Includes user ID and roles in claims
- Uses RS256 algorithm for signing

Resolves: JIRA-123"

# Bug fix commit
git commit -m "fix(payment): Prevent duplicate payment processing

Adds transaction ID check before processing payment.
Prevents race condition where same payment could be
processed multiple times.

Fixes: JIRA-456"

# Refactoring commit
git commit -m "refactor(user): Extract validation to separate service

Moves user validation logic from UserController to
UserValidationService for better separation of concerns
and easier testing.

No behavior change."

# Test commit
git commit -m "test(auth): Add integration tests for authentication

Adds comprehensive integration tests:
- Login with valid credentials
- Login with invalid credentials
- Token validation
- Token expiration

Coverage: 95%"

# Documentation commit
git commit -m "docs(api): Update authentication API documentation

Documents new JWT authentication endpoints:
- POST /api/auth/login
- POST /api/auth/refresh
- GET /api/auth/validate

Includes request/response examples."
```

**Commit best practices:**

```bash
# âœ… DO: Atomic commits (one logical change)
git add src/main/java/User.java
git commit -m "feat: Add email field to User model"

git add src/main/java/UserValidator.java
git commit -m "feat: Add email validation"

git add src/test/java/UserValidatorTest.java
git commit -m "test: Add email validation tests"

# âŒ DON'T: Mix unrelated changes
git add src/main/java/User.java src/main/java/Payment.java
git commit -m "Added stuff"

# âœ… DO: Descriptive messages
git commit -m "feat(auth): Implement password hashing with BCrypt

Uses BCrypt with strength 12 for secure password storage.
Adds PasswordEncoder bean configuration.

Security improvement."

# âŒ DON'T: Vague messages
git commit -m "fixed bug"
git commit -m "changes"
git commit -m "wip"

# âœ… DO: Explain WHY in commit body
git commit -m "refactor: Use HashMap instead of TreeMap for user cache

TreeMap maintains sorted order but we don't need sorting for
this use case. HashMap provides better O(1) lookup performance.

Performance improvement: 30% faster user lookup."

# âŒ DON'T: Only explain WHAT (code shows what)
git commit -m "Changed TreeMap to HashMap"
```

**Commit workflow:**

```bash
# Work on feature
vim src/main/java/auth/User.java
vim src/main/java/auth/UserService.java

# Stage related files
git add src/main/java/auth/User.java
git commit -m "feat(auth): Add User model with email and password fields"

# Continue work
vim src/main/java/auth/UserService.java
git add src/main/java/auth/UserService.java
git commit -m "feat(auth): Implement user registration service"

# Add tests
vim src/test/java/auth/UserServiceTest.java
git add src/test/java/auth/UserServiceTest.java
git commit -m "test(auth): Add user registration tests"

# View commit history before pushing
git log --oneline
# a1b2c3d (HEAD -> feature/auth) test(auth): Add user registration tests
# 9a8b7c6 feat(auth): Implement user registration service
# 8a7b6c5 feat(auth): Add User model with email and password fields
```

---

### Pushing to Remote

Push your feature branch to remote repository for collaboration.

**First push (set upstream):**

```bash
# Push and set upstream tracking
git push -u origin feature/user-authentication

# Output:
# Enumerating objects: 15, done.
# Counting objects: 100% (15/15), done.
# Delta compression using up to 8 threads
# Compressing objects: 100% (10/10), done.
# Writing objects: 100% (10/10), 2.5 KiB | 2.5 MiB/s, done.
# Total 10 (delta 5), reused 0 (delta 0)
# remote: Resolving deltas: 100% (5/5), completed with 3 local objects.
# To https://github.com/user/spring-boot-app.git
#  * [new branch]      feature/user-authentication -> feature/user-authentication
# Branch 'feature/user-authentication' set up to track remote branch 'feature/user-authentication' from 'origin'.
```

**Subsequent pushes:**

```bash
# After setting upstream, just use:
git push

# Or explicitly:
git push origin feature/user-authentication
```

**Push strategies:**

```bash
# Regular push (fast-forward only)
git push origin feature/auth

# Force push (after rebase/amend) - DANGEROUS
git push --force origin feature/auth

# Force push with lease (SAFER)
git push --force-with-lease origin feature/auth

# Push all branches
git push origin --all

# Push with tags
git push origin --tags
```

**Before pushing checklist:**

```bash
# 1. Review your commits
git log --oneline -5

# 2. Review your changes
git diff main

# 3. Run tests locally
mvn test
# or
./gradlew test

# 4. Check code quality
mvn checkstyle:check
mvn spotbugs:check

# 5. Ensure main is integrated
git fetch origin
git log main..origin/main  # Any new commits on main?

# If main has new commits:
git rebase origin/main

# 6. Push
git push -u origin feature/auth
```

---

### Opening PR

Create a pull request with clear description and context.

**GitHub PR creation:**

```bash
# After pushing feature branch
git push -u origin feature/user-authentication

# GitHub shows message:
# remote: Create a pull request for 'feature/user-authentication' on GitHub by visiting:
# remote:      https://github.com/user/spring-boot-app/pull/new/feature/user-authentication

# Visit URL or go to GitHub repository
# Click "Compare & pull request" button
```

**PR title and description template:**

````markdown
## Pull Request Template

### Title
feat(auth): Add JWT-based user authentication

### Description
Implements JWT-based authentication for the Spring Boot application.

### Changes Made
- Added User entity with email and password fields
- Implemented UserService for user registration and login
- Created JwtTokenProvider for token generation/validation
- Added authentication endpoints to AuthController
- Configured Spring Security with JWT filter

### Type of Change
- [x] New feature
- [ ] Bug fix
- [ ] Breaking change
- [ ] Documentation update
- [ ] Refactoring
- [ ] Performance improvement

### Testing
- [x] Unit tests added/updated (95% coverage)
- [x] Integration tests added
- [x] Manual testing completed
- [x] All existing tests pass

### Related Issues
Resolves: #123
Related to: #456

### Dependencies
- Added spring-boot-starter-security
- Added jjwt library for JWT handling

### Breaking Changes
None

### Migration Guide
N/A

### Screenshots/Examples
```json
// Login request
POST /api/auth/login
{
  "email": "user@example.com",
  "password": "SecurePassword123"
}

// Response
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "expiresIn": 86400
}
````

### Checklist

- [x] Code follows project style guidelines
- [x] Self-review completed
- [x] Comments added for complex logic
- [x] Documentation updated
- [x] No new warnings
- [x] Tests added/updated
- [x] Branch is up to date with main
- [x] Commits are clean and logical

### Reviewers

@tech-lead @senior-dev

### Additional Notes

Token expiration set to 24 hours. Can be configured via `jwt.expiration` property in application.yml.

````

**PR description best practices:**

```markdown
# âœ… GOOD PR Description

## What
Adds email validation to user registration

## Why
Users were able to register with invalid email addresses,
causing issues with password reset functionality.

## How
- Added regex pattern validation for email format
- Added unit tests for valid/invalid email formats
- Updated UserService to validate email before saving
- Added custom EmailInvalidException

## Testing
- Unit tests: 15 test cases covering edge cases
- Manual testing: Verified invalid emails are rejected
- Verified existing functionality still works

## Screenshots
[Before/After screenshots of validation]

---

# âŒ BAD PR Description

## Description
Fixed stuff

## Changes
Updated some files

## Testing
Tested it
````

**PR size guidelines:**

```
Small PR (Ideal):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ < 200 lines changed
â€¢ Single feature/fix
â€¢ Easy to review
â€¢ Fast to merge

Medium PR (Acceptable):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ 200-500 lines changed
â€¢ One feature with tests
â€¢ Reviewable in 30 min
â€¢ May need discussion

Large PR (Avoid):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ > 500 lines changed
â€¢ Multiple features
â€¢ Hard to review
â€¢ High risk of issues
â€¢ Consider splitting!
```

---

### Code Review Process

Reviewers examine code, provide feedback, and approve or request changes.

**Reviewer responsibilities:**

```markdown
### What to Review

#### 1. Correctness
- Does code do what PR claims?
- Are edge cases handled?
- Is error handling appropriate?
- Are there any bugs?

#### 2. Design
- Is code well-structured?
- Follows SOLID principles?
- Appropriate design patterns?
- Good separation of concerns?

#### 3. Readability
- Is code easy to understand?
- Are names descriptive?
- Is complexity manageable?
- Are comments helpful (not obvious)?

#### 4. Testing
- Are tests comprehensive?
- Do tests cover edge cases?
- Are tests readable?
- Is coverage adequate?

#### 5. Performance
- Any obvious performance issues?
- Inefficient algorithms?
- Database query optimization?
- Memory leaks?

#### 6. Security
- Input validation?
- SQL injection prevention?
- XSS prevention?
- Authentication/authorization?

#### 7. Maintainability
- Will future developers understand this?
- Is it easy to modify?
- Is duplication minimized?
- Is it consistent with codebase?
```

**Review comment examples:**

```java
// âŒ BAD Review Comment
"This is wrong"

// âœ… GOOD Review Comment
"This validation logic might allow empty strings. Consider:
if (email == null || email.trim().isEmpty()) {
    throw new ValidationException(\"Email cannot be empty\");
}
"

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// âŒ BAD Review Comment
"Bad code"

// âœ… GOOD Review Comment
"This O(nÂ²) loop could be optimized. Since we're just checking
for duplicates, consider using a HashSet:

Set<String> seen = new HashSet<>();
for (User user : users) {
    if (!seen.add(user.getEmail())) {
        throw new DuplicateEmailException();
    }
}

This improves time complexity from O(nÂ²) to O(n)."

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// âŒ BAD Review Comment
"Needs tests"

// âœ… GOOD Review Comment
"Could you add tests for these edge cases?
- Empty email string
- Email with whitespace
- Email with special characters
- Null email

Example:
@Test(expected = ValidationException.class)
public void testValidateEmail_whenNull_throwsException() {
    validator.validate(null);
}
"

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// âœ… GOOD Review Comments (Positive)
"Great refactoring! This is much more readable."

"Nice catch on that potential NPE. Good defensive programming."

"Excellent test coverage. I especially like the edge case tests."

"This is a clever solution to the concurrency issue. Well done!"
```

**Review workflow:**

```bash
# Reviewer checks out PR branch locally
git fetch origin
git checkout feature/user-authentication

# Or create local branch tracking remote
git checkout -b feature/user-authentication origin/feature/user-authentication

# Run tests locally
mvn clean test

# Run application and test manually
mvn spring-boot:run
# Test endpoints

# Review code in IDE
# Leave comments on GitHub

# Approve, request changes, or comment
```

**Review types:**

```
Comment:
â”€â”€â”€â”€â”€â”€â”€â”€
General feedback, questions, suggestions
No blocking - author can merge without addressing

Request Changes:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Issues that must be fixed before merge
Blocks merging until resolved
Use for bugs, security issues, major concerns

Approve:
â”€â”€â”€â”€â”€â”€â”€â”€
Code looks good, ready to merge
Author can merge after approval
```

---

### Addressing Review Comments

Author responds to feedback and updates PR.

**Responding to feedback:**

```markdown
# âœ… GOOD Responses

## Reviewer: "Could you add error handling for null input?"
Author: "Good catch! Added null check in commit abc123d.
Also added test case for null input."

## Reviewer: "This query might have N+1 problem"
Author: "You're right. Changed to use JOIN FETCH in commit def456e.
Verified with query logging that it now uses single query."

## Reviewer: "Consider using Optional instead of null"
Author: "Agreed. Refactored to use Optional<User> in commit ghi789f.
Updated all callers to handle Optional properly."

---

# âŒ BAD Responses

## Reviewer: "Could you add error handling?"
Author: "No"

## Reviewer: "This might have performance issues"
Author: "Works for me"

## Reviewer: "Consider using Optional"
Author: "I don't like Optional"
```

**Updating PR after review:**

```bash
# Make changes based on feedback
vim src/main/java/User.java

# Commit changes
git add src/main/java/User.java
git commit -m "refactor: Add null validation per review feedback"

# Push updates
git push origin feature/user-authentication

# PR automatically updates with new commits

# Respond to review comments on GitHub
# Click "Resolve conversation" when addressed
```

**Handling conflicting feedback:**

```markdown
# When reviewers disagree

## Reviewer A: "Use HashMap for better performance"
## Reviewer B: "Use TreeMap for sorted order"

Author response:
"Thanks for the feedback! Let me clarify the use case.
We need sorted iteration for the export feature, so TreeMap
is the right choice here. The slight performance cost is
acceptable given our usage patterns (< 100 entries).

@ReviewerA: Performance won't be an issue because we're dealing
with small datasets. Happy to revisit if we see performance
problems in production.

@ReviewerB: Agreed on TreeMap. Good catch!"
```

**Force push after review (when needed):**

```bash
# If you need to rebase or squash commits during review

# 1. Communicate first
# Post comment: "I'm going to rebase to clean up commits.
# Will force push in 5 minutes."

# 2. Rebase/squash
git rebase -i main

# 3. Force push with lease
git push --force-with-lease origin feature/user-authentication

# 4. Notify reviewers
# "Rebased and squashed commits. Please re-review."
```

---

### Merging PR (merge, squash, rebase)

Three strategies for merging pull requests.

**1. Merge Commit (Preserve all commits)**

```
Before merge:
main:     A---B---C
               \
feature:        D---E---F

After merge:
main:     A---B---C-------M
               \         /
feature:        D---E---F

M = merge commit with two parents
```

```bash
# GitHub UI: "Create a merge commit" button
# Git command equivalent:
git checkout main
git merge --no-ff feature/user-authentication
git push origin main

# Result:
# - All commits from feature branch preserved
# - Merge commit created
# - Full history visible
# - Can see feature as a unit
```

**When to use merge commit:**

- Want to preserve complete history
- Feature has multiple meaningful commits
- Using Git Flow workflow
- Want to group related commits

**2. Squash and Merge (Single commit)**

```
Before squash:
main:     A---B---C
               \
feature:        D---E---F

After squash:
main:     A---B---C---S
                     â†‘
              Single squashed commit (D+E+F)
```

```bash
# GitHub UI: "Squash and merge" button
# Git command equivalent:
git checkout main
git merge --squash feature/user-authentication
git commit -m "feat(auth): Add user authentication

Complete implementation:
- User model with validation
- JWT token generation
- Authentication endpoints
- Comprehensive tests

Resolves: #123"
git push origin main

# Result:
# - One commit on main
# - Clean linear history
# - Feature branch commits discarded
```

**When to use squash:**

- Feature has many WIP commits
- Want clean main history
- Small to medium features
- One feature = one commit philosophy

**3. Rebase and Merge (Linear history)**

```
Before rebase merge:
main:     A---B---C
               \
feature:        D---E---F

After rebase merge:
main:     A---B---C---D'---E'---F'

D', E', F' = feature commits rebased onto C
```

```bash
# GitHub UI: "Rebase and merge" button
# Git command equivalent:
git checkout feature/user-authentication
git rebase main
git checkout main
git merge --ff-only feature/user-authentication
git push origin main

# Result:
# - Linear history
# - All commits preserved
# - No merge commit
# - Commits rewritten (new SHAs)
```

**When to use rebase merge:**

- Want linear history
- Each commit is meaningful and clean
- Team prefers no merge commits
- Using trunk-based development

**Comparison table:**

|Aspect|Merge Commit|Squash|Rebase|
|---|---|---|---|
|History|Non-linear|Linear|Linear|
|Feature commits|Preserved|Combined|Preserved|
|Merge commit|Yes|No|No|
|Commit SHAs|Unchanged|New|New|
|Best for|Large features|Clean history|Meaningful commits|
|Reversibility|Easy|Medium|Medium|
|Complexity|Low|Low|High|

**Choosing merge strategy:**

```bash
# Small feature with messy commits
# Use: Squash and merge
feature/typo-fix (3 commits: "fix typo", "oops", "final fix")
â†’ Squash to: "fix: Correct typo in user service"

# Large feature with logical commits
# Use: Merge commit
feature/payment-integration (10 commits, each meaningful)
â†’ Merge commit preserves all commits

# Feature with clean commits
# Use: Rebase and merge
feature/add-validation (3 commits, all clean and logical)
â†’ Rebase creates linear history
```

**After merge:**

```bash
# Delete feature branch (GitHub UI or command)
git push origin --delete feature/user-authentication

# Delete local branch
git checkout main
git pull origin main
git branch -d feature/user-authentication

# Verify merge
git log --oneline -5
```

---

## 2. Code Review Best Practices

### Small, Focused PRs

Keep pull requests small and focused on single feature or fix.

**PR size guidelines:**

```
Tiny PR (< 50 lines):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Examples:
- Typo fix
- Configuration change
- Dependency update
- Small bug fix

Review time: 5 minutes
Approval: Same day

Small PR (50-200 lines):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Examples:
- New API endpoint
- New service class
- Bug fix with tests
- Refactoring single class

Review time: 15-30 minutes
Approval: Same day

Medium PR (200-500 lines):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Examples:
- Feature implementation
- Multiple related classes
- Database migration
- Integration tests

Review time: 30-60 minutes
Approval: 1-2 days

Large PR (> 500 lines):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Examples:
- Major feature
- Architecture change
- Framework upgrade

Review time: > 1 hour
Approval: Several days
âš ï¸ Consider splitting!
```

**How to keep PRs small:**

```bash
# âŒ BAD: One huge PR
feature/complete-payment-system
â”œâ”€â”€ Payment model
â”œâ”€â”€ PaymentService
â”œâ”€â”€ PaymentController
â”œâ”€â”€ PayPal integration
â”œâ”€â”€ Stripe integration
â”œâ”€â”€ Refund logic
â”œâ”€â”€ Transaction history
â”œâ”€â”€ Admin dashboard
â””â”€â”€ Email notifications
Total: 2,500 lines changed

# âœ… GOOD: Multiple small PRs
# PR 1:
feature/payment-model (100 lines)
â””â”€â”€ Payment entity and repository

# PR 2 (after PR 1 merged):
feature/payment-service (150 lines)
â””â”€â”€ Core payment processing logic

# PR 3 (after PR 2 merged):
feature/paypal-integration (200 lines)
â””â”€â”€ PayPal payment provider

# PR 4:
feature/stripe-integration (200 lines)
â””â”€â”€ Stripe payment provider

# PR 5:
feature/payment-api (100 lines)
â””â”€â”€ REST endpoints for payment

# Each PR is reviewable in < 30 minutes
```

**Breaking down large changes:**

```markdown
# Feature: E-commerce checkout system (too large for one PR)

## Phase 1: Foundation
PR 1: Add Product and Cart entities
PR 2: Implement CartService
PR 3: Add cart API endpoints

## Phase 2: Payment
PR 4: Add Payment model
PR 5: Implement PaymentService
PR 6: Integrate payment gateway
PR 7: Add payment endpoints

## Phase 3: Order Processing
PR 8: Add Order entity
PR 9: Implement OrderService
PR 10: Add order confirmation emails
PR 11: Add order API endpoints

Each PR builds on previous, all are small and focused
```

---

### Clear Commit Messages

Write commit messages that explain the change clearly.

**Commit message structure:**

```
<type>(<scope>): <subject>
                  â†‘
            50 chars max

<body - explain WHY and provide context>
        â†‘
    Wrap at 72 chars

<footer - reference issues, breaking changes>
```

**Good commit message examples:**

```bash
# Example 1: Bug fix
git commit -m "fix(payment): Prevent duplicate payment processing

Race condition allowed same payment to be processed multiple
times if user clicked submit button rapidly.

Added transaction ID uniqueness check and database constraint
to prevent duplicates. Also added idempotency key to API.

Fixes: #456
Breaking change: API now requires idempotency-key header"

# Example 2: Feature
git commit -m "feat(auth): Add password strength validation

Implements OWASP password guidelines:
- Minimum 12 characters
- At least one uppercase letter
- At least one lowercase letter
- At least one number
- At least one special character

Returns detailed validation errors to help users create
strong passwords.

Resolves: #123"

# Example 3: Refactoring
git commit -m "refactor(user): Extract validation to separate service

UserController had grown to 500 lines with complex validation
logic mixed with HTTP handling.

Extracted all validation logic to UserValidationService for:
- Better separation of concerns
- Easier testing
- Reusability across different controllers

No behavior change. All tests pass."

# Example 4: Performance
git commit -m "perf(search): Replace sequential scan with indexed query

Search was taking 5+ seconds for large datasets due to
sequential scan on user_email column.

Added database index on user_email and updated query to
use index. Search now completes in < 100ms.

Performance improvement: 50x faster for datasets > 10k users"

# Example 5: Test
git commit -m "test(payment): Add integration tests for refund flow

Adds comprehensive integration tests for refund functionality:
- Full refund of successful payment
- Partial refund
- Multiple partial refunds
- Refund of already refunded payment (should fail)
- Refund with expired payment token

Coverage increased from 60% to 95%"
```

**Bad commit message examples:**

```bash
# âŒ Too vague
git commit -m "fixed bug"
git commit -m "updates"
git commit -m "changes"

# âŒ Not descriptive
git commit -m "wip"
git commit -m "stuff"
git commit -m "asdf"

# âŒ Missing context
git commit -m "Updated User.java"
# What was updated? Why?

# âŒ Multiple changes
git commit -m "Added feature and fixed bug and refactored code"
# Should be 3 separate commits
```

**Commit message checklist:**

```markdown
Before committing, ask:

â–¡ Does subject line describe WHAT changed?
â–¡ Does body explain WHY?
â–¡ Is it clear how this helps?
â–¡ Are related issues referenced?
â–¡ Would a new team member understand this in 6 months?
â–¡ Is it one logical change?
â–¡ Are tests included/updated?
â–¡ Does it follow conventional commits format?
```

---

### Self-Review Before Submitting

Review your own PR before requesting others' time.

**Self-review checklist:**

```markdown
## Code Quality
â–¡ Code follows project style guide
â–¡ No commented-out code
â–¡ No debug statements (console.log, System.out.println)
â–¡ No TODO comments (or tracked in tickets)
â–¡ No hardcoded values (use configuration)
â–¡ No sensitive data (passwords, keys, tokens)

## Functionality
â–¡ Code does what PR claims
â–¡ Edge cases handled
â–¡ Error handling appropriate
â–¡ Input validation present
â–¡ No obvious bugs

## Testing
â–¡ Tests added for new code
â–¡ Tests updated for changed code
â–¡ All tests pass locally
â–¡ Test coverage meets threshold (typically 80%+)
â–¡ Tests cover edge cases
â–¡ Tests are readable and maintainable

## Documentation
â–¡ JavaDoc added for public methods
â–¡ README updated if needed
â–¡ API documentation updated
â–¡ Configuration changes documented
â–¡ Migration guide included if breaking changes

## Performance
â–¡ No obvious performance issues
â–¡ Database queries optimized
â–¡ No N+1 queries
â–¡ Appropriate caching
â–¡ No memory leaks

## Security
â–¡ Input sanitized
â–¡ SQL injection prevented
â–¡ XSS prevented
â–¡ Authentication/authorization checked
â–¡ Sensitive data encrypted
â–¡ Security scan passed

## Dependencies
â–¡ New dependencies justified
â–¡ Dependencies up to date
â–¡ No security vulnerabilities
â–¡ License compatible

## Git
â–¡ Commits are logical and atomic
â–¡ Commit messages are clear
â–¡ Branch is up to date with main
â–¡ No merge conflicts
â–¡ Unnecessary files not committed (.class, .idea, etc.)
```

**Self-review process:**

```bash
# 1. View your changes
git diff main

# 2. Review commit by commit
git log --oneline main..HEAD
git show <commit-sha>

# 3. Check what files changed
git diff --name-only main

# 4. Run tests
mvn clean test
./gradlew test

# 5. Run linters
mvn checkstyle:check
mvn spotbugs:check

# 6. Run security scan
mvn dependency-check:check

# 7. Check test coverage
mvn jacoco:report
open target/site/jacoco/index.html

# 8. Build and run locally
mvn clean install
mvn spring-boot:run

# 9. Manual testing
# Test happy path
# Test error cases
# Test edge cases

# 10. Review PR description
# Is it clear?
# Are all sections filled?
# Screenshots included if needed?

# 11. Finally, create PR
```

---

### Responding to Feedback

Handle review feedback professionally and constructively.

**Response guidelines:**

```markdown
## DO:

âœ… Thank reviewers for their time
"Thanks for the thorough review!"

âœ… Acknowledge valid points
"Good catch on that NPE. Fixed in abc123."

âœ… Ask for clarification if needed
"Could you clarify what you mean by 'better error handling'?
Are you concerned about the null case or the exception type?"

âœ… Explain your reasoning
"I chose ArrayList over LinkedList because we're doing
random access 90% of the time. Profile showed ArrayList
is 3x faster for our use case."

âœ… Suggest alternatives
"I see your point about complexity. What if we extracted
this logic to a separate method?"

âœ… Mark conversations resolved
After addressing feedback, click "Resolve conversation"

## DON'T:

âŒ Be defensive
"You don't understand the requirements"

âŒ Dismiss feedback
"It works fine for me"

âŒ Be passive-aggressive
"Fine, I'll change it even though it's not necessary"

âŒ Take it personally
"Why are you always criticizing my code?"

âŒ Ignore feedback
No response, no changes

âŒ Argue without evidence
"My way is better"
Better: "My way is better because [benchmarks/data/reasoning]"
```

**Handling disagreements:**

```markdown
# Scenario: Reviewer suggests approach you disagree with

## Reviewer:
"This should use Observer pattern instead of direct calls"

## âŒ BAD Response:
"No, my way is fine"

## âœ… GOOD Response:
"I considered Observer pattern but went with direct calls because:

1. We only have one observer currently (UserNotificationService)
2. Observer pattern adds complexity (listeners, registration)
3. Call stack is simpler to debug with direct calls
4. Performance impact is negligible (< 1ms)

However, if you think we'll add more observers soon, I'm happy
to refactor to Observer pattern. What's your concern about the
current approach?"

## Discussion continues...

## Resolution options:

### Option A: Reviewer convinced
Reviewer: "Fair points. Direct call is fine for single observer."
â†’ Mark resolved, no changes

### Option B: You're convinced
You: "You're right, we're adding email and SMS notifications
next sprint. Will refactor to Observer pattern in def456."
â†’ Make changes, push update

### Option C: Escalate
You: "Let's get @tech-lead's input on this"
Tech lead makes final decision
â†’ Implement decision
```

**Responding to multiple reviewers:**

```markdown
# When multiple reviewers comment

## Reviewer A:
"Extract this to a separate method"

## Reviewer B:
"Add null check"

## Reviewer C:
"Consider using Optional"

## Your response:
"Thanks everyone for the reviews!

@ReviewerA: Extracted to validateUserInput() in commit abc123
@ReviewerB: Added null check at the start of the method in abc123
@ReviewerC: Good suggestion. I've refactored to use Optional<User> in commit def456

All changes pushed. Please re-review when you have a chance."
```

---

## 3. Branch Protection Rules

### Require PR Reviews

Enforce code review before merging to protected branches.

**GitHub branch protection settings:**

```
Repository Settings â†’ Branches â†’ Add rule

Branch name pattern: main

â˜‘ Require pull request reviews before merging
  â˜‘ Required approving reviews: 2
  â˜‘ Dismiss stale pull request approvals when new commits are pushed
  â˜‘ Require review from Code Owners
  â˜‘ Restrict who can dismiss pull request reviews
      Team: tech-leads

â˜‘ Require status checks to pass before merging
  â˜‘ Require branches to be up to date before merging
  Required checks:
    â˜‘ ci/build
    â˜‘ ci/test
    â˜‘ ci/security-scan
    â˜‘ ci/code-quality

â˜‘ Require conversation resolution before merging

â˜‘ Include administrators
```

**CODEOWNERS file:**

```bash
# .github/CODEOWNERS

# Global code owners (approve all changes)
* @tech-lead @architect

# Java source code
*.java @java-team

# Authentication module (requires security team review)
/src/main/java/auth/ @security-team @java-team

# Payment module (requires payment team + security)
/src/main/java/payment/ @payment-team @security-team

# Database migrations (requires DBA review)
/src/main/resources/db/migration/ @dba-team

# Infrastructure (requires DevOps review)
/infrastructure/ @devops-team
/.github/workflows/ @devops-team
/Dockerfile @devops-team
/docker-compose.yml @devops-team

# Documentation (requires tech writer review)
/docs/ @tech-writing-team
*.md @tech-writing-team

# Build configuration
/pom.xml @build-team
/build.gradle @build-team

# Security-sensitive files
/src/main/resources/application*.yml @security-team
/src/main/resources/*.properties @security-team
```

---

### Require Status Checks (CI/CD)

Require automated checks to pass before merging.

**Required status checks:**

```yaml
# .github/workflows/pr-checks.yml
name: PR Checks

on:
  pull_request:
    branches: [ main, develop ]

jobs:
  build:
    name: Build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
      
      - name: Build with Maven
        run: mvn clean compile -B
      
      - name: Upload build artifacts
        uses: actions/upload-artifact@v3
        with:
          name: build-artifacts
          path: target/

  test:
    name: Test
    runs-on: ubuntu-latest
    needs: build
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
      
      - name: Run tests
        run: mvn test -B
      
      - name: Generate coverage report
        run: mvn jacoco:report
      
      - name: Check coverage threshold
        run: mvn jacoco:check -Djacoco.minimum.coverage=0.80
      
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          files: ./target/site/jacoco/jacoco.xml

  code-quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-java@v3
        with:
          java-version: '17'
      
      - name: Checkstyle
        run: mvn checkstyle:check
      
      - name: SpotBugs
        run: mvn spotbugs:check
      
      - name: PMD
        run: mvn pmd:check

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-java@v3
        with:
          java-version: '17'
      
      - name: OWASP Dependency Check
        run: mvn dependency-check:check -DfailBuildOnCVSS=7
      
      - name: Snyk Security Scan
        uses: snyk/actions/maven@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high
      
      - name: CodeQL Analysis
        uses: github/codeql-action/analyze@v2

  integration-test:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: test
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-java@v3
        with:
          java-version: '17'
      
      - name: Run integration tests
        run: mvn verify -Pintegration-tests
        env:
          SPRING_DATASOURCE_URL: jdbc:postgresql://localhost:5432/test
          SPRING_DATASOURCE_USERNAME: postgres
          SPRING_DATASOURCE_PASSWORD: postgres
```

**Status check requirements:**

```
All checks must pass before merge:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âœ“ Build succeeds
âœ“ All tests pass
âœ“ Code coverage â‰¥ 80%
âœ“ Checkstyle passes
âœ“ SpotBugs passes
âœ“ No high-severity security vulnerabilities
âœ“ Integration tests pass

If any check fails:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŒ Cannot merge
Fix issues â†’ Push update â†’ Checks run again
```

---

### Require Linear History

Enforce clean, linear commit history.

**Linear history setting:**

```
Branch protection rules:

â˜‘ Require linear history

Effects:
- Only allow squash or rebase merge
- Prevent merge commits on main
- Enforce clean, linear history
```

**Before/After linear history:**

```
Without linear history (allows merge commits):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

main: A---B---C-------M---E-------M---G
           \         /     \     /
            D---E---F       G---H

Complex, hard to follow


With linear history (squash or rebase only):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

main: A---B---C---D---E---F---G---H

Simple, easy to follow
```

---

### No Force Push to Main

Prevent rewriting history on protected branches.

**Force push protection:**

```
Branch protection rules:

â˜‘ Do not allow force pushes
  Even administrators cannot force push

â˜‘ Do not allow deletions
  Prevent accidental branch deletion

Effects:
â”€â”€â”€â”€â”€â”€â”€
âœ“ History is immutable
âœ“ Cannot rewrite commits
âœ“ Cannot delete branch
âœ“ Safe for collaboration
```

**What happens when protection is enabled:**

```bash
# Try to force push to main
git checkout main
git reset --hard HEAD~5
git push --force origin main

# âŒ ERROR:
# remote: error: GH006: Protected branch update failed
# remote: error: Cannot force-push to a protected branch
# To https://github.com/user/repo.git
#  ! [remote rejected] main -> main (protected branch hook declined)

# Try to delete main
git push origin --delete main

# âŒ ERROR:
# remote: error: GH006: Protected branch update failed
# remote: error: Cannot delete a protected branch
```

**Complete protection configuration:**

```
Repository Settings â†’ Branches â†’ Branch protection rules

Branch name pattern: main

Protect matching branches:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â˜‘ Require pull request reviews before merging
  Number of required approvals: 2
  â˜‘ Dismiss stale reviews when new commits pushed
  â˜‘ Require review from Code Owners
  â˜‘ Restrict who can dismiss reviews
      Teams: tech-leads

â˜‘ Require status checks to pass before merging
  â˜‘ Require branches to be up to date
  Required checks:
    - ci/build
    - ci/test
    - ci/security-scan
    - ci/code-quality
    - ci/integration-test

â˜‘ Require conversation resolution before merging

â˜‘ Require signed commits

â˜‘ Require linear history

â˜‘ Include administrators

Rules applied to administrators:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â˜‘ Do not allow bypassing the above settings

â˜‘ Do not allow force pushes
  Nobody can force push (including admins)

â˜‘ Do not allow deletions
  Nobody can delete branch (including admins)
```

---

## Summary

### Pull Request Workflow

- âœ… **Feature branches**: Descriptive names following conventions
- âœ… **Commits**: Atomic, conventional, well-documented
- âœ… **Pushing**: Set upstream, push regularly
- âœ… **PR creation**: Clear title, comprehensive description
- âœ… **Code review**: Constructive feedback, multiple reviewers
- âœ… **Addressing feedback**: Professional, timely responses
- âœ… **Merging**: Choose appropriate strategy (merge/squash/rebase)

### Code Review Best Practices

- âœ… **Small PRs**: < 200 lines ideal, split large features
- âœ… **Clear messages**: Explain WHY, provide context
- âœ… **Self-review**: Check your own code first
- âœ… **Feedback**: Respond professionally and constructively

### Branch Protection Rules

- âœ… **PR reviews**: Require approvals before merging
- âœ… **Status checks**: CI/CD must pass
- âœ… **Linear history**: Enforce clean commit history
- âœ… **No force push**: Protect main branch from rewrites
- âœ… **CODEOWNERS**: Require appropriate team reviews

**Key Principles:**

- Keep PRs small and focused
- Write clear, descriptive commits
- Review your own code thoroughly
- Respond to feedback professionally
- Protect important branches
- Automate quality checks
- Make code review a learning opportunity

**Team Culture:**

- Code review is collaborative, not confrontational
- Goal is code quality, not ego
- Learn from each other
- Celebrate good code
- Fix issues without blame

Congratulations! You now have a complete Git Deep Dive knowledge base! ğŸ‰