## Overview

Git's powerful recovery mechanisms mean you can almost always recover from mistakes. This guide covers common problems Java developers face and how to fix them safely.

```
┌─────────────────────────────────────────────────────────────────┐
│                  GIT RECOVERY MECHANISMS                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Problem Detection → Analysis → Recovery → Prevention          │
│                                                                 │
│  ┌──────────────┐   ┌──────────────┐   ┌──────────────┐      │
│  │   Reflog     │   │     fsck     │   │    Reset     │      │
│  │ (30-90 days) │   │  (orphaned)  │   │   (local)    │      │
│  │  Everything  │   │   commits    │   │   history    │      │
│  └──────────────┘   └──────────────┘   └──────────────┘      │
│                                                                 │
│  ┌──────────────┐   ┌──────────────┐   ┌──────────────┐      │
│  │   Revert     │   │  Cherry-pick │   │  Filter-repo │      │
│  │ (safe undo)  │   │  (selective) │   │  (history)   │      │
│  └──────────────┘   └──────────────┘   └──────────────┘      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 1. Common Problems

### Detached HEAD State

#### What It Means

```bash
# You're at a commit, not on a branch
$ git status
HEAD detached at abc1234

# You can make commits, but they're not on any branch
# If you switch branches, these commits become orphaned
```

#### How It Happens

```bash
# Checking out a specific commit
git checkout abc1234

# Checking out a tag
git checkout v1.0.0

# Checking out a remote branch without creating local
git checkout origin/feature-branch
```

#### How to Fix

```bash
# Option 1: Create a branch from here
git checkout -b my-feature-branch
# Now your commits are safe on a branch

# Option 2: Go back to a branch (loses commits)
git checkout main

# Option 3: Merge your commits into existing branch
git checkout main
git merge abc1234  # The commit you were at
```

#### Real-World Example

```bash
# You were debugging and checked out old commit
git checkout abc1234

# Made some fixes
echo "debug fix" >> fix.txt
git add fix.txt
git commit -m "Fixed bug"

# Now save this work
git checkout -b hotfix/production-bug
git push origin hotfix/production-bug
```

---

### Merge Conflicts in Binary Files

#### The Problem

```bash
# Binary files can't be merged automatically
$ git merge feature-branch
Auto-merging src/main/resources/logo.png
CONFLICT (content): Merge conflict in src/main/resources/logo.png
Automatic merge failed; fix conflicts and then commit the result.
```

#### Solutions

**Option 1: Choose One Version**

```bash
# Keep your version (ours)
git checkout --ours src/main/resources/logo.png

# Keep their version (theirs)
git checkout --theirs src/main/resources/logo.png

# Then complete the merge
git add src/main/resources/logo.png
git commit -m "Merged feature-branch, kept logo from main"
```

**Option 2: Use External Tool**

```bash
# Configure merge tool for binary files
git config merge.tool meld
git config mergetool.meld.path "/usr/bin/meld"

# Launch merge tool
git mergetool src/main/resources/logo.png
```

**Prevention Strategy**

```bash
# In .gitattributes - mark as binary, use ours by default
*.png binary merge=ours
*.jpg binary merge=ours
*.jar binary merge=ours
*.pdf binary merge=ours

# Now Git won't try to merge these files
```

---

### Large Files Accidentally Committed

#### The Problem

```bash
# Committed large file
git add application.log  # 500MB log file
git commit -m "Added changes"

# Now every clone downloads this huge file
# Even if you delete it in next commit!
```

#### Solution 1: Before Push (Easy)

```bash
# Reset to before the commit
git reset --soft HEAD~1

# Remove the large file
git restore --staged application.log

# Add it to .gitignore
echo "*.log" >> .gitignore
git add .gitignore

# Commit without the large file
git commit -m "Added changes (without log files)"
```

#### Solution 2: After Push (Requires Force Push)

```bash
# Remove file from all history
git filter-repo --path application.log --invert-paths

# Force push (WARNING: Coordinate with team!)
git push origin main --force

# Everyone else needs to:
git fetch origin
git reset --hard origin/main
```

#### Solution 3: Using BFG Repo-Cleaner

```bash
# Download BFG from https://rtyley.github.io/bfg-repo-cleaner/
# Remove all files larger than 100MB
java -jar bfg.jar --strip-blobs-bigger-than 100M my-repo.git

# Clean up
cd my-repo.git
git reflog expire --expire=now --all
git gc --prune=now --aggressive

# Force push
git push origin --force --all
```

#### Prevention

```bash
# Add to .gitignore
*.log
*.tmp
target/
*.class
.idea/
*.iml
node_modules/
.env
application-local.properties

# Use git-lfs for large files you NEED to track
git lfs install
git lfs track "*.psd"
git lfs track "*.zip"
git add .gitattributes
```

---

### Wrong Commit on Wrong Branch

#### Scenario 1: Committed to main Instead of Feature Branch

```bash
# You're on main and made a commit (not pushed yet)
git log --oneline -1
abc1234 (HEAD -> main) Feature: Added new endpoint

# Create feature branch at current commit
git branch feature/new-endpoint

# Move main back
git reset --hard origin/main

# Switch to your feature branch
git checkout feature/new-endpoint
# Your commit is now on the correct branch!
```

#### Scenario 2: Already Pushed to Wrong Branch

```bash
# Your commit is on main (already pushed)
# Create feature branch with this commit
git checkout -b feature/wrong-place

# Push feature branch
git push origin feature/wrong-place

# Go back to main and revert the commit
git checkout main
git revert abc1234
git push origin main

# Now submit PR from feature branch
```

#### Scenario 3: Multiple Commits on Wrong Branch

```bash
# Last 3 commits should be on feature branch
git log --oneline -3
abc1234 Third commit
def5678 Second commit  
ghi9012 First commit

# Create feature branch here
git branch feature/all-changes

# Reset main to before these commits
git reset --hard HEAD~3

# Force push main (if already pushed - coordinate with team!)
git push origin main --force

# Switch to feature branch
git checkout feature/all-changes
git push origin feature/all-changes
```

---

### Pushed Sensitive Data

#### Immediate Actions

```bash
# 1. Rotate credentials IMMEDIATELY
# Change passwords, revoke API keys, regenerate tokens

# 2. Remove from history using git-filter-repo
git filter-repo --path config/secrets.properties --invert-paths

# 3. Force push all branches
git push origin --force --all
git push origin --force --tags

# 4. Notify team to re-clone
# Everyone must delete their local copy and re-clone
```

#### Using BFG for Sensitive Data

```bash
# Create a file with passwords to remove
echo "password123" > passwords.txt
echo "api-key-secret" >> passwords.txt

# Run BFG
java -jar bfg.jar --replace-text passwords.txt my-repo.git

# Clean up
cd my-repo.git
git reflog expire --expire=now --all
git gc --prune=now --aggressive

# Force push
git push origin --force --all
```

#### Prevention

```bash
# Use git-secrets to prevent commits with secrets
git secrets --install
git secrets --register-aws

# Add patterns to catch secrets
git secrets --add 'password.*=.*'
git secrets --add '[A-Za-z0-9+/]{40}'  # API keys
git secrets --add 'api[_-]?key.*=.*'

# Scan repository
git secrets --scan

# In .gitignore
.env
.env.local
secrets.properties
application-secrets.yml
**/credentials.json
```

#### Using Environment Variables

```java
// Don't hardcode secrets
// BAD:
private static final String API_KEY = "sk-abc123...";

// GOOD:
private static final String API_KEY = System.getenv("API_KEY");

// In application.yml
spring:
  datasource:
    password: ${DB_PASSWORD}  # From environment
```

---

## 2. Recovery Techniques

### Git Reflog - The Time Machine

#### What is Reflog?

```bash
# Reflog records every HEAD movement
# It's your safety net - keeps history for 30-90 days

git reflog
abc1234 HEAD@{0}: commit: Fixed bug
def5678 HEAD@{1}: checkout: moving from feature to main
ghi9012 HEAD@{2}: commit: Added feature
jkl3456 HEAD@{3}: reset: moving to HEAD~1
mno7890 HEAD@{4}: commit: Experimental change (lost!)
```

#### Recover Deleted Branch

```bash
# Accidentally deleted branch
git branch -D feature-branch
# Deleted branch feature-branch (was abc1234).

# Find it in reflog
git reflog | grep feature-branch
abc1234 HEAD@{2}: commit: Last commit on feature-branch

# Recreate the branch
git branch feature-branch abc1234
# Branch restored!
```

#### Recover After Hard Reset

```bash
# You did a hard reset
git reset --hard HEAD~5
# Lost 5 commits!

# Find them in reflog
git reflog
abc1234 HEAD@{0}: reset: moving to HEAD~5
def5678 HEAD@{1}: commit: Important work (lost!)

# Restore to before the reset
git reset --hard HEAD@{1}
# All commits back!
```

#### Recover After Rebase Gone Wrong

```bash
# Rebase went wrong
git rebase main
# Lots of conflicts, gave up

# Check reflog
git reflog
abc1234 HEAD@{0}: rebase: aborting
def5678 HEAD@{1}: checkout: moving from feature to main
ghi9012 HEAD@{2}: commit: My work before rebase

# Go back to before rebase
git reset --hard HEAD@{2}
```

---

### Git fsck - Find Orphaned Commits

#### What is fsck?

```bash
# fsck finds "dangling" (orphaned) commits
# Useful when reflog expires or you need to find old work

git fsck --lost-found
dangling commit abc1234
dangling blob def5678
```

#### Recover Orphaned Commits

```bash
# Find all dangling commits
git fsck --lost-found --unreachable | grep commit

# Look at the commits
git show abc1234
git show def5678

# Create branch from recovered commit
git branch recovered-work abc1234
```

#### Real-World Recovery Example

```bash
# Developer lost work after complex rebase
git fsck --unreachable | grep commit > commits.txt

# Check each commit
for commit in $(cat commits.txt | awk '{print $3}'); do
  echo "=== Commit: $commit ==="
  git show --stat $commit
  echo ""
done

# Found the lost work!
git branch recovered abc1234
```

---

### Git Reset vs Git Revert

#### Understanding the Difference

```
┌────────────────────────────────────────────────────────────┐
│               RESET vs REVERT                              │
├────────────────────────────────────────────────────────────┤
│                                                            │
│  RESET: Moves branch pointer (rewrites history)           │
│         Use for: Local changes not yet pushed             │
│                                                            │
│  REVERT: Creates new commit that undoes changes           │
│          Use for: Changes already pushed (safe)           │
│                                                            │
└────────────────────────────────────────────────────────────┘
```

#### Git Reset Options

```bash
# --soft: Keep changes in staging
git reset --soft HEAD~1
# Commit undone, files still staged

# --mixed (default): Keep changes in working directory
git reset HEAD~1
# Commit undone, files unstaged but modified

# --hard: Discard all changes
git reset --hard HEAD~1
# Commit and changes completely gone (use reflog to recover!)
```

#### When to Use Reset

```bash
# Scenario 1: Undo last commit (not pushed)
git commit -m "Wrong message"
git reset --soft HEAD~1
git commit -m "Correct message"

# Scenario 2: Combine last 3 commits
git reset --soft HEAD~3
git commit -m "Combined feature changes"

# Scenario 3: Discard experimental work
git reset --hard HEAD~5
# Last 5 commits gone (use reflog to recover if needed)
```

#### When to Use Revert

```bash
# Scenario 1: Undo pushed commit (safe for team)
git revert abc1234
# Creates new commit that undoes abc1234

# Scenario 2: Undo multiple commits
git revert HEAD~3..HEAD
# Reverts last 3 commits with separate revert commits

# Scenario 3: Revert a merge commit
git revert -m 1 merge_commit_sha
# -m 1 means keep main branch changes
```

#### Comparison Example

```bash
# Initial state
A --- B --- C --- D (main)

# Using reset --hard HEAD~1 (rewrites history)
A --- B --- C (main)
# D is gone (can recover with reflog)

# Using revert HEAD (safe, new commit)
A --- B --- C --- D --- D' (main)
# D' undoes changes from D, history preserved
```

---

### Undoing Last Commit

#### Before Push - Use Reset

```bash
# Keep changes in working directory
git reset HEAD~1
# Modify files
git add .
git commit -m "Better commit message"

# Keep changes staged
git reset --soft HEAD~1
git commit -m "Better commit message"

# Discard everything
git reset --hard HEAD~1
```

#### After Push - Use Revert

```bash
# Safe for shared branches
git revert HEAD
git push origin main

# Or amend and force push (ONLY if you're alone on branch)
git commit --amend -m "Fixed message"
git push origin feature-branch --force
```

#### Fix Commit Message (Not Pushed)

```bash
git commit --amend -m "Corrected commit message"
```

#### Fix Commit Message (Already Pushed)

```bash
# Only if you're the only one using this branch
git commit --amend -m "Corrected message"
git push origin feature-branch --force

# Otherwise, just add a new commit with explanation
git commit --allow-empty -m "Previous commit: corrected typo in service name"
```

#### Add Forgotten Files to Last Commit

```bash
# Forgot to add a file
git add forgotten-file.txt
git commit --amend --no-edit
# File added to last commit

# If already pushed (and you're alone on branch)
git push origin feature-branch --force
```

---

### Splitting Commits with Interactive Rebase

#### Why Split Commits?

```bash
# You have one large commit that should be multiple
git log --oneline
abc1234 Added feature and fixed bugs and refactored code

# This should be:
# - Added feature X
# - Fixed bug in Y
# - Refactored Z component
```

#### How to Split Commits

```bash
# Start interactive rebase
git rebase -i HEAD~1

# In editor, change 'pick' to 'edit'
edit abc1234 Added feature and fixed bugs and refactored code

# Git stops at that commit
# Reset it but keep the changes
git reset HEAD~1

# Now commit in smaller pieces
git add src/main/java/Feature.java
git commit -m "Added feature X"

git add src/main/java/BugFix.java
git commit -m "Fixed bug in Y"

git add src/main/java/Refactored.java
git commit -m "Refactored Z component"

# Continue the rebase
git rebase --continue
```

#### Complete Example

```bash
# Current state
$ git log --oneline -1
abc1234 Massive commit with everything

# Check what's in the commit
$ git show HEAD --stat
src/main/java/feature/NewFeature.java  | 50 ++++++++++
src/main/java/bug/BugFix.java          | 20 ++--
src/main/java/refactor/Cleaned.java    | 30 +++---
pom.xml                                | 10 +-

# Start interactive rebase
$ git rebase -i HEAD~1

# Mark commit for editing
edit abc1234 Massive commit with everything

# Reset the commit
$ git reset HEAD~1
Unstaged changes after reset:
M       src/main/java/feature/NewFeature.java
M       src/main/java/bug/BugFix.java
M       src/main/java/refactor/Cleaned.java
M       pom.xml

# Commit 1: The feature
$ git add src/main/java/feature/NewFeature.java pom.xml
$ git commit -m "feat: Add new user authentication feature

- Implemented JWT-based authentication
- Added UserService and AuthController
- Updated dependencies in pom.xml"

# Commit 2: The bug fix
$ git add src/main/java/bug/BugFix.java
$ git commit -m "fix: Correct null pointer in payment processing

- Added null check before processing payment
- Added unit tests for edge case"

# Commit 3: The refactoring
$ git add src/main/java/refactor/Cleaned.java
$ git commit -m "refactor: Improve code readability in data layer

- Extracted helper methods
- Renamed variables for clarity
- No functional changes"

# Continue rebase
$ git rebase --continue

# Verify the split
$ git log --oneline -3
ghi9012 refactor: Improve code readability in data layer
def5678 fix: Correct null pointer in payment processing
abc1234 feat: Add new user authentication feature
```

---

## 3. Advanced Recovery Scenarios

### Recovering from Stash Gone Wrong

```bash
# Applied wrong stash
git stash apply stash@{3}
# Oh no, wrong changes!

# Reset to clean state
git reset --hard HEAD

# Apply correct stash
git stash apply stash@{1}
```

### Recovering Deleted Stash

```bash
# Find all stash commits
git fsck --unreachable | grep commit | cut -d ' ' -f3 | xargs git log --merges --no-walk --grep=WIP

# Or check reflog for stash
git reflog show stash

# Recreate stash from commit
git stash store -m "Recovered stash" abc1234
```

### Recovering After Force Push

```bash
# Someone force pushed, you lost commits
git reflog
abc1234 HEAD@{0}: pull: Fast-forward
def5678 HEAD@{1}: commit: My important work

# Recover your work
git checkout -b my-work-recovered def5678
git cherry-pick abc1234..def5678 onto main
```

---

## 4. Best Practices & Prevention

### Pre-commit Checks

```bash
# Install pre-commit hooks
# .git/hooks/pre-commit
#!/bin/bash

# Run tests
mvn test || exit 1

# Check for secrets
git secrets --scan || exit 1

# Check for large files
if git diff --cached --name-only | xargs du -b | awk '$1 > 5000000 {print $2}'; then
    echo "Error: Large files detected!"
    exit 1
fi

echo "Pre-commit checks passed"
```

### Create Regular Backups

```bash
# Create backup branch before risky operations
git branch backup/before-rebase-$(date +%Y%m%d)

# Or create a tag
git tag backup-before-rebase-$(date +%Y%m%d)

# Perform risky operation
git rebase -i HEAD~10

# If it goes wrong, recover
git reset --hard backup/before-rebase-20241115
```

### Use Aliases for Safety

```bash
# Add to ~/.gitconfig
[alias]
    # Safe operations
    unstage = reset HEAD --
    uncommit = reset --soft HEAD~1
    nevermind = reset --hard HEAD
    
    # Recovery
    recover = fsck --lost-found
    history = reflog --all
    
    # Info before destructive operations
    what-am-i-about-to-destroy = log HEAD..origin/main --oneline
```

### Team Guidelines

```bash
# Document in CONTRIBUTING.md
## Recovery Checklist

1. **Before Force Push:**
   - [ ] Notified team
   - [ ] Created backup branch
   - [ ] Verified no one else working on branch

2. **After Rebase:**
   - [ ] Ran full test suite
   - [ ] Checked for broken commits
   - [ ] Verified CI passes

3. **Emergency Recovery:**
   - [ ] Check reflog first
   - [ ] Use fsck if reflog empty
   - [ ] Contact DevOps if needed
```

---

## 5. Emergency Recovery Workflow

```bash
# Step 1: Don't panic!
# Step 2: Check reflog
git reflog --all

# Step 3: Find the commit you need
git log <commit-hash> --oneline

# Step 4: Create recovery branch
git branch recovery/<description> <commit-hash>

# Step 5: Verify recovery
git checkout recovery/<description>
git log --oneline -10

# Step 6: Merge back or cherry-pick
git checkout main
git merge recovery/<description>
# OR
git cherry-pick <specific-commits>
```

---

## Summary

### Quick Reference

|Problem|Before Push|After Push|
|---|---|---|
|Wrong commit message|`git commit --amend`|`git revert` + new commit|
|Wrong files|`git reset --soft HEAD~1`|`git revert` + new commit|
|Wrong branch|`git reset --hard origin/main`|`git revert` + PR from feature branch|
|Sensitive data|`git reset --hard HEAD~1`|`git-filter-repo` + force push|
|Lost commits|`git reflog`|`git reflog` + `git fsck`|

### Remember

1. **Reflog is your friend** - Everything is recoverable for 30-90 days
2. **Reset = Local only** - Use before pushing
3. **Revert = Safe for shared** - Use after pushing
4. **Create backups** - Before risky operations
5. **Never force push main** - Unless entire team is coordinated

