
## Overview

Understanding when and how to use rebase vs merge is crucial for maintaining a clean Git history without breaking collaboration. This guide covers the mechanics, use cases, and critical rules for Java developers.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              REBASE VS MERGE                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                        â”‚
â”‚  MERGE: Preserves History                             â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                            â”‚
â”‚  main:     A---B---C-------M                          â”‚
â”‚                 \         /                            â”‚
â”‚  feature:        D---E---F                             â”‚
â”‚                                                        â”‚
â”‚  â€¢ Creates merge commit (M)                           â”‚
â”‚  â€¢ Preserves all history                              â”‚
â”‚  â€¢ Non-destructive                                    â”‚
â”‚  â€¢ Safe for shared branches                           â”‚
â”‚                                                        â”‚
â”‚  REBASE: Rewrites History                             â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                             â”‚
â”‚  Before:                                               â”‚
â”‚  main:     A---B---C                                  â”‚
â”‚                 \                                      â”‚
â”‚  feature:        D---E---F                             â”‚
â”‚                                                        â”‚
â”‚  After rebase:                                         â”‚
â”‚  main:     A---B---C                                  â”‚
â”‚                     \                                  â”‚
â”‚  feature:            D'---E'---F'                      â”‚
â”‚                                                        â”‚
â”‚  â€¢ Replays commits on new base                        â”‚
â”‚  â€¢ Creates new commits (D', E', F')                   â”‚
â”‚  â€¢ Linear history                                     â”‚
â”‚  â€¢ DANGEROUS for shared branches                     â”‚
â”‚                                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 1. Git Rebase Explained

### What Rebase Does (Replays Commits)

Rebase takes commits from one branch and "replays" them on top of another branch, creating new commits with the same changes but different SHA-1 hashes.

**Step-by-step rebase process:**

```
Initial state:
main:     A---B---C---D
               \
feature:        E---F---G

Step 1: Git finds common ancestor (B)
Step 2: Git saves commits E, F, G as patches
Step 3: Git checks out latest main (D)
Step 4: Git applies patches one by one
        D + E patch = E'
        E' + F patch = F'
        F' + G patch = G'

Final state:
main:     A---B---C---D
                       \
feature:                E'---F'---G'

Note: E', F', G' are NEW commits with DIFFERENT SHA-1 hashes
```

**Basic rebase example:**

```bash
# Initial setup
git checkout main
git log --oneline
# d1e2f3g (HEAD -> main) Update README
# c1d2e3f Add database migration
# b1c2d3e Initial commit

# Create feature branch
git checkout -b feature/add-auth
git commit -m "Add User model"      # Commit E (sha: e1f2g3h)
git commit -m "Add AuthService"     # Commit F (sha: f2g3h4i)
git commit -m "Add login endpoint"  # Commit G (sha: g3h4i5j)

# Meanwhile, main branch gets new commits
git checkout main
git commit -m "Update dependencies" # Commit D

# View diverged history
git log --oneline --graph --all
# * d1e2f3g (HEAD -> main) Update dependencies
# | * g3h4i5j (feature/add-auth) Add login endpoint
# | * f2g3h4i Add AuthService
# | * e1f2g3h Add User model
# |/  
# * c1d2e3f Add database migration
# * b1c2d3e Initial commit

# Rebase feature branch onto main
git checkout feature/add-auth
git rebase main

# Output:
# First, rewinding head to replay your work on top of it...
# Applying: Add User model
# Applying: Add AuthService
# Applying: Add login endpoint

# View new linear history
git log --oneline --graph --all
# * g3h4i5j' (HEAD -> feature/add-auth) Add login endpoint
# * f2g3h4i' Add AuthService
# * e1f2g3h' Add User model
# * d1e2f3g (main) Update dependencies
# * c1d2e3f Add database migration
# * b1c2d3e Initial commit

# IMPORTANT: Original commits (e1f2g3h, f2g3h4i, g3h4i5j) are gone!
# New commits (e1f2g3h', f2g3h4i', g3h4i5j') have different SHA-1
```

**What actually changes during rebase:**

```java
// Original commit E (sha: e1f2g3h)
// src/main/java/User.java
public class User {
    private String name;
}

// Commit tree at time of original commit:
// parent: b1c2d3e (state of project at that time)

// After rebase, new commit E' (sha: e1f2g3h')
// Same file content:
public class User {
    private String name;
}

// But different commit tree:
// parent: d1e2f3g (different parent = different SHA-1)
// Even though content is identical, SHA-1 is different
```

**Under the hood:**

```bash
# What Git does during rebase

# 1. Detaches HEAD to common ancestor
git checkout <common-ancestor>

# 2. Checks out target branch
git checkout main

# 3. For each commit on feature branch:
#    - Creates patch (diff)
#    - Applies patch
#    - Creates new commit

# 4. Updates feature branch reference
git branch -f feature/add-auth <new-commit-sha>

# 5. Checks out feature branch
git checkout feature/add-auth
```

---

### Interactive Rebase (git rebase -i)

Interactive rebase lets you edit, reorder, squash, or drop commits.

**Starting interactive rebase:**

```bash
# Rebase last 5 commits interactively
git rebase -i HEAD~5

# Rebase all commits on feature branch
git rebase -i main

# Rebase from specific commit
git rebase -i a1b2c3d
```

**Interactive rebase editor:**

```bash
# Git opens editor with commits (oldest first)
pick e1f2g3h Add User model
pick f2g3h4i Add AuthService
pick g3h4i5j Fix typo in AuthService
pick h4i5j6k Add password validation
pick i5j6k7l Update AuthService docs

# Commands available:
# p, pick   = use commit
# r, reword = use commit, but edit commit message
# e, edit   = use commit, but stop for amending
# s, squash = use commit, but meld into previous commit
# f, fixup  = like "squash" but discard commit message
# x, exec   = run command (the rest of the line) using shell
# b, break  = stop here (continue rebase later with 'git rebase --continue')
# d, drop   = remove commit
# l, label  = label current HEAD with a name
# t, reset  = reset HEAD to a label
# m, merge  = create a merge commit using the original merge commit's message

# Lines can be re-ordered; they are executed from top to bottom
```

**Common interactive rebase operations:**

#### 1. Squash commits

```bash
# Before: 5 commits for one feature
pick e1f2g3h Add User model
pick f2g3h4i Add AuthService
pick g3h4i5j Fix typo in AuthService
pick h4i5j6k Add password validation
pick i5j6k7l Update AuthService docs

# Change to:
pick e1f2g3h Add User model
squash f2g3h4i Add AuthService
squash g3h4i5j Fix typo in AuthService
squash h4i5j6k Add password validation
squash i5j6k7l Update AuthService docs

# Save and close editor
# Git opens editor for combined commit message:
# This is a combination of 5 commits.
# The first commit's message is:
Add User model

# This is the 2nd commit message:
Add AuthService

# This is the 3rd commit message:
Fix typo in AuthService
# ... etc

# Edit to single message:
feat: Implement user authentication

Adds User model with authentication support:
- User model with email and password fields
- AuthService for authentication logic
- Password validation with bcrypt
- Complete documentation

# Result: 1 commit instead of 5
git log --oneline
# a1b2c3d (HEAD -> feature/add-auth) feat: Implement user authentication
# d1e2f3g (main) Update dependencies
```

#### 2. Reword commit messages

```bash
# Original commits with poor messages
pick e1f2g3h WIP
pick f2g3h4i Fixed stuff
pick g3h4i5j More changes

# Change to:
reword e1f2g3h WIP
reword f2g3h4i Fixed stuff
reword g3h4i5j More changes

# Git stops at each commit to edit message
# First commit - editor opens:
# WIP

# Change to:
feat: Add User model with validation

# Second commit - editor opens:
# Fixed stuff

# Change to:
fix: Correct email validation regex

# Third commit - editor opens:
# More changes

# Change to:
docs: Add authentication API documentation

# Result: Same commits, better messages
git log --oneline
# g3h4i5j (HEAD -> feature/add-auth) docs: Add authentication API documentation
# f2g3h4i fix: Correct email validation regex
# e1f2g3h feat: Add User model with validation
```

#### 3. Edit commits

```bash
# Stop at a commit to modify it
pick e1f2g3h Add User model
edit f2g3h4i Add AuthService
pick g3h4i5j Add tests

# Save and close
# Git stops at f2g3h4i
# Stopped at f2g3h4i... Add AuthService
# You can amend the commit now, with
#
#   git commit --amend
#
# Once you are satisfied with your changes, run
#
#   git rebase --continue

# Modify files
vim src/main/java/AuthService.java
git add .
git commit --amend --no-edit

# Or split the commit
git reset HEAD^
git add src/main/java/AuthService.java
git commit -m "Add AuthService class"
git add src/main/java/TokenService.java
git commit -m "Add TokenService class"

# Continue rebase
git rebase --continue
```

#### 4. Reorder commits

```bash
# Original order
pick e1f2g3h Add User model
pick f2g3h4i Add tests
pick g3h4i5j Add AuthService

# Reorder: implementation before tests
pick e1f2g3h Add User model
pick g3h4i5j Add AuthService
pick f2g3h4i Add tests

# Save and close
# Git applies commits in new order
```

#### 5. Drop commits

```bash
# Remove unwanted commits
pick e1f2g3h Add User model
pick f2g3h4i Add debug logging
pick g3h4i5j Add AuthService

# Remove debug logging
pick e1f2g3h Add User model
drop f2g3h4i Add debug logging
pick g3h4i5j Add AuthService

# Or just delete the line:
pick e1f2g3h Add User model
pick g3h4i5j Add AuthService
```

#### 6. Fixup (squash without editing message)

```bash
# Quick fixes that should be combined
pick e1f2g3h Add User model
pick f2g3h4i Fix typo
pick g3h4i5j Add AuthService
pick h4i5j6k Fix another typo

# Use fixup for typo fixes
pick e1f2g3h Add User model
fixup f2g3h4i Fix typo
pick g3h4i5j Add AuthService
fixup h4i5j6k Fix another typo

# Result: 2 commits, typo fixes absorbed
# No need to edit commit messages
```

---

### Rewriting History

**âš ï¸ WARNING: Rewriting history is powerful but dangerous!**

```
SAFE ZONE               DANGER ZONE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€              â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Local commits           Pushed commits
Your feature branch     Main/develop branch
Private work            Shared branches
Before pushing          After others pulled
```

**What "rewriting history" means:**

```bash
# Before rebase
git log --oneline
# g3h4i5j (HEAD -> feature/add-auth) Add login endpoint
# f2g3h4i Add AuthService
# e1f2g3h Add User model
# d1e2f3g (main) Update dependencies

# After rebase
git log --oneline
# g3h4i5j' (HEAD -> feature/add-auth) Add login endpoint
# f2g3h4i' Add AuthService
# e1f2g3h' Add User model
# d1e2f3g (main) Update dependencies

# Original commits (g3h4i5j, f2g3h4i, e1f2g3h) are GONE
# New commits (g3h4i5j', f2g3h4i', e1f2g3h') exist instead
# This is "rewriting history"
```

**If someone already has the old commits:**

```bash
# Developer A (you) - after rebase
git log --oneline
# g3h4i5j' Add login endpoint  â† New commits

# Developer B (teammate) - before your rebase
git log --oneline
# g3h4i5j Add login endpoint   â† Old commits

# When Developer B tries to pull:
git pull origin feature/add-auth
# error: Your local changes to the following files would be overwritten
# CONFLICT (content): Merge conflict in ...
# Both modified: src/main/java/AuthService.java

# Developer B's branch has diverged!
# They have commits that no longer exist in history
```

---

### When to Rebase (Feature Branches)

**âœ… Safe rebase scenarios:**

#### 1. Local commits not yet pushed

```bash
# You've been working locally
git commit -m "WIP: Add auth"
git commit -m "Fix typo"
git commit -m "More WIP"
git commit -m "Finally working"

# Clean up before pushing
git rebase -i HEAD~4
# Squash all into one commit

# Now push
git push origin feature/add-auth
```

#### 2. Personal feature branch

```bash
# Your feature branch, only you are working on it
git checkout feature/my-feature

# Keep it updated with main
git rebase main

# If you've pushed before, force push
git push --force-with-lease origin feature/my-feature
```

#### 3. Before creating Pull Request

```bash
# Clean up messy commit history before PR
git checkout feature/add-payment

# Interactive rebase to clean up
git rebase -i main

# Squash, reorder, reword commits
# Then push (or force push if already pushed)
git push --force-with-lease origin feature/add-payment

# Create PR with clean history
```

#### 4. Updating feature branch with latest main

```bash
# Get latest main
git checkout main
git pull origin main

# Update feature branch
git checkout feature/add-auth
git rebase main

# Resolve any conflicts
# Then continue
git rebase --continue

# Force push updated branch
git push --force-with-lease origin feature/add-auth
```

---

### When NOT to Rebase (Shared Branches)

**âŒ NEVER rebase these:**

#### 1. Main/master branch

```bash
# âŒ NEVER DO THIS
git checkout main
git rebase feature/something

# Why? Main branch is shared by entire team
# Rewriting main branch history will break everyone's work
```

#### 2. Develop branch (in Git Flow)

```bash
# âŒ NEVER DO THIS
git checkout develop
git rebase feature/something

# Develop is shared - same problem as main
```

#### 3. Any branch others are working on

```bash
# âŒ NEVER DO THIS if others have this branch
git checkout feature/shared-feature
git rebase main
git push --force origin feature/shared-feature

# Other developers will have conflicts when they pull
```

#### 4. Released/tagged commits

```bash
# âŒ NEVER DO THIS
git rebase -i v1.0.0

# Released commits should be immutable
# Others may depend on specific commit SHAs
```

#### 5. Public/published history

```bash
# âŒ NEVER DO THIS
git rebase -i HEAD~10
git push --force origin main

# If others have pulled these commits, you'll break their repos
```

---

### Golden Rule: Never Rebase Public History

**The Golden Rule:**

> **Never rebase commits that exist outside your repository and that people may have based work on.**

**Why this rule exists:**

```
Scenario: You rebase public history

You (Developer A):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Push commits A-B-C to feature branch
2. Teammate pulls your branch
3. You rebase (creating A'-B'-C')
4. You force push

Teammate (Developer B):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Pulled your commits A-B-C
2. Made commits D-E on top
3. Tries to pull your changes
4. Gets conflicts because A-B-C don't exist anymore
5. Now has messy history with duplicated commits

Result: Complete chaos ğŸ”¥
```

**Visual representation:**

```
Before your rebase:
Your branch:      A---B---C (pushed)
Teammate's work:  A---B---C---D---E

After your rebase:
Your branch:      A'---B'---C' (force pushed)
Teammate's work:  A---B---C---D---E
                  
Teammate pulls:
Teammate's branch becomes:
                  A---B---C---D---E
                                   \
                  A'---B'---C'-------M (mess!)
```

**Exception: Communicated force push**

```bash
# Only force push if:
# 1. You communicate with team
# 2. No one else is working on the branch
# 3. You use --force-with-lease

# Announce to team:
# "I'm cleaning up feature/add-auth branch.
#  If you have it checked out, please delete and re-pull."

git rebase -i main
git push --force-with-lease origin feature/add-auth

# Teammates do:
git checkout main
git branch -D feature/add-auth
git fetch origin
git checkout feature/add-auth
```

**--force-with-lease (safer force push):**

```bash
# Regular force push (dangerous)
git push --force origin feature/branch
# Overwrites remote even if someone else pushed

# Force with lease (safer)
git push --force-with-lease origin feature/branch
# Only succeeds if no one else pushed since your last fetch
# Fails if remote has commits you don't have

# Example:
git fetch origin
git rebase -i main
git push --force-with-lease origin feature/branch
# âœ… Succeeds if no one pushed since fetch

# If someone pushed:
git push --force-with-lease origin feature/branch
# âŒ error: failed to push some refs
# hint: Updates were rejected because the remote contains work that you do
# hint: not have locally. This is usually caused by another repository pushing
```

---

## 2. Rebase Use Cases

### Clean Up Local Commits Before PR

**Scenario:** You have messy commits that need cleanup before review.

```bash
# Your local commits
git log --oneline
# h4i5j6k Update tests
# g3h4i5j Fix typo
# f2g3h4i WIP: Add validation
# e1f2g3h Add User model
# d1e2f3g Fix bug
# c1d2e3f More WIP
# b1c2d3e Initial auth implementation
# a1b2c3d (main) Update dependencies

# Clean up before PR
git rebase -i main

# Editor opens:
pick b1c2d3e Initial auth implementation
pick c1d2e3f More WIP
pick d1e2f3g Fix bug
pick e1f2g3h Add User model
pick f2g3h4i WIP: Add validation
pick g3h4i5j Fix typo
pick h4i5j6k Update tests

# Clean it up:
pick b1c2d3e Initial auth implementation
fixup c1d2e3f More WIP
fixup d1e2f3g Fix bug
pick e1f2g3h Add User model
pick f2g3h4i WIP: Add validation
fixup g3h4i5j Fix typo
squash h4i5j6k Update tests

# Also reword commit messages:
reword b1c2d3e Initial auth implementation
fixup c1d2e3f More WIP
fixup d1e2f3g Fix bug
reword e1f2g3h Add User model
reword f2g3h4i WIP: Add validation
fixup g3h4i5j Fix typo
squash h4i5j6k Update tests

# Final result - 3 clean commits:
git log --oneline
# x3y4z5a feat: Add user authentication with validation and tests
# w2x3y4z feat: Add User model with email validation
# v1w2x3y feat: Implement authentication service
# a1b2c3d (main) Update dependencies
```

**Before/After comparison:**

```
Before:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
7 messy commits:
â€¢ b1c2d3e Initial auth implementation
â€¢ c1d2e3f More WIP
â€¢ d1e2f3g Fix bug
â€¢ e1f2g3h Add User model
â€¢ f2g3h4i WIP: Add validation
â€¢ g3h4i5j Fix typo
â€¢ h4i5j6k Update tests

After:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3 logical commits:
â€¢ v1w2x3y feat: Implement authentication service
â€¢ w2x3y4z feat: Add User model with email validation
â€¢ x3y4z5a feat: Add user authentication with validation and tests

Reviewer sees: Clean, logical progression
You see: Professional, reviewable history
```

---

### Squash Multiple Commits into One

**Use case:** Combine related commits for cleaner history.

```bash
# Multiple commits for single feature
git log --oneline
# f6g7h8i Add test for edge case
# e5f6g7h Fix failing test
# d4e5f6g Add integration tests
# c3d4e5f Add unit tests
# b2c3d4e Add UserService implementation
# a1b2c3d (main) Update dependencies

# Squash all into one
git rebase -i main

pick b2c3d4e Add UserService implementation
squash c3d4e5f Add unit tests
squash d4e5f6g Add integration tests
squash e5f6g7h Fix failing test
squash f6g7h8i Add test for edge case

# Edit combined message:
feat: Add UserService with comprehensive tests

Implements UserService for user management:
- CRUD operations for users
- Email validation
- Password hashing
- Unit tests (95% coverage)
- Integration tests with database
- Edge case handling

Resolves: #123

# Result:
git log --oneline
# z9a1b2c (HEAD -> feature/user-service) feat: Add UserService with comprehensive tests
# a1b2c3d (main) Update dependencies
```

**When to squash:**

```
âœ… Squash when:
- Multiple WIP commits
- Series of bug fixes
- Incremental development
- Typo fixes
- Experiments that worked

âŒ Don't squash when:
- Commits are logically separate features
- Need to preserve detailed history
- Working on main/develop
- Commits are already pushed to shared branch
```

---

### Edit Commit Messages

**Use case:** Fix poor commit messages after the fact.

```bash
# Poor messages
git log --oneline
# f6g7h8i stuff
# e5f6g7h fixed
# d4e5f6g changes
# c3d4e5f wip
# b2c3d4e (main) Update dependencies

# Fix them
git rebase -i b2c3d4e

reword c3d4e5f wip
reword d4e5f6g changes
reword e5f6g7h fixed
reword f6g7h8i stuff

# Git stops at each commit for new message

# Commit 1 - editor opens:
wip

# Change to:
feat: Add User authentication model

Adds User entity with:
- Email and password fields
- Validation annotations
- JPA mappings

# Commit 2 - editor opens:
changes

# Change to:
feat: Implement AuthenticationService

Implements authentication logic:
- Login with email/password
- JWT token generation
- Password hashing with BCrypt

# Commit 3 - editor opens:
fixed

# Change to:
fix: Correct token expiration time

Token expiration was set to 1 minute instead of 24 hours.
Fixed to proper production value.

# Commit 4 - editor opens:
stuff

# Change to:
test: Add authentication integration tests

Comprehensive test suite for authentication:
- Login success scenarios
- Invalid credentials handling
- Token validation tests

# Result - professional messages:
git log --oneline
# z9a1b2c test: Add authentication integration tests
# y8z9a1b fix: Correct token expiration time
# x7y8z9a feat: Implement AuthenticationService
# w6x7y8z feat: Add User authentication model
# b2c3d4e (main) Update dependencies
```

---

### Reorder Commits

**Use case:** Put commits in logical order.

```bash
# Commits in wrong order
git log --oneline
# f6g7h8i Add User model
# e5f6g7h Add tests for UserService
# d4e5f6g Add UserService
# c3d4e5f Update database schema
# b2c3d4e (main) Initial commit

# Problem: Tests before implementation, model after service

# Reorder logically
git rebase -i b2c3d4e

pick c3d4e5f Update database schema
pick f6g7h8i Add User model          # Move up
pick d4e5f6g Add UserService         # Keep here
pick e5f6g7h Add tests for UserService # Keep here

# Result - logical order:
git log --oneline
# y8z9a1b Add tests for UserService
# x7y8z9a Add UserService
# w6x7y8z Add User model
# v5w6x7y Update database schema
# b2c3d4e (main) Initial commit
```

**Complex reordering:**

```bash
# Before: Mixed feature commits
git log --oneline
# j9k1l2m Fix auth bug
# i8j9k1l Add payment tests
# h7i8j9k Add payment service
# g6h7i8j Fix user bug
# f5g6h7i Add user tests
# e4f5g6h Add user service
# d3e4f5g (main) Initial commit

# Reorder by feature
git rebase -i d3e4f5g

# Group user commits
pick e4f5g6h Add user service
pick f5g6h7i Add user tests
pick g6h7i8j Fix user bug

# Group payment commits
pick h7i8j9k Add payment service
pick i8j9k1l Add payment tests

# Standalone fixes
pick j9k1l2m Fix auth bug

# Result - organized by feature:
git log --oneline
# a1b2c3d Fix auth bug
# z9a1b2c Add payment tests
# y8z9a1b Add payment service
# x7y8z9a Fix user bug
# w6x7y8z Add user tests
# v5w6x7y Add user service
# d3e4f5g (main) Initial commit
```

---

### Split Commits

**Use case:** Break one large commit into multiple logical commits.

```bash
# One huge commit
git log --oneline
# e4f5g6h Add authentication feature
# d3e4f5g (main) Initial commit

git show e4f5g6h --stat
# src/main/java/User.java          | 50 ++++++++++++
# src/main/java/AuthService.java   | 80 ++++++++++++++++++
# src/main/java/TokenService.java  | 60 ++++++++++++++
# src/test/java/AuthTest.java      | 100 ++++++++++++++++++++++
# pom.xml                           | 15 ++++
# 5 files changed, 305 insertions(+)

# Split into logical commits
git rebase -i d3e4f5g

# Change pick to edit
edit e4f5g6h Add authentication feature

# Git stops at commit
# Stopped at e4f5g6h... Add authentication feature
# You can amend the commit now, with
#   git commit --amend

# Reset the commit (but keep changes)
git reset HEAD^

# Now all files are unstaged
git status
# Changes not staged for commit:
#   modified:   pom.xml
#   new file:   src/main/java/User.java
#   new file:   src/main/java/AuthService.java
#   new file:   src/main/java/TokenService.java
#   new file:   src/test/java/AuthTest.java

# Commit #1: Dependencies
git add pom.xml
git commit -m "chore: Add Spring Security dependencies"

# Commit #2: User model
git add src/main/java/User.java
git commit -m "feat: Add User model for authentication"

# Commit #3: Token service
git add src/main/java/TokenService.java
git commit -m "feat: Add TokenService for JWT generation"

# Commit #4: Auth service
git add src/main/java/AuthService.java
git commit -m "feat: Add AuthService for user authentication"

# Commit #5: Tests
git add src/test/java/AuthTest.java
git commit -m "test: Add comprehensive authentication tests"

# Continue rebase
git rebase --continue

# Result - 5 logical commits:
git log --oneline
# k9l1m2n test: Add comprehensive authentication tests
# j8k9l1m feat: Add AuthService for user authentication
# i7j8k9l feat: Add TokenService for JWT generation
# h6i7j8k feat: Add User model for authentication
# g5h6i7j chore: Add Spring Security dependencies
# d3e4f5g (main) Initial commit
```

---

## 3. Merge vs Rebase Comparison

### Side-by-Side Comparison

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              MERGE vs REBASE                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  SCENARIO: Update feature branch with main             â”‚
â”‚                                                         â”‚
â”‚  Initial State:                                         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                          â”‚
â”‚  main:     A---B---C---D                                â”‚
â”‚                 \                                       â”‚
â”‚  feature:        E---F---G                              â”‚
â”‚                                                         â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•           â”‚
â”‚                                                         â”‚
â”‚  Option 1: MERGE                                        â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                       â”‚
â”‚  $ git checkout feature                                 â”‚
â”‚  $ git merge main                                       â”‚
â”‚                                                         â”‚
â”‚  Result:                                                â”‚
â”‚  main:     A---B---C---D                                â”‚
â”‚                 \       \                               â”‚
â”‚  feature:        E---F---G---M                          â”‚
â”‚                                                         â”‚
â”‚  â€¢ Creates merge commit (M)                            â”‚
â”‚  â€¢ Preserves all history                               â”‚
â”‚  â€¢ Non-linear graph                                    â”‚
â”‚  â€¢ Commits E, F, G unchanged                           â”‚
â”‚                                                         â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•           â”‚
â”‚                                                         â”‚
â”‚  Option 2: REBASE                                       â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                      â”‚
â”‚  $ git checkout feature                                 â”‚
â”‚  $ git rebase main                                      â”‚
â”‚                                                         â”‚
â”‚  Result:                                                â”‚
â”‚  main:     A---B---C---D                                â”‚
â”‚                         \                               â”‚
â”‚  feature:                E'---F'---G'                   â”‚
â”‚                                                         â”‚
â”‚  â€¢ No merge commit                                     â”‚
â”‚  â€¢ Linear history                                      â”‚
â”‚  â€¢ Commits rewritten (E', F', G')                      â”‚
â”‚  â€¢ Original E, F, G discarded                          â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Detailed Comparison Table

|Aspect|Merge|Rebase|
|---|---|---|
|**History**|Preserves exact history|Rewrites history|
|**Graph**|Non-linear (branches visible)|Linear (no branches)|
|**Commits**|Original commits preserved|New commits created|
|**SHA-1**|Unchanged|New SHA-1 hashes|
|**Traceability**|Can see when branches merged|Can't see original branches|
|**Merge Commit**|Creates merge commit|No merge commit|
|**Safety**|Safe for shared branches|Dangerous for shared branches|
|**Conflicts**|Resolve once (during merge)|May resolve per commit|
|**Reversibility**|Easy to revert merge|Hard to undo rebase|
|**Team Impact**|No impact on others|Can break others' work|
|**Best For**|Shared branches, preserving history|Personal branches, clean history|

---

### Merge: Preserves History, Creates Merge Commits

**Advantages:**

```
âœ… Truth preservation
   - Shows exactly what happened
   - When branches diverged
   - When they merged back

âœ… Safety
   - Can't break shared history
   - Others' work unaffected
   - Easy to revert

âœ… Context
   - See feature as a unit
   - Track feature development
   - Understand timeline

âœ… Traceability
   - See which commits belong to which feature
   - Audit trail intact
   - Debugging easier
```

**Disadvantages:**

```
âŒ Cluttered history
   - Many merge commits
   - Complex graph
   - Harder to read git log

âŒ Messy timeline
   - Commits interleaved
   - Multiple storylines
   - Confusing chronology

âŒ Noise
   - Extra commits in history
   - "Merged main into feature" messages
   - Harder to find specific changes
```

**When to use merge:**

```bash
# âœ… Main/develop branches
git checkout main
git merge feature/new-feature

# âœ… Shared feature branches
git checkout feature/shared
git merge main

# âœ… Release branches
git checkout release/1.2.0
git merge hotfix/critical-bug

# âœ… When preserving exact history matters
git merge --no-ff feature/important-feature

# âœ… Public branches
git checkout public-api
git merge feature/new-endpoint
```

---

### Rebase: Linear History, Rewrites Commits

**Advantages:**

```
âœ… Clean history
   - Linear timeline
   - Easy to read
   - Logical progression

âœ… Simplified graph
   - No merge commits
   - Straight line
   - Easy to follow

âœ… Better bisect
   - git bisect works better
   - Clear cause-effect
   - Easier debugging

âœ… Professional appearance
   - Looks like planned progression
   - Logical commit sequence
   - Easy to review
```

**Disadvantages:**

```
âŒ Loses context
   - Can't see original branches
   - Lost timeline information
   - Harder to understand how feature developed

âŒ Dangerous
   - Can break others' work
   - Rewrites published history
   - Hard to recover from mistakes

âŒ Conflict complexity
   - May need to resolve same conflict multiple times
   - One conflict per commit
   - Can be tedious

âŒ False history
   - Commits appear newer than they are
   - Lost real timeline
   - Misleading git blame
```

**When to use rebase:**

```bash
# âœ… Personal feature branches
git checkout feature/my-work
git rebase main

# âœ… Before creating PR
git rebase -i main
git push --force-with-lease origin feature/my-work

# âœ… Cleaning local commits
git rebase -i HEAD~5

# âœ… Updating private branch
git fetch origin
git rebase origin/main

# âœ… When linear history preferred
git rebase main
```

---

### Which to Use When (Team Conventions)

**Recommended workflows:**

#### 1. GitHub Flow Style

```bash
# Main branch: only merge
git checkout main
git merge --no-ff feature/new-feature

# Feature branches: rebase to stay updated
git checkout feature/my-work
git rebase main

# Before PR: rebase and clean up
git rebase -i main
git push --force-with-lease origin feature/my-work

# PR merge: squash merge
# (Done via GitHub UI)
```

#### 2. Git Flow Style

```bash
# Main: only merge from release/hotfix
git checkout main
git merge --no-ff release/1.2.0

# Develop: merge features
git checkout develop
git merge --no-ff feature/new-feature

# Features: can rebase on develop
git checkout feature/my-feature
git rebase develop

# Release/Hotfix: merge only
git checkout release/1.2.0
git merge --no-ff hotfix/critical-fix
```

#### 3. Trunk-Based Development

```bash
# Main: frequent small merges
git checkout main
git merge --ff-only feature/quick-fix

# Short-lived branches: rebase
git checkout feature/small-change
git rebase main
git checkout main
git merge --ff-only feature/small-change

# Or rebase then merge
git rebase main
git push --force-with-lease origin feature/small-change
# Then merge via PR
```

**Team decision matrix:**

|Team Type|Strategy|Reason|
|---|---|---|
|**Enterprise, large team**|Merge only|Safety, traceability|
|**Startup, small team**|Rebase features, merge to main|Clean history, flexibility|
|**Open source**|Merge with --no-ff|Preserve contribution history|
|**Solo developer**|Rebase freely|Maximum flexibility|
|**Regulated industry**|Merge only|Audit requirements|

**Establishing team conventions:**

```bash
# Document in CONTRIBUTING.md
# Git Workflow
# 
# Feature Branches:
# - Name: feature/description
# - Update with: git rebase main
# - Before PR: Clean up with interactive rebase
# - Push: Use --force-with-lease if rebased
# 
# Main Branch:
# - Merge features with: git merge --no-ff
# - Never rebase
# - Never force push
# 
# Pull Requests:
# - Squash merge for small features (< 5 commits)
# - Regular merge for large features (> 5 commits)
# - Must pass CI before merge

# Configure repository
# .git/config or .gitconfig
[branch "main"]
    mergeoptions = --no-ff

[pull]
    rebase = true  # or false, depending on team preference
```

---

## Summary

### Git Rebase

- âœ… **Replays commits** on new base, creating new SHA-1 hashes
- âœ… **Interactive rebase** (`-i`) for editing, squashing, reordering
- âœ… **Rewrites history** - powerful but dangerous
- âœ… **Safe for**: Local commits, personal branches, before PR
- âŒ **Never for**: Shared branches, pushed commits, main/develop

### Use Cases

- âœ… **Clean up** messy local commits before PR
- âœ… **Squash** multiple commits into logical units
- âœ… **Reword** poor commit messages
- âœ… **Reorder** commits for logical flow
- âœ… **Split** large commits into smaller ones

### Merge vs Rebase

- âœ… **Merge**: Preserves history, safe, creates merge commits
- âœ… **Rebase**: Linear history, rewrites commits, cleaner
- âœ… **Choose based on**: Team conventions, branch type, safety needs

### Golden Rules

- ğŸš« **Never rebase public history**
- ğŸš« **Never rebase shared branches**
- ğŸš« **Never rebase main/develop**
- âœ… **Communicate** before force pushing
- âœ… **Use --force-with-lease** instead of --force

**Key Takeaway:** Rebase is a powerful tool for clean history, but use it responsibly and only on private branches!

