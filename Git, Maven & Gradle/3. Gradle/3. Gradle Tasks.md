## Overview

Tasks are the fundamental unit of work in Gradle. Every build operation is represented by a task, from compiling Java code to running tests to creating JAR files. Understanding tasks is essential to mastering Gradle.

```
┌─────────────────────────────────────────────────────────────────┐
│                    GRADLE TASK LIFECYCLE                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. INITIALIZATION                                              │
│     └── Read settings.gradle                                    │
│                                                                 │
│  2. CONFIGURATION                                               │
│     ├── Evaluate build.gradle                                  │
│     ├── Create task objects                                    │
│     ├── Configure task properties                              │
│     └── Build task dependency graph (DAG)                      │
│                                                                 │
│  3. EXECUTION                                                   │
│     ├── Determine tasks to run                                 │
│     ├── Check task up-to-date status                          │
│     ├── Execute task actions (if needed)                       │
│     └── Cache results                                          │
│                                                                 │
│  Task States:                                                   │
│  ✓ EXECUTED      - Task ran                                    │
│  ✓ UP-TO-DATE    - Inputs/outputs unchanged                   │
│  ✓ FROM-CACHE    - Retrieved from build cache                 │
│  ✓ SKIPPED       - Condition not met                          │
│  ✓ NO-SOURCE     - No input files                             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 1. Built-in Tasks

### Core Java Tasks

**Build Lifecycle:**

```
┌────────────────────────────────────────────────────────────┐
│              GRADLE JAVA BUILD LIFECYCLE                   │
├────────────────────────────────────────────────────────────┤
│                                                            │
│  clean                                                     │
│    ↓                                                       │
│  compileJava ────────┐                                    │
│                      ├──→ classes ──┐                     │
│  processResources ───┘               │                     │
│                                      ↓                     │
│                                    jar ──→ assemble       │
│                                      ↑                     │
│  compileTestJava ──┐                │                     │
│                    ├─→ testClasses ─┤                     │
│  processTestRes ───┘                │                     │
│                                      ↓                     │
│                                    test ──→ check         │
│                                                ↓           │
│                                             build          │
│                                                            │
└────────────────────────────────────────────────────────────┘
```

---

### Essential Built-in Tasks

#### 1. build

```bash
# Complete build: compile, test, package
./gradlew build

# What it does:
# 1. compileJava
# 2. processResources
# 3. classes
# 4. jar
# 5. assemble
# 6. compileTestJava
# 7. processTestResources
# 8. testClasses
# 9. test
# 10. check
```

**Breakdown:**

```groovy
// build = assemble + check
build {
    dependsOn assemble, check
}

// assemble = create all artifacts (JAR, WAR, etc.)
assemble {
    dependsOn jar
}

// check = run all verification tasks (tests, linting)
check {
    dependsOn test
}
```

---

#### 2. clean

```bash
# Delete build directory
./gradlew clean

# Clean and build
./gradlew clean build
```

**What it does:**

```
Deletes:
  - build/ directory
  - All generated files
  - Compiled classes
  - Test reports
  - JAR files
  - Cached data
```

**Configuration:**

```groovy
// Customize clean task
clean {
    delete 'custom-output'
    delete fileTree('logs') {
        include '*.log'
    }
}
```

---

#### 3. test

```bash
# Run all tests
./gradlew test

# Run specific test class
./gradlew test --tests UserServiceTest

# Run tests matching pattern
./gradlew test --tests *ServiceTest

# Run single test method
./gradlew test --tests UserServiceTest.testGetUser
```

**Configuration:**

```groovy
test {
    // Use JUnit Platform
    useJUnitPlatform()
    
    // Test execution
    maxParallelForks = Runtime.runtime.availableProcessors().intdiv(2) ?: 1
    maxHeapSize = '1G'
    
    // Test logging
    testLogging {
        events "passed", "skipped", "failed"
        exceptionFormat "full"
        showStandardStreams = false
        showStackTraces = true
        showCauses = true
    }
    
    // System properties
    systemProperty 'spring.profiles.active', 'test'
    systemProperty 'user.timezone', 'UTC'
    
    // Environment variables
    environment 'TEST_ENV', 'integration'
    
    // Include/exclude tests
    include '**/*Test.class'
    exclude '**/*IntegrationTest.class'
    
    // Fail fast
    failFast = true
    
    // Retry failed tests
    retry {
        maxRetries = 3
        maxFailures = 20
    }
}

// Test output
afterTest { descriptor, result ->
    logger.lifecycle("Test: ${descriptor} - Result: ${result.resultType}")
}
```

---

#### 4. jar

```bash
# Create JAR file
./gradlew jar

# Output: build/libs/project-name-version.jar
```

**Configuration:**

```groovy
jar {
    // Archive naming
    archiveBaseName = 'my-app'
    archiveVersion = '1.0.0'
    archiveClassifier = 'all'
    // Result: my-app-1.0.0-all.jar
    
    // Manifest
    manifest {
        attributes(
            'Implementation-Title': project.name,
            'Implementation-Version': project.version,
            'Main-Class': 'com.example.Application',
            'Class-Path': configurations.runtimeClasspath.files.collect { it.name }.join(' ')
        )
    }
    
    // Include/exclude files
    from('src/main/resources') {
        include '**/*.properties'
    }
    
    exclude '**/Test*.class'
    
    // Duplicate strategy
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

// Fat JAR (include dependencies)
jar {
    from {
        configurations.runtimeClasspath.collect {
            it.isDirectory() ? it : zipTree(it)
        }
    }
    
    manifest {
        attributes 'Main-Class': 'com.example.Application'
    }
    
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}
```

---

#### 5. bootJar (Spring Boot)

```bash
# Create Spring Boot executable JAR
./gradlew bootJar

# Output: build/libs/project-name-version.jar
```

**Configuration:**

```groovy
plugins {
    id 'org.springframework.boot' version '3.2.0'
}

bootJar {
    archiveBaseName = 'my-app'
    archiveVersion = '1.0.0'
    
    // Main class
    mainClass = 'com.example.Application'
    
    // Layer tools (for Docker optimization)
    layered {
        enabled = true
    }
    
    // Exclude dev tools
    excludeDevtools = true
    
    // Launch script (for Unix)
    launchScript()
}
```

---

#### 6. dependencies

```bash
# Show dependency tree
./gradlew dependencies

# Specific configuration
./gradlew dependencies --configuration compileClasspath
./gradlew dependencies --configuration runtimeClasspath
./gradlew dependencies --configuration testImplementation

# Output example:
compileClasspath - Compile classpath for source set 'main'.
+--- org.springframework.boot:spring-boot-starter-web -> 3.2.0
|    +--- org.springframework.boot:spring-boot-starter:3.2.0
|    |    +--- org.springframework.boot:spring-boot:3.2.0
|    |    +--- org.springframework.boot:spring-boot-autoconfigure:3.2.0
|    |    \--- ...
```

**Useful Dependency Tasks:**

```bash
# Check for dependency updates
./gradlew dependencyUpdates

# Analyze dependencies
./gradlew dependencyInsight --dependency spring-boot-starter-web

# Build scan (detailed dependency info)
./gradlew build --scan
```

---

#### 7. tasks

```bash
# List all available tasks
./gradlew tasks

# List all tasks (including internal)
./gradlew tasks --all

# List tasks in specific group
./gradlew tasks --group build
./gradlew tasks --group verification
```

**Output Example:**

```
Build tasks
-----------
assemble - Assembles the outputs of this project.
build - Assembles and tests this project.
clean - Deletes the build directory.
jar - Assembles a jar archive containing the main classes.

Documentation tasks
-------------------
javadoc - Generates Javadoc API documentation for the main source code.

Verification tasks
------------------
check - Runs all checks.
test - Runs the test suite.
```

---

### Additional Built-in Tasks

```bash
# Compilation
./gradlew compileJava          # Compile Java sources
./gradlew compileTestJava      # Compile test sources

# Resources
./gradlew processResources     # Copy resources to build
./gradlew processTestResources # Copy test resources

# Classes
./gradlew classes              # Compile and process resources
./gradlew testClasses          # Compile and process test resources

# Assembly
./gradlew assemble             # Create all artifacts (JAR, WAR)

# Verification
./gradlew check                # Run all verification tasks

# Documentation
./gradlew javadoc              # Generate Javadoc

# Application
./gradlew run                  # Run application (with application plugin)

# Distribution
./gradlew distZip              # Create ZIP distribution
./gradlew distTar              # Create TAR distribution

# Installation
./gradlew installDist          # Install distribution locally

# Build info
./gradlew properties           # Show project properties
./gradlew projects             # List sub-projects
```

---

## 2. Task Dependencies

### Understanding Task Dependencies

**Dependency Types:**

```
┌────────────────────────────────────────────────────────────┐
│              TASK DEPENDENCY TYPES                         │
├────────────────────────────────────────────────────────────┤
│                                                            │
│  dependsOn:                                                │
│  - Task B depends on Task A                                │
│  - Task A runs BEFORE Task B                               │
│  - Most common dependency type                             │
│                                                            │
│  finalizedBy:                                              │
│  - Task B finalizes Task A                                 │
│  - Task B runs AFTER Task A (always)                       │
│  - Even if Task A fails                                    │
│                                                            │
│  mustRunAfter:                                             │
│  - Task B must run after Task A                            │
│  - Only when both are scheduled                            │
│  - Doesn't force Task A to run                             │
│                                                            │
│  shouldRunAfter:                                           │
│  - Task B should run after Task A                          │
│  - Soft ordering constraint                                │
│  - Can be ignored to avoid cycles                          │
│                                                            │
└────────────────────────────────────────────────────────────┘
```

---

### 1. dependsOn

**Basic Usage:**

```groovy
// Task B depends on Task A
taskB.dependsOn taskA

// Multiple dependencies
taskC.dependsOn taskA, taskB

// Inline
task myTask {
    dependsOn 'compile', 'test'
}
```

**Examples:**

```groovy
// Single dependency
task processData {
    dependsOn 'downloadData'
    
    doLast {
        println 'Processing data...'
    }
}

// Multiple dependencies
task deployApp {
    dependsOn 'build', 'runTests', 'packageApp'
    
    doLast {
        println 'Deploying application...'
    }
}

// Conditional dependencies
task integrationTest {
    if (project.hasProperty('runIntegration')) {
        dependsOn 'startTestDb', 'test'
    }
}

// Dynamic dependencies
task buildAll {
    dependsOn tasks.matching { task ->
        task.name.startsWith('build')
    }
}

// Task collection
task compileAll {
    dependsOn tasks.withType(JavaCompile)
}
```

**Named Task Configuration:**

```groovy
// Groovy DSL
tasks.named('build') {
    dependsOn 'customTask'
}

// Kotlin DSL
tasks.named("build") {
    dependsOn("customTask")
}
```

---

### 2. finalizedBy

**Ensures cleanup or post-processing always runs:**

```groovy
// Task A is finalized by Task B
taskA.finalizedBy taskB

// Example: Always cleanup, even if build fails
task buildApp {
    doLast {
        println 'Building app...'
        // Build might fail here
    }
}

task cleanup {
    doLast {
        println 'Cleaning up temporary files...'
    }
}

buildApp.finalizedBy cleanup

// Result: cleanup ALWAYS runs after buildApp
// Even if buildApp fails!
```

**Real-world Examples:**

```groovy
// 1. Stop server after integration tests
task startTestServer {
    doLast {
        println 'Starting test server...'
    }
}

task integrationTest {
    dependsOn startTestServer
    finalizedBy stopTestServer
    
    doLast {
        println 'Running integration tests...'
    }
}

task stopTestServer {
    doLast {
        println 'Stopping test server...'
    }
}

// 2. Generate test report even if tests fail
test {
    finalizedBy testReport
}

task testReport {
    doLast {
        println 'Generating test report...'
    }
}

// 3. Cleanup resources after deployment
task deploy {
    finalizedBy cleanupDeploymentArtifacts
}
```

---

### 3. mustRunAfter

**Ordering constraint (when both tasks run):**

```groovy
// Task B must run after Task A (if both run)
taskB.mustRunAfter taskA

// Example: Ensure test runs before deploy (if both scheduled)
task test {
    doLast {
        println 'Running tests...'
    }
}

task deploy {
    mustRunAfter test
    
    doLast {
        println 'Deploying...'
    }
}

// Running just deploy: deploy runs (test doesn't run)
// ./gradlew deploy
// Output: Deploying...

// Running both: test runs first, then deploy
// ./gradlew test deploy
// Output:
// Running tests...
// Deploying...
```

**Real-world Examples:**

```groovy
// 1. Integration tests after unit tests
task integrationTest {
    mustRunAfter test
}

// 2. Build order for modules
project(':webapp') {
    tasks.named('build') {
        mustRunAfter ':api:build'
    }
}

// 3. Avoid parallel conflicts
task updateDatabase {
    doLast {
        println 'Updating database schema...'
    }
}

task seedDatabase {
    mustRunAfter updateDatabase
    
    doLast {
        println 'Seeding database...'
    }
}
```

---

### 4. shouldRunAfter

**Soft ordering (can be ignored to prevent cycles):**

```groovy
// Task B should run after Task A (when both run)
taskB.shouldRunAfter taskA

// Example: Prefer tests before packaging
task packageApp {
    shouldRunAfter test
}

// Difference from mustRunAfter:
// - mustRunAfter: Strict ordering
// - shouldRunAfter: Preferred ordering, can be ignored
```

**When to use shouldRunAfter:**

```groovy
// Use shouldRunAfter when:
// 1. Ordering is preferred but not required
// 2. Avoiding circular dependencies
// 3. Performance optimization hints

task generateResources {
    doLast {
        println 'Generating resources...'
    }
}

task compileJava {
    // Prefer to compile after resources generated
    // But not strictly required
    shouldRunAfter generateResources
}
```

---

### Dependency Graph Example

```groovy
task downloadData {
    doLast {
        println '1. Downloading data...'
    }
}

task validateData {
    dependsOn downloadData
    doLast {
        println '2. Validating data...'
    }
}

task processData {
    dependsOn validateData
    doLast {
        println '3. Processing data...'
    }
}

task generateReport {
    dependsOn processData
    finalizedBy cleanup
    doLast {
        println '4. Generating report...'
    }
}

task cleanup {
    doLast {
        println '5. Cleaning up...'
    }
}

// Running: ./gradlew generateReport
// Output:
// 1. Downloading data...
// 2. Validating data...
// 3. Processing data...
// 4. Generating report...
// 5. Cleaning up...
```

**Visualize Dependencies:**

```bash
# Show task dependencies
./gradlew generateReport --dry-run

# Task tree plugin (install first)
./gradlew taskTree generateReport
```

---

## 3. Custom Tasks

### Basic Custom Task

```groovy
// Simple task
task hello {
    doLast {
        println 'Hello, World!'
    }
}

// Run: ./gradlew hello
// Output: Hello, World!
```

---

### Task Actions

**Configuration vs Execution:**

```groovy
task example {
    // CONFIGURATION PHASE - Always runs
    println 'Configuring task'
    
    // EXECUTION PHASE - Only runs when task executes
    doFirst {
        println 'First action'
    }
    
    doLast {
        println 'Last action'
    }
}

// Running: ./gradlew example
// Output:
// Configuring task          (Configuration phase)
// First action              (Execution phase)
// Last action               (Execution phase)
```

**Multiple Actions:**

```groovy
task multiAction {
    doFirst {
        println '1. First'
    }
    
    doFirst {
        println '2. Another first (runs before previous doFirst!)'
    }
    
    doLast {
        println '3. Last'
    }
    
    doLast {
        println '4. Another last'
    }
}

// Output:
// 2. Another first (doFirst actions in reverse order)
// 1. First
// 3. Last
// 4. Another last (doLast actions in order)
```

---

### Task with Type

```groovy
// Copy task
task copyFiles(type: Copy) {
    from 'src/main/resources'
    into "${buildDir}/resources"
    
    include '**/*.properties'
    exclude '**/*.tmp'
}

// Zip task
task packageApp(type: Zip) {
    archiveBaseName = 'my-app'
    archiveVersion = '1.0.0'
    destinationDirectory = file("${buildDir}/distributions")
    
    from 'build/libs'
    from 'config'
}

// Exec task
task runScript(type: Exec) {
    workingDir 'scripts'
    commandLine 'python', 'deploy.py'
}

// Delete task
task cleanLogs(type: Delete) {
    delete fileTree('logs') {
        include '**/*.log'
    }
}
```

---

### Task with Properties

```groovy
// Task with configuration properties
task greet {
    ext.greeting = 'Hello'
    ext.person = 'World'
    
    doLast {
        println "${greeting}, ${person}!"
    }
}

// Configure from command line
// ./gradlew greet -Pgreeting=Hi -Pperson=Gradle
// Output: Hi, Gradle!

// Or configure programmatically
greet {
    greeting = 'Welcome'
    person = 'User'
}
```

---

### Typed Custom Task

**Groovy DSL:**

```groovy
// Define custom task type
abstract class GreetingTask extends DefaultTask {
    @Input
    String greeting = 'Hello'
    
    @Input
    String person = 'World'
    
    @TaskAction
    void greet() {
        println "${greeting}, ${person}!"
    }
}

// Use custom task
task morning(type: GreetingTask) {
    greeting = 'Good morning'
    person = 'Team'
}

task evening(type: GreetingTask) {
    greeting = 'Good evening'
    person = 'Everyone'
}
```

**Kotlin DSL:**

```kotlin
// Define custom task type
abstract class GreetingTask : DefaultTask() {
    @get:Input
    var greeting: String = "Hello"
    
    @get:Input
    var person: String = "World"
    
    @TaskAction
    fun greet() {
        println("$greeting, $person!")
    }
}

// Use custom task
tasks.register<GreetingTask>("morning") {
    greeting = "Good morning"
    person = "Team"
}

tasks.register<GreetingTask>("evening") {
    greeting = "Good evening"
    person = "Everyone"
}
```

---

### Advanced Custom Task

```groovy
abstract class GenerateVersionTask extends DefaultTask {
    @Input
    String version
    
    @OutputFile
    File outputFile = project.file("${project.buildDir}/version.txt")
    
    @TaskAction
    void generate() {
        outputFile.parentFile.mkdirs()
        outputFile.text = """
Version: ${version}
Build Time: ${new Date()}
Built By: ${System.getProperty('user.name')}
"""
    }
}

task generateVersion(type: GenerateVersionTask) {
    version = project.version
    outputFile = file("${buildDir}/resources/main/version.txt")
}

// Add to build process
processResources.dependsOn generateVersion
```

---

## 4. Task Configuration

### Inputs and Outputs

**Why Use Inputs/Outputs:**

```
✓ Incremental builds (skip if unchanged)
✓ Build cache (reuse from cache)
✓ Up-to-date checks
✓ Parallel execution
✓ Dependency tracking
```

---

### Input Annotations

```groovy
abstract class ProcessDataTask extends DefaultTask {
    // File input
    @InputFile
    File inputFile
    
    // Directory input
    @InputDirectory
    File sourceDir
    
    // Multiple files
    @InputFiles
    FileCollection inputFiles
    
    // Property input
    @Input
    String processingMode
    
    // Optional input
    @Optional
    @Input
    String optionalParam
    
    // Nested input
    @Nested
    ProcessingOptions options
    
    @TaskAction
    void process() {
        // Process data
    }
}
```

---

### Output Annotations

```groovy
abstract class GenerateReportTask extends DefaultTask {
    // File output
    @OutputFile
    File reportFile
    
    // Directory output
    @OutputDirectory
    File outputDir
    
    // Multiple outputs
    @OutputFiles
    FileCollection outputs
    
    @TaskAction
    void generate() {
        // Generate report
    }
}
```

---

### Complete Incremental Task Example

```groovy
// Task only runs when inputs change
abstract class CompileTemplatesTask extends DefaultTask {
    // Inputs
    @InputDirectory
    File templateDir = project.file('src/templates')
    
    @Input
    String templateEngine = 'mustache'
    
    // Outputs
    @OutputDirectory
    File outputDir = project.file("${project.buildDir}/generated-html")
    
    @TaskAction
    void compile() {
        outputDir.mkdirs()
        
        templateDir.eachFile { template ->
            def output = new File(outputDir, "${template.name}.html")
            output.text = processTemplate(template, templateEngine)
        }
    }
    
    private String processTemplate(File template, String engine) {
        // Template processing logic
        return "Processed: ${template.text}"
    }
}

task compileTemplates(type: CompileTemplatesTask) {
    templateDir = file('templates')
    outputDir = file("${buildDir}/html")
}

// First run:  EXECUTED
// Second run: UP-TO-DATE (if no changes)
// After edit: EXECUTED (only changed files)
```

---

### Up-to-Date Checks

**Gradle automatically determines if task is up-to-date:**

```groovy
task processData {
    inputs.dir 'src/data'
    inputs.property 'processingMode', 'fast'
    outputs.dir "${buildDir}/processed"
    
    doLast {
        // Process data
        println 'Processing data...'
    }
}

// First run:
// > Task :processData
// Processing data...

// Second run (no changes):
// > Task :processData UP-TO-DATE

// After changing input file:
// > Task :processData
// Processing data...
```

---

### Skip Task Conditionally

```groovy
task deployToProduction {
    // Only run in production
    onlyIf {
        project.hasProperty('env') && env == 'production'
    }
    
    doLast {
        println 'Deploying to production...'
    }
}

// Run with condition:
// ./gradlew deployToProduction -Penv=production

// Skip condition:
task processOptional {
    onlyIf {
        project.file('input.txt').exists()
    }
    
    doLast {
        println 'Processing optional file...'
    }
}
```

---

### Task Timeout

```groovy
task longRunningTask {
    timeout = Duration.ofMinutes(5)
    
    doLast {
        // Long running operation
        sleep(1000)
    }
}
```

---

### Task Caching

```groovy
// Enable task output caching
task generateDocs {
    inputs.dir 'src'
    outputs.dir "${buildDir}/docs"
    outputs.cacheIf { true }
    
    doLast {
        // Generate documentation
    }
}

// Or for custom task type
abstract class CachedTask extends DefaultTask {
    @CacheableTask
    static abstract class Cached extends CachedTask {}
}
```

---

## 5. Task Execution Control

### Excluding Tasks

```bash
# Exclude specific task
./gradlew build -x test

# Exclude multiple tasks
./gradlew build -x test -x javadoc

# Build without tests and documentation
./gradlew build -x test -x javadoc -x asciidoctor
```

---

### Dry Run

```bash
# Show what would run (don't execute)
./gradlew build --dry-run

# Output:
# :compileJava SKIPPED
# :processResources SKIPPED
# :classes SKIPPED
# :jar SKIPPED
# :assemble SKIPPED
# :compileTestJava SKIPPED
# :processTestResources SKIPPED
# :testClasses SKIPPED
# :test SKIPPED
# :check SKIPPED
# :build SKIPPED
```

---

### Continue on Failure

```bash
# Continue even if some tasks fail
./gradlew build --continue

# Useful for:
# - Running all tests (see all failures)
# - Multi-module builds
# - CI/CD pipelines
```

---

### Parallel Execution

```bash
# Run tasks in parallel
./gradlew build --parallel

# Specify max workers
./gradlew build --parallel --max-workers=4
```

---

## Summary

### Task Execution States

```
┌────────────────────────────────────────────────────────────┐
│                  TASK STATES                               │
├────────────────────────────────────────────────────────────┤
│                                                            │
│  EXECUTED        Task ran successfully                     │
│  UP-TO-DATE      Inputs unchanged, output reused          │
│  FROM-CACHE      Retrieved from build cache               │
│  SKIPPED         onlyIf condition false                    │
│  NO-SOURCE       No input files to process                │
│  FAILED          Task execution failed                     │
│                                                            │
└────────────────────────────────────────────────────────────┘
```

### Essential Built-in Tasks

```bash
./gradlew build           # Complete build
./gradlew clean           # Delete build/
./gradlew test            # Run tests
./gradlew jar             # Create JAR
./gradlew bootJar         # Spring Boot JAR
./gradlew dependencies    # Dependency tree
./gradlew tasks           # List tasks
```

### Task Dependencies

```groovy
// Before: A runs before B
taskB.dependsOn taskA

// After: B runs after A (always)
taskA.finalizedBy taskB

// Ordering: B after A (when both run)
taskB.mustRunAfter taskA

// Soft ordering: B preferably after A
taskB.shouldRunAfter taskA
```

### Custom Task Template

```groovy
abstract class MyTask extends DefaultTask {
    @InputDirectory
    File inputDir
    
    @OutputDirectory
    File outputDir
    
    @Input
    String mode = 'default'
    
    @TaskAction
    void execute() {
        // Task implementation
    }
}

task myCustomTask(type: MyTask) {
    inputDir = file('input')
    outputDir = file("${buildDir}/output")
    mode = 'advanced'
}
```

### Best Practices

```
✓ Use inputs/outputs for incremental builds
✓ Use dependsOn for task ordering
✓ Use finalizedBy for cleanup
✓ Make tasks cacheable when possible
✓ Add task descriptions
✓ Group related tasks
✓ Use typed tasks for reusability
✓ Leverage up-to-date checks
```
