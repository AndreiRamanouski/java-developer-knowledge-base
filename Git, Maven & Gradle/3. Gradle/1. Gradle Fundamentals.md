## Overview

Gradle is a powerful build automation tool that combines the best features of Ant's flexibility and Maven's dependency management, with a modern DSL-based approach that makes builds more concise and maintainable.

```
┌─────────────────────────────────────────────────────────────────┐
│                    GRADLE ARCHITECTURE                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  build.gradle (or build.gradle.kts)                            │
│       ↓                                                         │
│  Gradle Core Engine                                             │
│       ├── Dependency Resolution                                 │
│       ├── Task Execution (DAG)                                 │
│       ├── Incremental Builds                                    │
│       └── Build Cache                                          │
│            ↓                                                    │
│  ┌─────────────┬─────────────┬─────────────┐                  │
│  │   Plugins   │  Task Graph │   Cache     │                  │
│  │             │             │             │                  │
│  │ • Java      │ Task DAG    │ Local Cache │                  │
│  │ • Spring    │ Determines  │ Remote Cache│                  │
│  │ • Android   │ Exec Order  │ Up-to-date  │                  │
│  └─────────────┴─────────────┴─────────────┘                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 1. What is Gradle?

### Core Concepts

Gradle is a build automation tool that provides:

**1. Declarative & Imperative Build Scripts**

```groovy
// Declarative (what to build)
plugins {
    id 'java'
    id 'org.springframework.boot' version '3.1.5'
}

// Imperative (how to build)
task customTask {
    doLast {
        println "Building custom component"
        // Custom build logic
    }
}
```

**2. Groovy or Kotlin DSL**

```groovy
// Groovy DSL (build.gradle)
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    testImplementation 'org.junit.jupiter:junit-jupiter'
}
```

```kotlin
// Kotlin DSL (build.gradle.kts)
dependencies {
    implementation("org.springframework.boot:spring-boot-starter-web")
    testImplementation("org.junit.jupiter:junit-jupiter")
}
```

**3. Powerful Dependency Management**

```groovy
repositories {
    mavenCentral()
    maven { url 'https://repo.spring.io/milestone' }
}

dependencies {
    implementation platform('org.springframework.boot:spring-boot-dependencies:3.1.5')
    implementation 'org.springframework.boot:spring-boot-starter-web'
    
    // Version constraints
    implementation('com.google.guava:guava') {
        version {
            strictly '[30.0, 31.0['
            prefer '30.1.1-jre'
        }
    }
}
```

**4. Incremental Builds & Caching**

```
First build:
  ├── Compile Java: 30s
  ├── Process Resources: 5s
  ├── Run Tests: 20s
  └── Build JAR: 2s
  Total: 57s

Second build (no changes):
  ├── Compile Java: UP-TO-DATE
  ├── Process Resources: UP-TO-DATE
  ├── Run Tests: UP-TO-DATE
  └── Build JAR: UP-TO-DATE
  Total: <1s
```

---

### Why Use Gradle?

**Performance:**

```
┌────────────────────────────────────────────────────────────┐
│              BUILD PERFORMANCE COMPARISON                  │
├────────────────────────────────────────────────────────────┤
│                                                            │
│  Gradle Advantages:                                        │
│  ✓ Incremental builds (only changed files)               │
│  ✓ Build cache (reuse across branches)                   │
│  ✓ Parallel execution (by default)                       │
│  ✓ Daemon (keeps JVM running)                            │
│  ✓ Configuration cache (faster config)                   │
│                                                            │
│  Typical Performance:                                      │
│  Full build:        Gradle ~= Maven                       │
│  Incremental build: Gradle 10-100x faster                │
│  No-op build:       Gradle <1s, Maven 5-10s             │
│                                                            │
└────────────────────────────────────────────────────────────┘
```

**Flexibility:**

```groovy
// Custom tasks are first-class citizens
task generateDocs {
    inputs.dir 'src/main/java'
    outputs.dir 'build/docs'
    
    doLast {
        // Custom documentation generation
        exec {
            commandLine 'asciidoctor', 'README.adoc'
        }
    }
}

// Modify existing tasks
compileJava {
    options.compilerArgs += ['-Xlint:unchecked', '-Xlint:deprecation']
}
```

**Modern Features:**

```groovy
// Composite builds (multiple projects as one)
includeBuild('../library-project')

// Version catalogs (centralized versions)
dependencies {
    implementation libs.spring.boot.web
    implementation libs.bundles.logging
}

// Convention plugins (reusable configuration)
plugins {
    id 'com.company.java-conventions'
}
```

---

## 2. Gradle vs Maven

### Detailed Comparison

```
┌────────────────────────────────────────────────────────────────┐
│                  GRADLE vs MAVEN                               │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  Configuration Files:                                          │
│  Maven:  pom.xml (XML, verbose)                               │
│  Gradle: build.gradle (Groovy/Kotlin, concise)               │
│                                                                │
│  Build Model:                                                  │
│  Maven:  Fixed lifecycle phases                               │
│  Gradle: Task DAG (directed acyclic graph)                    │
│                                                                │
│  Flexibility:                                                  │
│  Maven:  Convention over configuration                        │
│  Gradle: Flexible, programmable, extensible                   │
│                                                                │
│  Performance:                                                  │
│  Maven:  Full rebuilds common                                 │
│  Gradle: Incremental builds, caching                          │
│                                                                │
│  Learning Curve:                                               │
│  Maven:  Simpler, more predictable                            │
│  Gradle: Steeper, more powerful                               │
│                                                                │
│  Ecosystem:                                                    │
│  Maven:  Massive (older, more plugins)                        │
│  Gradle: Growing (newer, active development)                  │
│                                                                │
│  Best For:                                                     │
│  Maven:  Enterprise, standardization                          │
│  Gradle: Performance, flexibility, Android                    │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

### Configuration Comparison

**Maven (pom.xml):**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0">
    <modelVersion>4.0.0</modelVersion>
    
    <groupId>com.company</groupId>
    <artifactId>my-app</artifactId>
    <version>1.0.0-SNAPSHOT</version>
    <packaging>jar</packaging>
    
    <properties>
        <java.version>17</java.version>
        <spring-boot.version>3.1.5</spring-boot.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <version>${spring-boot.version}</version>
        </dependency>
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter</artifactId>
            <version>5.10.0</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <version>${spring-boot.version}</version>
            </plugin>
        </plugins>
    </build>
</project>
```

**Gradle (build.gradle) - Groovy DSL:**

```groovy
plugins {
    id 'java'
    id 'org.springframework.boot' version '3.1.5'
}

group = 'com.company'
version = '1.0.0-SNAPSHOT'
sourceCompatibility = '17'

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.0'
}
```

**Gradle (build.gradle.kts) - Kotlin DSL:**

```kotlin
plugins {
    java
    id("org.springframework.boot") version "3.1.5"
}

group = "com.company"
version = "1.0.0-SNAPSHOT"
java.sourceCompatibility = JavaVersion.VERSION_17

repositories {
    mavenCentral()
}

dependencies {
    implementation("org.springframework.boot:spring-boot-starter-web")
    testImplementation("org.junit.jupiter:junit-jupiter:5.10.0")
}
```

**Comparison:**

```
Lines of code:
  Maven:   ~40 lines
  Gradle:  ~15 lines (Groovy)
  Gradle:  ~16 lines (Kotlin)

Readability:
  Maven:   Verbose XML tags
  Gradle:  Concise, programming language-like

Flexibility:
  Maven:   Limited to XML structure
  Gradle:  Full programming capabilities
```

---

### Build Model Comparison

**Maven: Linear Lifecycle**

```
validate → compile → test → package → verify → install → deploy

Fixed phases
Cannot skip or reorder
Always executes in same sequence
```

**Gradle: Task DAG (Directed Acyclic Graph)**

```
compileJava ────┐
                ├──→ classes ──→ jar ──→ build
processResources┘

Flexible task dependencies
Can skip tasks (UP-TO-DATE)
Parallel execution
Dynamic task graph
```

**Example: Gradle Task Graph**

```groovy
task compileJava {
    // Compile Java sources
}

task processResources {
    // Copy resources
}

task classes {
    dependsOn compileJava, processResources
}

task jar {
    dependsOn classes
}

task build {
    dependsOn jar, test
}

// Gradle builds dependency graph:
//        compileJava ───┐
//                       ├─→ classes ─→ jar ─┐
//   processResources ───┘                   ├─→ build
//                                           │
//                       test ───────────────┘
```

---

### Performance Comparison

**Build Speed:**

```
Project: 100 Java classes, 50 tests

Clean Build (first time):
  Maven:  45s
  Gradle: 40s
  Winner: Roughly equal

Incremental Build (1 file changed):
  Maven:  30s (recompiles everything)
  Gradle: 2s  (only changed file)
  Winner: Gradle 15x faster

No-op Build (nothing changed):
  Maven:  8s  (checks everything)
  Gradle: 0.5s (UP-TO-DATE checks)
  Winner: Gradle 16x faster

Multi-module (10 modules):
  Maven:  Sequential by default
  Gradle: Parallel by default
  Winner: Gradle (depends on setup)
```

**Why Gradle is Faster:**

```
1. Incremental Builds
   - Tracks input/output of each task
   - Only reruns when inputs change
   
2. Build Cache
   - Reuses outputs from previous builds
   - Works across branches and machines
   
3. Daemon
   - Keeps JVM running between builds
   - Faster startup (no JVM initialization)
   
4. Parallel Execution
   - Runs independent tasks in parallel
   - Default behavior (not opt-in like Maven -T)
   
5. Configuration Cache
   - Caches build configuration
   - Faster configuration phase
```

---

### Flexibility Comparison

**Maven: Convention Over Configuration**

```xml
<!-- Maven way: Fixed structure -->
<build>
    <sourceDirectory>src/main/java</sourceDirectory>
    <testSourceDirectory>src/test/java</testSourceDirectory>
    
    <!-- Custom behavior requires plugins -->
    <plugins>
        <plugin>
            <artifactId>maven-compiler-plugin</artifactId>
            <configuration>
                <source>17</source>
                <target>17</target>
            </configuration>
        </plugin>
    </plugins>
</build>
```

**Gradle: Flexible & Programmable**

```groovy
// Gradle way: Full programming capabilities

// Simple configuration
java {
    sourceCompatibility = JavaVersion.VERSION_17
}

// Custom source sets
sourceSets {
    integration {
        java.srcDir 'src/integration/java'
        resources.srcDir 'src/integration/resources'
    }
}

// Programmatic logic
tasks.withType(JavaCompile) {
    options.compilerArgs += ['-Xlint:unchecked']
    
    if (project.hasProperty('strict')) {
        options.compilerArgs += ['-Werror']
    }
}

// Custom tasks
task generateVersion {
    doLast {
        def versionFile = file("$buildDir/version.txt")
        versionFile.text = version
    }
}

// Conditional configuration
if (project.hasProperty('profile') && profile == 'prod') {
    dependencies {
        implementation 'com.company:production-libs:1.0.0'
    }
}
```

---

### Learning Curve

**Maven:**

```
Pros:
  ✓ Simple XML structure
  ✓ Predictable behavior
  ✓ Extensive documentation
  ✓ Large community
  ✓ Easy to get started

Cons:
  ✗ XML verbosity
  ✗ Limited flexibility
  ✗ Custom behavior difficult
  ✗ Plugin development complex
```

**Gradle:**

```
Pros:
  ✓ Concise syntax
  ✓ Powerful and flexible
  ✓ Modern features
  ✓ Better performance
  ✓ Programmatic approach

Cons:
  ✗ Steeper learning curve
  ✗ More complex conceptually
  ✗ DSL knowledge required
  ✗ Smaller ecosystem (but growing)
  ✗ Can be "too flexible" (foot-gun)
```

---

### Ecosystem Comparison

**Maven:**

```
Strengths:
  ✓ Older, more established
  ✓ More plugins available
  ✓ Better enterprise tooling support
  ✓ Universal understanding
  ✓ Repository managers (Nexus, Artifactory)

Plugin Ecosystem:
  - maven-compiler-plugin
  - maven-surefire-plugin
  - maven-shade-plugin
  - maven-assembly-plugin
  - Spring Boot Maven Plugin
  - +thousands more
```

**Gradle:**

```
Strengths:
  ✓ Active development
  ✓ Modern architecture
  ✓ Growing ecosystem
  ✓ Official Android build tool
  ✓ Better integration with IDEs

Plugin Ecosystem:
  - Java Plugin (built-in)
  - Spring Boot Gradle Plugin
  - Shadow Plugin (fat JAR)
  - Kotlin Plugin
  - Android Gradle Plugin
  - +growing collection
```

---

### When to Choose Which

**Choose Maven When:**

```
✓ Enterprise environment with Maven expertise
✓ Need maximum stability and predictability
✓ Working with legacy projects (already Maven)
✓ Team prefers convention over flexibility
✓ Simple, straightforward builds
✓ Need widest plugin ecosystem
```

**Choose Gradle When:**

```
✓ Building Android applications (required)
✓ Need best build performance
✓ Complex, custom build requirements
✓ Multi-language projects (Java, Kotlin, Groovy)
✓ Want modern build features
✓ Team comfortable with programming concepts
```

**Can Use Both:**

```
Many organizations use both:
  - Maven for simpler services
  - Gradle for Android and complex builds
  - Gradle for microservices (performance)
  - Maven for traditional enterprise apps
```

---

## 3. Gradle Wrapper

### What is the Wrapper?

The Gradle Wrapper allows you to run Gradle builds without requiring Gradle to be pre-installed.

**Benefits:**

```
✓ Consistent Gradle version across team
✓ No global Gradle installation needed
✓ CI/CD works without setup
✓ Easy to upgrade Gradle version
✓ Works on Windows, Linux, macOS
```

---

### Wrapper Files

**Project Structure with Wrapper:**

```
my-project/
├── gradle/
│   └── wrapper/
│       ├── gradle-wrapper.jar          # Wrapper executable
│       └── gradle-wrapper.properties   # Wrapper configuration
├── gradlew                             # Unix/Linux/Mac wrapper script
├── gradlew.bat                         # Windows wrapper script
├── build.gradle                        # Build script
└── settings.gradle                     # Project settings
```

**gradle-wrapper.properties:**

```properties
# Gradle wrapper configuration
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.4-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
```

**Key Properties:**

```
distributionUrl:
  - Gradle version to use
  - gradle-8.4-bin.zip (binaries only)
  - gradle-8.4-all.zip (includes sources and docs)

distributionBase:
  - Where to download Gradle
  - GRADLE_USER_HOME = ~/.gradle

networkTimeout:
  - Download timeout (milliseconds)
  - 10000ms = 10 seconds
```

---

### Using the Wrapper

**Unix/Linux/macOS:**

```bash
# Make executable (if needed)
chmod +x gradlew

# Build project
./gradlew build

# Run tests
./gradlew test

# Clean build
./gradlew clean build

# List tasks
./gradlew tasks

# Run with specific Gradle version
./gradlew wrapper --gradle-version 8.4
```

**Windows:**

```cmd
# Build project
gradlew.bat build

# Or just
gradlew build

# Clean build
gradlew clean build

# List tasks
gradlew tasks
```

**First Run:**

```bash
# First time running wrapper
./gradlew build

# Downloads Gradle if not present:
Downloading https://services.gradle.org/distributions/gradle-8.4-bin.zip
...........10%...........20%...........30%...........40%
...........50%...........60%...........70%...........80%
...........90%...........100%

Unzipping /home/user/.gradle/wrapper/dists/gradle-8.4-bin/.../gradle-8.4-bin.zip
...

# Subsequent runs use downloaded version:
BUILD SUCCESSFUL in 5s
```

---

### Generating the Wrapper

**Initial Wrapper Setup:**

```bash
# Generate wrapper (requires Gradle installed)
gradle wrapper --gradle-version 8.4

# Generated files:
# ├── gradle/wrapper/gradle-wrapper.jar
# ├── gradle/wrapper/gradle-wrapper.properties
# ├── gradlew
# └── gradlew.bat
```

**Update Wrapper Version:**

```bash
# Update to specific version
./gradlew wrapper --gradle-version 8.5

# Update to latest release
./gradlew wrapper --gradle-version latest

# Update to latest snapshot
./gradlew wrapper --gradle-version latest-snapshot

# Use all distribution (with sources)
./gradlew wrapper --gradle-version 8.4 --distribution-type all
```

**Wrapper Task Configuration:**

```groovy
// build.gradle
wrapper {
    gradleVersion = '8.4'
    distributionType = Wrapper.DistributionType.ALL
}

// Or in Kotlin DSL (build.gradle.kts)
tasks.wrapper {
    gradleVersion = "8.4"
    distributionType = Wrapper.DistributionType.ALL
}
```

---

### Why Use the Wrapper?

**1. Version Consistency**

```
Without Wrapper:
  Developer A: Gradle 7.6
  Developer B: Gradle 8.0
  CI Server:   Gradle 7.5
  Result:      Inconsistent builds, "works on my machine"

With Wrapper:
  All:         Gradle 8.4 (from wrapper)
  Result:      Consistent builds everywhere
```

**2. No Installation Required**

```
New Developer Setup:

Without Wrapper:
  1. Install Java
  2. Download Gradle
  3. Set GRADLE_HOME
  4. Add to PATH
  5. Verify installation
  6. Clone project
  7. Build

With Wrapper:
  1. Install Java
  2. Clone project
  3. ./gradlew build  # Done!
```

**3. Easy Version Updates**

```bash
# Update Gradle version for entire team
./gradlew wrapper --gradle-version 8.5

# Commit changes
git add gradle/wrapper/
git add gradlew gradlew.bat
git commit -m "Update Gradle to 8.5"

# Everyone gets new version on next pull
git pull
./gradlew build  # Uses Gradle 8.5
```

**4. CI/CD Integration**

```yaml
# GitHub Actions - No Gradle installation needed
name: Build
on: [push]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-java@v3
        with:
          java-version: '17'
      - run: ./gradlew build  # Uses wrapper
```

---

### Committing Wrapper to Repository

**What to Commit:**

```bash
# ✓ COMMIT these files
git add gradle/wrapper/gradle-wrapper.jar
git add gradle/wrapper/gradle-wrapper.properties
git add gradlew
git add gradlew.bat

# ✗ DON'T commit
# gradle/wrapper/dists/  (downloaded Gradle distributions)
# .gradle/               (build cache)
```

**.gitignore:**

```
# Gradle
.gradle/
build/
!gradle/wrapper/gradle-wrapper.jar
!gradle/wrapper/gradle-wrapper.properties

# Keep wrapper JAR despite ignoring .jar files
!**/gradle/wrapper/gradle-wrapper.jar
```

**Why Commit Wrapper JAR:**

```
gradle-wrapper.jar is small (~60KB) and:
  ✓ Required to run wrapper
  ✓ Ensures wrapper works everywhere
  ✓ No external dependencies
  ✓ Industry best practice
  ✓ Recommended by Gradle team
```

---

### Wrapper Security

**Validation:**

```properties
# gradle-wrapper.properties
validateDistributionUrl=true  # Verify URL is from gradle.org
```

**Checksum Verification:**

```bash
# Gradle automatically verifies checksums
# Uses SHA-256 hash to ensure integrity
# Prevents tampering
```

**Custom Distribution:**

```properties
# Use company mirror for security/speed
distributionUrl=https\://nexus.company.com/gradle/gradle-8.4-bin.zip

# Or local file
distributionUrl=file:///opt/gradle/gradle-8.4-bin.zip
```

---

### Troubleshooting Wrapper

**Permission Issues (Unix):**

```bash
# Make wrapper executable
chmod +x gradlew

# Verify
ls -l gradlew
# -rwxr-xr-x ... gradlew
```

**Download Issues:**

```bash
# Check network connectivity
curl -I https://services.gradle.org/distributions/gradle-8.4-bin.zip

# Increase timeout
# Edit gradle-wrapper.properties
networkTimeout=30000  # 30 seconds

# Manual download and extract
wget https://services.gradle.org/distributions/gradle-8.4-bin.zip
unzip gradle-8.4-bin.zip -d ~/.gradle/wrapper/dists/gradle-8.4
```

**Wrong Gradle Version:**

```bash
# Check current version
./gradlew --version

# Update wrapper
./gradlew wrapper --gradle-version 8.4

# Force re-download
rm -rf ~/.gradle/wrapper/dists/gradle-8.4
./gradlew build
```

---

## 4. Basic Gradle Commands

### Common Commands

```bash
# Build project
./gradlew build

# Clean build
./gradlew clean build

# Run tests
./gradlew test

# Skip tests
./gradlew build -x test

# Run specific task
./gradlew compileJava

# List all tasks
./gradlew tasks

# List all tasks (including dependencies)
./gradlew tasks --all

# Show dependency tree
./gradlew dependencies

# Show project info
./gradlew projects

# Show project properties
./gradlew properties

# Continuous build (watches for changes)
./gradlew build --continuous

# Debug build
./gradlew build --debug

# Run with stacktrace
./gradlew build --stacktrace

# Parallel execution
./gradlew build --parallel

# Refresh dependencies
./gradlew build --refresh-dependencies

# Offline mode
./gradlew build --offline
```

---

### Task Execution

**Task Dependencies:**

```bash
# Build task runs all dependent tasks
./gradlew build

# Dependency chain:
compileJava → classes → jar → assemble → build
                                  ↑
                               test ─┘
```

**Selective Execution:**

```bash
# Run only compilation
./gradlew compileJava

# Run multiple tasks
./gradlew clean test

# Exclude tasks
./gradlew build -x test -x javadoc
```

---

## 5. Project Structure

### Standard Gradle Project

```
my-gradle-project/
├── gradle/
│   └── wrapper/
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── com/company/app/
│   │   │       └── Application.java
│   │   └── resources/
│   │       └── application.properties
│   └── test/
│       ├── java/
│       │   └── com/company/app/
│       │       └── ApplicationTest.java
│       └── resources/
│           └── test.properties
├── build.gradle          # Build script (Groovy)
├── settings.gradle       # Project settings
├── gradlew              # Unix wrapper
├── gradlew.bat          # Windows wrapper
└── .gitignore
```

**settings.gradle:**

```groovy
rootProject.n = 'my-gradle-project'

// For multi-module projects
// include 'module-a', 'module-b'
```

**build.gradle (minimal):**

```groovy
plugins {
    id 'java'
}

group = 'com.company'
version = '1.0.0-SNAPSHOT'

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.slf4j:slf4j-api:2.0.9'
    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.0'
}

test {
    useJUnitPlatform()
}
```

---

## Summary

### Key Takeaways

**1. Gradle vs Maven:**

```
Gradle Strengths:
  ✓ Better performance (incremental builds, caching)
  ✓ More flexible (programmable DSL)
  ✓ Modern features (daemon, parallel by default)
  ✓ Concise configuration

Maven Strengths:
  ✓ Simpler to learn
  ✓ More standardized
  ✓ Larger ecosystem
  ✓ Better enterprise adoption
```

**2. Gradle Wrapper:**

```
✓ Use wrapper (gradlew) instead of global Gradle
✓ Commit wrapper files to version control
✓ Ensures consistent Gradle version
✓ No installation required
✓ Update with: ./gradlew wrapper --gradle-version X.Y
```

**3. Configuration:**

```
Groovy DSL:  build.gradle     (more common)
Kotlin DSL:  build.gradle.kts (type-safe, IDE support)

Both are fully functional, choose based on preference
```

### Essential Commands

```bash
# Basic workflow
./gradlew build              # Build project
./gradlew test              # Run tests
./gradlew clean build       # Clean and build

# Information
./gradlew tasks             # List tasks
./gradlew dependencies      # Show dependencies
./gradlew properties        # Show properties

# Wrapper
./gradlew wrapper --gradle-version 8.4  # Update Gradle
./gradlew --version         # Show Gradle version

# Performance
./gradlew build --parallel  # Parallel execution
./gradlew build --offline   # Offline mode
./gradlew build --build-cache  # Enable cache
```

### Quick Start

```bash
# 1. Clone project
git clone <repository>

# 2. Build (wrapper handles Gradle download)
./gradlew build

# 3. Run tests
./gradlew test

# 4. That's it!
```
