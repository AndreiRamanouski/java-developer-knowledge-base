
## Overview

Applications need configuration and secrets:

- **Configuration**: Non-sensitive settings (database host, feature flags, timeouts)
- **Secrets**: Sensitive data (passwords, API keys, certificates)

**Kubernetes provides:**

- **ConfigMaps**: Store non-sensitive configuration
- **Secrets**: Store sensitive data (base64 encoded)
- **Environment Variables**: Pass config/secrets to pods
- **Downward API**: Expose pod/container metadata

---

## 1. ConfigMaps

**ConfigMap** stores non-sensitive configuration data in key-value pairs.

### Why Use ConfigMaps?

**Problems without ConfigMaps:**

```dockerfile
# Bad: Configuration hardcoded in image
FROM openjdk:17
ENV DATABASE_HOST=prod-db.example.com
ENV DATABASE_PORT=5432
ENV LOG_LEVEL=INFO

# Issues:
# - Must rebuild image for config changes
# - Different images for dev/staging/prod
# - Can't change config without redeployment
```

**Solution with ConfigMaps:**

```yaml
# Good: Configuration external to image
# Same image, different config per environment
# Can update config without rebuilding image
```

### Creating ConfigMaps

#### Method 1: From Literal Values

```bash
# Create from command line
kubectl create configmap app-config \
  --from-literal=database.host=postgres.default.svc.cluster.local \
  --from-literal=database.port=5432 \
  --from-literal=log.level=INFO \
  --from-literal=max.connections=100

# View ConfigMap
kubectl get configmap app-config -o yaml
```

**Output:**

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  database.host: postgres.default.svc.cluster.local
  database.port: "5432"
  log.level: INFO
  max.connections: "100"
```

#### Method 2: From YAML File

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
  namespace: production
data:
  # Simple key-value pairs
  database.host: "postgres.default.svc.cluster.local"
  database.port: "5432"
  log.level: "INFO"
  
  # Multi-line values
  application.properties: |
    server.port=8080
    spring.datasource.url=jdbc:postgresql://postgres:5432/mydb
    spring.datasource.username=appuser
    logging.level.root=INFO
    logging.level.com.myapp=DEBUG
  
  # JSON configuration
  feature-flags.json: |
    {
      "features": {
        "newUI": true,
        "betaFeatures": false,
        "apiV2": true
      }
    }
```

```bash
# Apply ConfigMap
kubectl apply -f configmap.yaml

# View ConfigMap
kubectl describe configmap app-config
```

#### Method 3: From File

```bash
# Create from single file
kubectl create configmap nginx-config --from-file=nginx.conf

# Create from multiple files
kubectl create configmap app-configs \
  --from-file=application.properties \
  --from-file=logging.properties \
  --from-file=database.properties

# Create from directory (all files in directory)
kubectl create configmap config-dir --from-file=./config/
```

**Example file** (`application.properties`):

```properties
server.port=8080
spring.application.name=myapp
spring.profiles.active=production
database.url=jdbc:postgresql://postgres:5432/mydb
cache.ttl=3600
```

```bash
# Create ConfigMap from this file
kubectl create configmap app-props --from-file=application.properties

# Resulting ConfigMap:
# data:
#   application.properties: |
#     server.port=8080
#     spring.application.name=myapp
#     ...
```

#### Method 4: From Env File

```bash
# env-file format
cat > app.env <<EOF
DATABASE_HOST=postgres.default.svc.cluster.local
DATABASE_PORT=5432
LOG_LEVEL=INFO
MAX_CONNECTIONS=100
EOF

# Create ConfigMap from env file
kubectl create configmap app-env --from-env-file=app.env

# Resulting ConfigMap:
# data:
#   DATABASE_HOST: postgres.default.svc.cluster.local
#   DATABASE_PORT: "5432"
#   LOG_LEVEL: INFO
#   MAX_CONNECTIONS: "100"
```

---

### Mounting as Files vs Environment Variables

#### Option 1: Environment Variables (Simple Key-Value)

**Use when:**

- Simple configuration
- Application reads from environment variables
- Few config items

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: myapp
spec:
  containers:
  - name: app
    image: myapp:1.0
    
    # Method 1: Individual environment variables
    env:
    - name: DATABASE_HOST
      valueFrom:
        configMapKeyRef:
          name: app-config
          key: database.host
    
    - name: DATABASE_PORT
      valueFrom:
        configMapKeyRef:
          name: app-config
          key: database.port
    
    - name: LOG_LEVEL
      valueFrom:
        configMapKeyRef:
          name: app-config
          key: log.level
```

**Method 2: All Keys as Environment Variables**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: myapp
spec:
  containers:
  - name: app
    image: myapp:1.0
    
    # Import ALL keys from ConfigMap as env vars
    envFrom:
    - configMapRef:
        name: app-config
    
    # All keys become env vars:
    # database.host → DATABASE_HOST (dots replaced with underscores)
    # database.port → DATABASE_PORT
    # log.level → LOG_LEVEL
```

**Verify environment variables:**

```bash
# Check environment variables in pod
kubectl exec myapp -- env | grep DATABASE

# Output:
DATABASE_HOST=postgres.default.svc.cluster.local
DATABASE_PORT=5432
```

#### Option 2: Mounted as Files (Config Files)

**Use when:**

- Application expects config files
- Complex configuration (JSON, YAML, properties)
- Multiple config files

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: myapp
spec:
  containers:
  - name: app
    image: myapp:1.0
    
    volumeMounts:
    # Mount ConfigMap as directory
    - name: config-volume
      mountPath: /etc/config
      readOnly: true
    
    # App can now read files:
    # /etc/config/application.properties
    # /etc/config/feature-flags.json
  
  volumes:
  - name: config-volume
    configMap:
      name: app-config
```

**What gets mounted:**

```bash
# Inside the pod:
kubectl exec myapp -- ls -la /etc/config

# Output:
total 16
drwxrwxrwx 3 root root 4096 Nov 14 10:00 .
drwxr-xr-x 1 root root 4096 Nov 14 10:00 ..
drwxr-xr-x 2 root root 4096 Nov 14 10:00 ..data
lrwxrwxrwx 1 root root   18 Nov 14 10:00 application.properties -> ..data/application.properties
lrwxrwxrwx 1 root root   21 Nov 14 10:00 feature-flags.json -> ..data/feature-flags.json

# View file contents:
kubectl exec myapp -- cat /etc/config/application.properties
```

#### Option 3: Mount Specific Keys

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: myapp
spec:
  containers:
  - name: app
    image: myapp:1.0
    
    volumeMounts:
    - name: config-volume
      mountPath: /etc/config
  
  volumes:
  - name: config-volume
    configMap:
      name: app-config
      items:
      # Only mount specific keys
      - key: application.properties
        path: app.properties  # Rename file
      - key: feature-flags.json
        path: features.json
```

**Result:**

```bash
# Only these files mounted:
/etc/config/app.properties
/etc/config/features.json
```

#### Option 4: Mount Single File

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
  - name: nginx
    image: nginx:1.25
    
    volumeMounts:
    # Mount single file (not whole directory)
    - name: nginx-config
      mountPath: /etc/nginx/nginx.conf
      subPath: nginx.conf  # Important: subPath for single file!
  
  volumes:
  - name: nginx-config
    configMap:
      name: nginx-config
      items:
      - key: nginx.conf
        path: nginx.conf
```

**Why subPath?**

```yaml
# Without subPath:
# mountPath: /etc/nginx/nginx.conf
# Result: /etc/nginx/nginx.conf becomes a DIRECTORY!
# All other files in /etc/nginx disappear

# With subPath:
# mountPath: /etc/nginx/nginx.conf
# subPath: nginx.conf
# Result: Only this one file is replaced
# Other files in /etc/nginx remain intact
```

---

### Updating Configs (Rolling Updates)

#### Automatic ConfigMap Updates

**How it works:**

```yaml
# 1. Create ConfigMap
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  log.level: INFO

# 2. Pod mounts ConfigMap as volume
# File contents automatically updated when ConfigMap changes!
# (with up to 60 second delay)
```

**Important Notes:**

- ✅ **Mounted as volume**: Updates automatically (60s delay)
- ❌ **Environment variables**: Do NOT update (pod restart required)
- ❌ **subPath mounts**: Do NOT update (pod restart required)

#### Update ConfigMap

```bash
# Method 1: Edit directly
kubectl edit configmap app-config

# Method 2: Apply updated YAML
kubectl apply -f configmap.yaml

# Method 3: Patch specific key
kubectl patch configmap app-config -p '{"data":{"log.level":"DEBUG"}}'

# Method 4: Replace from file
kubectl create configmap app-config --from-file=application.properties --dry-run=client -o yaml | kubectl apply -f -
```

#### Trigger Pod Restart After ConfigMap Update

**Problem:** ConfigMap updated, but pod doesn't reload config automatically.

**Solution 1: Add annotation to trigger rolling restart**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  template:
    metadata:
      annotations:
        # Change this annotation to trigger rollout
        configmap.version: "v1"
    spec:
      containers:
      - name: app
        image: myapp:1.0
```

```bash
# Update ConfigMap
kubectl apply -f configmap.yaml

# Trigger restart by changing annotation
kubectl patch deployment myapp -p \
  '{"spec":{"template":{"metadata":{"annotations":{"configmap.version":"v2"}}}}}'

# This triggers rolling restart with new config
```

**Solution 2: ConfigMap hash in annotation (automatic)**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  template:
    metadata:
      annotations:
        # Include ConfigMap hash (use tool like Helm)
        checksum/config: {{ include (print $.Template.BasePath "/configmap.yaml") . | sha256sum }}
```

**Solution 3: Use Reloader (automatic)**

```bash
# Install Reloader
kubectl apply -f https://raw.githubusercontent.com/stakater/Reloader/master/deployments/kubernetes/reloader.yaml

# Add annotation to deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
  annotations:
    reloader.stakater.com/auto: "true"
spec:
  # Reloader watches ConfigMaps/Secrets
  # Automatically restarts pods when they change
```

#### Immutable ConfigMaps (Recommended for Production)

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config-v1
immutable: true  # Cannot be modified!
data:
  log.level: INFO
```

**Why immutable ConfigMaps?**

- ✅ Prevent accidental changes
- ✅ Better performance (kubelet doesn't watch for changes)
- ✅ Explicit versioning

**Update strategy with immutable ConfigMaps:**

```bash
# 1. Create new ConfigMap with new version
kubectl apply -f configmap-v2.yaml
# name: app-config-v2

# 2. Update deployment to use new ConfigMap
kubectl set env deployment/myapp --from=configmap/app-config-v2

# 3. Rolling update automatically happens

# 4. After successful rollout, delete old ConfigMap
kubectl delete configmap app-config-v1
```

---

## 2. Secrets

**Secret** stores sensitive data (passwords, tokens, keys).

### ⚠️ Important: Secrets are NOT Encrypted by Default!

**Critical Understanding:**

```yaml
# Secrets are BASE64 ENCODED, not ENCRYPTED!
echo "my-password" | base64
# Output: bXktcGFzc3dvcmQK

# Anyone with cluster access can decode:
echo "bXktcGFzc3dvcmQK" | base64 -d
# Output: my-password

# Secrets provide:
✅ Separation from ConfigMaps
✅ RBAC (access control)
✅ Audit logging
❌ NOT encryption!

# For true encryption, use:
- Encryption at rest (etcd encryption)
- External secret management (Vault, AWS Secrets Manager)
- Sealed Secrets
```

---

### Secret Types

#### 1. Opaque (Generic)

Most common type for arbitrary key-value pairs.

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: db-secret
type: Opaque  # Default type
data:
  # Base64 encoded values
  username: YWRtaW4=           # admin
  password: cGFzc3dvcmQxMjM=   # password123
```

**Create from command line:**

```bash
# Create secret
kubectl create secret generic db-secret \
  --from-literal=username=admin \
  --from-literal=password=password123

# Kubernetes automatically base64 encodes values

# View secret (values hidden)
kubectl get secret db-secret

# View secret data (base64 encoded)
kubectl get secret db-secret -o yaml

# Decode secret
kubectl get secret db-secret -o jsonpath='{.data.password}' | base64 -d
```

**Create from file:**

```bash
# Create password file
echo -n "password123" > password.txt

# Create secret from file
kubectl create secret generic db-secret \
  --from-file=password=password.txt

# Create from multiple files
kubectl create secret generic app-secrets \
  --from-file=username.txt \
  --from-file=password.txt \
  --from-file=api-key.txt
```

#### 2. kubernetes.io/dockerconfigjson (Docker Registry)

For pulling images from private Docker registries.

```bash
# Create docker-registry secret
kubectl create secret docker-registry regcred \
  --docker-server=docker.io \
  --docker-username=myuser \
  --docker-password=mypassword \
  --docker-email=myemail@example.com

# Or from existing Docker config
kubectl create secret generic regcred \
  --from-file=.dockerconfigjson=$HOME/.docker/config.json \
  --type=kubernetes.io/dockerconfigjson
```

**Use in pod:**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: private-app
spec:
  containers:
  - name: app
    image: myregistry.com/myapp:latest
  
  # Reference docker-registry secret
  imagePullSecrets:
  - name: regcred
```

#### 3. kubernetes.io/tls (TLS Certificate)

For storing TLS certificates and private keys.

```bash
# Create TLS secret from cert files
kubectl create secret tls my-tls-secret \
  --cert=tls.crt \
  --key=tls.key

# Generated secret contains:
# data:
#   tls.crt: <base64 encoded certificate>
#   tls.key: <base64 encoded private key>
```

**Use in Ingress:**

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-ingress
spec:
  tls:
  - hosts:
    - example.com
    secretName: my-tls-secret
  rules:
  - host: example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: web-service
            port:
              number: 80
```

#### 4. kubernetes.io/ssh-auth (SSH Authentication)

For SSH private keys.

```bash
# Create SSH secret
kubectl create secret generic ssh-key-secret \
  --from-file=ssh-privatekey=$HOME/.ssh/id_rsa \
  --type=kubernetes.io/ssh-auth
```

#### 5. kubernetes.io/basic-auth (Basic Authentication)

For basic auth credentials.

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: basic-auth
type: kubernetes.io/basic-auth
stringData:  # stringData automatically encodes to base64
  username: admin
  password: t0p-Secret
```

---

### Using Secrets in Pods

#### Method 1: Environment Variables

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: myapp
spec:
  containers:
  - name: app
    image: myapp:1.0
    
    env:
    # Individual secret values
    - name: DB_USERNAME
      valueFrom:
        secretKeyRef:
          name: db-secret
          key: username
    
    - name: DB_PASSWORD
      valueFrom:
        secretKeyRef:
          name: db-secret
          key: password
    
    # All secret values as env vars
    envFrom:
    - secretRef:
        name: api-credentials
```

```bash
# Verify (be careful in production!)
kubectl exec myapp -- env | grep DB_

# Output:
DB_USERNAME=admin
DB_PASSWORD=password123
```

#### Method 2: Mounted as Files

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: myapp
spec:
  containers:
  - name: app
    image: myapp:1.0
    
    volumeMounts:
    - name: secret-volume
      mountPath: /etc/secrets
      readOnly: true
    
    # Application reads:
    # /etc/secrets/username
    # /etc/secrets/password
  
  volumes:
  - name: secret-volume
    secret:
      secretName: db-secret
```

```bash
# Inside pod:
ls -la /etc/secrets/

# Output:
lrwxrwxrwx 1 root root 15 Nov 14 10:00 username -> ..data/username
lrwxrwxrwx 1 root root 15 Nov 14 10:00 password -> ..data/password

# Read secret file:
cat /etc/secrets/password
# Output: password123 (decoded!)
```

#### Method 3: Specific Secret Keys

```yaml
volumes:
- name: secret-volume
  secret:
    secretName: db-secret
    items:
    - key: username
      path: db-username  # Custom filename
      mode: 0400         # File permissions (read-only for owner)
    - key: password
      path: db-password
      mode: 0400
```

---

### External Secret Management

For production, use external secret management instead of Kubernetes Secrets.

#### Why External Secret Management?

**Problems with Kubernetes Secrets:**

- ❌ Base64 encoding is NOT encryption
- ❌ Secrets stored in etcd (need encryption at rest)
- ❌ Secrets visible to anyone with cluster access
- ❌ No secret rotation
- ❌ No audit trail
- ❌ Secrets in Git (YAML files)

**External Solutions:**

- ✅ True encryption
- ✅ Centralized secret management
- ✅ Automatic rotation
- ✅ Audit logging
- ✅ Access control
- ✅ Secrets never stored in Git

---

#### 1. HashiCorp Vault

**Most popular enterprise secret management solution.**

**Architecture:**

```
┌─────────────────────────────────────────┐
│         Kubernetes Cluster              │
│                                         │
│  ┌───────────────────────────────────┐ │
│  │ Pod with Vault Agent Sidecar      │ │
│  │  ┌──────────┐  ┌──────────────┐  │ │
│  │  │  App     │  │ Vault Agent  │  │ │
│  │  │Container │  │  (Sidecar)   │  │ │
│  │  │          │  │              │  │ │
│  │  │ Reads:   │  │ Fetches      │  │ │
│  │  │/vault/   │◄─┤secrets from  │  │ │
│  │  │secrets/  │  │Vault server  │  │ │
│  │  └──────────┘  └──────┬───────┘  │ │
│  └─────────────────────────┼─────────┘ │
│                            │           │
└────────────────────────────┼───────────┘
                             │
                             ▼
                    ┌──────────────┐
                    │ Vault Server │
                    │ (External)   │
                    └──────────────┘
```

**Setup with Vault Agent Injector:**

```bash
# Install Vault on Kubernetes
helm repo add hashicorp https://helm.releases.hashicorp.com
helm install vault hashicorp/vault

# Enable Kubernetes authentication in Vault
vault auth enable kubernetes

# Create secret in Vault
vault kv put secret/myapp/config \
  username=admin \
  password=secret123 \
  api-key=abc123xyz
```

**Pod with Vault annotations:**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: myapp
  annotations:
    # Inject Vault Agent sidecar
    vault.hashicorp.com/agent-inject: "true"
    vault.hashicorp.com/role: "myapp"
    
    # Inject specific secrets
    vault.hashicorp.com/agent-inject-secret-database: "secret/myapp/config"
    vault.hashicorp.com/agent-inject-template-database: |
      {{- with secret "secret/myapp/config" -}}
      export DB_USERNAME="{{ .Data.data.username }}"
      export DB_PASSWORD="{{ .Data.data.password }}"
      {{- end }}
spec:
  serviceAccountName: myapp
  containers:
  - name: app
    image: myapp:1.0
    command: ["/bin/sh"]
    args:
    - -c
    - |
      source /vault/secrets/database
      java -jar app.jar
```

**What happens:**

1. Vault Agent sidecar injected automatically
2. Authenticates with Vault using ServiceAccount token
3. Fetches secrets from Vault
4. Writes secrets to `/vault/secrets/database`
5. App sources secrets from file
6. Vault Agent keeps secrets up to date (auto-rotation)

---

#### 2. External Secrets Operator

**Syncs secrets from external systems into Kubernetes Secrets.**

**Supported backends:**

- AWS Secrets Manager
- AWS Parameter Store
- Azure Key Vault
- Google Secret Manager
- HashiCorp Vault
- 1Password
- Many more

**Installation:**

```bash
# Install External Secrets Operator
helm repo add external-secrets https://charts.external-secrets.io
helm install external-secrets external-secrets/external-secrets
```

**Example: AWS Secrets Manager**

**Step 1: Create secret in AWS:**

```bash
# Create secret in AWS Secrets Manager
aws secretsmanager create-secret \
  --name myapp/database \
  --secret-string '{"username":"admin","password":"secret123"}'
```

**Step 2: Configure SecretStore:**

```yaml
apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: aws-secrets-manager
  namespace: default
spec:
  provider:
    aws:
      service: SecretsManager
      region: us-east-1
      auth:
        jwt:
          serviceAccountRef:
            name: external-secrets-sa
```

**Step 3: Create ExternalSecret:**

```yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: database-secret
  namespace: default
spec:
  refreshInterval: 1h  # Sync every hour
  
  secretStoreRef:
    name: aws-secrets-manager
    kind: SecretStore
  
  target:
    name: database-secret  # Kubernetes Secret to create
    creationPolicy: Owner
  
  data:
  - secretKey: username
    remoteRef:
      key: myapp/database
      property: username
  
  - secretKey: password
    remoteRef:
      key: myapp/database
      property: password
```

**Step 4: Use secret in pod:**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: myapp
spec:
  containers:
  - name: app
    image: myapp:1.0
    env:
    - name: DB_USERNAME
      valueFrom:
        secretKeyRef:
          name: database-secret  # Created by ExternalSecret
          key: username
    - name: DB_PASSWORD
      valueFrom:
        secretKeyRef:
          name: database-secret
          key: password
```

**How it works:**

```
1. External Secrets Operator watches ExternalSecret resources
2. Fetches secrets from AWS Secrets Manager
3. Creates/updates Kubernetes Secret
4. Pod uses Kubernetes Secret normally
5. Operator syncs changes automatically (every 1h)
```

---

#### 3. Sealed Secrets

**Encrypt secrets so they can be stored in Git safely.**

**Problem:**

```yaml
# This secret contains sensitive data
# Cannot commit to Git!
apiVersion: v1
kind: Secret
metadata:
  name: db-secret
data:
  password: cGFzc3dvcmQxMjM=  # Anyone can decode!
```

**Solution: Sealed Secrets**

```yaml
# Encrypted secret - SAFE to commit to Git
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: db-secret
spec:
  encryptedData:
    password: AgBh7Xz9K...encrypted...long...string
```

**Installation:**

```bash
# Install Sealed Secrets controller
kubectl apply -f https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.24.0/controller.yaml

# Install kubeseal CLI
brew install kubeseal
# or
wget https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.24.0/kubeseal-linux-amd64
chmod +x kubeseal-linux-amd64
sudo mv kubeseal-linux-amd64 /usr/local/bin/kubeseal
```

**Usage:**

```bash
# 1. Create normal secret (don't apply!)
kubectl create secret generic db-secret \
  --from-literal=password=secret123 \
  --dry-run=client -o yaml > secret.yaml

# 2. Encrypt with kubeseal
kubeseal -f secret.yaml -w sealed-secret.yaml

# 3. sealed-secret.yaml can be safely committed to Git!
git add sealed-secret.yaml
git commit -m "Add database secret"

# 4. Apply sealed secret
kubectl apply -f sealed-secret.yaml

# 5. Sealed Secrets controller automatically:
#    - Decrypts SealedSecret
#    - Creates normal Secret
#    - Pods use secret normally
```

**Verify:**

```bash
# SealedSecret exists
kubectl get sealedsecrets

# Normal Secret was created automatically
kubectl get secret db-secret

# Only the controller can decrypt!
# Even cluster admins cannot decrypt without controller's private key
```

**Key Features:**

- ✅ Safe to store in Git (encrypted)
- ✅ GitOps-friendly
- ✅ One-way encryption (can't decrypt without controller)
- ✅ Namespace/name scoped (can't move to different namespace)

---

### Base64 Encoding (NOT Encryption!)

**Critical Understanding:**

```bash
# Encoding (reversible!)
echo -n "my-secret-password" | base64
# Output: bXktc2VjcmV0LXBhc3N3b3Jk

# Decoding (anyone can do this!)
echo "bXktc2VjcmV0LXBhc3N3b3Jk" | base64 -d
# Output: my-secret-password

# This is NOT encryption!
# Just encoding for binary-safe storage
```

**Why base64?**

- Secrets can contain binary data (certificates, keys)
- YAML/JSON require text-safe format
- Base64 makes binary data text-safe

**Security measures:**

```yaml
# 1. RBAC - limit who can read secrets
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: secret-reader
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get", "list"]
  # Only specific people have this role!

# 2. Encryption at rest (etcd encryption)
# Configure API server:
--encryption-provider-config=/etc/kubernetes/enc/encryption-config.yaml

# 3. Use external secret management (Vault, AWS Secrets Manager)

# 4. Use Sealed Secrets for GitOps

# 5. Audit logging
--audit-policy-file=/etc/kubernetes/audit-policy.yaml
# Tracks who accessed which secrets
```

---

## 3. Environment Variables

### From ConfigMaps/Secrets

**Complete example combining ConfigMaps and Secrets:**

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  LOG_LEVEL: "INFO"
  DATABASE_HOST: "postgres.default.svc.cluster.local"
  DATABASE_PORT: "5432"
  CACHE_ENABLED: "true"

---
apiVersion: v1
kind: Secret
metadata:
  name: app-secrets
type: Opaque
stringData:
  DATABASE_PASSWORD: "secret123"
  API_KEY: "abc123xyz"

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: app
        image: myapp:1.0
        
        env:
        # Static value
        - name: ENVIRONMENT
          value: "production"
        
        # From ConfigMap (specific key)
        - name: LOG_LEVEL
          valueFrom:
            configMapKeyRef:
              name: app-config
              key: LOG_LEVEL
        
        # From Secret (specific key)
        - name: DATABASE_PASSWORD
          valueFrom:
            secretKeyRef:
              name: app-secrets
              key: DATABASE_PASSWORD
        
        # All keys from ConfigMap
        envFrom:
        - configMapRef:
            name: app-config
        
        # All keys from Secret
        - secretRef:
            name: app-secrets
```

**Result inside container:**

```bash
kubectl exec myapp-xxx -- env

# Output:
ENVIRONMENT=production
LOG_LEVEL=INFO
DATABASE_HOST=postgres.default.svc.cluster.local
DATABASE_PORT=5432
CACHE_ENABLED=true
DATABASE_PASSWORD=secret123
API_KEY=abc123xyz
```

---

### Downward API (Pod Metadata)

**Downward API** exposes pod/container metadata as environment variables or files.

#### Available Metadata

**Pod-level:**

- Pod name
- Pod namespace
- Pod IP
- Service account name
- Node name
- Pod UID

**Container-level:**

- CPU request
- CPU limit
- Memory request
- Memory limit

**Labels and annotations**

---

#### Method 1: Environment Variables

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: myapp
  namespace: production
  labels:
    app: myapp
    version: "1.0"
  annotations:
    build: "2024-11-14"
spec:
  containers:
  - name: app
    image: myapp:1.0
    
    env:
    # Pod name
    - name: MY_POD_NAME
      valueFrom:
        fieldRef:
          fieldPath: metadata.name
    
    # Pod namespace
    - name: MY_POD_NAMESPACE
      valueFrom:
        fieldRef:
          fieldPath: metadata.namespace
    
    # Pod IP
    - name: MY_POD_IP
      valueFrom:
        fieldRef:
          fieldPath: status.podIP
    
    # Node name
    - name: MY_NODE_NAME
      valueFrom:
        fieldRef:
          fieldPath: spec.nodeName
    
    # Service account
    - name: MY_POD_SERVICE_ACCOUNT
      valueFrom:
        fieldRef:
          fieldPath: spec.serviceAccountName
    
    # Container CPU request
    - name: MY_CPU_REQUEST
      valueFrom:
        resourceFieldRef:
          containerName: app
          resource: requests.cpu
    
    # Container memory limit
    - name: MY_MEM_LIMIT
      valueFrom:
        resourceFieldRef:
          containerName: app
          resource: limits.memory
    
    # Pod label
    - name: MY_POD_LABEL_APP
      valueFrom:
        fieldRef:
          fieldPath: metadata.labels['app']
    
    # Pod annotation
    - name: MY_POD_ANNOTATION_BUILD
      valueFrom:
        fieldRef:
          fieldPath: metadata.annotations['build']
    
    resources:
      requests:
        cpu: "500m"
        memory: "512Mi"
      limits:
        cpu: "1000m"
        memory: "1Gi"
```

**Verify:**

```bash
kubectl exec myapp -- env | grep MY_

# Output:
MY_POD_NAME=myapp
MY_POD_NAMESPACE=production
MY_POD_IP=10.244.1.5
MY_NODE_NAME=node-1
MY_POD_SERVICE_ACCOUNT=default
MY_CPU_REQUEST=1
MY_MEM_LIMIT=1073741824
MY_POD_LABEL_APP=myapp
MY_POD_ANNOTATION_BUILD=2024-11-14
```

#### Method 2: Mounted as Files

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: myapp
  labels:
    app: myapp
    tier: backend
spec:
  containers:
  - name: app
    image: myapp:1.0
    
    volumeMounts:
    - name: podinfo
      mountPath: /etc/podinfo
  
  volumes:
  - name: podinfo
    downwardAPI:
      items:
      # Pod labels
      - path: "labels"
        fieldRef:
          fieldPath: metadata.labels
      
      # Pod annotations
      - path: "annotations"
        fieldRef:
          fieldPath: metadata.annotations
      
      # Pod name
      - path: "pod-name"
        fieldRef:
          fieldPath: metadata.name
      
      # Resource limits
      - path: "cpu-limit"
        resourceFieldRef:
          containerName: app
          resource: limits.cpu
      
      - path: "memory-limit"
        resourceFieldRef:
          containerName: app
          resource: limits.memory
```

**Access files:**

```bash
kubectl exec myapp -- cat /etc/podinfo/labels

# Output:
app="myapp"
tier="backend"

kubectl exec myapp -- cat /etc/podinfo/pod-name

# Output:
myapp

kubectl exec myapp -- cat /etc/podinfo/cpu-limit

# Output:
1
```

---

#### Use Cases for Downward API

**1. Logging with pod information:**

```yaml
env:
- name: POD_NAME
  valueFrom:
    fieldRef:
      fieldPath: metadata.name
- name: POD_NAMESPACE
  valueFrom:
    fieldRef:
      fieldPath: metadata.namespace

# Application logs include pod info:
# [2024-11-14 10:30:00] [myapp-abc123] [production] INFO: Request processed
```

**2. Service discovery:**

```yaml
env:
- name: POD_IP
  valueFrom:
    fieldRef:
      fieldPath: status.podIP

# Application registers itself with service discovery:
# consul.register(POD_IP, PORT)
```

**3. Resource-aware applications:**

```yaml
env:
- name: MEMORY_LIMIT
  valueFrom:
    resourceFieldRef:
      resource: limits.memory

# Application calculates cache size:
# cache_size = MEMORY_LIMIT * 0.3
```

**4. Blue-green deployments:**

```yaml
env:
- name: DEPLOYMENT_VERSION
  valueFrom:
    fieldRef:
      fieldPath: metadata.labels['version']

# Application reports version in metrics:
# deployment_version{version="1.2.0"}
```

---

## Best Practices

### ConfigMaps

**✅ DO:**

- Use ConfigMaps for non-sensitive configuration
- Version ConfigMaps (app-config-v1, app-config-v2)
- Use immutable ConfigMaps in production
- Document what each key means
- Validate configuration in application startup

**❌ DON'T:**

- Store secrets in ConfigMaps
- Use mutable ConfigMaps in production (causes inconsistency)
- Create massive ConfigMaps (split into multiple)
- Rely on automatic updates (explicit restart better)

### Secrets

**✅ DO:**

- Use external secret management (Vault, AWS Secrets Manager)
- Enable encryption at rest (etcd encryption)
- Use RBAC to limit secret access
- Use Sealed Secrets for GitOps
- Rotate secrets regularly
- Use stringData for YAML (auto-encodes)
- Mount secrets as files (more secure than env vars)

**❌ DON'T:**

- Commit secrets to Git
- Log secret values
- Store secrets in ConfigMaps
- Give everyone secret read access
- Use same secret across environments
- Print env vars in production

### Environment Variables

**✅ DO:**

- Use for simple key-value configuration
- Combine ConfigMaps + Secrets + Downward API
- Document all environment variables
- Provide defaults in application

**❌ DON'T:**

- Use for large configuration files (use volumes)
- Echo environment variables in logs
- Expose secrets via environment (prefer volumes)

---

## Complete Example: Spring Boot Application

```yaml
# ConfigMap for application configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: spring-config
data:
  application.properties: |
    server.port=8080
    spring.application.name=myapp
    logging.level.root=INFO
    logging.level.com.myapp=DEBUG
  
  logback-spring.xml: |
    <configuration>
      <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
          <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
      </appender>
      <root level="INFO">
        <appender-ref ref="CONSOLE"/>
      </root>
    </configuration>

---
# Secret for sensitive data
apiVersion: v1
kind: Secret
metadata:
  name: spring-secrets
type: Opaque
stringData:
  spring.datasource.password: "secret123"
  spring.redis.password: "redis-secret"
  jwt.secret: "jwt-secret-key-12345"

---
# Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: spring-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: spring-app
  template:
    metadata:
      labels:
        app: spring-app
        version: "1.0"
    spec:
      containers:
      - name: app
        image: myapp:1.0
        ports:
        - containerPort: 8080
        
        env:
        # Static configuration
        - name: SPRING_PROFILES_ACTIVE
          value: "production"
        
        # From ConfigMap
        - name: SERVER_PORT
          value: "8080"
        
        # From Secret
        - name: SPRING_DATASOURCE_PASSWORD
          valueFrom:
            secretKeyRef:
              name: spring-secrets
              key: spring.datasource.password
        
        - name: SPRING_REDIS_PASSWORD
          valueFrom:
            secretKeyRef:
              name: spring-secrets
              key: spring.redis.password
        
        # Downward API
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        
        - name: POD_IP
          valueFrom:
            fieldRef:
              fieldPath: status.podIP
        
        # Resource info
        - name: MEMORY_LIMIT
          valueFrom:
            resourceFieldRef:
              resource: limits.memory
        
        # Mount config files
        volumeMounts:
        - name: config
          mountPath: /config
          readOnly: true
        
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        
        livenessProbe:
          httpGet:
            path: /actuator/health/liveness
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        
        readinessProbe:
          httpGet:
            path: /actuator/health/readiness
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
      
      volumes:
      - name: config
        configMap:
          name: spring-config
```

**Application reads configuration:**

```java
// From environment variables
String password = System.getenv("SPRING_DATASOURCE_PASSWORD");
String podName = System.getenv("POD_NAME");

// From config files
@PropertySource("file:/config/application.properties")

// From application.properties (environment variables override)
@Value("${spring.datasource.password}")
private String password;
```

---


### Quick Reference

|Type|Purpose|Sensitive|Encoded|Usage|
|---|---|---|---|---|
|**ConfigMap**|Non-sensitive config|No|No|Config files, env vars|
|**Secret**|Sensitive data|Yes|Base64|Passwords, tokens, certs|
|**Downward API**|Pod metadata|No|No|Pod name, IP, resources|

### Key Takeaways

**ConfigMaps:**

- ✅ External configuration (12-factor app)
- ✅ Mount as files or env vars
- ✅ Use immutable ConfigMaps for production
- ✅ Updates require pod restart (unless mounted as volume)

**Secrets:**

- ⚠️ Base64 encoding is NOT encryption!
- ✅ Use external secret management (Vault, AWS SM)
- ✅ Enable etcd encryption at rest
- ✅ Use RBAC to restrict access
- ✅ Mount as files (more secure than env vars)
- ✅ Use Sealed Secrets for GitOps

**Environment Variables:**

- ✅ Simple key-value configuration
- ✅ Combine ConfigMaps + Secrets + Downward API
- ❌ Don't use for large config files
- ❌ Don't log secrets

**Downward API:**

- ✅ Expose pod/container metadata
- ✅ Use for logging, service discovery
- ✅ Available as env vars or files

**Production Security:**

1. Use external secret management (Vault)
2. Enable etcd encryption
3. Implement RBAC
4. Use Sealed Secrets for GitOps
5. Rotate secrets regularly
6. Audit secret access
7. Never commit secrets to Git
