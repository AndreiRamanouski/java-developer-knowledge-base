# CI/CD Fundamentals

## 1. Continuous Integration

### What is Continuous Integration (CI)?

**Continuous Integration** is the practice of frequently integrating code changes into a shared repository, with automated builds and tests running on each integration.

```
Traditional Development (Weekly/Monthly Merges):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Dev1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Merge (PAIN!)   â”‚
â”‚  Dev2 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Merge (PAIN!)   â”‚
â”‚  Dev3 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Merge (PAIN!)   â”‚
â”‚                                                  â”‚
â”‚  Problems:                                       â”‚
â”‚  - Massive merge conflicts                       â”‚
â”‚  - Integration issues discovered late            â”‚
â”‚  - Long debugging sessions                       â”‚
â”‚  - "Works on my machine"                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Continuous Integration (Multiple Times Daily):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Dev1 â”€â–¶ Merge â”€â–¶ Build â”€â–¶ Test â”€â–¶ âœ“           â”‚
â”‚          (frequent, small changes)               â”‚
â”‚                                                  â”‚
â”‚  Dev2 â”€â–¶ Merge â”€â–¶ Build â”€â–¶ Test â”€â–¶ âœ“           â”‚
â”‚          (multiple times per day)                â”‚
â”‚                                                  â”‚
â”‚  Dev3 â”€â–¶ Merge â”€â–¶ Build â”€â–¶ Test â”€â–¶ âœ“           â”‚
â”‚          (automated feedback)                    â”‚
â”‚                                                  â”‚
â”‚  Benefits:                                       â”‚
â”‚  - Small, manageable changes                     â”‚
â”‚  - Quick feedback (5-10 minutes)                â”‚
â”‚  - Early bug detection                           â”‚
â”‚  - Reduced integration risk                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### Core Principles of CI

**1. Single Source Repository**

```
âœ… One repository for all code
âœ… Version control (Git)
âœ… Everyone commits to main/trunk
âœ… Feature branches short-lived

âŒ Multiple repositories scattered
âŒ Code on local machines
âŒ Long-lived feature branches
âŒ Manual file sharing
```

**2. Automate the Build**

```bash
# Every commit triggers automated build
git push origin main
  â†“
CI Server detects change
  â†“
Checkout code
  â†“
Build application
  â†“
Run unit tests
  â†“
Report results (âœ“ or âœ—)
```

**3. Self-Testing Build**

```
Build includes comprehensive tests:
â”œâ”€â”€ Unit Tests (fast, isolated)
â”œâ”€â”€ Integration Tests (components together)
â”œâ”€â”€ Code Quality Checks (linting, coverage)
â””â”€â”€ Security Scans (vulnerabilities)

Goal: Catch bugs immediately after commit
```

**4. Commit Frequently**

```
Bad:  Commit once per week
Good: Commit multiple times per day

Why frequent commits?
- Smaller changesets
- Easier to review
- Faster to identify issues
- Reduces merge conflicts
```

**5. Fast Builds**

```
Build time targets:
- Ideal: < 10 minutes
- Acceptable: < 30 minutes
- Problem: > 1 hour

If builds are slow:
- Parallelize tests
- Cache dependencies
- Split into stages
- Use faster infrastructure
```

**6. Test in Production-Like Environment**

```
Development â†’ Staging â†’ Production
     â†“            â†“           â†“
  (similar)   (identical)  (production)

Avoid "works on my machine" syndrome
```

**7. Easy Access to Latest Build**

```
Everyone can:
- See latest build status
- Download latest build
- View test results
- Access build artifacts
```

**8. Visible Results**

```
Build status displayed prominently:
- Dashboard (big screen)
- Slack/Teams notifications
- Email alerts
- Build light (physical indicator)
```

---

### Benefits of CI

#### 1. Early Bug Detection

**Without CI:**

```
Week 1: Developer writes code with bug
Week 2: More code built on buggy foundation
Week 3: Another developer's code affected
Week 4: Bug discovered during testing
Week 5: Difficult, time-consuming fix
Week 6: Regression testing

Total cost: 6 weeks + frustrated team
```

**With CI:**

```
Hour 1: Developer commits code
Hour 1: CI runs, test fails
Hour 1: Developer notified immediately
Hour 2: Developer fixes bug
Hour 2: CI runs, test passes

Total cost: 1 hour
```

**Bug Cost Increases Over Time:**

```
Stage               Cost to Fix    Time to Fix
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
During coding       $1             1 hour
After commit        $10            5 hours
During testing      $100           2 days
In production       $1000+         1 week+
```

#### 2. Faster Feedback

```
Traditional (Manual Testing):
Code â†’ Wait days/weeks â†’ Test â†’ Feedback
Total: Days to weeks

CI (Automated Testing):
Code â†’ Wait minutes â†’ Test â†’ Feedback
Total: 5-15 minutes

Result: 100x faster iteration
```

#### 3. Reduced Integration Risk

```
Without CI:
â”œâ”€â”€ Long-lived branches
â”œâ”€â”€ Massive merge conflicts
â”œâ”€â”€ Integration hell
â””â”€â”€ "Big bang" integration

With CI:
â”œâ”€â”€ Trunk-based development
â”œâ”€â”€ Small, frequent merges
â”œâ”€â”€ Continuous integration
â””â”€â”€ Smooth, predictable releases
```

#### 4. Higher Code Quality

```
Automated checks on every commit:
â”œâ”€â”€ Code style (linting)
â”œâ”€â”€ Test coverage (>80%)
â”œâ”€â”€ Security vulnerabilities
â”œâ”€â”€ Performance regressions
â”œâ”€â”€ Documentation completeness
â””â”€â”€ Dependency updates

Impossible to maintain manually at scale
```

#### 5. Increased Confidence

```
Before release:
âœ“ 1000+ automated tests passed
âœ“ Code reviewed by peers
âœ“ Security scanned
âœ“ Performance validated
âœ“ Deployed to staging successfully

Developer confidence: High
Risk of production issues: Low
```

#### 6. Faster Time to Market

```
Traditional Release Cycle:
Development (2 weeks)
  â†’ Integration (1 week)
  â†’ Testing (1 week)
  â†’ Bug fixes (1 week)
  â†’ Release (1 day)
Total: 5 weeks

CI/CD Release Cycle:
Development (2 weeks)
  â†’ Continuous integration (automatic)
  â†’ Continuous testing (automatic)
  â†’ Continuous deployment (automatic)
Total: 2 weeks

60% faster to market!
```

---

### CI Best Practices

#### 1. Commit Often

```
âœ… Good Practice:
- Commit 5-10 times per day
- Small, focused changes
- Complete features in small increments
- Always leave code in working state

âŒ Bad Practice:
- Commit once per week
- Massive changesets
- Break build and leave it broken
- Commit incomplete work
```

**Example commit workflow:**

```bash
# Morning
git commit -m "Add user entity"
git push

# Mid-morning
git commit -m "Add user repository"
git push

# Before lunch
git commit -m "Add user service tests"
git push

# Afternoon
git commit -m "Implement user service"
git push

# End of day
git commit -m "Add user controller endpoint"
git push

Result: 5 small commits, all building successfully
```

#### 2. Don't Commit Broken Code

```
Before committing:
âœ“ Run tests locally
âœ“ Build succeeds
âœ“ No compilation errors
âœ“ No obvious bugs

If build is broken:
1. Fix immediately (highest priority)
2. Or revert the commit
3. Never leave build broken overnight
```

**Pre-commit checks:**

```bash
# .git/hooks/pre-commit
#!/bin/bash

echo "Running pre-commit checks..."

# Run tests
./gradlew test || exit 1

# Check code style
./gradlew checkstyle || exit 1

# Security scan
./gradlew dependencyCheckAnalyze || exit 1

echo "âœ“ All checks passed"
```

#### 3. Fix Broken Builds Immediately

```
Build Status: FAILED
Priority: DROP EVERYTHING

Steps:
1. Stop current work
2. Investigate failure
3. Fix or revert
4. Verify fix
5. Resume normal work

Time limit: < 10 minutes
```

**Build failure protocol:**

```
Build fails â†’ Notification sent
              â†“
         Developer alerted
              â†“
    Fix within 10 minutes
              â†“
         Or revert commit
              â†“
      Build green again

Team principle: Keep main branch always deployable
```

#### 4. Write Automated Tests

```
Test Pyramid:

         /\
        /  \      E2E Tests (few, slow)
       /â”€â”€â”€â”€\     
      /      \    Integration Tests (some, moderate)
     /â”€â”€â”€â”€â”€â”€â”€â”€\   
    /          \  Unit Tests (many, fast)
   /â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\

Target coverage:
- Unit tests: 80%+
- Integration tests: Critical paths
- E2E tests: User journeys
```

**Test categories:**

```java
// Unit Test (fast)
@Test
public void shouldCalculateTotal() {
    OrderService service = new OrderService();
    assertEquals(100.0, service.calculateTotal(items));
}

// Integration Test (moderate)
@Test
@SpringBootTest
public void shouldCreateOrder() {
    Order order = orderService.create(orderDto);
    assertNotNull(orderRepository.findById(order.getId()));
}

// E2E Test (slow)
@Test
public void userCanCheckout() {
    driver.get("/products");
    driver.findElement(By.id("add-to-cart")).click();
    driver.findElement(By.id("checkout")).click();
    assertTrue(driver.getCurrentUrl().contains("/order-confirmation"));
}
```

#### 5. Keep Builds Fast

```
Build time optimization:

Stage 1: Compile (1 min)
Stage 2: Unit Tests (2 min)
Stage 3: Integration Tests (5 min)
Stage 4: Code Quality (2 min)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Total: 10 minutes âœ“

If slower:
- Run stages in parallel
- Cache dependencies
- Incremental builds
- Faster hardware
- Split test suites
```

**Parallel execution:**

```yaml
# .github/workflows/ci.yml
jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - run: ./gradlew test
  
  integration-tests:
    runs-on: ubuntu-latest
    steps:
      - run: ./gradlew integrationTest
  
  security-scan:
    runs-on: ubuntu-latest
    steps:
      - run: ./gradlew dependencyCheck

# All run in parallel (3x faster!)
```

#### 6. Test in Clone of Production

```
Environment Parity:

Production Environment:
â”œâ”€â”€ OS: Ubuntu 22.04
â”œâ”€â”€ Java: 17
â”œâ”€â”€ PostgreSQL: 15
â”œâ”€â”€ Redis: 7
â””â”€â”€ Nginx: 1.24

CI Environment (should match):
â”œâ”€â”€ OS: Ubuntu 22.04 âœ“
â”œâ”€â”€ Java: 17 âœ“
â”œâ”€â”€ PostgreSQL: 15 âœ“
â”œâ”€â”€ Redis: 7 âœ“
â””â”€â”€ Nginx: 1.24 âœ“
```

**Docker for consistency:**

```yaml
# docker-compose.ci.yml
version: '3.8'
services:
  app:
    build: .
    depends_on:
      - postgres
      - redis
  
  postgres:
    image: postgres:15
    environment:
      POSTGRES_PASSWORD: test
  
  redis:
    image: redis:7
```

#### 7. Make Results Visible

```
Build Status Dashboard:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Project         Status    Time   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  âœ“ backend       PASSED    8m     â”‚
â”‚  âœ— frontend      FAILED    5m     â”‚
â”‚  âœ“ mobile-app    PASSED    12m    â”‚
â”‚  âš  api-gateway   UNSTABLE  10m    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Notifications:
- Slack: #build-status channel
- Email: developers@company.com
- Dashboard: https://ci.company.com
```

#### 8. Automate Deployment

```
Successful build â†’ Automatic deployment

Development:
Build passes â†’ Deploy to dev (automatic)

Staging:
Build passes â†’ Deploy to staging (automatic)

Production:
Build passes â†’ Deploy to prod (manual approval)
           or â†’ Deploy to prod (automatic, with safeguards)
```

---

### CI Workflow Example

```
Developer Workflow:

1. Pull latest code
   git pull origin main

2. Create feature branch (optional)
   git checkout -b feature/add-user-api

3. Write code + tests
   [Development]

4. Run tests locally
   ./gradlew test

5. Commit + push
   git commit -m "Add user API endpoint"
   git push origin feature/add-user-api

6. CI pipeline triggered automatically
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚  Checkout code              â”‚
   â”‚  â†“                          â”‚
   â”‚  Install dependencies       â”‚
   â”‚  â†“                          â”‚
   â”‚  Compile                    â”‚
   â”‚  â†“                          â”‚
   â”‚  Run unit tests             â”‚
   â”‚  â†“                          â”‚
   â”‚  Run integration tests      â”‚
   â”‚  â†“                          â”‚
   â”‚  Code quality checks        â”‚
   â”‚  â†“                          â”‚
   â”‚  Security scan              â”‚
   â”‚  â†“                          â”‚
   â”‚  Build artifacts            â”‚
   â”‚  â†“                          â”‚
   â”‚  Deploy to dev              â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

7. Receive notification
   âœ“ Build #123 passed in 8 minutes

8. Create pull request
   Code review by peers

9. Merge to main
   Another CI build runs

10. Automatic deployment
    Dev â†’ Staging â†’ Production
```

---

## 2. Continuous Delivery vs Deployment

### Continuous Delivery (CD)

**Definition:** Keeping code in a deployable state at all times, ready for manual deployment to production.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      CONTINUOUS DELIVERY                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                            â”‚
â”‚  Code â†’ Build â†’ Test â†’ Staging            â”‚
â”‚                          â†“                 â”‚
â”‚                    [Manual Gate]           â”‚
â”‚                          â†“                 â”‚
â”‚                      Production            â”‚
â”‚                                            â”‚
â”‚  Key: Manual approval before production    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Characteristics:**

- âœ… Automated pipeline to staging
- âœ… Always ready to deploy
- âœ… Manual production deployment
- âœ… Business decides when to release
- âœ… Lower risk (human oversight)

**When to use:**

- Regulated industries (finance, healthcare)
- Mission-critical systems
- Need for scheduled releases
- Compliance requirements

---

### Continuous Deployment (CD)

**Definition:** Automatically deploying every change that passes tests to production.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      CONTINUOUS DEPLOYMENT                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                            â”‚
â”‚  Code â†’ Build â†’ Test â†’ Staging â†’ Prod     â”‚
â”‚                    â†“        â†“       â†“     â”‚
â”‚               [Automatic][Automatic][Auto] â”‚
â”‚                                            â”‚
â”‚  Key: Fully automated, no manual gates     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Characteristics:**

- âœ… Fully automated pipeline
- âœ… Deploy to production automatically
- âœ… Multiple deployments per day
- âœ… Fast feedback from users
- âœ… Requires excellent test coverage

**When to use:**

- SaaS applications
- Internal tools
- Mature DevOps organizations
- High-quality automated tests

---

### Continuous Delivery vs Deployment

|Aspect|Continuous Delivery|Continuous Deployment|
|---|---|---|
|**Automation**|To staging|To production|
|**Production Deploy**|Manual|Automatic|
|**Frequency**|When business decides|Multiple times daily|
|**Risk**|Lower (human check)|Higher (automated)|
|**Speed**|Moderate|Very fast|
|**Requirements**|Good tests|Excellent tests|
|**Best for**|Regulated industries|SaaS, internal tools|

**Visual Comparison:**

```
Continuous Delivery:
Commit â†’ CI â†’ Staging â†’ [ğŸ‘¤ Human] â†’ Production
                         â†‘
                    Manual approval

Continuous Deployment:
Commit â†’ CI â†’ Staging â†’ [ğŸ¤– Auto] â†’ Production
                         â†‘
                    Automatic if tests pass
```

---

### Deployment Strategies

#### 1. Blue-Green Deployment

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  BLUE-GREEN DEPLOYMENT               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                      â”‚
â”‚  Before:                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                         â”‚
â”‚  â”‚  Blue   â”‚ â† 100% traffic          â”‚
â”‚  â”‚  (v1.0) â”‚                         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                         â”‚
â”‚                                      â”‚
â”‚  During:                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  Blue   â”‚   â”‚  Green  â”‚          â”‚
â”‚  â”‚  (v1.0) â”‚   â”‚  (v2.0) â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚       â†‘             â†‘               â”‚
â”‚   100% traffic    Testing           â”‚
â”‚                                      â”‚
â”‚  After (instant switch):             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  Blue   â”‚   â”‚  Green  â”‚          â”‚
â”‚  â”‚  (v1.0) â”‚   â”‚  (v2.0) â”‚ â† 100%   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚      Standby                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Pros:
âœ“ Zero downtime
âœ“ Instant rollback
âœ“ Test in production environment
âœ“ Full version switchover

Cons:
âœ— 2x infrastructure cost
âœ— Database migrations tricky
âœ— Need router/load balancer support
```

#### 2. Canary Deployment

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CANARY DEPLOYMENT                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                      â”‚
â”‚  Phase 1: Initial (5% traffic)       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  v1.0   â”‚   â”‚  v2.0   â”‚          â”‚
â”‚  â”‚  95%    â”‚   â”‚   5%    â”‚ â† Canary â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                      â”‚
â”‚  Phase 2: Expand (50% traffic)       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  v1.0   â”‚   â”‚  v2.0   â”‚          â”‚
â”‚  â”‚  50%    â”‚   â”‚  50%    â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                      â”‚
â”‚  Phase 3: Complete (100% traffic)    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                         â”‚
â”‚  â”‚  v2.0   â”‚                         â”‚
â”‚  â”‚  100%   â”‚                         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Pros:
âœ“ Gradual rollout
âœ“ Real user validation
âœ“ Low blast radius
âœ“ Data-driven decisions

Cons:
âœ— Complex monitoring
âœ— Longer deployment time
âœ— Version compatibility needed
```

#### 3. Rolling Deployment

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ROLLING DEPLOYMENT (Kubernetes)     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                      â”‚
â”‚  Step 1: 3 pods v1.0                 â”‚
â”‚  [v1.0] [v1.0] [v1.0]                â”‚
â”‚                                      â”‚
â”‚  Step 2: Create 1 new, kill 1 old    â”‚
â”‚  [v1.0] [v1.0] [v2.0]                â”‚
â”‚                                      â”‚
â”‚  Step 3: Create 1 new, kill 1 old    â”‚
â”‚  [v1.0] [v2.0] [v2.0]                â”‚
â”‚                                      â”‚
â”‚  Step 4: Create 1 new, kill 1 old    â”‚
â”‚  [v2.0] [v2.0] [v2.0]                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Pros:
âœ“ Zero downtime
âœ“ No extra infrastructure
âœ“ Automatic in Kubernetes
âœ“ Gradual replacement

Cons:
âœ— Mixed versions during rollout
âœ— Rollback slower than blue-green
âœ— Requires version compatibility
```

#### 4. Recreate Deployment

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  RECREATE DEPLOYMENT                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                      â”‚
â”‚  Step 1: All pods v1.0               â”‚
â”‚  [v1.0] [v1.0] [v1.0]                â”‚
â”‚                                      â”‚
â”‚  Step 2: Kill all                    â”‚
â”‚  [    ] [    ] [    ] â† DOWNTIME     â”‚
â”‚                                      â”‚
â”‚  Step 3: Create all new              â”‚
â”‚  [v2.0] [v2.0] [v2.0]                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Pros:
âœ“ Simple
âœ“ No version compatibility issues
âœ“ Clean slate

Cons:
âœ— Downtime!
âœ— All-or-nothing
âœ— Not suitable for production
```

---

### Release Management

#### Release Types

**1. Feature Release**

```
Version: 1.0.0 â†’ 1.1.0
Content: New features
Frequency: Monthly/Quarterly
Testing: Comprehensive
Approval: Product + Engineering
```

**2. Hotfix Release**

```
Version: 1.0.0 â†’ 1.0.1
Content: Critical bug fix
Frequency: As needed
Testing: Targeted
Approval: Engineering (fast-tracked)
```

**3. Patch Release**

```
Version: 1.0.0 â†’ 1.0.1
Content: Bug fixes
Frequency: Weekly/Bi-weekly
Testing: Full regression
Approval: Engineering
```

#### Release Process

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  RELEASE MANAGEMENT PROCESS        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                    â”‚
â”‚  1. Planning                       â”‚
â”‚     - Define scope                 â”‚
â”‚     - Set timeline                 â”‚
â”‚     - Assign owners                â”‚
â”‚     â†“                              â”‚
â”‚  2. Development                    â”‚
â”‚     - Feature development          â”‚
â”‚     - Code reviews                 â”‚
â”‚     - Unit testing                 â”‚
â”‚     â†“                              â”‚
â”‚  3. Integration                    â”‚
â”‚     - Merge to release branch      â”‚
â”‚     - Integration testing          â”‚
â”‚     - Performance testing          â”‚
â”‚     â†“                              â”‚
â”‚  4. Staging                        â”‚
â”‚     - Deploy to staging            â”‚
â”‚     - QA testing                   â”‚
â”‚     - UAT (User Acceptance)        â”‚
â”‚     â†“                              â”‚
â”‚  5. Production Readiness           â”‚
â”‚     - Final review                 â”‚
â”‚     - Approval gate                â”‚
â”‚     - Communication plan           â”‚
â”‚     â†“                              â”‚
â”‚  6. Deployment                     â”‚
â”‚     - Production deployment        â”‚
â”‚     - Monitoring                   â”‚
â”‚     - Smoke tests                  â”‚
â”‚     â†“                              â”‚
â”‚  7. Post-Release                   â”‚
â”‚     - Monitor metrics              â”‚
â”‚     - Gather feedback              â”‚
â”‚     - Document learnings           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Release Checklist

```markdown
## Pre-Release Checklist

### Code Quality
- [ ] All tests passing
- [ ] Code coverage > 80%
- [ ] No critical security vulnerabilities
- [ ] Performance benchmarks met
- [ ] Database migrations tested

### Documentation
- [ ] Release notes written
- [ ] API documentation updated
- [ ] User guide updated
- [ ] Runbooks updated

### Infrastructure
- [ ] Scaling plan ready
- [ ] Monitoring alerts configured
- [ ] Rollback plan documented
- [ ] Database backups verified

### Communication
- [ ] Stakeholders notified
- [ ] Support team briefed
- [ ] Customers informed
- [ ] Maintenance window scheduled

### Testing
- [ ] Unit tests: 100% passed
- [ ] Integration tests: 100% passed
- [ ] E2E tests: 100% passed
- [ ] Performance tests: Passed
- [ ] Security scan: Passed
- [ ] UAT: Approved

### Approval
- [ ] Engineering lead: âœ“
- [ ] Product manager: âœ“
- [ ] QA lead: âœ“
- [ ] Security team: âœ“
```

---

## 3. CI/CD Pipelines

### Pipeline Stages

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              CI/CD PIPELINE                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                 â”‚
â”‚  Source â†’ Build â†’ Test â†’ Package â†’ Deploy      â”‚
â”‚                                                 â”‚
â”‚  Stage 1: SOURCE                                â”‚
â”‚  â”œâ”€â”€ Checkout code from Git                    â”‚
â”‚  â”œâ”€â”€ Download dependencies                     â”‚
â”‚  â””â”€â”€ Setup environment                         â”‚
â”‚                                                 â”‚
â”‚  Stage 2: BUILD                                 â”‚
â”‚  â”œâ”€â”€ Compile source code                       â”‚
â”‚  â”œâ”€â”€ Generate artifacts                        â”‚
â”‚  â””â”€â”€ Create Docker image                       â”‚
â”‚                                                 â”‚
â”‚  Stage 3: TEST                                  â”‚
â”‚  â”œâ”€â”€ Unit tests (fast)                         â”‚
â”‚  â”œâ”€â”€ Integration tests (moderate)              â”‚
â”‚  â”œâ”€â”€ E2E tests (slow)                          â”‚
â”‚  â”œâ”€â”€ Security scan                             â”‚
â”‚  â””â”€â”€ Code quality analysis                     â”‚
â”‚                                                 â”‚
â”‚  Stage 4: PACKAGE                               â”‚
â”‚  â”œâ”€â”€ Build final artifact                      â”‚
â”‚  â”œâ”€â”€ Tag Docker image                          â”‚
â”‚  â””â”€â”€ Push to registry                          â”‚
â”‚                                                 â”‚
â”‚  Stage 5: DEPLOY                                â”‚
â”‚  â”œâ”€â”€ Deploy to dev (automatic)                 â”‚
â”‚  â”œâ”€â”€ Deploy to staging (automatic)             â”‚
â”‚  â””â”€â”€ Deploy to prod (manual/automatic)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Stage 1: Build

```bash
# Build stage responsibilities:
1. Checkout source code
2. Resolve dependencies
3. Compile code
4. Create binaries/artifacts

Example (Java):
./gradlew clean build

Example (Node.js):
npm ci
npm run build

Example (Go):
go build -o app

Output: Compiled application ready for testing
```

#### Stage 2: Test

```bash
# Test stage (pyramid approach):

Level 1: Unit Tests (70%)
- Fast (seconds)
- Isolated
- No external dependencies
./gradlew test

Level 2: Integration Tests (20%)
- Moderate speed (minutes)
- Test component interactions
- Database, APIs, services
./gradlew integrationTest

Level 3: E2E Tests (10%)
- Slow (minutes to hours)
- Full user workflows
- Browser automation
./gradlew e2eTest

Additional:
- Code coverage report
- Security vulnerability scan
- Code quality analysis (SonarQube)
```

#### Stage 3: Deploy

```bash
# Deployment stage:

Environment: Development
- Automatic deployment
- Every successful build
- Used for testing

Environment: Staging
- Automatic deployment
- After passing all tests
- Production-like environment

Environment: Production
- Manual approval (CD) OR
- Automatic (CD)
- After validation in staging
```

---

### Artifacts

**Build artifacts** are the outputs of your build process.

```
Types of Artifacts:

1. Compiled Binaries
   - .jar (Java)
   - .war (Java Web)
   - .exe (Windows)
   - Binary executables

2. Container Images
   - Docker images
   - OCI images
   - Tagged versions

3. Package Files
   - .deb (Debian)
   - .rpm (RedHat)
   - .zip/.tar.gz (Archives)

4. Web Assets
   - Minified JavaScript
   - Compiled CSS
   - Optimized images

5. Documentation
   - API docs
   - User guides
   - Release notes

6. Test Reports
   - Coverage reports
   - Test results
   - Performance metrics
```

**Artifact Management:**

```
1. Versioning
   myapp-1.2.3.jar
   myapp:1.2.3 (Docker)

2. Storage
   - Artifact repository (Nexus, Artifactory)
   - Container registry (Docker Hub, Harbor)
   - Cloud storage (S3, GCS)

3. Retention
   - Keep releases: Forever
   - Keep snapshots: 30 days
   - Keep PR builds: 7 days

4. Traceability
   - Link to commit SHA
   - Link to build number
   - Link to test results
```

---

### Pipeline as Code

**Benefits:**

- âœ… Version controlled
- âœ… Code reviewable
- âœ… Reusable
- âœ… Testable
- âœ… Reproducible

**Example: GitHub Actions**

```yaml
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
      
      - name: Build with Gradle
        run: ./gradlew build
      
      - name: Upload artifact
        uses: actions/upload-artifact@v3
        with:
          name: app-jar
          path: build/libs/*.jar

  test:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - uses: actions/checkout@v3
      
      - name: Run tests
        run: ./gradlew test
      
      - name: Publish test results
        uses: dorny/test-reporter@v1
        if: always()
        with:
          name: Test Results
          path: build/test-results/**/*.xml
          reporter: java-junit

  deploy-staging:
    runs-on: ubuntu-latest
    needs: [build, test]
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Deploy to staging
        run: |
          kubectl set image deployment/myapp \
            myapp=myapp:${{ github.sha }} \
            -n staging

  deploy-production:
    runs-on: ubuntu-latest
    needs: deploy-staging
    if: github.ref == 'refs/heads/main'
    environment: production
    steps:
      - name: Deploy to production
        run: |
          kubectl set image deployment/myapp \
            myapp=myapp:${{ github.sha }} \
            -n production
```

---

## Summary

### Continuous Integration

- âœ… **Definition**: Frequent code integration with automated builds/tests
- âœ… **Benefits**: Early bug detection, faster feedback, reduced risk
- âœ… **Best Practices**:
    - Commit often (5-10x daily)
    - Fix broken builds immediately
    - Keep builds fast (<10 minutes)
    - Test in production-like environment

### Continuous Delivery vs Deployment

- **Continuous Delivery**: Manual production deployment
- **Continuous Deployment**: Automatic production deployment
- **Deployment Strategies**:
    - Blue-Green: Instant switchover
    - Canary: Gradual rollout
    - Rolling: Sequential replacement
    - Recreate: All-or-nothing

### CI/CD Pipelines

- **Stages**: Source â†’ Build â†’ Test â†’ Package â†’ Deploy
- **Artifacts**: Versioned, stored, traceable outputs
- **Pipeline as Code**: Version-controlled, reviewable, reusable

### Key Metrics

- Build time: < 10 minutes
- Test coverage: > 80%
- Deployment frequency: Multiple times daily
- Lead time: Hours, not weeks
- Change failure rate: < 15%
- Mean time to recovery: < 1 hour
