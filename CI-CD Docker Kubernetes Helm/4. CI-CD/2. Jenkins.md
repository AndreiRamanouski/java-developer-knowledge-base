
## 1. Jenkins Architecture

### Master/Agent Architecture

```
┌─────────────────────────────────────────────────┐
│           JENKINS ARCHITECTURE                  │
├─────────────────────────────────────────────────┤
│                                                 │
│              ┌──────────────┐                   │
│              │   Jenkins    │                   │
│              │   Master     │                   │
│              │              │                   │
│              │ - Scheduling │                   │
│              │ - Monitoring │                   │
│              │ - UI         │                   │
│              │ - Config     │                   │
│              └──────┬───────┘                   │
│                     │                           │
│        ┌────────────┼────────────┐             │
│        │            │            │             │
│        ▼            ▼            ▼             │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐          │
│  │ Agent 1 │ │ Agent 2 │ │ Agent 3 │          │
│  │ Linux   │ │ Windows │ │ Docker  │          │
│  │         │ │         │ │         │          │
│  │ Execute │ │ Execute │ │ Execute │          │
│  │  Jobs   │ │  Jobs   │ │  Jobs   │          │
│  └─────────┘ └─────────┘ └─────────┘          │
│                                                 │
└─────────────────────────────────────────────────┘
```

**Master Node Responsibilities:**

- Schedule build jobs
- Dispatch builds to agents
- Monitor agent status
- Record and present build results
- Serve Jenkins UI
- Manage configuration
- Plugin management

**Agent Node Responsibilities:**

- Execute builds
- Report results to master
- Provide build environment
- Isolated execution

**Communication:**

```
Master ←→ Agent (JNLP/SSH)
- Master initiates connection
- Encrypted communication
- Bidirectional data flow
- Real-time status updates
```

---

### Executors and Nodes

**Node:** Physical or virtual machine that runs builds

**Executor:** Slot on a node that can run one build

```
┌────────────────────────────────────┐
│  NODE CONFIGURATION                │
├────────────────────────────────────┤
│                                    │
│  Master Node                       │
│  ├── Executor 1 [Running Job #45] │
│  ├── Executor 2 [Running Job #46] │
│  └── Executor 3 [Idle]             │
│                                    │
│  Agent Node 1 (Linux)              │
│  ├── Executor 1 [Running Job #47] │
│  ├── Executor 2 [Running Job #48] │
│  ├── Executor 3 [Idle]             │
│  └── Executor 4 [Idle]             │
│                                    │
│  Agent Node 2 (Windows)            │
│  ├── Executor 1 [Running Job #49] │
│  └── Executor 2 [In Queue]         │
└────────────────────────────────────┘
```

**Executor Configuration:**

```groovy
// Set number of executors on node
// Typically: Number of CPU cores
Master: 2 executors (light workload)
Agent: 4 executors (heavy workload)

// Best practice:
Executors = CPU cores (for CPU-bound)
Executors = 2x CPU cores (for I/O-bound)
```

**Node Labels:**

```
Agent 1: [linux, docker, java17, maven]
Agent 2: [windows, dotnet, msbuild]
Agent 3: [linux, nodejs, docker, k8s]

Pipeline uses labels to select nodes:
agent { label 'linux && docker' }
```

---

### Distributed Builds

**Why Distributed Builds?**

- ✅ Parallel execution (faster builds)
- ✅ Different environments (OS, tools)
- ✅ Resource isolation
- ✅ Scalability

**Setup Methods:**

**1. SSH Agents (Permanent)**

```
Master → SSH → Agent (always running)

Configuration:
- SSH credentials
- Java path on agent
- Number of executors
- Node labels
```

**2. JNLP Agents (Java Web Start)**

```
Agent → JNLP → Master (agent-initiated)

Configuration:
- Download agent.jar from master
- Run: java -jar agent.jar -jnlpUrl <url>
- Agent connects to master
```

**3. Docker Agents (Dynamic)**

```
Master → Docker → Container (on-demand)

Configuration:
- Docker plugin
- Spin up containers as needed
- Terminate after build
- Cost-effective
```

**4. Kubernetes Agents (Dynamic)**

```
Master → Kubernetes → Pod (on-demand)

Configuration:
- Kubernetes plugin
- Dynamic pod creation
- Auto-scaling
- Cloud-native
```

**Example: Distributed Build Flow**

```
Build Triggered
    ↓
Master schedules build
    ↓
Checks available agents with label 'docker'
    ↓
Agent 3 (docker) selected
    ↓
Build executes on Agent 3
    ↓
Results sent to Master
    ↓
Build complete
```

---

## 2. Jenkins Pipelines

### Declarative vs Scripted

**Declarative Pipeline (Recommended)**

```groovy
// Jenkinsfile (Declarative)
pipeline {
    agent any
    
    stages {
        stage('Build') {
            steps {
                echo 'Building...'
                sh './gradlew build'
            }
        }
        
        stage('Test') {
            steps {
                echo 'Testing...'
                sh './gradlew test'
            }
        }
        
        stage('Deploy') {
            steps {
                echo 'Deploying...'
                sh './deploy.sh'
            }
        }
    }
}

// Characteristics:
// ✓ Structured, easy to read
// ✓ Better validation
// ✓ Built-in sections
// ✓ Recommended for most cases
```

**Scripted Pipeline (Advanced)**

```groovy
// Jenkinsfile (Scripted)
node {
    stage('Build') {
        echo 'Building...'
        sh './gradlew build'
    }
    
    stage('Test') {
        echo 'Testing...'
        sh './gradlew test'
    }
    
    stage('Deploy') {
        echo 'Deploying...'
        sh './deploy.sh'
    }
}

// Characteristics:
// ✓ More flexible (full Groovy)
// ✓ Complex logic easier
// ✓ Harder to read
// ✓ Use for advanced scenarios
```

**Comparison:**

|Feature|Declarative|Scripted|
|---|---|---|
|**Syntax**|Structured|Groovy|
|**Readability**|High|Medium|
|**Flexibility**|Limited|Full|
|**Validation**|Built-in|Manual|
|**Best for**|Most cases|Complex logic|

---

### Jenkinsfile (Pipeline as Code)

**Complete Jenkinsfile Example:**

```groovy
// Jenkinsfile
pipeline {
    // Define where to run
    agent {
        label 'docker'
    }
    
    // Environment variables
    environment {
        DOCKER_REGISTRY = 'docker.io'
        DOCKER_IMAGE = 'mycompany/myapp'
        MAVEN_OPTS = '-Xmx1024m'
    }
    
    // Parameters
    parameters {
        string(name: 'VERSION', defaultValue: '1.0.0', description: 'Version to build')
        choice(name: 'ENVIRONMENT', choices: ['dev', 'staging', 'prod'], description: 'Target environment')
        booleanParam(name: 'RUN_TESTS', defaultValue: true, description: 'Run tests?')
    }
    
    // Build options
    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timeout(time: 1, unit: 'HOURS')
        timestamps()
        disableConcurrentBuilds()
    }
    
    // Triggers
    triggers {
        cron('H 2 * * *')  // Daily at 2 AM
        pollSCM('H/5 * * * *')  // Poll every 5 minutes
    }
    
    // Stages
    stages {
        stage('Checkout') {
            steps {
                checkout scm
                sh 'git rev-parse HEAD > commit-id.txt'
            }
        }
        
        stage('Build') {
            steps {
                echo "Building version ${params.VERSION}"
                sh './gradlew clean build -Pversion=${params.VERSION}'
            }
        }
        
        stage('Test') {
            when {
                expression { params.RUN_TESTS == true }
            }
            steps {
                sh './gradlew test'
            }
            post {
                always {
                    junit 'build/test-results/**/*.xml'
                }
            }
        }
        
        stage('Docker Build') {
            steps {
                script {
                    docker.build("${DOCKER_IMAGE}:${params.VERSION}")
                }
            }
        }
        
        stage('Deploy') {
            when {
                branch 'main'
            }
            steps {
                sh './deploy.sh ${params.ENVIRONMENT}'
            }
        }
    }
    
    // Post-build actions
    post {
        success {
            echo 'Build succeeded!'
            slackSend(color: 'good', message: "Build succeeded: ${env.JOB_NAME} ${env.BUILD_NUMBER}")
        }
        failure {
            echo 'Build failed!'
            slackSend(color: 'danger', message: "Build failed: ${env.JOB_NAME} ${env.BUILD_NUMBER}")
        }
        always {
            cleanWs()
        }
    }
}
```

---

### Stages, Steps, Agents

**Stages:** Major phases of pipeline

```groovy
stages {
    stage('Build') {
        // Build phase
    }
    stage('Test') {
        // Test phase
    }
    stage('Deploy') {
        // Deploy phase
    }
}
```

**Steps:** Individual tasks within stage

```groovy
stage('Build') {
    steps {
        sh 'mvn clean'        // Step 1
        sh 'mvn compile'      // Step 2
        sh 'mvn package'      // Step 3
    }
}
```

**Agents:** Where to execute

```groovy
// Global agent (all stages)
pipeline {
    agent any
    stages { ... }
}

// Per-stage agent
pipeline {
    agent none
    stages {
        stage('Build') {
            agent { label 'linux' }
            steps { ... }
        }
        stage('Windows Tests') {
            agent { label 'windows' }
            steps { ... }
        }
    }
}

// Docker agent
stage('Build') {
    agent {
        docker {
            image 'maven:3.8-openjdk-17'
            args '-v $HOME/.m2:/root/.m2'
        }
    }
    steps {
        sh 'mvn clean package'
    }
}
```

---

### Parallel Execution

```groovy
pipeline {
    agent any
    
    stages {
        stage('Parallel Tests') {
            parallel {
                stage('Unit Tests') {
                    steps {
                        sh './gradlew test'
                    }
                }
                
                stage('Integration Tests') {
                    steps {
                        sh './gradlew integrationTest'
                    }
                }
                
                stage('E2E Tests') {
                    steps {
                        sh './gradlew e2eTest'
                    }
                }
            }
        }
    }
}

// Result: All three test suites run simultaneously
// Time: 5 minutes instead of 15 minutes
```

**Parallel with Different Agents:**

```groovy
stage('Cross-Platform Build') {
    parallel {
        stage('Linux Build') {
            agent { label 'linux' }
            steps {
                sh './build-linux.sh'
            }
        }
        
        stage('Windows Build') {
            agent { label 'windows' }
            steps {
                bat 'build-windows.bat'
            }
        }
        
        stage('Mac Build') {
            agent { label 'mac' }
            steps {
                sh './build-mac.sh'
            }
        }
    }
}
```

---

### When Conditions

```groovy
pipeline {
    agent any
    
    stages {
        stage('Deploy to Dev') {
            when {
                branch 'develop'
            }
            steps {
                sh './deploy.sh dev'
            }
        }
        
        stage('Deploy to Staging') {
            when {
                branch 'main'
            }
            steps {
                sh './deploy.sh staging'
            }
        }
        
        stage('Deploy to Production') {
            when {
                allOf {
                    branch 'main'
                    tag pattern: "v\\d+\\.\\d+\\.\\d+", comparator: "REGEXP"
                }
            }
            steps {
                input message: 'Deploy to production?'
                sh './deploy.sh production'
            }
        }
        
        stage('Nightly Build') {
            when {
                triggeredBy 'TimerTrigger'
            }
            steps {
                sh './nightly-tasks.sh'
            }
        }
        
        stage('PR Validation') {
            when {
                changeRequest()
            }
            steps {
                sh './validate-pr.sh'
            }
        }
    }
}
```

**When Conditions Reference:**

```groovy
// Branch conditions
when { branch 'main' }
when { not { branch 'main' } }
when { anyOf { branch 'main'; branch 'develop' } }

// Environment conditions
when { environment name: 'DEPLOY_TO', value: 'production' }

// Expression conditions
when { expression { return params.RUN_TESTS == true } }

// Tag conditions
when { tag "v*" }

// Trigger conditions
when { triggeredBy 'SCMTrigger' }
when { triggeredBy 'TimerTrigger' }

// Change request (PR)
when { changeRequest() }
when { changeRequest target: 'main' }

// Combined conditions
when {
    allOf {
        branch 'main'
        environment name: 'DEPLOY_ENV', value: 'prod'
    }
}
```

---

## 3. Jenkins for Java Projects

### Complete Java Pipeline

```groovy
// Jenkinsfile for Spring Boot application
pipeline {
    agent {
        docker {
            image 'maven:3.8-openjdk-17'
            args '-v $HOME/.m2:/root/.m2'
        }
    }
    
    environment {
        SONAR_TOKEN = credentials('sonar-token')
        DOCKER_REGISTRY = 'docker.io'
        DOCKER_IMAGE = 'mycompany/spring-app'
    }
    
    parameters {
        string(name: 'MAVEN_OPTS', defaultValue: '-Xmx1024m', description: 'Maven JVM options')
        booleanParam(name: 'SKIP_TESTS', defaultValue: false, description: 'Skip tests')
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
                script {
                    env.GIT_COMMIT_SHORT = sh(
                        script: "git rev-parse --short HEAD",
                        returnStdout: true
                    ).trim()
                }
            }
        }
        
        stage('Build') {
            steps {
                sh '''
                    mvn clean compile \
                        -DskipTests=${params.SKIP_TESTS} \
                        -Dmaven.test.skip=${params.SKIP_TESTS}
                '''
            }
        }
        
        stage('Unit Tests') {
            when {
                expression { params.SKIP_TESTS == false }
            }
            steps {
                sh 'mvn test'
            }
            post {
                always {
                    // Publish JUnit test results
                    junit 'target/surefire-reports/**/*.xml'
                }
            }
        }
        
        stage('Integration Tests') {
            when {
                expression { params.SKIP_TESTS == false }
            }
            steps {
                sh 'mvn verify -DskipUnitTests'
            }
            post {
                always {
                    junit 'target/failsafe-reports/**/*.xml'
                }
            }
        }
        
        stage('Code Coverage') {
            steps {
                sh 'mvn jacoco:report'
            }
            post {
                always {
                    // Publish JaCoCo coverage report
                    jacoco(
                        execPattern: 'target/jacoco.exec',
                        classPattern: 'target/classes',
                        sourcePattern: 'src/main/java'
                    )
                }
            }
        }
        
        stage('SonarQube Analysis') {
            steps {
                sh '''
                    mvn sonar:sonar \
                        -Dsonar.projectKey=my-project \
                        -Dsonar.host.url=https://sonar.example.com \
                        -Dsonar.login=${SONAR_TOKEN}
                '''
            }
        }
        
        stage('Quality Gate') {
            steps {
                timeout(time: 5, unit: 'MINUTES') {
                    waitForQualityGate abortPipeline: true
                }
            }
        }
        
        stage('Package') {
            steps {
                sh 'mvn package -DskipTests'
            }
            post {
                success {
                    archiveArtifacts artifacts: 'target/*.jar', fingerprint: true
                }
            }
        }
        
        stage('Docker Build') {
            steps {
                script {
                    def imageTag = "${env.DOCKER_IMAGE}:${env.GIT_COMMIT_SHORT}"
                    def latestTag = "${env.DOCKER_IMAGE}:latest"
                    
                    docker.build(imageTag)
                    docker.image(imageTag).tag(latestTag)
                }
            }
        }
        
        stage('Docker Push') {
            when {
                branch 'main'
            }
            steps {
                script {
                    docker.withRegistry("https://${env.DOCKER_REGISTRY}", 'docker-credentials') {
                        docker.image("${env.DOCKER_IMAGE}:${env.GIT_COMMIT_SHORT}").push()
                        docker.image("${env.DOCKER_IMAGE}:latest").push()
                    }
                }
            }
        }
        
        stage('Deploy to Dev') {
            when {
                branch 'develop'
            }
            steps {
                sh './deploy.sh dev'
            }
        }
        
        stage('Deploy to Prod') {
            when {
                branch 'main'
            }
            steps {
                input message: 'Deploy to production?'
                sh './deploy.sh prod'
            }
        }
    }
    
    post {
        always {
            cleanWs()
        }
        success {
            slackSend(
                color: 'good',
                message: "✓ Build succeeded: ${env.JOB_NAME} #${env.BUILD_NUMBER}"
            )
        }
        failure {
            slackSend(
                color: 'danger',
                message: "✗ Build failed: ${env.JOB_NAME} #${env.BUILD_NUMBER}"
            )
        }
    }
}
```

---

### Maven/Gradle Integration

**Maven Configuration:**

```groovy
// Maven build
sh 'mvn clean install'

// With profiles
sh 'mvn clean install -Pproduction'

// Skip tests
sh 'mvn clean install -DskipTests'

// Custom settings
sh 'mvn clean install -s settings.xml'

// Deploy artifacts
sh 'mvn deploy'

// Release
sh 'mvn release:prepare release:perform'
```

**Gradle Configuration:**

```groovy
// Gradle build
sh './gradlew clean build'

// With profiles
sh './gradlew clean build -Pproduction'

// Skip tests
sh './gradlew clean build -x test'

// Publish
sh './gradlew publish'

// With Gradle wrapper verification
sh '''
    ./gradlew wrapper --gradle-version=8.4
    ./gradlew clean build
'''
```

---

### JUnit Test Reports

```groovy
stage('Test') {
    steps {
        sh './gradlew test'
    }
    post {
        always {
            // Publish JUnit test results
            junit(
                testResults: 'build/test-results/**/*.xml',
                allowEmptyResults: true,
                healthScaleFactor: 1.0
            )
            
            // Or for Maven
            junit 'target/surefire-reports/**/*.xml'
        }
    }
}

// Jenkins will display:
// - Test trend graph
// - Pass/fail statistics
// - Test duration
// - Failed test details
```

---

### Code Coverage (JaCoCo)

```groovy
stage('Code Coverage') {
    steps {
        // Generate JaCoCo report
        sh './gradlew jacocoTestReport'
    }
    post {
        always {
            // Publish coverage report
            jacoco(
                execPattern: 'build/jacoco/test.exec',
                classPattern: 'build/classes/java/main',
                sourcePattern: 'src/main/java',
                exclusionPattern: '**/*Test*.class',
                changeBuildStatus: true,
                minimumInstructionCoverage: '80',
                maximumInstructionCoverage: '90'
            )
        }
    }
}

// Fail build if coverage below threshold
script {
    def coverage = readFile('build/reports/jacoco/test/html/index.html')
    if (coverage.contains('Total</td><td class="ctr2">([0-9]+)%')) {
        def percent = Matcher.lastMatcher[0][1].toInteger()
        if (percent < 80) {
            error "Code coverage is ${percent}%, must be at least 80%"
        }
    }
}
```

---

### Static Analysis (SonarQube)

```groovy
stage('SonarQube Analysis') {
    environment {
        SONAR_TOKEN = credentials('sonar-token')
    }
    steps {
        withSonarQubeEnv('SonarQube Server') {
            sh '''
                ./gradlew sonarqube \
                    -Dsonar.projectKey=my-project \
                    -Dsonar.projectName='My Project' \
                    -Dsonar.host.url=https://sonar.example.com \
                    -Dsonar.login=${SONAR_TOKEN} \
                    -Dsonar.java.binaries=build/classes \
                    -Dsonar.coverage.jacoco.xmlReportPaths=build/reports/jacoco/test/jacocoTestReport.xml
            '''
        }
    }
}

stage('Quality Gate') {
    steps {
        timeout(time: 5, unit: 'MINUTES') {
            // Wait for SonarQube analysis to complete
            waitForQualityGate abortPipeline: true
        }
    }
}

// Quality gate checks:
// - Code coverage > 80%
// - No critical bugs
// - No blocker issues
// - Security hotspots reviewed
// - Code smells below threshold
```

---

### Docker Build and Push

```groovy
stage('Docker Build') {
    steps {
        script {
            // Build image
            def app = docker.build("mycompany/myapp:${env.BUILD_NUMBER}")
            
            // Tag image
            app.tag("${env.GIT_COMMIT}")
            app.tag("latest")
        }
    }
}

stage('Docker Push') {
    steps {
        script {
            docker.withRegistry('https://registry.example.com', 'docker-credentials') {
                def app = docker.image("mycompany/myapp:${env.BUILD_NUMBER}")
                app.push("${env.BUILD_NUMBER}")
                app.push("${env.GIT_COMMIT}")
                app.push("latest")
            }
        }
    }
}

// With Dockerfile
stage('Docker Build') {
    steps {
        sh '''
            docker build \
                -t mycompany/myapp:${BUILD_NUMBER} \
                -t mycompany/myapp:${GIT_COMMIT} \
                -t mycompany/myapp:latest \
                --build-arg VERSION=${BUILD_NUMBER} \
                .
        '''
    }
}

// Multi-stage Docker build
// Dockerfile
FROM maven:3.8-openjdk-17 AS build
WORKDIR /app
COPY pom.xml .
RUN mvn dependency:go-offline
COPY src ./src
RUN mvn package -DskipTests

FROM openjdk:17-jdk-slim
COPY --from=build /app/target/*.jar app.jar
ENTRYPOINT ["java", "-jar", "app.jar"]
```

---

## 4. Jenkins Plugins

### Essential Plugins

**1. Docker Plugin**

```groovy
// Configure in Jenkins > Manage > Plugins > Available
// Search: "Docker" and install

// Usage in pipeline
pipeline {
    agent {
        docker {
            image 'maven:3.8-openjdk-17'
            args '-v $HOME/.m2:/root/.m2'
            reuseNode true
        }
    }
    stages {
        stage('Build') {
            steps {
                sh 'mvn clean package'
            }
        }
    }
}
```

**2. Kubernetes Plugin (Dynamic Agents)**

```groovy
// Configure: Jenkins > Manage > Clouds > Add Kubernetes

// Pod template
podTemplate(
    label: 'mypod',
    containers: [
        containerTemplate(
            name: 'maven',
            image: 'maven:3.8-openjdk-17',
            command: 'sleep',
            args: '99999'
        ),
        containerTemplate(
            name: 'docker',
            image: 'docker:latest',
            command: 'sleep',
            args: '99999'
        )
    ],
    volumes: [
        hostPathVolume(hostPath: '/var/run/docker.sock', mountPath: '/var/run/docker.sock')
    ]
) {
    node('mypod') {
        stage('Build') {
            container('maven') {
                sh 'mvn clean package'
            }
        }
        stage('Docker Build') {
            container('docker') {
                sh 'docker build -t myapp:latest .'
            }
        }
    }
}
```

**3. GitHub Integration**

```groovy
// Install: GitHub Plugin, GitHub Branch Source Plugin

// Webhook configuration
// GitHub repo → Settings → Webhooks → Add webhook
// Payload URL: http://jenkins.example.com/github-webhook/
// Content type: application/json
// Events: Push, Pull request

// Pipeline triggered automatically on:
// - Push to repository
// - Pull request created/updated
// - Tag created
```

**4. GitLab Integration**

```groovy
// Install: GitLab Plugin

// Configuration
// GitLab → Settings → Webhooks
// URL: http://jenkins.example.com/project/myproject
// Trigger: Push events, Merge request events

// Pipeline with GitLab status
pipeline {
    agent any
    
    options {
        gitLabConnection('gitlab')
    }
    
    stages {
        stage('Build') {
            steps {
                updateGitlabCommitStatus name: 'build', state: 'running'
                sh 'make build'
                updateGitlabCommitStatus name: 'build', state: 'success'
            }
        }
    }
    
    post {
        failure {
            updateGitlabCommitStatus name: 'build', state: 'failed'
        }
    }
}
```

**5. Slack Notifications**

```groovy
// Install: Slack Notification Plugin

// Configure: Jenkins > Manage > System > Slack
// Workspace: mycompany
// Credentials: Add Slack token
// Default channel: #jenkins

// Usage
pipeline {
    agent any
    
    stages {
        stage('Build') {
            steps {
                sh './build.sh'
            }
        }
    }
    
    post {
        success {
            slackSend(
                color: 'good',
                channel: '#builds',
                message: "✓ Build succeeded: ${env.JOB_NAME} #${env.BUILD_NUMBER}\n<${env.BUILD_URL}|View Build>"
            )
        }
        failure {
            slackSend(
                color: 'danger',
                channel: '#builds',
                message: "✗ Build failed: ${env.JOB_NAME} #${env.BUILD_NUMBER}\n<${env.BUILD_URL}|View Build>"
            )
        }
    }
}
```

**6. Email Notifications**

```groovy
// Install: Email Extension Plugin

// Configure: Jenkins > Manage > System > Extended E-mail Notification
// SMTP server: smtp.gmail.com
// Port: 587
// Credentials: Add email credentials

// Usage
post {
    always {
        emailext(
            subject: "Build ${currentBuild.result}: ${env.JOB_NAME} #${env.BUILD_NUMBER}",
            body: """
                Build ${currentBuild.result}
                
                Project: ${env.JOB_NAME}
                Build Number: ${env.BUILD_NUMBER}
                URL: ${env.BUILD_URL}
                
                Changes:
                ${currentBuild.changeSets.collect { it.items.collect { "- ${it.msg}" } }.flatten().join('\n')}
            """,
            to: 'team@example.com',
            attachLog: true
        )
    }
}
```

---

## 5. Advanced Topics

### Shared Libraries (Reusable Pipeline Code)

**Why Shared Libraries?**

- ✅ Reuse pipeline code across projects
- ✅ Standardize build processes
- ✅ Centralized maintenance
- ✅ Version control for pipeline logic

**Directory Structure:**

```
jenkins-shared-library/
├── vars/
│   ├── buildJavaApp.groovy
│   ├── deployToKubernetes.groovy
│   └── notifySlack.groovy
├── src/
│   └── com/
│       └── mycompany/
│           └── jenkins/
│               └── Utils.groovy
└── resources/
    └── templates/
        └── Dockerfile
```

**Shared Library Configuration:**

```groovy
// Jenkins > Manage > System > Global Pipeline Libraries
Name: my-shared-library
Default version: main
Retrieval method: Modern SCM
Source: Git
Repository URL: https://github.com/mycompany/jenkins-shared-library
```

**Example Global Variable (vars/buildJavaApp.groovy):**

```groovy
// vars/buildJavaApp.groovy
def call(Map config = [:]) {
    pipeline {
        agent any
        
        stages {
            stage('Checkout') {
                steps {
                    checkout scm
                }
            }
            
            stage('Build') {
                steps {
                    sh "${config.buildTool} clean ${config.buildGoal}"
                }
            }
            
            stage('Test') {
                steps {
                    sh "${config.buildTool} test"
                }
                post {
                    always {
                        junit 'target/surefire-reports/**/*.xml'
                    }
                }
            }
            
            stage('Package') {
                steps {
                    sh "${config.buildTool} package"
                }
            }
        }
    }
}
```

**Using Shared Library:**

```groovy
// Jenkinsfile
@Library('my-shared-library') _

buildJavaApp(
    buildTool: 'mvn',
    buildGoal: 'install'
)
```

**Advanced Example:**

```groovy
// vars/standardPipeline.groovy
def call(body) {
    def config = [:]
    body.resolveStrategy = Closure.DELEGATE_FIRST
    body.delegate = config
    body()

    pipeline {
        agent any
        
        stages {
            stage('Build') {
                steps {
                    script {
                        if (config.buildCommand) {
                            sh config.buildCommand
                        } else {
                            error "Build command not specified"
                        }
                    }
                }
            }
            
            stage('Test') {
                when {
                    expression { config.runTests != false }
                }
                steps {
                    sh config.testCommand ?: './gradlew test'
                }
            }
            
            stage('Deploy') {
                when {
                    branch config.deployBranch ?: 'main'
                }
                steps {
                    sh config.deployCommand
                }
            }
        }
        
        post {
            always {
                notifySlack(currentBuild.result)
            }
        }
    }
}

// Usage in Jenkinsfile
@Library('my-shared-library') _

standardPipeline {
    buildCommand = './gradlew build'
    testCommand = './gradlew test integrationTest'
    deployCommand = './deploy.sh production'
    deployBranch = 'main'
    runTests = true
}
```

---

### Multi-Branch Pipelines

**Setup:**

1. New Item → Multibranch Pipeline
2. Branch Sources → Add source (Git/GitHub/GitLab)
3. Behaviors → Discover branches/PRs
4. Build Configuration → Jenkinsfile

**Features:**

- Automatic branch discovery
- Separate builds per branch
- PR validation
- Branch-specific configuration

**Example:**

```groovy
// Jenkinsfile (in repository)
pipeline {
    agent any
    
    stages {
        stage('Build') {
            steps {
                echo "Building branch: ${env.BRANCH_NAME}"
                sh './gradlew build'
            }
        }
        
        stage('Deploy to Dev') {
            when {
                branch 'feature/*'
            }
            steps {
                sh './deploy.sh dev'
            }
        }
        
        stage('Deploy to Staging') {
            when {
                branch 'develop'
            }
            steps {
                sh './deploy.sh staging'
            }
        }
        
        stage('Deploy to Production') {
            when {
                branch 'main'
            }
            steps {
                input message: 'Deploy to production?'
                sh './deploy.sh production'
            }
        }
    }
}

// Branch detection:
// main → Deploy to production
// develop → Deploy to staging
// feature/xyz → Deploy to dev
// PR #123 → Build and test only
```

---

### Blue Ocean UI

**Installation:**

```
Manage Jenkins → Plugins → Available → "Blue Ocean"
Install without restart
```

**Features:**

- Modern, visual pipeline UI
- Pipeline editor (visual designer)
- Branch/PR overview
- Better visualization of parallel stages
- Improved log viewing

**Access:**

```
Classic: http://jenkins.example.com/job/myproject/
Blue Ocean: http://jenkins.example.com/blue/organizations/jenkins/myproject/
```

**Pipeline Editor:**

- Visual Jenkinsfile editor
- Drag-and-drop stages
- Auto-generate Jenkinsfile
- Commit directly to repo

---

### Jenkins X (Kubernetes-Native CI/CD)

**Jenkins X** is a Kubernetes-native CI/CD solution.

**Key Features:**

- GitOps workflows
- Automated Kubernetes deployments
- Preview environments for PRs
- Tekton pipelines (Cloud Native)
- Built-in best practices

**Installation:**

```bash
# Install jx CLI
brew install jenkins-x/jx/jx

# Create cluster with jx
jx create cluster gke

# Or install on existing cluster
jx install --provider kubernetes
```

**Pipeline (jenkins-x.yml):**

```yaml
buildPack: maven
pipelineConfig:
  pipelines:
    release:
      pipeline:
        stages:
        - name: Build
          steps:
          - sh: mvn clean install
        - name: Test
          steps:
          - sh: mvn test
        - name: Docker
          steps:
          - sh: docker build -t $DOCKER_REGISTRY/$ORG/$APP_NAME:$VERSION .
          - sh: docker push $DOCKER_REGISTRY/$ORG/$APP_NAME:$VERSION
        - name: Deploy
          steps:
          - sh: jx step helm apply
    
    pullRequest:
      pipeline:
        stages:
        - name: Build
          steps:
          - sh: mvn clean install
        - name: Test
          steps:
          - sh: mvn test
```

**GitOps Workflow:**

```
1. Developer pushes code
2. Jenkins X builds & tests
3. Creates container image
4. Updates Helm chart version
5. Commits to GitOps repo
6. Flux/ArgoCD deploys to cluster
```

---

## Summary

### Architecture

- **Master/Agent**: Distributed builds
- **Executors**: Parallel job execution
- **Dynamic Agents**: Kubernetes/Docker on-demand

### Pipelines

- **Declarative**: Structured, recommended
- **Scripted**: Flexible, advanced
- **Pipeline as Code**: Version-controlled Jenkinsfile

### Java Integration

- **Build**: Maven/Gradle
- **Test**: JUnit reports
- **Coverage**: JaCoCo
- **Analysis**: SonarQube
- **Docker**: Build and push images

### Plugins

- **Docker**: Container-based builds
- **Kubernetes**: Dynamic agent provisioning
- **GitHub/GitLab**: SCM integration
- **Slack/Email**: Notifications

### Advanced

- **Shared Libraries**: Reusable pipeline code
- **Multi-Branch**: Automatic branch/PR builds
- **Blue Ocean**: Modern UI
- **Jenkins X**: Kubernetes-native CI/CD
