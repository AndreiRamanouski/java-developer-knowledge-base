# GitLab CI/CD

## 1. GitLab CI Fundamentals

### .gitlab-ci.yml

**GitLab CI/CD** uses `.gitlab-ci.yml` file in repository root to define pipelines.

**Basic Structure:**

```yaml
# .gitlab-ci.yml

# Global variables
variables:
  MAVEN_OPTS: "-Dmaven.repo.local=$CI_PROJECT_DIR/.m2/repository"

# Stages (execution order)
stages:
  - build
  - test
  - deploy

# Before script (runs before every job)
before_script:
  - echo "Starting job ${CI_JOB_NAME}"

# Jobs
build-job:
  stage: build
  script:
    - echo "Building the application"
    - ./gradlew build

test-job:
  stage: test
  script:
    - echo "Running tests"
    - ./gradlew test

deploy-job:
  stage: deploy
  script:
    - echo "Deploying application"
    - ./deploy.sh production
  only:
    - main
```

**Pipeline Execution:**

```
┌────────────────────────────────────────┐
│  GITLAB CI/CD PIPELINE                 │
├────────────────────────────────────────┤
│                                        │
│  Stage 1: BUILD                        │
│  ├── build-job (runs)                  │
│  └── Wait for completion               │
│            ↓                           │
│  Stage 2: TEST                         │
│  ├── unit-test (runs in parallel)     │
│  ├── integration-test (parallel)      │
│  └── e2e-test (parallel)              │
│            ↓                           │
│  Stage 3: DEPLOY                       │
│  └── deploy-job (runs)                │
│                                        │
│  Pipeline passes ✓                     │
└────────────────────────────────────────┘
```

---

### Runners

**GitLab Runner** is the agent that executes CI/CD jobs.

#### Runner Types

**1. Shared Runners (Instance-wide)**

```
Available to all projects in GitLab instance
- Provided by GitLab.com (free tier: 400 minutes/month)
- Or self-hosted shared runners
- Configured by admin
- No setup required for projects
```

**2. Specific Runners (Project-specific)**

```
Dedicated to specific project
- Better performance (no competition)
- Custom configuration
- Can be tagged for specific jobs
- Full control over environment
```

**3. Group Runners**

```
Available to all projects in a group
- Share between team projects
- Better resource utilization
- Group-level management
```

**Runner Architecture:**

```
┌──────────────────────────────────────┐
│  GitLab Instance                     │
│  ├── Project A                       │
│  ├── Project B                       │
│  └── Project C                       │
└────────────┬─────────────────────────┘
             │
        API Connection
             │
┌────────────▼─────────────────────────┐
│  GitLab Runner                       │
│  ├── Executor (Docker/Shell/K8s)    │
│  ├── Job Queue                       │
│  └── Build Artifacts                 │
└──────────────────────────────────────┘
```

#### Installing GitLab Runner

```bash
# Linux (Debian/Ubuntu)
curl -L "https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh" | sudo bash
sudo apt-get install gitlab-runner

# Register runner
sudo gitlab-runner register

# Configuration prompts:
# GitLab URL: https://gitlab.com/
# Registration token: [from project Settings > CI/CD > Runners]
# Description: my-runner
# Tags: docker,linux,java
# Executor: docker
# Default image: alpine:latest

# Verify
gitlab-runner list
```

#### Runner Executors

**Docker Executor (Most Common):**

```yaml
# Each job runs in fresh Docker container
# .gitlab-ci.yml
build:
  image: maven:3.8-openjdk-17
  script:
    - mvn clean package
```

**Shell Executor:**

```yaml
# Runs on runner's host machine
build:
  script:
    - mvn clean package
  tags:
    - shell
```

**Kubernetes Executor:**

```yaml
# Runs in Kubernetes pod
build:
  image: maven:3.8-openjdk-17
  script:
    - mvn clean package
  tags:
    - kubernetes
```

---

### Jobs, Stages, Pipelines

#### Jobs

**Job** is the smallest unit of work.

```yaml
# Basic job
my-job:
  script:
    - echo "Hello World"

# Job with image
build:
  image: maven:3.8-openjdk-17
  script:
    - mvn clean package

# Job with services (databases, etc.)
test:
  image: node:18
  services:
    - postgres:15
  variables:
    POSTGRES_DB: testdb
    POSTGRES_USER: test
    POSTGRES_PASSWORD: test
  script:
    - npm test

# Job with artifacts
build:
  script:
    - mvn package
  artifacts:
    paths:
      - target/*.jar
    expire_in: 1 week

# Job with cache
build:
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - .m2/repository
  script:
    - mvn package

# Job with dependencies (download artifacts)
deploy:
  dependencies:
    - build
  script:
    - ./deploy.sh target/app.jar
```

#### Stages

**Stages** group jobs and define execution order.

```yaml
stages:
  - build
  - test
  - package
  - deploy

# Jobs in same stage run in parallel
# Stages run sequentially

build-app:
  stage: build
  script:
    - mvn compile

unit-test:
  stage: test
  script:
    - mvn test

integration-test:
  stage: test
  script:
    - mvn verify

package:
  stage: package
  script:
    - mvn package

deploy:
  stage: deploy
  script:
    - ./deploy.sh
```

**Execution Flow:**

```
build-app (stage: build)
    ↓ completes
┌───────────────────────────┐
│  stage: test (parallel)   │
│  ├── unit-test            │
│  └── integration-test     │
└───────────────────────────┘
    ↓ both complete
package (stage: package)
    ↓ completes
deploy (stage: deploy)
```

#### Pipelines

**Pipeline** is complete set of stages and jobs.

```yaml
# Complete pipeline example
variables:
  DOCKER_IMAGE: mycompany/myapp
  MAVEN_OPTS: "-Dmaven.repo.local=$CI_PROJECT_DIR/.m2/repository"

stages:
  - build
  - test
  - package
  - deploy

before_script:
  - echo "Pipeline started for ${CI_COMMIT_REF_NAME}"

# Build stage
compile:
  stage: build
  image: maven:3.8-openjdk-17
  script:
    - mvn clean compile
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - .m2/repository
  artifacts:
    paths:
      - target/classes
    expire_in: 1 hour

# Test stage (parallel)
unit-tests:
  stage: test
  image: maven:3.8-openjdk-17
  script:
    - mvn test
  artifacts:
    reports:
      junit: target/surefire-reports/TEST-*.xml

integration-tests:
  stage: test
  image: maven:3.8-openjdk-17
  services:
    - postgres:15
  variables:
    POSTGRES_DB: testdb
    POSTGRES_USER: test
    POSTGRES_PASSWORD: test
  script:
    - mvn verify -DskipUnitTests
  artifacts:
    reports:
      junit: target/failsafe-reports/TEST-*.xml

# Package stage
build-jar:
  stage: package
  image: maven:3.8-openjdk-17
  script:
    - mvn package -DskipTests
  artifacts:
    paths:
      - target/*.jar
    expire_in: 1 week

build-docker:
  stage: package
  image: docker:24
  services:
    - docker:24-dind
  script:
    - docker build -t $DOCKER_IMAGE:$CI_COMMIT_SHA .
    - docker tag $DOCKER_IMAGE:$CI_COMMIT_SHA $DOCKER_IMAGE:latest
    - docker push $DOCKER_IMAGE:$CI_COMMIT_SHA
    - docker push $DOCKER_IMAGE:latest

# Deploy stage
deploy-staging:
  stage: deploy
  script:
    - ./deploy.sh staging
  environment:
    name: staging
    url: https://staging.example.com
  only:
    - develop

deploy-production:
  stage: deploy
  script:
    - ./deploy.sh production
  environment:
    name: production
    url: https://example.com
  when: manual
  only:
    - main
```

---

### Job Control

**only/except (legacy):**

```yaml
deploy:
  script:
    - ./deploy.sh
  only:
    - main
    - develop
  except:
    - tags
```

**rules (modern, recommended):**

```yaml
deploy:
  script:
    - ./deploy.sh
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_COMMIT_BRANCH == "develop"'
    - if: '$CI_COMMIT_TAG'
      when: never

# Complex rules
deploy:
  script:
    - ./deploy.sh
  rules:
    # Deploy to production on main
    - if: '$CI_COMMIT_BRANCH == "main"'
      variables:
        ENVIRONMENT: production
    # Deploy to staging on develop
    - if: '$CI_COMMIT_BRANCH == "develop"'
      variables:
        ENVIRONMENT: staging
    # Manual deploy for feature branches
    - if: '$CI_COMMIT_BRANCH =~ /^feature\//'
      when: manual
      variables:
        ENVIRONMENT: dev
```

**when:**

```yaml
# Always run (default)
job1:
  when: on_success

# Run on failure
cleanup:
  when: on_failure
  script:
    - ./cleanup.sh

# Manual trigger
deploy:
  when: manual
  script:
    - ./deploy.sh

# Always run (even if pipeline fails)
notifications:
  when: always
  script:
    - ./notify.sh
```

---

## 2. GitLab CI for Java

### Complete Java Pipeline

```yaml
# .gitlab-ci.yml for Spring Boot application

# Docker image for all jobs (can be overridden per job)
image: maven:3.8-openjdk-17

# Global variables
variables:
  MAVEN_OPTS: >-
    -Dhttps.protocols=TLSv1.2
    -Dmaven.repo.local=$CI_PROJECT_DIR/.m2/repository
    -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=WARN
    -Dorg.slf4j.simpleLogger.showDateTime=true
    -Djava.awt.headless=true
  MAVEN_CLI_OPTS: >-
    --batch-mode
    --errors
    --fail-at-end
    --show-version
  DOCKER_IMAGE: registry.gitlab.com/$CI_PROJECT_PATH
  KUBERNETES_NAMESPACE: $CI_PROJECT_NAME

# Cache Maven dependencies
cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths:
    - .m2/repository

# Pipeline stages
stages:
  - build
  - test
  - quality
  - package
  - deploy

# Before script (runs before every job)
before_script:
  - echo "Java version:"
  - java -version
  - echo "Maven version:"
  - mvn -version

# Build stage
compile:
  stage: build
  script:
    - mvn $MAVEN_CLI_OPTS clean compile
  artifacts:
    paths:
      - target/classes
    expire_in: 1 hour

# Test stage
unit-tests:
  stage: test
  script:
    - mvn $MAVEN_CLI_OPTS test
  artifacts:
    when: always
    reports:
      junit:
        - target/surefire-reports/TEST-*.xml
    paths:
      - target/surefire-reports
    expire_in: 1 week
  coverage: '/Total.*?([0-9]{1,3})%/'

integration-tests:
  stage: test
  services:
    - name: postgres:15
      alias: postgres
    - name: redis:7
      alias: redis
  variables:
    POSTGRES_DB: testdb
    POSTGRES_USER: test
    POSTGRES_PASSWORD: test
    SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/testdb
    SPRING_DATASOURCE_USERNAME: test
    SPRING_DATASOURCE_PASSWORD: test
    SPRING_REDIS_HOST: redis
    SPRING_REDIS_PORT: 6379
  script:
    - mvn $MAVEN_CLI_OPTS verify -DskipUnitTests
  artifacts:
    when: always
    reports:
      junit:
        - target/failsafe-reports/TEST-*.xml
    paths:
      - target/failsafe-reports
    expire_in: 1 week

# Code quality stage
code-coverage:
  stage: quality
  script:
    - mvn $MAVEN_CLI_OPTS jacoco:report
  artifacts:
    paths:
      - target/site/jacoco
    expire_in: 1 week
  coverage: '/Total.*?([0-9]{1,3})%/'

sonarqube:
  stage: quality
  image: maven:3.8-openjdk-17
  variables:
    SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"
    GIT_DEPTH: "0"
  cache:
    key: "${CI_JOB_NAME}"
    paths:
      - .sonar/cache
  script:
    - mvn $MAVEN_CLI_OPTS verify sonar:sonar
      -Dsonar.projectKey=$CI_PROJECT_PATH_SLUG
      -Dsonar.qualitygate.wait=true
  only:
    - main
    - develop

# Package stage
maven-package:
  stage: package
  script:
    - mvn $MAVEN_CLI_OPTS package -DskipTests
  artifacts:
    paths:
      - target/*.jar
    expire_in: 1 month
  only:
    - main
    - develop
    - tags

docker-build:
  stage: package
  image: docker:24
  services:
    - docker:24-dind
  variables:
    DOCKER_TLS_CERTDIR: "/certs"
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    # Build image
    - docker build
      --build-arg VERSION=$CI_COMMIT_SHORT_SHA
      -t $DOCKER_IMAGE:$CI_COMMIT_SHA
      -t $DOCKER_IMAGE:latest
      .
    # Push images
    - docker push $DOCKER_IMAGE:$CI_COMMIT_SHA
    - docker push $DOCKER_IMAGE:latest
    # Tag with version if tagged commit
    - |
      if [ -n "$CI_COMMIT_TAG" ]; then
        docker tag $DOCKER_IMAGE:$CI_COMMIT_SHA $DOCKER_IMAGE:$CI_COMMIT_TAG
        docker push $DOCKER_IMAGE:$CI_COMMIT_TAG
      fi
  only:
    - main
    - develop
    - tags

# Deploy stages
deploy-dev:
  stage: deploy
  image: bitnami/kubectl:latest
  script:
    - kubectl config use-context $K8S_CONTEXT
    - kubectl set image deployment/$CI_PROJECT_NAME
      $CI_PROJECT_NAME=$DOCKER_IMAGE:$CI_COMMIT_SHA
      -n dev
    - kubectl rollout status deployment/$CI_PROJECT_NAME -n dev
  environment:
    name: development
    url: https://dev.example.com
  only:
    - develop

deploy-staging:
  stage: deploy
  image: bitnami/kubectl:latest
  script:
    - kubectl config use-context $K8S_CONTEXT
    - kubectl set image deployment/$CI_PROJECT_NAME
      $CI_PROJECT_NAME=$DOCKER_IMAGE:$CI_COMMIT_SHA
      -n staging
    - kubectl rollout status deployment/$CI_PROJECT_NAME -n staging
  environment:
    name: staging
    url: https://staging.example.com
  only:
    - main

deploy-production:
  stage: deploy
  image: bitnami/kubectl:latest
  script:
    - kubectl config use-context $K8S_CONTEXT
    - kubectl set image deployment/$CI_PROJECT_NAME
      $CI_PROJECT_NAME=$DOCKER_IMAGE:$CI_COMMIT_TAG
      -n production
    - kubectl rollout status deployment/$CI_PROJECT_NAME -n production
  environment:
    name: production
    url: https://example.com
  when: manual
  only:
    - tags
```

---

### Maven/Gradle Cache

**Maven Cache Configuration:**

```yaml
variables:
  MAVEN_OPTS: "-Dmaven.repo.local=$CI_PROJECT_DIR/.m2/repository"

cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths:
    - .m2/repository

# Per-job cache
build:
  cache:
    key: maven-cache
    paths:
      - .m2/repository
    policy: pull-push  # Download and upload
  script:
    - mvn clean package

test:
  cache:
    key: maven-cache
    paths:
      - .m2/repository
    policy: pull  # Only download (faster)
  script:
    - mvn test
```

**Gradle Cache Configuration:**

```yaml
variables:
  GRADLE_OPTS: "-Dorg.gradle.daemon=false"
  GRADLE_USER_HOME: "$CI_PROJECT_DIR/.gradle"

cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths:
    - .gradle/wrapper
    - .gradle/caches

build:
  script:
    - ./gradlew clean build --build-cache

test:
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - .gradle/wrapper
      - .gradle/caches
    policy: pull
  script:
    - ./gradlew test
```

**Cache Best Practices:**

```yaml
# 1. Use different cache keys per branch
cache:
  key: ${CI_COMMIT_REF_SLUG}  # Branch name

# 2. Use cache policy
cache:
  policy: pull-push  # Default
  policy: pull       # Only download (read-only jobs)
  policy: push       # Only upload (setup jobs)

# 3. Cache only necessary files
cache:
  paths:
    - .m2/repository
    - !.m2/repository/**/*SNAPSHOT*  # Exclude snapshots

# 4. Set expiration
cache:
  expire_in: 1 week
```

---

### Docker-in-Docker (DinD)

**Building Docker images in GitLab CI:**

```yaml
# Method 1: Docker-in-Docker (dind)
docker-build:
  image: docker:24
  services:
    - docker:24-dind
  variables:
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_VERIFY: 1
    DOCKER_CERT_PATH: "$DOCKER_TLS_CERTDIR/client"
  before_script:
    - docker info
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA

# Method 2: Kaniko (rootless, more secure)
docker-build-kaniko:
  image:
    name: gcr.io/kaniko-project/executor:debug
    entrypoint: [""]
  script:
    - mkdir -p /kaniko/.docker
    - echo "{\"auths\":{\"$CI_REGISTRY\":{\"auth\":\"$(echo -n $CI_REGISTRY_USER:$CI_REGISTRY_PASSWORD | base64)\"}}}" > /kaniko/.docker/config.json
    - /kaniko/executor
      --context $CI_PROJECT_DIR
      --dockerfile $CI_PROJECT_DIR/Dockerfile
      --destination $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
      --destination $CI_REGISTRY_IMAGE:latest

# Method 3: Buildah (rootless alternative)
docker-build-buildah:
  image: quay.io/buildah/stable
  script:
    - buildah bud -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - buildah login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - buildah push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
```

**Multi-stage Docker build:**

```dockerfile
# Dockerfile
FROM maven:3.8-openjdk-17 AS build
WORKDIR /app
COPY pom.xml .
RUN mvn dependency:go-offline
COPY src ./src
RUN mvn package -DskipTests

FROM openjdk:17-jdk-slim
COPY --from=build /app/target/*.jar app.jar
ENTRYPOINT ["java", "-jar", "app.jar"]
```

```yaml
# .gitlab-ci.yml
docker-build:
  image: docker:24
  services:
    - docker:24-dind
  script:
    - docker build
      --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
      --build-arg VCS_REF=$CI_COMMIT_SHORT_SHA
      --build-arg VERSION=$CI_COMMIT_TAG
      -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
      .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
```

---

### Container Registry Integration

**GitLab Container Registry** is built-in.

```yaml
variables:
  # GitLab Container Registry
  CI_REGISTRY: registry.gitlab.com
  CI_REGISTRY_IMAGE: registry.gitlab.com/$CI_PROJECT_PATH
  
  # Or use external registry
  DOCKER_REGISTRY: docker.io
  DOCKER_IMAGE: mycompany/myapp

# Login to GitLab registry (automatic with CI variables)
before_script:
  - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY

# Build and push
docker-build:
  image: docker:24
  services:
    - docker:24-dind
  script:
    # Build
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker build -t $CI_REGISTRY_IMAGE:latest .
    
    # Push to GitLab registry
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - docker push $CI_REGISTRY_IMAGE:latest
    
    # Tag for specific version
    - |
      if [ -n "$CI_COMMIT_TAG" ]; then
        docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE:$CI_COMMIT_TAG
        docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_TAG
      fi

# Use image from registry
deploy:
  image: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  script:
    - ./deploy.sh
```

**Registry Cleanup:**

```yaml
# Settings > CI/CD > Container Registry
# Cleanup policy:
# - Keep n tags: 10
# - Keep tags matching: v*
# - Older than: 30 days
# - Remove tags matching: .*-branch-.*

# Or manual cleanup
cleanup-old-images:
  stage: cleanup
  image: docker:24
  script:
    - |
      # Delete images older than 30 days
      docker system prune -a --filter "until=720h" --force
  when: manual
  only:
    - schedules
```

---

### Kubernetes Deployment

```yaml
# Deploy to Kubernetes
deploy-k8s:
  stage: deploy
  image: bitnami/kubectl:latest
  variables:
    KUBE_NAMESPACE: $CI_PROJECT_NAME
  before_script:
    # Setup kubectl
    - kubectl config set-cluster k8s --server="$KUBE_URL" --insecure-skip-tls-verify=true
    - kubectl config set-credentials admin --token="$KUBE_TOKEN"
    - kubectl config set-context default --cluster=k8s --user=admin --namespace="$KUBE_NAMESPACE"
    - kubectl config use-context default
  script:
    # Create namespace if not exists
    - kubectl create namespace $KUBE_NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
    
    # Deploy using kubectl
    - kubectl set image deployment/$CI_PROJECT_NAME
      $CI_PROJECT_NAME=$CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
      -n $KUBE_NAMESPACE
    
    # Wait for rollout
    - kubectl rollout status deployment/$CI_PROJECT_NAME -n $KUBE_NAMESPACE
    
    # Verify deployment
    - kubectl get pods -n $KUBE_NAMESPACE
  environment:
    name: production
    url: https://example.com
    kubernetes:
      namespace: $KUBE_NAMESPACE
  only:
    - main

# Deploy using Helm
deploy-helm:
  stage: deploy
  image: alpine/helm:latest
  before_script:
    - helm repo add bitnami https://charts.bitnami.com/bitnami
    - helm repo update
  script:
    - helm upgrade --install $CI_PROJECT_NAME ./helm-chart
      --namespace $KUBE_NAMESPACE
      --create-namespace
      --set image.repository=$CI_REGISTRY_IMAGE
      --set image.tag=$CI_COMMIT_SHA
      --set ingress.hosts[0].host=example.com
      --wait
      --timeout 5m
  environment:
    name: production
    url: https://example.com
  only:
    - main

# Deploy using GitLab Kubernetes Agent
deploy-agent:
  stage: deploy
  image: bitnami/kubectl:latest
  script:
    # GitLab Kubernetes Agent handles authentication
    - kubectl config use-context $CI_PROJECT_PATH:production-agent
    - kubectl apply -f k8s/
    - kubectl rollout status deployment/$CI_PROJECT_NAME
  environment:
    name: production
    kubernetes:
      namespace: production
  only:
    - main
```

---

## 3. Advanced Features

### Templates and Includes

**Reusable templates** reduce duplication.

**Template file (templates/maven.yml):**

```yaml
# templates/maven.yml
.maven_cache:
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - .m2/repository

.maven_build:
  extends: .maven_cache
  image: maven:3.8-openjdk-17
  variables:
    MAVEN_OPTS: "-Dmaven.repo.local=$CI_PROJECT_DIR/.m2/repository"
  before_script:
    - mvn -version

.maven_test:
  extends: .maven_build
  artifacts:
    reports:
      junit: target/surefire-reports/TEST-*.xml
```

**Main pipeline (.gitlab-ci.yml):**

```yaml
# .gitlab-ci.yml
include:
  - local: 'templates/maven.yml'

stages:
  - build
  - test

build:
  extends: .maven_build
  stage: build
  script:
    - mvn clean compile

test:
  extends: .maven_test
  stage: test
  script:
    - mvn test
```

**Include from multiple sources:**

```yaml
include:
  # Local file
  - local: 'templates/build.yml'
  
  # Project file
  - project: 'my-group/ci-templates'
    ref: main
    file: '/templates/maven.yml'
  
  # Remote URL
  - remote: 'https://gitlab.com/example/templates/-/raw/main/maven.yml'
  
  # Template from GitLab
  - template: Security/SAST.gitlab-ci.yml
```

**Parameterized templates:**

```yaml
# templates/deploy.yml
.deploy_template:
  image: bitnami/kubectl:latest
  script:
    - kubectl set image deployment/${APP_NAME}
      ${APP_NAME}=${DOCKER_IMAGE}:${VERSION}
      -n ${NAMESPACE}
    - kubectl rollout status deployment/${APP_NAME} -n ${NAMESPACE}
  environment:
    name: ${ENV_NAME}
    url: ${ENV_URL}

# .gitlab-ci.yml
include:
  - local: 'templates/deploy.yml'

deploy-staging:
  extends: .deploy_template
  variables:
    APP_NAME: myapp
    DOCKER_IMAGE: registry.gitlab.com/myapp
    VERSION: $CI_COMMIT_SHA
    NAMESPACE: staging
    ENV_NAME: staging
    ENV_URL: https://staging.example.com
  only:
    - develop

deploy-production:
  extends: .deploy_template
  variables:
    APP_NAME: myapp
    DOCKER_IMAGE: registry.gitlab.com/myapp
    VERSION: $CI_COMMIT_TAG
    NAMESPACE: production
    ENV_NAME: production
    ENV_URL: https://example.com
  only:
    - tags
```

---

### Dynamic Child Pipelines

**Generate pipelines dynamically** based on changed files or other conditions.

```yaml
# .gitlab-ci.yml (parent pipeline)
stages:
  - generate
  - deploy

generate-pipeline:
  stage: generate
  image: ruby:3.2
  script:
    - |
      cat > generated-config.yml << EOF
      deploy-app-1:
        stage: deploy
        script:
          - echo "Deploying app 1"
        only:
          changes:
            - app1/**/*
      
      deploy-app-2:
        stage: deploy
        script:
          - echo "Deploying app 2"
        only:
          changes:
            - app2/**/*
      EOF
  artifacts:
    paths:
      - generated-config.yml

child-pipeline:
  stage: deploy
  trigger:
    include:
      - artifact: generated-config.yml
        job: generate-pipeline
    strategy: depend
```

**Monorepo example:**

```yaml
# Generate child pipeline for changed microservices
generate-pipeline:
  stage: generate
  image: alpine:latest
  script:
    - |
      # Detect changed services
      CHANGED_SERVICES=$(git diff --name-only $CI_COMMIT_BEFORE_SHA $CI_COMMIT_SHA | cut -d'/' -f1 | sort -u)
      
      # Generate pipeline
      echo "stages:" > pipeline.yml
      echo "  - build" >> pipeline.yml
      echo "  - deploy" >> pipeline.yml
      
      for service in $CHANGED_SERVICES; do
        if [ -d "$service" ]; then
          cat >> pipeline.yml << EOF
      
      build-$service:
        stage: build
        script:
          - cd $service
          - ./build.sh
      
      deploy-$service:
        stage: deploy
        script:
          - cd $service
          - ./deploy.sh
      EOF
        fi
      done
  artifacts:
    paths:
      - pipeline.yml

trigger-child:
  stage: deploy
  trigger:
    include:
      - artifact: pipeline.yml
        job: generate-pipeline
```

---

### Environments and Deployments

**Environments** track where code is deployed.

```yaml
deploy-production:
  stage: deploy
  script:
    - ./deploy.sh production
  environment:
    name: production
    url: https://example.com
    deployment_tier: production
    on_stop: stop-production
  only:
    - main

stop-production:
  stage: deploy
  script:
    - ./undeploy.sh production
  environment:
    name: production
    action: stop
  when: manual
  only:
    - main
```

**Environment with variables:**

```yaml
deploy:
  stage: deploy
  script:
    - ./deploy.sh $DEPLOY_ENV $DEPLOY_URL
  environment:
    name: $DEPLOY_ENV
    url: $DEPLOY_URL
    deployment_tier: $DEPLOY_TIER
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      variables:
        DEPLOY_ENV: production
        DEPLOY_URL: https://example.com
        DEPLOY_TIER: production
    - if: '$CI_COMMIT_BRANCH == "develop"'
      variables:
        DEPLOY_ENV: staging
        DEPLOY_URL: https://staging.example.com
        DEPLOY_TIER: staging
```

**Protected environments:**

```
Settings > CI/CD > Protected Environments
- production: Deploy only from main, requires approval
- staging: Deploy from main and develop
```

---

### Review Apps

**Review Apps** create temporary environment for merge requests.

```yaml
review-app:
  stage: deploy
  image: bitnami/kubectl:latest
  script:
    # Create unique namespace for MR
    - export NAMESPACE="review-mr-${CI_MERGE_REQUEST_IID}"
    - kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
    
    # Deploy app to review namespace
    - helm upgrade --install review-${CI_MERGE_REQUEST_IID} ./helm-chart
      --namespace $NAMESPACE
      --create-namespace
      --set image.repository=$CI_REGISTRY_IMAGE
      --set image.tag=$CI_COMMIT_SHA
      --set ingress.hosts[0].host=review-mr-${CI_MERGE_REQUEST_IID}.example.com
      --wait
  environment:
    name: review/$CI_COMMIT_REF_NAME
    url: https://review-mr-${CI_MERGE_REQUEST_IID}.example.com
    on_stop: stop-review-app
    auto_stop_in: 1 week
  only:
    - merge_requests

stop-review-app:
  stage: deploy
  image: bitnami/kubectl:latest
  script:
    - export NAMESPACE="review-mr-${CI_MERGE_REQUEST_IID}"
    - helm uninstall review-${CI_MERGE_REQUEST_IID} --namespace $NAMESPACE
    - kubectl delete namespace $NAMESPACE
  environment:
    name: review/$CI_COMMIT_REF_NAME
    action: stop
  when: manual
  only:
    - merge_requests
```

**Review app workflow:**

```
1. Developer creates MR
2. Review app deployed automatically
3. URL posted in MR comments
4. Reviewers test in review environment
5. MR merged or closed
6. Review app automatically destroyed
```

---

### Auto DevOps

**Auto DevOps** provides automatic CI/CD without configuration.

**Enable Auto DevOps:**

```
Settings > CI/CD > Auto DevOps
- Enable Auto DevOps
- Deployment strategy: Continuous deployment
- Domain: *.example.com
```

**What Auto DevOps includes:**

- ✅ Build (Docker image)
- ✅ Test (unit, integration)
- ✅ Code Quality
- ✅ Security Scanning (SAST, DAST, dependency scanning)
- ✅ License Management
- ✅ Container Scanning
- ✅ Review Apps
- ✅ Staging Deployment
- ✅ Production Deployment
- ✅ Performance Testing
- ✅ Monitoring

**Customize Auto DevOps:**

```yaml
# .gitlab-ci.yml (overrides)
include:
  - template: Auto-DevOps.gitlab-ci.yml

variables:
  POSTGRES_ENABLED: "true"
  POSTGRES_VERSION: "15"
  AUTO_DEVOPS_BUILD_IMAGE_CNB_ENABLED: "false"
  AUTO_DEVOPS_BUILD_IMAGE_FORWARDED_CI_VARIABLES: >-
    MAVEN_OPTS,
    GRADLE_OPTS

# Disable specific stages
test:
  variables:
    AUTO_DEVOPS_DISABLED: "true"

# Add custom jobs
custom-deploy:
  stage: deploy
  script:
    - ./custom-deploy.sh
```

---

## Summary

### GitLab CI Fundamentals

- ✅ **.gitlab-ci.yml**: Pipeline as code in repo
- ✅ **Runners**: Shared, specific, group runners
- ✅ **Jobs/Stages**: Parallel execution, sequential stages
- ✅ **Pipelines**: Complete CI/CD workflow

### GitLab CI for Java

- ✅ **Maven/Gradle**: Dependency caching
- ✅ **Docker-in-Docker**: Build containers in CI
- ✅ **Container Registry**: Built-in image storage
- ✅ **Kubernetes**: Automated deployments

### Advanced Features

- ✅ **Templates**: Reusable pipeline code
- ✅ **Child Pipelines**: Dynamic generation
- ✅ **Environments**: Deployment tracking
- ✅ **Review Apps**: Temporary MR environments
- ✅ **Auto DevOps**: Zero-config CI/CD

### Key Benefits

- Built-in Container Registry
- Integrated with GitLab
- Kubernetes native
- Auto DevOps
- Review Apps
- Security scanning built-in
