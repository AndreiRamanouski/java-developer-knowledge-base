
## 1. GitHub Actions Basics

### Workflows, Jobs, Steps

**GitHub Actions** automates workflows using YAML files in `.github/workflows/`.

```
┌─────────────────────────────────────────┐
│     GITHUB ACTIONS HIERARCHY            │
├─────────────────────────────────────────┤
│                                         │
│  Workflow                               │
│  └── Job 1                             │
│      ├── Step 1 (action)              │
│      ├── Step 2 (command)             │
│      └── Step 3 (action)              │
│  └── Job 2 (parallel)                 │
│      ├── Step 1                        │
│      └── Step 2                        │
│  └── Job 3 (depends on Job 1)         │
│      └── Steps...                      │
│                                         │
└─────────────────────────────────────────┘
```

**Basic Workflow:**

```yaml
# .github/workflows/ci.yml
name: CI Pipeline

# Trigger on push to main
on:
  push:
    branches: [ main ]

# Define jobs
jobs:
  build:
    # Runner environment
    runs-on: ubuntu-latest
    
    # Steps to execute
    steps:
      # Checkout code
      - uses: actions/checkout@v4
      
      # Run command
      - name: Build application
        run: echo "Building..."
      
      # Run script
      - name: Run tests
        run: |
          echo "Running tests..."
          npm test
```

**Complete Example:**

```yaml
name: Complete CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Job 1: Build
  build:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: 'maven'
      
      - name: Build with Maven
        run: mvn clean package -DskipTests
      
      - name: Upload artifact
        uses: actions/upload-artifact@v3
        with:
          name: app-jar
          path: target/*.jar
  
  # Job 2: Test (runs in parallel with build)
  test:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: 'maven'
      
      - name: Run tests
        run: mvn test
      
      - name: Publish test results
        uses: dorny/test-reporter@v1
        if: always()
        with:
          name: Test Results
          path: target/surefire-reports/*.xml
          reporter: java-junit
  
  # Job 3: Deploy (runs after build)
  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Download artifact
        uses: actions/download-artifact@v3
        with:
          name: app-jar
      
      - name: Deploy to server
        run: echo "Deploying..."
```

---

### Triggers

**Event triggers** determine when workflows run.

#### Push Event

```yaml
# Trigger on push to any branch
on: push

# Specific branches
on:
  push:
    branches:
      - main
      - develop
      - 'releases/**'

# Exclude branches
on:
  push:
    branches:
      - main
    branches-ignore:
      - 'feature/**'

# Specific paths
on:
  push:
    paths:
      - 'src/**'
      - 'pom.xml'
    paths-ignore:
      - 'docs/**'
      - '**.md'

# Tags
on:
  push:
    tags:
      - 'v*'
      - 'release-*'
```

#### Pull Request Event

```yaml
# Trigger on PR to main
on:
  pull_request:
    branches: [ main ]

# PR types
on:
  pull_request:
    types:
      - opened
      - synchronize
      - reopened
      - ready_for_review

# PR paths
on:
  pull_request:
    paths:
      - 'src/**'
      - 'tests/**'
```

#### Schedule (Cron)

```yaml
# Run daily at 2 AM UTC
on:
  schedule:
    - cron: '0 2 * * *'

# Multiple schedules
on:
  schedule:
    - cron: '0 2 * * *'    # Daily at 2 AM
    - cron: '0 14 * * 1'   # Mondays at 2 PM
    - cron: '0 0 1 * *'    # First day of month

# Cron syntax:
# ┌───────────── minute (0 - 59)
# │ ┌───────────── hour (0 - 23)
# │ │ ┌───────────── day of month (1 - 31)
# │ │ │ ┌───────────── month (1 - 12)
# │ │ │ │ ┌───────────── day of week (0 - 6) (Sunday=0)
# │ │ │ │ │
# * * * * *
```

#### Manual (workflow_dispatch)

```yaml
# Manual trigger with inputs
on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        type: choice
        options:
          - dev
          - staging
          - production
      version:
        description: 'Version to deploy'
        required: true
        type: string
      dry-run:
        description: 'Perform dry run'
        required: false
        type: boolean
        default: false

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Deploy
        run: |
          echo "Deploying version ${{ inputs.version }}"
          echo "Environment: ${{ inputs.environment }}"
          echo "Dry run: ${{ inputs.dry-run }}"
```

#### Multiple Triggers

```yaml
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 2 * * *'
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Build
        run: echo "Triggered by ${{ github.event_name }}"
```

#### Other Triggers

```yaml
# Release created
on:
  release:
    types: [ created, published ]

# Issue events
on:
  issues:
    types: [ opened, labeled ]

# Repository dispatch (external webhook)
on:
  repository_dispatch:
    types: [ deploy ]

# Workflow run (trigger after another workflow)
on:
  workflow_run:
    workflows: ["CI"]
    types: [ completed ]
    branches: [ main ]
```

---

### Runners

**Runners** execute workflows.

#### GitHub-Hosted Runners

**Available runners:**

```yaml
# Ubuntu
runs-on: ubuntu-latest      # Ubuntu 22.04
runs-on: ubuntu-22.04
runs-on: ubuntu-20.04

# Windows
runs-on: windows-latest     # Windows Server 2022
runs-on: windows-2022
runs-on: windows-2019

# macOS
runs-on: macos-latest       # macOS 13
runs-on: macos-13
runs-on: macos-12
runs-on: macos-11

# Specs (GitHub-hosted):
# - 2 CPU cores
# - 7 GB RAM
# - 14 GB SSD
```

**Usage limits (Free tier):**

```
GitHub Free: 2,000 minutes/month
GitHub Pro: 3,000 minutes/month
GitHub Team: 10,000 minutes/month
GitHub Enterprise: 50,000 minutes/month

Multipliers:
- Ubuntu: 1x
- Windows: 2x
- macOS: 10x
```

#### Self-Hosted Runners

**Setup:**

```bash
# Download runner
mkdir actions-runner && cd actions-runner
curl -o actions-runner-linux-x64-2.311.0.tar.gz \
  -L https://github.com/actions/runner/releases/download/v2.311.0/actions-runner-linux-x64-2.311.0.tar.gz
tar xzf ./actions-runner-linux-x64-2.311.0.tar.gz

# Configure
./config.sh --url https://github.com/myorg/myrepo \
  --token XXXXXXXXXXXXXXXXXXXXX

# Run as service
sudo ./svc.sh install
sudo ./svc.sh start

# Verify
sudo ./svc.sh status
```

**Use in workflow:**

```yaml
jobs:
  build:
    runs-on: self-hosted
    
    # Or with labels
    runs-on: [self-hosted, linux, x64, gpu]
    
    steps:
      - uses: actions/checkout@v4
      - name: Build
        run: ./build.sh
```

**Benefits of self-hosted:**

- ✅ No minute limits
- ✅ Custom hardware (GPU, more RAM)
- ✅ Faster (cache dependencies)
- ✅ Access to internal resources
- ✅ Custom software pre-installed

**Drawbacks:**

- ❌ Manual maintenance
- ❌ Security considerations
- ❌ Need to manage updates

---

### Matrix Strategy

**Run jobs with different configurations:**

```yaml
jobs:
  test:
    runs-on: ${{ matrix.os }}
    
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        java-version: [11, 17, 21]
        # Creates 9 jobs (3 OS × 3 Java versions)
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up JDK ${{ matrix.java-version }}
        uses: actions/setup-java@v3
        with:
          java-version: ${{ matrix.java-version }}
          distribution: 'temurin'
      
      - name: Test on ${{ matrix.os }}
        run: mvn test

# Advanced matrix
jobs:
  test:
    runs-on: ${{ matrix.os }}
    
    strategy:
      fail-fast: false  # Continue even if one fails
      max-parallel: 2   # Limit concurrent jobs
      matrix:
        os: [ubuntu-latest, windows-latest]
        java-version: [11, 17]
        include:
          # Add specific configuration
          - os: ubuntu-latest
            java-version: 21
            experimental: true
        exclude:
          # Exclude specific combination
          - os: windows-latest
            java-version: 11
    
    continue-on-error: ${{ matrix.experimental || false }}
    
    steps:
      - uses: actions/checkout@v4
      - name: Test
        run: mvn test
```

---

## 2. Actions for Java

### Complete Java CI/CD Pipeline

```yaml
# .github/workflows/java-ci-cd.yml
name: Java CI/CD

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  release:
    types: [ created ]

env:
  JAVA_VERSION: '17'
  MAVEN_OPTS: -Xmx1024m
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Build and test
  build:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for SonarQube
      
      - name: Set up JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v3
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: 'maven'
      
      - name: Build with Maven
        run: mvn clean compile
      
      - name: Run unit tests
        run: mvn test
      
      - name: Run integration tests
        run: mvn verify -DskipUnitTests
      
      - name: Generate code coverage
        run: mvn jacoco:report
      
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          files: ./target/site/jacoco/jacoco.xml
          flags: unittests
      
      - name: SonarQube Scan
        if: github.event_name != 'pull_request'
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          mvn sonar:sonar \
            -Dsonar.projectKey=myproject \
            -Dsonar.organization=myorg \
            -Dsonar.host.url=https://sonarcloud.io \
            -Dsonar.login=$SONAR_TOKEN
      
      - name: Package application
        run: mvn package -DskipTests
      
      - name: Upload artifact
        uses: actions/upload-artifact@v3
        with:
          name: app-jar
          path: target/*.jar
          retention-days: 7

  # Security scanning
  security:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Run Snyk security scan
        uses: snyk/actions/maven@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
      
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
      
      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'

  # Build Docker image
  docker:
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name != 'pull_request'
    
    permissions:
      contents: read
      packages: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Download artifact
        uses: actions/download-artifact@v3
        with:
          name: app-jar
          path: target
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache
          cache-to: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache,mode=max

  # Deploy to Kubernetes
  deploy-staging:
    needs: docker
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'
    
    environment:
      name: staging
      url: https://staging.example.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure kubectl
        uses: azure/k8s-set-context@v3
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.KUBE_CONFIG_STAGING }}
      
      - name: Deploy to Kubernetes
        uses: azure/k8s-deploy@v4
        with:
          namespace: staging
          manifests: |
            k8s/deployment.yaml
            k8s/service.yaml
          images: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}

  deploy-production:
    needs: docker
    runs-on: ubuntu-latest
    if: github.event_name == 'release'
    
    environment:
      name: production
      url: https://example.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure kubectl
        uses: azure/k8s-set-context@v3
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.KUBE_CONFIG_PRODUCTION }}
      
      - name: Deploy to Kubernetes
        uses: azure/k8s-deploy@v4
        with:
          namespace: production
          manifests: |
            k8s/deployment.yaml
            k8s/service.yaml
          images: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.event.release.tag_name }}
```

---

### actions/setup-java

```yaml
# Basic setup
- name: Set up JDK 17
  uses: actions/setup-java@v3
  with:
    java-version: '17'
    distribution: 'temurin'

# With caching
- name: Set up JDK 17
  uses: actions/setup-java@v3
  with:
    java-version: '17'
    distribution: 'temurin'
    cache: 'maven'  # or 'gradle'

# Multiple Java versions
- name: Set up JDK
  uses: actions/setup-java@v3
  with:
    java-version: |
      11
      17
    distribution: 'temurin'
    cache: 'maven'

# Specific distribution
- name: Set up JDK
  uses: actions/setup-java@v3
  with:
    java-version: '17'
    distribution: 'adopt'  # adopt, temurin, zulu, corretto, microsoft, oracle

# With server authentication (for private Maven repos)
- name: Set up JDK with Maven settings
  uses: actions/setup-java@v3
  with:
    java-version: '17'
    distribution: 'temurin'
    cache: 'maven'
    server-id: github
    server-username: MAVEN_USERNAME
    server-password: MAVEN_TOKEN
```

---

### Maven Actions

```yaml
# Basic Maven build
- name: Build with Maven
  run: mvn clean package

# Maven with options
- name: Build with Maven
  run: |
    mvn clean package \
      -DskipTests \
      --batch-mode \
      --errors \
      --fail-at-end \
      --show-version

# Maven wrapper
- name: Make Maven wrapper executable
  run: chmod +x ./mvnw

- name: Build with Maven wrapper
  run: ./mvnw clean package

# Maven with profiles
- name: Build with Maven
  run: mvn clean package -Pproduction

# Maven deploy to repository
- name: Deploy to Maven Central
  env:
    MAVEN_USERNAME: ${{ secrets.OSSRH_USERNAME }}
    MAVEN_PASSWORD: ${{ secrets.OSSRH_TOKEN }}
  run: |
    mvn deploy \
      -DskipTests \
      --settings .github/settings.xml

# Maven with SonarQube
- name: Analyze with SonarQube
  env:
    SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
  run: |
    mvn verify sonar:sonar \
      -Dsonar.projectKey=myproject \
      -Dsonar.host.url=https://sonarcloud.io \
      -Dsonar.login=$SONAR_TOKEN
```

---

### Gradle Actions

```yaml
# Setup Gradle
- name: Setup Gradle
  uses: gradle/gradle-build-action@v2

# Basic Gradle build
- name: Build with Gradle
  run: ./gradlew build

# Gradle with options
- name: Build with Gradle
  run: |
    ./gradlew build \
      --no-daemon \
      --stacktrace \
      --build-cache

# Gradle with caching (automatic with gradle-build-action)
- name: Setup Gradle
  uses: gradle/gradle-build-action@v2
  with:
    cache-read-only: false
    gradle-home-cache-cleanup: true

# Gradle publish
- name: Publish to Maven Central
  env:
    OSSRH_USERNAME: ${{ secrets.OSSRH_USERNAME }}
    OSSRH_PASSWORD: ${{ secrets.OSSRH_TOKEN }}
    SIGNING_KEY_ID: ${{ secrets.SIGNING_KEY_ID }}
    SIGNING_PASSWORD: ${{ secrets.SIGNING_PASSWORD }}
  run: ./gradlew publish

# Gradle with SonarQube
- name: Analyze with SonarQube
  env:
    SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
  run: |
    ./gradlew sonarqube \
      -Dsonar.projectKey=myproject \
      -Dsonar.host.url=https://sonarcloud.io \
      -Dsonar.login=$SONAR_TOKEN
```

---

### Docker Build and Push

```yaml
# Simple Docker build
- name: Build Docker image
  run: |
    docker build -t myapp:latest .
    docker push myapp:latest

# Docker Buildx (multi-platform)
- name: Set up Docker Buildx
  uses: docker/setup-buildx-action@v3

- name: Build and push
  uses: docker/build-push-action@v5
  with:
    context: .
    push: true
    tags: |
      myapp:latest
      myapp:${{ github.sha }}
    platforms: linux/amd64,linux/arm64

# With GitHub Container Registry
- name: Log in to GitHub Container Registry
  uses: docker/login-action@v3
  with:
    registry: ghcr.io
    username: ${{ github.actor }}
    password: ${{ secrets.GITHUB_TOKEN }}

- name: Build and push
  uses: docker/build-push-action@v5
  with:
    context: .
    push: true
    tags: |
      ghcr.io/${{ github.repository }}:latest
      ghcr.io/${{ github.repository }}:${{ github.sha }}

# With Docker Hub
- name: Log in to Docker Hub
  uses: docker/login-action@v3
  with:
    username: ${{ secrets.DOCKER_USERNAME }}
    password: ${{ secrets.DOCKER_PASSWORD }}

- name: Build and push
  uses: docker/build-push-action@v5
  with:
    context: .
    push: true
    tags: |
      myorg/myapp:latest
      myorg/myapp:${{ github.sha }}

# With caching
- name: Build and push
  uses: docker/build-push-action@v5
  with:
    context: .
    push: true
    tags: myapp:latest
    cache-from: type=registry,ref=myapp:buildcache
    cache-to: type=registry,ref=myapp:buildcache,mode=max

# Multi-stage build
- name: Build and push
  uses: docker/build-push-action@v5
  with:
    context: .
    file: ./Dockerfile
    target: production
    push: true
    tags: myapp:latest
    build-args: |
      VERSION=${{ github.ref_name }}
      BUILD_DATE=${{ github.event.head_commit.timestamp }}
```

---

### Kubernetes Deployment

```yaml
# Using kubectl
- name: Set up kubectl
  uses: azure/setup-kubectl@v3

- name: Configure kubectl
  run: |
    echo "${{ secrets.KUBE_CONFIG }}" > kubeconfig
    export KUBECONFIG=kubeconfig
    kubectl config view

- name: Deploy to Kubernetes
  run: |
    kubectl set image deployment/myapp \
      myapp=myapp:${{ github.sha }} \
      -n production
    kubectl rollout status deployment/myapp -n production

# Using Helm
- name: Install Helm
  uses: azure/setup-helm@v3
  with:
    version: 'v3.13.0'

- name: Deploy with Helm
  run: |
    helm upgrade --install myapp ./helm-chart \
      --namespace production \
      --create-namespace \
      --set image.tag=${{ github.sha }} \
      --set ingress.hosts[0].host=example.com \
      --wait \
      --timeout 5m

# Using k8s-deploy action
- name: Deploy to Kubernetes
  uses: azure/k8s-deploy@v4
  with:
    namespace: production
    manifests: |
      k8s/deployment.yaml
      k8s/service.yaml
      k8s/ingress.yaml
    images: |
      myapp:${{ github.sha }}
    kubectl-version: 'latest'

# Using kustomize
- name: Deploy with Kustomize
  run: |
    cd k8s/overlays/production
    kustomize edit set image myapp=myapp:${{ github.sha }}
    kubectl apply -k .

# ArgoCD sync
- name: Trigger ArgoCD sync
  run: |
    argocd app sync myapp \
      --server argocd.example.com \
      --auth-token ${{ secrets.ARGOCD_TOKEN }} \
      --revision ${{ github.sha }}
```

---

## 3. Reusable Workflows

### Composite Actions

**Create reusable action:**

```yaml
# .github/actions/setup-java-app/action.yml
name: 'Setup Java Application'
description: 'Set up Java, cache dependencies, and build'

inputs:
  java-version:
    description: 'Java version'
    required: false
    default: '17'
  build-command:
    description: 'Build command'
    required: false
    default: 'mvn clean package'

outputs:
  artifact-path:
    description: 'Path to built artifact'
    value: ${{ steps.build.outputs.path }}

runs:
  using: 'composite'
  steps:
    - name: Set up JDK ${{ inputs.java-version }}
      uses: actions/setup-java@v3
      with:
        java-version: ${{ inputs.java-version }}
        distribution: 'temurin'
        cache: 'maven'
      shell: bash
    
    - name: Build application
      id: build
      run: |
        ${{ inputs.build-command }}
        echo "path=target/*.jar" >> $GITHUB_OUTPUT
      shell: bash
```

**Use composite action:**

```yaml
# .github/workflows/ci.yml
name: CI

on: push

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup and build
        uses: ./.github/actions/setup-java-app
        with:
          java-version: '17'
          build-command: 'mvn clean package -DskipTests'
      
      - name: Run tests
        run: mvn test
```

**Advanced composite action:**

```yaml
# .github/actions/deploy-k8s/action.yml
name: 'Deploy to Kubernetes'
description: 'Deploy application to Kubernetes cluster'

inputs:
  environment:
    description: 'Target environment'
    required: true
  image-tag:
    description: 'Docker image tag'
    required: true
  kubeconfig:
    description: 'Kubernetes config'
    required: true
  namespace:
    description: 'Kubernetes namespace'
    required: true

runs:
  using: 'composite'
  steps:
    - name: Configure kubectl
      run: |
        echo "${{ inputs.kubeconfig }}" > kubeconfig
        export KUBECONFIG=kubeconfig
      shell: bash
    
    - name: Deploy
      run: |
        kubectl set image deployment/myapp \
          myapp=myapp:${{ inputs.image-tag }} \
          -n ${{ inputs.namespace }}
        
        kubectl rollout status deployment/myapp \
          -n ${{ inputs.namespace }} \
          --timeout=5m
      shell: bash
    
    - name: Verify deployment
      run: |
        kubectl get pods -n ${{ inputs.namespace }}
        kubectl get svc -n ${{ inputs.namespace }}
      shell: bash
```

---

### Workflow Templates

**Organization-wide reusable workflow:**

```yaml
# .github/workflows/java-ci-template.yml (in special repo)
name: Reusable Java CI

on:
  workflow_call:
    inputs:
      java-version:
        required: false
        type: string
        default: '17'
      build-command:
        required: false
        type: string
        default: 'mvn clean package'
      run-tests:
        required: false
        type: boolean
        default: true
    secrets:
      SONAR_TOKEN:
        required: false
      DOCKER_USERNAME:
        required: false
      DOCKER_PASSWORD:
        required: false
    outputs:
      artifact-name:
        description: "Name of the uploaded artifact"
        value: ${{ jobs.build.outputs.artifact }}

jobs:
  build:
    runs-on: ubuntu-latest
    
    outputs:
      artifact: ${{ steps.upload.outputs.artifact-id }}
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up JDK ${{ inputs.java-version }}
        uses: actions/setup-java@v3
        with:
          java-version: ${{ inputs.java-version }}
          distribution: 'temurin'
          cache: 'maven'
      
      - name: Build
        run: ${{ inputs.build-command }}
      
      - name: Test
        if: inputs.run-tests
        run: mvn test
      
      - name: SonarQube
        if: secrets.SONAR_TOKEN != ''
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: mvn sonar:sonar
      
      - name: Upload artifact
        id: upload
        uses: actions/upload-artifact@v3
        with:
          name: app-jar
          path: target/*.jar
```

**Use reusable workflow:**

```yaml
# Project's .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [ main ]

jobs:
  call-java-ci:
    uses: myorg/.github/.github/workflows/java-ci-template.yml@main
    with:
      java-version: '17'
      build-command: 'mvn clean package -DskipTests'
      run-tests: true
    secrets:
      SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

  deploy:
    needs: call-java-ci
    runs-on: ubuntu-latest
    steps:
      - name: Deploy
        run: echo "Deploying ${{ needs.call-java-ci.outputs.artifact-name }}"
```

**Complete reusable workflow example:**

```yaml
# .github/workflows/reusable-deploy.yml
name: Reusable Deploy Workflow

on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
      image-tag:
        required: true
        type: string
      helm-chart-path:
        required: false
        type: string
        default: './helm-chart'
    secrets:
      KUBE_CONFIG:
        required: true
      REGISTRY_USERNAME:
        required: true
      REGISTRY_PASSWORD:
        required: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    environment:
      name: ${{ inputs.environment }}
      url: https://${{ inputs.environment }}.example.com
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Log in to registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}
      
      - name: Install Helm
        uses: azure/setup-helm@v3
      
      - name: Configure kubectl
        run: echo "${{ secrets.KUBE_CONFIG }}" > kubeconfig
      
      - name: Deploy
        run: |
          export KUBECONFIG=kubeconfig
          helm upgrade --install myapp ${{ inputs.helm-chart-path }} \
            --namespace ${{ inputs.environment }} \
            --create-namespace \
            --set image.tag=${{ inputs.image-tag }} \
            --wait
```

---

### Organization-Wide Workflows

**Starter workflows (for organization):**

```yaml
# In .github repository of organization:
# workflow-templates/java-ci.yml
name: Java CI

on:
  push:
    branches: [ $default-branch ]
  pull_request:
    branches: [ $default-branch ]

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: 'maven'
      
      - name: Build with Maven
        run: mvn clean package
      
      - name: Run tests
        run: mvn test

# workflow-templates/java-ci.properties.json
{
  "name": "Java CI Starter Workflow",
  "description": "Standard Java CI workflow for Maven projects",
  "iconName": "java",
  "categories": [
    "Java",
    "Maven"
  ],
  "filePatterns": [
    "pom.xml"
  ]
}
```

**Required workflows (enforce in organization):**

```yaml
# .github/workflows/security-scan.yml (in .github-private repo)
name: Security Scan (Required)

on:
  pull_request:
  push:
    branches: [ main ]

jobs:
  security:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Run security scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
      
      - name: Check for vulnerabilities
        run: |
          if [ $? -ne 0 ]; then
            echo "Security vulnerabilities found!"
            exit 1
          fi
```

---

## Summary

### GitHub Actions Basics

- ✅ **Workflows**: YAML files in `.github/workflows/`
- ✅ **Jobs**: Parallel execution by default
- ✅ **Steps**: Sequential actions/commands
- ✅ **Triggers**: push, PR, schedule, manual, and more
- ✅ **Runners**: GitHub-hosted (2000 min/month free) or self-hosted

### Actions for Java

- ✅ **setup-java**: Multiple distributions, automatic caching
- ✅ **Maven/Gradle**: Built-in caching, wrapper support
- ✅ **Docker**: Multi-platform builds, layer caching
- ✅ **Kubernetes**: kubectl, Helm, Kustomize deployment

### Reusable Workflows

- ✅ **Composite Actions**: Reusable steps in single action
- ✅ **Workflow Templates**: Call workflows from other workflows
- ✅ **Organization-Wide**: Starter and required workflows

### Key Features

- Free 2000 minutes/month
- Matrix builds (multi-version testing)
- Environment protection rules
- Secret management
- Artifact storage (90 days)
- Built-in container registry (GHCR)
- Dependency caching
- Security scanning integration

### Best Practices

- Use caching for dependencies
- Minimize runner minutes
- Use self-hosted for intensive workloads
- Leverage matrix for multi-version testing
- Use environments for deployment gates
- Store secrets in GitHub Secrets
- Use reusable workflows to DRY
- Monitor workflow runs and costs
