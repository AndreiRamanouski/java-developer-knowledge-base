
## 1. What is Helm?

### Package Manager for Kubernetes

**Helm** is the package manager for Kubernetes - like apt/yum for Linux or npm for Node.js.

**Without Helm:**

```bash
# Deploy application manually
kubectl apply -f deployment.yaml
kubectl apply -f service.yaml
kubectl apply -f configmap.yaml
kubectl apply -f ingress.yaml
kubectl apply -f secrets.yaml
kubectl apply -f hpa.yaml
kubectl apply -f pdb.yaml
# ... and many more files

# Problems:
# - Managing multiple YAML files
# - No versioning
# - Hard to share
# - Difficult to customize for different environments
# - No easy rollback
```

**With Helm:**

```bash
# Deploy entire application with one command
helm install myapp ./mychart

# Or from repository
helm install myapp bitnami/postgresql

# Benefits:
# ✅ Single command deployment
# ✅ Version control
# ✅ Easy customization
# ✅ Simple rollback
# ✅ Shareable packages
```

---

### Helm 2 vs Helm 3 (Major Differences)

**Helm 2 Architecture:**

```
┌──────────────────────────────────────────┐
│  Helm 2 (DEPRECATED - DO NOT USE)       │
├──────────────────────────────────────────┤
│                                          │
│  ┌──────────┐                           │
│  │  Helm    │ ─────┐                    │
│  │  Client  │      │                    │
│  └──────────┘      │                    │
│                    ▼                    │
│             ┌──────────────┐            │
│             │   Tiller     │            │
│             │  (Server)    │            │
│             └──────┬───────┘            │
│                    │                    │
│                    ▼                    │
│             ┌──────────────┐            │
│             │  Kubernetes  │            │
│             │   Cluster    │            │
│             └──────────────┘            │
│                                          │
│  Issues:                                 │
│  - Tiller runs as cluster admin         │
│  - Security risk!                       │
│  - Complex RBAC setup                   │
│  - Single point of failure              │
└──────────────────────────────────────────┘
```

**Helm 3 Architecture:**

```
┌──────────────────────────────────────────┐
│  Helm 3 (Current - USE THIS)            │
├──────────────────────────────────────────┤
│                                          │
│  ┌──────────┐                           │
│  │  Helm    │                           │
│  │  Client  │                           │
│  └────┬─────┘                           │
│       │ Uses user's kubeconfig          │
│       │ No server component!            │
│       ▼                                 │
│  ┌──────────────┐                       │
│  │  Kubernetes  │                       │
│  │   Cluster    │                       │
│  └──────────────┘                       │
│                                          │
│  Benefits:                               │
│  ✅ No Tiller (more secure)             │
│  ✅ Uses user's permissions             │
│  ✅ Simpler architecture                │
│  ✅ Better security                     │
└──────────────────────────────────────────┘
```

**Major Differences:**

|Feature|Helm 2|Helm 3|
|---|---|---|
|**Tiller**|Required (security risk)|Removed ✅|
|**Release Storage**|ConfigMaps in kube-system|Secrets in app namespace ✅|
|**CRD Handling**|Manual lifecycle|Improved handling ✅|
|**Chart API Version**|v1|v2 ✅|
|**requirements.yaml**|Separate file|Merged into Chart.yaml ✅|
|**helm init**|Required|Not needed ✅|
|**3-way merge**|No|Yes (better upgrades) ✅|
|**Library Charts**|No|Yes ✅|
|**JSON Schema Validation**|No|Yes ✅|

**Migration from Helm 2 to Helm 3:**

```bash
# DO NOT USE HELM 2!
# If you have Helm 2, migrate:

# Install Helm 3
curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

# Migrate releases (use 2to3 plugin)
helm plugin install https://github.com/helm/helm-2to3
helm 2to3 convert

# Verify Helm 3
helm version
# Output: version.BuildInfo{Version:"v3.13.0", ...}
```

---

### Why Use Helm?

#### 1. Templating

**Problem: Repetitive YAML**

```yaml
# dev-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp-dev
spec:
  replicas: 2
  template:
    spec:
      containers:
      - name: myapp
        image: myapp:1.0.0-dev
        resources:
          limits:
            memory: "512Mi"

---
# prod-deployment.yaml (almost identical!)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp-prod
spec:
  replicas: 10
  template:
    spec:
      containers:
      - name: myapp
        image: myapp:1.0.0
        resources:
          limits:
            memory: "2Gi"
```

**Solution: Helm Templates**

```yaml
# templates/deployment.yaml (single file!)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ .Release.Name }}
spec:
  replicas: {{ .Values.replicaCount }}
  template:
    spec:
      containers:
      - name: {{ .Chart.Name }}
        image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
        resources:
          limits:
            memory: {{ .Values.resources.limits.memory }}
```

```yaml
# values-dev.yaml
replicaCount: 2
image:
  repository: myapp
  tag: 1.0.0-dev
resources:
  limits:
    memory: 512Mi

---
# values-prod.yaml
replicaCount: 10
image:
  repository: myapp
  tag: 1.0.0
resources:
  limits:
    memory: 2Gi
```

```bash
# Deploy to dev
helm install myapp-dev ./mychart -f values-dev.yaml

# Deploy to prod
helm install myapp-prod ./mychart -f values-prod.yaml
```

#### 2. Versioning

```bash
# View all releases
helm list

# Output:
NAME      REVISION  STATUS    CHART         APP VERSION
myapp     1         deployed  myapp-1.0.0   1.0.0

# Upgrade to new version
helm upgrade myapp ./mychart --set image.tag=2.0.0

# View history
helm history myapp

# Output:
REVISION  STATUS      CHART         DESCRIPTION
1         superseded  myapp-1.0.0   Install complete
2         deployed    myapp-2.0.0   Upgrade complete

# Rollback to previous version
helm rollback myapp 1
```

#### 3. Easy Sharing

```bash
# Package chart
helm package mychart/
# Creates: mychart-1.0.0.tgz

# Share via repository
helm repo add myrepo https://charts.example.com
helm repo update

# Install from repository
helm install myapp myrepo/mychart
```

#### 4. Dependency Management

```yaml
# Chart.yaml
dependencies:
- name: postgresql
  version: "12.0.0"
  repository: https://charts.bitnami.com/bitnami
- name: redis
  version: "17.0.0"
  repository: https://charts.bitnami.com/bitnami
```

```bash
# Install app with dependencies
helm install myapp ./mychart
# Automatically installs PostgreSQL and Redis!
```

---

## 2. Core Concepts

### Charts (Package Format)

**Chart** = Package containing all Kubernetes resources for an application.

```
mychart/
├── Chart.yaml          # Chart metadata
├── values.yaml         # Default configuration
├── templates/          # Kubernetes manifests with templates
│   ├── deployment.yaml
│   ├── service.yaml
│   └── ingress.yaml
├── charts/             # Dependencies
│   └── postgresql/
└── .helmignore         # Files to ignore
```

**Chart Types:**

1. **Application Chart:** Deployable application
2. **Library Chart:** Helper functions, no resources
3. **Dependency Chart:** Sub-chart

---

### Releases (Deployed Instance)

**Release** = Running instance of a chart.

```bash
# One chart, multiple releases
helm install frontend-dev ./webapp
helm install frontend-staging ./webapp
helm install frontend-prod ./webapp

# Each release is independent:
# - Different namespace
# - Different configuration
# - Different version
# - Separate lifecycle
```

**Release Storage (Helm 3):**

```bash
# Releases stored as Secrets in release namespace
kubectl get secrets -n production

# Output:
NAME                          TYPE                 DATA
sh.helm.release.v1.myapp.v1   helm.sh/release.v1   1
sh.helm.release.v1.myapp.v2   helm.sh/release.v1   1

# Contains:
# - Release metadata
# - Chart used
# - Values provided
# - Manifest
# - Hooks
```

---

### Repositories (Chart Storage)

**Repository** = HTTP server storing packaged charts.

**Public Repositories:**

```bash
# Add Bitnami repository (most popular)
helm repo add bitnami https://charts.bitnami.com/bitnami

# Add other repositories
helm repo add stable https://charts.helm.sh/stable
helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx

# Update repositories
helm repo update

# Search for charts
helm search repo postgresql

# Output:
NAME                 CHART VERSION  APP VERSION  DESCRIPTION
bitnami/postgresql   12.0.0         15.0.0       PostgreSQL is an advanced...
stable/postgresql    8.6.4          11.7.0       Chart for PostgreSQL
```

**Private Repository:**

```bash
# Add private repository with authentication
helm repo add mycompany https://charts.company.com \
  --username admin \
  --password secret

# Or use token
helm repo add mycompany https://charts.company.com \
  --pass-credentials
```

**Repository Index:**

```yaml
# index.yaml (repository metadata)
apiVersion: v1
entries:
  mychart:
  - name: mychart
    version: 1.0.0
    appVersion: "1.0"
    description: My application chart
    created: 2024-11-14T10:00:00.000000000Z
    digest: 3e5a2b1c...
    urls:
    - https://charts.example.com/mychart-1.0.0.tgz
```

---

### Values (Configuration)

**Values** = Configuration passed to chart.

**Priority Order (highest to lowest):**

```bash
1. --set flag (command line)
2. -f / --values flag (values file)
3. values.yaml in chart (default)
```

**Example:**

```yaml
# values.yaml (default)
replicaCount: 1
image:
  repository: nginx
  tag: "1.25"
```

```yaml
# values-prod.yaml (override for production)
replicaCount: 5
image:
  tag: "1.25.3"
```

```bash
# Install with overrides
helm install myapp ./mychart \
  -f values-prod.yaml \          # File override
  --set replicaCount=10          # Command line override (highest priority)

# Result:
# replicaCount: 10 (from --set)
# image.repository: nginx (from values.yaml)
# image.tag: "1.25.3" (from values-prod.yaml)
```

---

## 3. Chart Structure

### Complete Chart Directory Structure

```
mychart/
├── Chart.yaml              # Chart metadata (required)
├── values.yaml             # Default configuration (required)
├── values.schema.json      # JSON schema for values validation
├── templates/              # Template files (required)
│   ├── NOTES.txt          # Post-install notes
│   ├── _helpers.tpl       # Helper templates
│   ├── deployment.yaml
│   ├── service.yaml
│   ├── ingress.yaml
│   ├── configmap.yaml
│   ├── secret.yaml
│   ├── hpa.yaml
│   ├── serviceaccount.yaml
│   └── tests/
│       └── test-connection.yaml
├── charts/                 # Dependency charts
│   └── postgresql/
├── crds/                   # Custom Resource Definitions
│   └── mycrd.yaml
├── templates/hooks/        # Lifecycle hooks
│   ├── pre-install.yaml
│   └── post-upgrade.yaml
├── .helmignore            # Ignore patterns
├── README.md              # Chart documentation
├── LICENSE                # Chart license
└── requirements.lock      # Dependency lock file (Helm 2)
```

---

### Chart.yaml (Metadata)

**Chart.yaml** defines chart metadata.

```yaml
# Chart.yaml (required)
apiVersion: v2  # Helm 3 uses v2
name: mychart
description: A Helm chart for my application
type: application  # application or library

# Chart version (semantic versioning)
version: 1.0.0

# Application version
appVersion: "1.2.3"

# Keywords for searching
keywords:
  - web
  - application
  - production

# Maintainers
maintainers:
  - name: John Doe
    email: john@example.com
    url: https://github.com/johndoe

# Chart home page
home: https://github.com/mycompany/mychart

# Sources
sources:
  - https://github.com/mycompany/myapp

# Icon URL
icon: https://example.com/icon.png

# Dependencies
dependencies:
  - name: postgresql
    version: "~12.0.0"  # Version constraint
    repository: https://charts.bitnami.com/bitnami
    condition: postgresql.enabled  # Optional: conditional dependency
    tags:  # Optional: tag-based enabling
      - database
    import-values:  # Import specific values
      - child: image.tag
        parent: postgresql.imageTag
  
  - name: redis
    version: "^17.0.0"
    repository: https://charts.bitnami.com/bitnami
    condition: redis.enabled
    alias: cache  # Use different name

# Kubernetes version constraint
kubeVersion: ">=1.24.0-0"

# Deprecation notice
deprecated: false

# Annotations (metadata for tools)
annotations:
  category: Web
  licenses: Apache-2.0
```

**Version Constraints:**

```yaml
dependencies:
  # Exact version
  - name: postgresql
    version: "12.0.0"
  
  # Tilde constraint (patch updates)
  - name: redis
    version: "~17.0.0"  # 17.0.x (17.0.0, 17.0.1, ...)
  
  # Caret constraint (minor updates)
  - name: mysql
    version: "^9.0.0"   # 9.x.x (9.0.0, 9.1.0, 9.2.0, ...)
  
  # Range
  - name: nginx
    version: ">=1.0.0 <2.0.0"
  
  # OR condition
  - name: mongodb
    version: "1.0.0 || 2.0.0"
```

---

### values.yaml (Default Config)

**values.yaml** provides default configuration values.

```yaml
# values.yaml

# Replica count
replicaCount: 3

# Image configuration
image:
  repository: myapp
  pullPolicy: IfNotPresent
  tag: "1.0.0"

# Image pull secrets
imagePullSecrets: []

# Service account
serviceAccount:
  create: true
  annotations: {}
  name: ""

# Pod annotations
podAnnotations: {}

# Pod security context
podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 1000

# Container security context
securityContext:
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true
  runAsNonRoot: true
  capabilities:
    drop:
    - ALL

# Service configuration
service:
  type: ClusterIP
  port: 80
  targetPort: 8080
  annotations: {}

# Ingress configuration
ingress:
  enabled: false
  className: "nginx"
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # cert-manager.io/cluster-issuer: letsencrypt
  hosts:
    - host: myapp.example.com
      paths:
        - path: /
          pathType: Prefix
  tls: []
    # - secretName: myapp-tls
    #   hosts:
    #     - myapp.example.com

# Resource limits/requests
resources:
  limits:
    cpu: 1000m
    memory: 1Gi
  requests:
    cpu: 500m
    memory: 512Mi

# Autoscaling
autoscaling:
  enabled: false
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: 80

# Node selector
nodeSelector: {}

# Tolerations
tolerations: []

# Affinity
affinity: {}

# Health checks
livenessProbe:
  httpGet:
    path: /health
    port: http
  initialDelaySeconds: 30
  periodSeconds: 10

readinessProbe:
  httpGet:
    path: /ready
    port: http
  initialDelaySeconds: 5
  periodSeconds: 5

# Environment variables
env:
  - name: ENVIRONMENT
    value: "production"
  - name: LOG_LEVEL
    value: "INFO"

# ConfigMap data
configMap:
  data:
    application.properties: |
      server.port=8080
      logging.level.root=INFO

# Secret data (base64 encoded)
secret:
  data: {}

# Persistence
persistence:
  enabled: false
  storageClass: ""
  accessMode: ReadWriteOnce
  size: 10Gi

# Dependencies
postgresql:
  enabled: true
  auth:
    username: appuser
    password: ""  # Override in production!
    database: mydb
  primary:
    persistence:
      size: 10Gi

redis:
  enabled: true
  auth:
    enabled: true
    password: ""  # Override in production!
  master:
    persistence:
      size: 5Gi
```

**Best Practices:**

```yaml
# ✅ DO:
# - Provide sensible defaults
# - Document all options
# - Group related values
# - Use clear naming
# - Include examples in comments

# ❌ DON'T:
# - Include sensitive data (passwords, keys)
# - Use environment-specific values
# - Make values too deeply nested
# - Use unclear abbreviations
```

---

### templates/ (Kubernetes Manifests)

**templates/** contains Kubernetes manifests with Go templating.

**Example: deployment.yaml**

```yaml
{{- if .Values.deployment.enabled }}
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "mychart.fullname" . }}
  labels:
    {{- include "mychart.labels" . | nindent 4 }}
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      {{- include "mychart.selectorLabels" . | nindent 6 }}
  template:
    metadata:
      annotations:
        checksum/config: {{ include (print $.Template.BasePath "/configmap.yaml") . | sha256sum }}
        {{- with .Values.podAnnotations }}
        {{- toYaml . | nindent 8 }}
        {{- end }}
      labels:
        {{- include "mychart.selectorLabels" . | nindent 8 }}
    spec:
      {{- with .Values.imagePullSecrets }}
      imagePullSecrets:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      serviceAccountName: {{ include "mychart.serviceAccountName" . }}
      securityContext:
        {{- toYaml .Values.podSecurityContext | nindent 8 }}
      containers:
      - name: {{ .Chart.Name }}
        image: "{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}"
        imagePullPolicy: {{ .Values.image.pullPolicy }}
        ports:
        - name: http
          containerPort: {{ .Values.service.targetPort }}
          protocol: TCP
        {{- if .Values.livenessProbe }}
        livenessProbe:
          {{- toYaml .Values.livenessProbe | nindent 10 }}
        {{- end }}
        {{- if .Values.readinessProbe }}
        readinessProbe:
          {{- toYaml .Values.readinessProbe | nindent 10 }}
        {{- end }}
        resources:
          {{- toYaml .Values.resources | nindent 10 }}
        {{- with .Values.env }}
        env:
          {{- toYaml . | nindent 10 }}
        {{- end }}
      {{- with .Values.nodeSelector }}
      nodeSelector:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .Values.tolerations }}
      tolerations:
        {{- toYaml . | nindent 8 }}
      {{- end }}
{{- end }}
```

**Template Functions:**

```yaml
# String manipulation
{{ upper "hello" }}              # HELLO
{{ lower "WORLD" }}              # world
{{ title "hello world" }}        # Hello World
{{ trim "  hello  " }}           # hello
{{ trimSuffix "-" "hello-" }}    # hello

# Type conversion
{{ quote "value" }}              # "value"
{{ toString 123 }}               # "123"
{{ toJson .Values }}             # JSON output
{{ toYaml .Values }}             # YAML output

# Default values
{{ .Values.image.tag | default "latest" }}
{{ .Values.replicas | default 1 }}

# Conditionals
{{- if .Values.ingress.enabled }}
# ... ingress config
{{- end }}

{{- if and .Values.enabled .Values.persistence.enabled }}
# ... both must be true
{{- end }}

{{- if or .Values.dev .Values.staging }}
# ... either can be true
{{- end }}

# Loops
{{- range .Values.env }}
- name: {{ .name }}
  value: {{ .value }}
{{- end }}

# Include templates
{{ include "mychart.labels" . }}
{{ include "mychart.selectorLabels" . | nindent 4 }}
```

---

### _helpers.tpl (Template Helpers)

**_helpers.tpl** contains reusable template snippets.

```yaml
{{/*
Expand the name of the chart.
*/}}
{{- define "mychart.name" -}}
{{- default .Chart.Name .Values.nameOverride | trunc 63 | trimSuffix "-" }}
{{- end }}

{{/*
Create a default fully qualified app name.
*/}}
{{- define "mychart.fullname" -}}
{{- if .Values.fullnameOverride }}
{{- .Values.fullnameOverride | trunc 63 | trimSuffix "-" }}
{{- else }}
{{- $name := default .Chart.Name .Values.nameOverride }}
{{- if contains $name .Release.Name }}
{{- .Release.Name | trunc 63 | trimSuffix "-" }}
{{- else }}
{{- printf "%s-%s" .Release.Name $name | trunc 63 | trimSuffix "-" }}
{{- end }}
{{- end }}
{{- end }}

{{/*
Common labels
*/}}
{{- define "mychart.labels" -}}
helm.sh/chart: {{ include "mychart.chart" . }}
{{ include "mychart.selectorLabels" . }}
{{- if .Chart.AppVersion }}
app.kubernetes.io/version: {{ .Chart.AppVersion | quote }}
{{- end }}
app.kubernetes.io/managed-by: {{ .Release.Service }}
{{- end }}

{{/*
Selector labels
*/}}
{{- define "mychart.selectorLabels" -}}
app.kubernetes.io/name: {{ include "mychart.name" . }}
app.kubernetes.io/instance: {{ .Release.Name }}
{{- end }}

{{/*
Create the name of the service account to use
*/}}
{{- define "mychart.serviceAccountName" -}}
{{- if .Values.serviceAccount.create }}
{{- default (include "mychart.fullname" .) .Values.serviceAccount.name }}
{{- else }}
{{- default "default" .Values.serviceAccount.name }}
{{- end }}
{{- end }}
```

---

### charts/ (Dependencies)

**charts/** contains dependent charts.

```bash
# Download dependencies
helm dependency update

# Result:
mychart/
├── Chart.yaml
├── charts/
│   ├── postgresql-12.0.0.tgz
│   └── redis-17.0.0.tgz
└── Chart.lock  # Lock file (versions used)
```

**Chart.lock:**

```yaml
dependencies:
- name: postgresql
  repository: https://charts.bitnami.com/bitnami
  version: 12.0.0
- name: redis
  repository: https://charts.bitnami.com/bitnami
  version: 17.0.0
digest: sha256:abc123...
generated: "2024-11-14T10:00:00Z"
```

---

### .helmignore

**.helmignore** specifies files to exclude from chart package.

```
# .helmignore

# Development files
*.swp
*.bak
*.tmp
*~

# CI/CD
.gitlab-ci.yml
.github/
Jenkinsfile

# Documentation
docs/
OWNERS
README.md

# Testing
test/
tests/

# Version control
.git/
.gitignore

# IDE
.vscode/
.idea/
*.iml
```

---

## Summary

### Helm Benefits

- ✅ **Templating**: One chart, multiple environments
- ✅ **Versioning**: Track all changes
- ✅ **Rollback**: Easy revert to previous version
- ✅ **Sharing**: Distribute via repositories
- ✅ **Dependencies**: Automatic sub-chart management

### Core Concepts

- **Chart**: Package (template + values + metadata)
- **Release**: Deployed instance of chart
- **Repository**: Chart storage server
- **Values**: Configuration (override hierarchy)

### Chart Structure

- **Chart.yaml**: Metadata and dependencies
- **values.yaml**: Default configuration
- **templates/**: Kubernetes manifests with Go templates
- **_helpers.tpl**: Reusable template functions
- **charts/**: Dependency charts
- **.helmignore**: Exclude patterns

### Helm 3 Advantages

- No Tiller (more secure)
- Uses user's kubeconfig
- Better upgrade logic (3-way merge)
- Library charts support
- JSON schema validation
