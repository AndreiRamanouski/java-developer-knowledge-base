
## 1. Spring Boot Chart Template

### Complete Chart Structure

```
spring-boot-app/
├── Chart.yaml
├── values.yaml
├── values-dev.yaml
├── values-staging.yaml
├── values-prod.yaml
└── templates/
    ├── deployment.yaml
    ├── service.yaml
    ├── configmap.yaml
    ├── secret.yaml
    ├── ingress.yaml
    ├── hpa.yaml
    ├── serviceaccount.yaml
    ├── pdb.yaml
    ├── NOTES.txt
    └── _helpers.tpl
```

---

### Chart.yaml

```yaml
apiVersion: v2
name: spring-boot-app
description: Production-ready Helm chart for Spring Boot applications
type: application
version: 1.0.0
appVersion: "1.0.0"

keywords:
  - spring-boot
  - java
  - microservice
  - web

maintainers:
  - name: DevOps Team
    email: devops@example.com

home: https://github.com/mycompany/spring-boot-app
sources:
  - https://github.com/mycompany/spring-boot-app

icon: https://spring.io/images/spring-logo.svg

# Dependencies (optional)
dependencies:
  - name: postgresql
    version: "~12.1.0"
    repository: https://charts.bitnami.com/bitnami
    condition: postgresql.enabled
  
  - name: redis
    version: "~17.3.0"
    repository: https://charts.bitnami.com/bitnami
    condition: redis.enabled
    alias: cache

kubeVersion: ">=1.24.0-0"
```

---

### values.yaml (Comprehensive Default Configuration)

```yaml
# values.yaml - Production defaults

# Global settings
global:
  imageRegistry: ""
  imagePullSecrets: []

# Number of replicas
replicaCount: 3

# Image configuration
image:
  registry: docker.io
  repository: mycompany/spring-boot-app
  tag: ""  # Overrides Chart.AppVersion
  pullPolicy: IfNotPresent

# Image pull secrets
imagePullSecrets: []
# - name: regcred

# Name overrides
nameOverride: ""
fullnameOverride: ""

# ServiceAccount configuration
serviceAccount:
  create: true
  annotations: {}
  name: ""

# Pod annotations
podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "8080"
  prometheus.io/path: "/actuator/prometheus"

# Pod labels
podLabels:
  app.kubernetes.io/component: backend
  app.kubernetes.io/part-of: myapp

# Pod security context
podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 1000
  seccompProfile:
    type: RuntimeDefault

# Container security context
securityContext:
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true
  runAsNonRoot: true
  runAsUser: 1000
  capabilities:
    drop:
    - ALL

# Service configuration
service:
  type: ClusterIP
  port: 80
  targetPort: 8080
  annotations: {}
  # For LoadBalancer type
  # loadBalancerIP: ""
  # loadBalancerSourceRanges: []

# Ingress configuration
ingress:
  enabled: false
  className: "nginx"
  annotations:
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
  hosts:
    - host: myapp.example.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: myapp-tls
      hosts:
        - myapp.example.com

# Resource configuration
resources:
  limits:
    cpu: 1000m
    memory: 1Gi
  requests:
    cpu: 500m
    memory: 512Mi

# JVM configuration
jvm:
  # Memory settings (percentage of container memory)
  memory:
    initialRAMPercentage: 50.0
    maxRAMPercentage: 75.0
  
  # GC settings
  gc:
    type: G1GC  # G1GC, ParallelGC, ZGC, ShenandoahGC
    maxGCPauseMillis: 100
  
  # Additional JVM options
  extraOpts: ""
  # extraOpts: "-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof"

# Spring Boot configuration
springBoot:
  profile: production
  
  # Actuator endpoints
  management:
    endpoints:
      web:
        exposure:
          include: health,info,metrics,prometheus
    health:
      probes:
        enabled: true
  
  # Server configuration
  server:
    port: 8080
    shutdown: graceful
  
  # Graceful shutdown timeout
  lifecycle:
    timeout: 30s

# Environment variables
env: []
# - name: ENVIRONMENT
#   value: "production"
# - name: LOG_LEVEL
#   value: "INFO"

# Environment variables from ConfigMap
envFrom: []
# - configMapRef:
#     name: app-config
# - secretRef:
#     name: app-secrets

# Health checks
livenessProbe:
  httpGet:
    path: /actuator/health/liveness
    port: 8080
  initialDelaySeconds: 60
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3
  successThreshold: 1

readinessProbe:
  httpGet:
    path: /actuator/health/readiness
    port: 8080
  initialDelaySeconds: 30
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 3
  successThreshold: 1

startupProbe:
  httpGet:
    path: /actuator/health/liveness
    port: 8080
  initialDelaySeconds: 0
  periodSeconds: 10
  timeoutSeconds: 3
  failureThreshold: 30  # 5 minutes total
  successThreshold: 1

# Lifecycle hooks
lifecycle:
  preStop:
    exec:
      command:
        - sh
        - -c
        - sleep 10

# Volumes
volumes: []
# - name: tmp
#   emptyDir: {}
# - name: cache
#   emptyDir: {}

volumeMounts: []
# - name: tmp
#   mountPath: /tmp
# - name: cache
#   mountPath: /app/cache

# Pod Disruption Budget
podDisruptionBudget:
  enabled: true
  minAvailable: 1
  # maxUnavailable: 1

# Autoscaling
autoscaling:
  enabled: false
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 0
      policies:
      - type: Percent
        value: 100
        periodSeconds: 15

# Node selection
nodeSelector: {}
# disktype: ssd
# node-role: worker

tolerations: []
# - key: "key"
#   operator: "Equal"
#   value: "value"
#   effect: "NoSchedule"

affinity: {}
# podAntiAffinity:
#   preferredDuringSchedulingIgnoredDuringExecution:
#   - weight: 100
#     podAffinityTerm:
#       labelSelector:
#         matchExpressions:
#         - key: app.kubernetes.io/name
#           operator: In
#           values:
#           - spring-boot-app
#       topologyKey: kubernetes.io/hostname

# Pod priority
priorityClassName: ""

# Deployment strategy
strategy:
  type: RollingUpdate
  rollingUpdate:
    maxSurge: 1
    maxUnavailable: 0

# Termination grace period
terminationGracePeriodSeconds: 40

# ConfigMap for application configuration
config:
  # application.yaml content
  application: |
    spring:
      application:
        name: ${SPRING_APPLICATION_NAME:myapp}
      datasource:
        url: jdbc:postgresql://${DATABASE_HOST:localhost}:${DATABASE_PORT:5432}/${DATABASE_NAME:mydb}
        username: ${DATABASE_USERNAME:appuser}
        hikari:
          maximum-pool-size: 20
          minimum-idle: 5
          connection-timeout: 30000
          idle-timeout: 600000
          max-lifetime: 1800000
      
      jpa:
        hibernate:
          ddl-auto: validate
        show-sql: false
        properties:
          hibernate:
            format_sql: false
            dialect: org.hibernate.dialect.PostgreSQLDialect
      
      redis:
        host: ${REDIS_HOST:localhost}
        port: ${REDIS_PORT:6379}
        timeout: 2000ms
        lettuce:
          pool:
            max-active: 8
            max-idle: 8
            min-idle: 2
    
    server:
      port: ${SERVER_PORT:8080}
      shutdown: graceful
      tomcat:
        threads:
          max: 200
          min-spare: 10
        connection-timeout: 20000
    
    management:
      endpoints:
        web:
          exposure:
            include: health,info,metrics,prometheus
      endpoint:
        health:
          probes:
            enabled: true
          show-details: when-authorized
      metrics:
        export:
          prometheus:
            enabled: true
    
    logging:
      level:
        root: INFO
        com.mycompany: DEBUG
      pattern:
        console: "%d{yyyy-MM-dd HH:mm:ss} - %logger{36} - %msg%n"

  # Additional config files
  # logback-spring.xml: |
  #   <configuration>
  #     ...
  #   </configuration>

# Secret for sensitive data
secrets:
  # Database credentials
  database:
    username: appuser
    password: ""  # Must be set via --set or sealed-secrets
    name: mydb
  
  # Redis password
  redis:
    password: ""
  
  # JWT secret
  jwt:
    secret: ""

# PostgreSQL dependency (optional)
postgresql:
  enabled: false
  auth:
    username: appuser
    password: ""
    database: mydb
  primary:
    persistence:
      enabled: true
      size: 10Gi
    resources:
      limits:
        memory: 2Gi
        cpu: 1000m

# Redis dependency (optional)
cache:
  enabled: false
  auth:
    enabled: true
    password: ""
  master:
    persistence:
      enabled: false
  resources:
    limits:
      memory: 512Mi
      cpu: 500m
```

---

### templates/deployment.yaml

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "spring-boot-app.fullname" . }}
  labels:
    {{- include "spring-boot-app.labels" . | nindent 4 }}
spec:
  {{- if not .Values.autoscaling.enabled }}
  replicas: {{ .Values.replicaCount }}
  {{- end }}
  
  strategy:
    {{- toYaml .Values.strategy | nindent 4 }}
  
  selector:
    matchLabels:
      {{- include "spring-boot-app.selectorLabels" . | nindent 6 }}
  
  template:
    metadata:
      annotations:
        checksum/config: {{ include (print $.Template.BasePath "/configmap.yaml") . | sha256sum }}
        checksum/secret: {{ include (print $.Template.BasePath "/secret.yaml") . | sha256sum }}
        {{- with .Values.podAnnotations }}
        {{- toYaml . | nindent 8 }}
        {{- end }}
      labels:
        {{- include "spring-boot-app.selectorLabels" . | nindent 8 }}
        {{- with .Values.podLabels }}
        {{- toYaml . | nindent 8 }}
        {{- end }}
    
    spec:
      {{- with .Values.imagePullSecrets }}
      imagePullSecrets:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      
      serviceAccountName: {{ include "spring-boot-app.serviceAccountName" . }}
      
      securityContext:
        {{- toYaml .Values.podSecurityContext | nindent 8 }}
      
      {{- if .Values.priorityClassName }}
      priorityClassName: {{ .Values.priorityClassName }}
      {{- end }}
      
      containers:
      - name: {{ .Chart.Name }}
        securityContext:
          {{- toYaml .Values.securityContext | nindent 10 }}
        
        image: "{{ .Values.image.registry }}/{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}"
        imagePullPolicy: {{ .Values.image.pullPolicy }}
        
        ports:
        - name: http
          containerPort: {{ .Values.springBoot.server.port }}
          protocol: TCP
        
        env:
        # Spring Boot profile
        - name: SPRING_PROFILES_ACTIVE
          value: {{ .Values.springBoot.profile | quote }}
        
        # Application name
        - name: SPRING_APPLICATION_NAME
          value: {{ include "spring-boot-app.fullname" . }}
        
        # Server port
        - name: SERVER_PORT
          value: {{ .Values.springBoot.server.port | quote }}
        
        # JVM options
        - name: JAVA_OPTS
          value: >-
            -XX:+UseContainerSupport
            -XX:InitialRAMPercentage={{ .Values.jvm.memory.initialRAMPercentage }}
            -XX:MaxRAMPercentage={{ .Values.jvm.memory.maxRAMPercentage }}
            {{- if eq .Values.jvm.gc.type "G1GC" }}
            -XX:+UseG1GC
            -XX:MaxGCPauseMillis={{ .Values.jvm.gc.maxGCPauseMillis }}
            {{- else if eq .Values.jvm.gc.type "ZGC" }}
            -XX:+UseZGC
            {{- else if eq .Values.jvm.gc.type "ShenandoahGC" }}
            -XX:+UseShenandoahGC
            {{- end }}
            -XX:+HeapDumpOnOutOfMemoryError
            -XX:HeapDumpPath=/tmp/heapdump.hprof
            -XX:+ExitOnOutOfMemoryError
            {{- if .Values.jvm.extraOpts }}
            {{ .Values.jvm.extraOpts }}
            {{- end }}
        
        # Spring config location
        - name: SPRING_CONFIG_LOCATION
          value: "file:/config/application.yaml"
        
        # Database configuration
        {{- if .Values.postgresql.enabled }}
        - name: DATABASE_HOST
          value: {{ include "spring-boot-app.fullname" . }}-postgresql
        - name: DATABASE_PORT
          value: "5432"
        {{- end }}
        - name: DATABASE_NAME
          valueFrom:
            secretKeyRef:
              name: {{ include "spring-boot-app.fullname" . }}-secret
              key: database-name
        - name: DATABASE_USERNAME
          valueFrom:
            secretKeyRef:
              name: {{ include "spring-boot-app.fullname" . }}-secret
              key: database-username
        - name: DATABASE_PASSWORD
          valueFrom:
            secretKeyRef:
              name: {{ include "spring-boot-app.fullname" . }}-secret
              key: database-password
        
        # Redis configuration
        {{- if .Values.cache.enabled }}
        - name: REDIS_HOST
          value: {{ include "spring-boot-app.fullname" . }}-cache-master
        - name: REDIS_PORT
          value: "6379"
        - name: REDIS_PASSWORD
          valueFrom:
            secretKeyRef:
              name: {{ include "spring-boot-app.fullname" . }}-secret
              key: redis-password
        {{- end }}
        
        # Pod metadata (Downward API)
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: POD_IP
          valueFrom:
            fieldRef:
              fieldPath: status.podIP
        
        # Additional environment variables
        {{- with .Values.env }}
        {{- toYaml . | nindent 8 }}
        {{- end }}
        
        {{- with .Values.envFrom }}
        envFrom:
        {{- toYaml . | nindent 8 }}
        {{- end }}
        
        volumeMounts:
        - name: config
          mountPath: /config
          readOnly: true
        - name: tmp
          mountPath: /tmp
        {{- with .Values.volumeMounts }}
        {{- toYaml . | nindent 8 }}
        {{- end }}
        
        {{- with .Values.livenessProbe }}
        livenessProbe:
          {{- toYaml . | nindent 10 }}
        {{- end }}
        
        {{- with .Values.readinessProbe }}
        readinessProbe:
          {{- toYaml . | nindent 10 }}
        {{- end }}
        
        {{- with .Values.startupProbe }}
        startupProbe:
          {{- toYaml . | nindent 10 }}
        {{- end }}
        
        resources:
          {{- toYaml .Values.resources | nindent 10 }}
        
        {{- with .Values.lifecycle }}
        lifecycle:
          {{- toYaml . | nindent 10 }}
        {{- end }}
      
      volumes:
      - name: config
        configMap:
          name: {{ include "spring-boot-app.fullname" . }}-config
      - name: tmp
        emptyDir: {}
      {{- with .Values.volumes }}
      {{- toYaml . | nindent 6 }}
      {{- end }}
      
      {{- with .Values.nodeSelector }}
      nodeSelector:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      
      {{- with .Values.affinity }}
      affinity:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      
      {{- with .Values.tolerations }}
      tolerations:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      
      terminationGracePeriodSeconds: {{ .Values.terminationGracePeriodSeconds }}
```

---

### templates/service.yaml

```yaml
apiVersion: v1
kind: Service
metadata:
  name: {{ include "spring-boot-app.fullname" . }}
  labels:
    {{- include "spring-boot-app.labels" . | nindent 4 }}
  {{- with .Values.service.annotations }}
  annotations:
    {{- toYaml . | nindent 4 }}
  {{- end }}
spec:
  type: {{ .Values.service.type }}
  
  {{- if and (eq .Values.service.type "LoadBalancer") .Values.service.loadBalancerIP }}
  loadBalancerIP: {{ .Values.service.loadBalancerIP }}
  {{- end }}
  
  {{- if and (eq .Values.service.type "LoadBalancer") .Values.service.loadBalancerSourceRanges }}
  loadBalancerSourceRanges:
  {{- range .Values.service.loadBalancerSourceRanges }}
  - {{ . }}
  {{- end }}
  {{- end }}
  
  ports:
  - port: {{ .Values.service.port }}
    targetPort: http
    protocol: TCP
    name: http
    {{- if and (eq .Values.service.type "NodePort") .Values.service.nodePort }}
    nodePort: {{ .Values.service.nodePort }}
    {{- end }}
  
  selector:
    {{- include "spring-boot-app.selectorLabels" . | nindent 4 }}
```

---

### templates/configmap.yaml

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "spring-boot-app.fullname" . }}-config
  labels:
    {{- include "spring-boot-app.labels" . | nindent 4 }}
data:
  application.yaml: |
{{ .Values.config.application | indent 4 }}
  
  {{- range $key, $value := .Values.config }}
  {{- if ne $key "application" }}
  {{ $key }}: |
{{ $value | indent 4 }}
  {{- end }}
  {{- end }}
```

---

### templates/secret.yaml

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: {{ include "spring-boot-app.fullname" . }}-secret
  labels:
    {{- include "spring-boot-app.labels" . | nindent 4 }}
type: Opaque
stringData:
  database-username: {{ .Values.secrets.database.username | quote }}
  database-password: {{ required "secrets.database.password is required" .Values.secrets.database.password | quote }}
  database-name: {{ .Values.secrets.database.name | quote }}
  
  {{- if .Values.cache.enabled }}
  redis-password: {{ required "secrets.redis.password is required" .Values.secrets.redis.password | quote }}
  {{- end }}
  
  {{- if .Values.secrets.jwt.secret }}
  jwt-secret: {{ .Values.secrets.jwt.secret | quote }}
  {{- end }}
```

---

### templates/ingress.yaml

```yaml
{{- if .Values.ingress.enabled -}}
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: {{ include "spring-boot-app.fullname" . }}
  labels:
    {{- include "spring-boot-app.labels" . | nindent 4 }}
  {{- with .Values.ingress.annotations }}
  annotations:
    {{- toYaml . | nindent 4 }}
  {{- end }}
spec:
  {{- if .Values.ingress.className }}
  ingressClassName: {{ .Values.ingress.className }}
  {{- end }}
  
  {{- if .Values.ingress.tls }}
  tls:
  {{- range .Values.ingress.tls }}
  - hosts:
    {{- range .hosts }}
    - {{ . | quote }}
    {{- end }}
    secretName: {{ .secretName }}
  {{- end }}
  {{- end }}
  
  rules:
  {{- range .Values.ingress.hosts }}
  - host: {{ .host | quote }}
    http:
      paths:
      {{- range .paths }}
      - path: {{ .path }}
        pathType: {{ .pathType }}
        backend:
          service:
            name: {{ include "spring-boot-app.fullname" $ }}
            port:
              number: {{ $.Values.service.port }}
      {{- end }}
  {{- end }}
{{- end }}
```

---

### templates/hpa.yaml

```yaml
{{- if .Values.autoscaling.enabled }}
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: {{ include "spring-boot-app.fullname" . }}
  labels:
    {{- include "spring-boot-app.labels" . | nindent 4 }}
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: {{ include "spring-boot-app.fullname" . }}
  
  minReplicas: {{ .Values.autoscaling.minReplicas }}
  maxReplicas: {{ .Values.autoscaling.maxReplicas }}
  
  metrics:
  {{- if .Values.autoscaling.targetCPUUtilizationPercentage }}
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: {{ .Values.autoscaling.targetCPUUtilizationPercentage }}
  {{- end }}
  
  {{- if .Values.autoscaling.targetMemoryUtilizationPercentage }}
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: {{ .Values.autoscaling.targetMemoryUtilizationPercentage }}
  {{- end }}
  
  {{- with .Values.autoscaling.behavior }}
  behavior:
    {{- toYaml . | nindent 4 }}
  {{- end }}
{{- end }}
```

---

### templates/_helpers.tpl

```yaml
{{/*
Expand the name of the chart.
*/}}
{{- define "spring-boot-app.name" -}}
{{- default .Chart.Name .Values.nameOverride | trunc 63 | trimSuffix "-" }}
{{- end }}

{{/*
Create a default fully qualified app name.
*/}}
{{- define "spring-boot-app.fullname" -}}
{{- if .Values.fullnameOverride }}
{{- .Values.fullnameOverride | trunc 63 | trimSuffix "-" }}
{{- else }}
{{- $name := default .Chart.Name .Values.nameOverride }}
{{- if contains $name .Release.Name }}
{{- .Release.Name | trunc 63 | trimSuffix "-" }}
{{- else }}
{{- printf "%s-%s" .Release.Name $name | trunc 63 | trimSuffix "-" }}
{{- end }}
{{- end }}
{{- end }}

{{/*
Create chart name and version as used by the chart label.
*/}}
{{- define "spring-boot-app.chart" -}}
{{- printf "%s-%s" .Chart.Name .Chart.Version | replace "+" "_" | trunc 63 | trimSuffix "-" }}
{{- end }}

{{/*
Common labels
*/}}
{{- define "spring-boot-app.labels" -}}
helm.sh/chart: {{ include "spring-boot-app.chart" . }}
{{ include "spring-boot-app.selectorLabels" . }}
{{- if .Chart.AppVersion }}
app.kubernetes.io/version: {{ .Chart.AppVersion | quote }}
{{- end }}
app.kubernetes.io/managed-by: {{ .Release.Service }}
{{- end }}

{{/*
Selector labels
*/}}
{{- define "spring-boot-app.selectorLabels" -}}
app.kubernetes.io/name: {{ include "spring-boot-app.name" . }}
app.kubernetes.io/instance: {{ .Release.Name }}
{{- end }}

{{/*
Create the name of the service account to use
*/}}
{{- define "spring-boot-app.serviceAccountName" -}}
{{- if .Values.serviceAccount.create }}
{{- default (include "spring-boot-app.fullname" .) .Values.serviceAccount.name }}
{{- else }}
{{- default "default" .Values.serviceAccount.name }}
{{- end }}
{{- end }}
```

---

### Environment-Specific Values

#### values-dev.yaml

```yaml
# Development environment configuration
replicaCount: 1

image:
  tag: latest
  pullPolicy: Always

springBoot:
  profile: dev

resources:
  limits:
    cpu: 500m
    memory: 512Mi
  requests:
    cpu: 250m
    memory: 256Mi

jvm:
  memory:
    maxRAMPercentage: 80.0

autoscaling:
  enabled: false

ingress:
  enabled: true
  hosts:
    - host: myapp-dev.example.com
      paths:
        - path: /
          pathType: Prefix
  tls: []

postgresql:
  enabled: true
  auth:
    password: devpassword

cache:
  enabled: true
  auth:
    password: devredis

secrets:
  database:
    password: devpassword
  redis:
    password: devredis

config:
  application: |
    spring:
      datasource:
        url: jdbc:postgresql://${DATABASE_HOST}:5432/${DATABASE_NAME}
        username: ${DATABASE_USERNAME}
      jpa:
        show-sql: true
    logging:
      level:
        root: DEBUG
        com.mycompany: TRACE
```

---

#### values-prod.yaml

```yaml
# Production environment configuration
replicaCount: 5

image:
  tag: v1.2.3  # Always use specific version!
  pullPolicy: IfNotPresent

springBoot:
  profile: production

resources:
  limits:
    cpu: 2000m
    memory: 2Gi
  requests:
    cpu: 1000m
    memory: 1Gi

jvm:
  memory:
    initialRAMPercentage: 50.0
    maxRAMPercentage: 75.0
  gc:
    type: G1GC
    maxGCPauseMillis: 100

autoscaling:
  enabled: true
  minReplicas: 5
  maxReplicas: 20
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

podDisruptionBudget:
  enabled: true
  minAvailable: 3

ingress:
  enabled: true
  className: nginx
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/rate-limit: "100"
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
  hosts:
    - host: myapp.example.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: myapp-prod-tls
      hosts:
        - myapp.example.com

postgresql:
  enabled: true
  auth:
    password: ""  # Set via --set or sealed-secrets
  primary:
    persistence:
      size: 50Gi
      storageClass: fast-ssd
    resources:
      limits:
        cpu: 2000m
        memory: 4Gi
      requests:
        cpu: 1000m
        memory: 2Gi

cache:
  enabled: true
  auth:
    password: ""
  master:
    resources:
      limits:
        cpu: 1000m
        memory: 1Gi

secrets:
  database:
    password: ""  # Must be set!
  redis:
    password: ""  # Must be set!

affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
    - weight: 100
      podAffinityTerm:
        labelSelector:
          matchExpressions:
          - key: app.kubernetes.io/name
            operator: In
            values:
            - spring-boot-app
        topologyKey: kubernetes.io/hostname

config:
  application: |
    spring:
      datasource:
        hikari:
          maximum-pool-size: 50
          connection-timeout: 20000
      jpa:
        show-sql: false
    logging:
      level:
        root: WARN
        com.mycompany: INFO
```

---

## 2. Best Practices

### Immutable Tags (Not :latest)

**❌ BAD: Using :latest**

```yaml
# DON'T DO THIS IN PRODUCTION!
image:
  tag: latest
  pullPolicy: Always

# Problems:
# - No version control
# - Can't rollback
# - Unpredictable deployments
# - Cache issues
# - Difficult debugging
```

**✅ GOOD: Using specific versions**

```yaml
# values-prod.yaml
image:
  tag: v1.2.3  # Semantic versioning
  pullPolicy: IfNotPresent

# OR
image:
  tag: "20241114-abc123"  # Date + commit hash
  pullPolicy: IfNotPresent

# OR
image:
  tag: sha256:abc123...  # Digest (most immutable)
  pullPolicy: IfNotPresent
```

**Best practices:**

```yaml
# 1. Use semantic versioning
image:
  tag: v1.2.3

# 2. Include build metadata
image:
  tag: v1.2.3-20241114

# 3. Use commit hash
image:
  tag: v1.2.3-abc123

# 4. Use image digest (most secure)
image:
  repository: myapp
  digest: sha256:abc123def456...
```

**CI/CD Integration:**

```bash
# In CI/CD pipeline, set tag dynamically
helm upgrade myapp ./spring-boot-app \
  --set image.tag=${GIT_TAG} \
  --set image.pullPolicy=IfNotPresent
```

---

### Resource Requests/Limits

**Calculate appropriate values:**

```yaml
# Small application (< 100 RPS)
resources:
  requests:
    cpu: 250m      # 0.25 CPU cores
    memory: 512Mi  # 512 MB
  limits:
    cpu: 500m      # 0.5 CPU cores
    memory: 512Mi  # 512 MB (no burstable memory for Java!)

jvm:
  memory:
    maxRAMPercentage: 75.0  # 384 MB heap (75% of 512MB)

# Medium application (100-1000 RPS)
resources:
  requests:
    cpu: 500m
    memory: 1Gi
  limits:
    cpu: 1000m
    memory: 1Gi

jvm:
  memory:
    maxRAMPercentage: 75.0  # 768 MB heap

# Large application (> 1000 RPS)
resources:
  requests:
    cpu: 1000m
    memory: 2Gi
  limits:
    cpu: 2000m
    memory: 2Gi

jvm:
  memory:
    maxRAMPercentage: 75.0  # 1.5 GB heap
```

**Memory calculation:**

```
Container Memory: 1 Gi (1024 MB)
├── JVM Heap: 768 MB (75%)
└── Off-heap: 256 MB (25%)
    ├── Metaspace: ~100 MB
    ├── Thread stacks: ~50 MB
    ├── Direct buffers: ~50 MB
    └── Native memory: ~56 MB
```

---

### Health Check Configuration

**Production-ready probes:**

```yaml
# Startup probe (for slow-starting apps)
startupProbe:
  httpGet:
    path: /actuator/health/liveness
    port: 8080
  initialDelaySeconds: 0
  periodSeconds: 10
  timeoutSeconds: 3
  failureThreshold: 30      # 5 minutes total
  successThreshold: 1

# Liveness probe (restart if fails)
livenessProbe:
  httpGet:
    path: /actuator/health/liveness
    port: 8080
    scheme: HTTP
  initialDelaySeconds: 60   # After startup probe succeeds
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3       # Restart after 30 seconds
  successThreshold: 1

# Readiness probe (remove from service if fails)
readinessProbe:
  httpGet:
    path: /actuator/health/readiness
    port: 8080
    scheme: HTTP
  initialDelaySeconds: 30
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 3       # Remove after 15 seconds
  successThreshold: 1       # Add back immediately
```

**Spring Boot health endpoint configuration:**

```yaml
# application.yaml
management:
  endpoint:
    health:
      probes:
        enabled: true
      show-details: when-authorized
      group:
        liveness:
          include: livenessState,diskSpace
        readiness:
          include: readinessState,db,redis
  health:
    livenessState:
      enabled: true
    readinessState:
      enabled: true
```

---

### Rolling Update Strategy

```yaml
# Production strategy
strategy:
  type: RollingUpdate
  rollingUpdate:
    maxSurge: 1         # Create 1 extra pod
    maxUnavailable: 0   # Zero downtime!

# Explanation:
# With 5 replicas:
# 1. Create 1 new pod (total: 6)
# 2. Wait for new pod ready
# 3. Terminate 1 old pod (total: 5)
# 4. Repeat until all updated
```

**Strategy examples:**

```yaml
# Fast rollout (can have downtime)
strategy:
  type: RollingUpdate
  rollingUpdate:
    maxSurge: 2
    maxUnavailable: 1

# Zero downtime (recommended for production)
strategy:
  type: RollingUpdate
  rollingUpdate:
    maxSurge: 1
    maxUnavailable: 0

# Recreate (all pods terminated, then created)
strategy:
  type: Recreate
  # Use only for non-HA apps or breaking changes
```

---

### Annotations and Labels

**Recommended labels:**

```yaml
podLabels:
  # Standard Kubernetes labels
  app.kubernetes.io/name: spring-boot-app
  app.kubernetes.io/instance: myapp-prod
  app.kubernetes.io/version: "1.2.3"
  app.kubernetes.io/component: backend
  app.kubernetes.io/part-of: myapp
  app.kubernetes.io/managed-by: Helm
  
  # Custom labels
  team: platform
  env: production
  cost-center: engineering
```

**Recommended annotations:**

```yaml
podAnnotations:
  # Prometheus scraping
  prometheus.io/scrape: "true"
  prometheus.io/port: "8080"
  prometheus.io/path: "/actuator/prometheus"
  
  # Checksum for auto-restart on config change
  checksum/config: {{ include (print $.Template.BasePath "/configmap.yaml") . | sha256sum }}
  checksum/secret: {{ include (print $.Template.BasePath "/secret.yaml") . | sha256sum }}
  
  # Documentation
  description: "Spring Boot REST API"
  contact: "platform-team@example.com"
  
  # Build information
  build.version: "1.2.3"
  build.commit: "abc123"
  build.date: "2024-11-14"
```

---

## Deployment Commands

```bash
# Install chart
helm install myapp ./spring-boot-app \
  -f values-prod.yaml \
  --set secrets.database.password=${DB_PASSWORD} \
  --set secrets.redis.password=${REDIS_PASSWORD} \
  --namespace production \
  --create-namespace

# Upgrade chart
helm upgrade myapp ./spring-boot-app \
  -f values-prod.yaml \
  --set image.tag=v1.2.4 \
  --namespace production

# Dry run (test without applying)
helm install myapp ./spring-boot-app \
  -f values-prod.yaml \
  --dry-run --debug

# Rollback
helm rollback myapp 1 --namespace production

# Uninstall
helm uninstall myapp --namespace production
```

---

## Summary

### Spring Boot Chart Template

- ✅ Complete production-ready chart
- ✅ Configurable replicas with HPA
- ✅ ClusterIP/LoadBalancer service options
- ✅ ConfigMap for application configuration
- ✅ Secret for sensitive data
- ✅ Ingress with TLS support
- ✅ Comprehensive health checks
- ✅ PostgreSQL and Redis dependencies

### Best Practices

- ✅ **Immutable tags**: Never use :latest in production
- ✅ **Resource limits**: Set requests = limits for JVM apps
- ✅ **Health checks**: Startup, liveness, readiness probes
- ✅ **Rolling updates**: maxSurge=1, maxUnavailable=0 for zero downtime
- ✅ **Labels/Annotations**: Standard Kubernetes labels + custom metadata

### Key Configurations

- JVM heap: 75% of container memory
- Graceful shutdown: 30s + 10s preStop
- HPA: CPU 70%, Memory 80%
- PDB: minAvailable based on replicas
- Anti-affinity: Spread pods across nodes
