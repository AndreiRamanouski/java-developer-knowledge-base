
## 1. Java Application Dockerfile Patterns

### Spring Boot Application (Fat JAR)

Spring Boot creates a self-contained JAR with embedded Tomcat/Jetty. This is the most common pattern.

#### Basic Spring Boot Dockerfile

```dockerfile
FROM eclipse-temurin:17-jre-jammy

WORKDIR /app

# Copy the fat JAR
COPY target/myapp-1.0.0.jar app.jar

# Run the application
CMD ["java", "-jar", "app.jar"]
```

#### Production-Ready Spring Boot Dockerfile

```dockerfile
# ==============================================
# Build Stage
# ==============================================
FROM maven:3.9-eclipse-temurin-17 AS build

WORKDIR /build

# Copy Maven wrapper and pom.xml for dependency caching
COPY .mvn/ .mvn/
COPY mvnw pom.xml ./

# Download dependencies (this layer is cached)
RUN ./mvnw dependency:go-offline -B

# Copy source code
COPY src ./src

# Build the application
RUN ./mvnw clean package -DskipTests -B && \
    # Extract the JAR name from target directory
    mv target/*.jar target/app.jar

# ==============================================
# Runtime Stage
# ==============================================
FROM eclipse-temurin:17-jre-jammy

# Install curl for health checks
RUN apt-get update && \
    apt-get install -y --no-install-recommends curl && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

# Create non-root user
RUN groupadd -r spring && useradd -r -g spring spring

WORKDIR /app

# Copy JAR from build stage
COPY --from=build --chown=spring:spring /build/target/app.jar .

# Switch to non-root user
USER spring

# Expose application port
EXPOSE 8080

# Health check using Spring Boot Actuator
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
    CMD curl -f http://localhost:8080/actuator/health || exit 1

# JVM configuration for containers
ENV JAVA_OPTS="-XX:+UseContainerSupport \
               -XX:MaxRAMPercentage=75.0 \
               -XX:+UseG1GC \
               -XX:+UseStringDeduplication \
               -Djava.security.egd=file:/dev/./urandom"

# Run the application
ENTRYPOINT ["sh", "-c", "java ${JAVA_OPTS} -jar app.jar"]
```

#### Optimized with Layered JARs (Spring Boot 2.3+)

Spring Boot can split the JAR into layers for better caching:

```dockerfile
# ==============================================
# Build Stage
# ==============================================
FROM maven:3.9-eclipse-temurin-17 AS build

WORKDIR /build

COPY .mvn/ .mvn/
COPY mvnw pom.xml ./
RUN ./mvnw dependency:go-offline -B

COPY src ./src
RUN ./mvnw clean package -DskipTests -B

# Extract layers
RUN java -Djarmode=layertools -jar target/*.jar extract

# ==============================================
# Runtime Stage
# ==============================================
FROM eclipse-temurin:17-jre-jammy

RUN groupadd -r spring && useradd -r -g spring spring

WORKDIR /app

# Copy layers in order of least to most frequently changing
COPY --from=build --chown=spring:spring /build/dependencies/ ./
COPY --from=build --chown=spring:spring /build/spring-boot-loader/ ./
COPY --from=build --chown=spring:spring /build/snapshot-dependencies/ ./
COPY --from=build --chown=spring:spring /build/application/ ./

USER spring

EXPOSE 8080

ENTRYPOINT ["java", "-XX:+UseContainerSupport", "-XX:MaxRAMPercentage=75.0", \
            "org.springframework.boot.loader.JarLauncher"]
```

**Why layered JARs?**

- Dependencies change rarely → cached
- Your code changes often → only this layer rebuilds
- Faster builds and deployments!

#### Spring Boot with External Configuration

```dockerfile
FROM eclipse-temurin:17-jre-jammy

RUN groupadd -r spring && useradd -r -g spring spring

WORKDIR /app

# Copy JAR
COPY --chown=spring:spring target/app.jar .

# Create directory for external config
RUN mkdir -p /app/config && chown spring:spring /app/config

USER spring

EXPOSE 8080

# Spring Boot looks for config in these locations (in order):
# 1. /app/config/application.yml (mounted volume)
# 2. /app/application.yml
# 3. Inside JAR (default)

ENTRYPOINT ["java", "-jar", "app.jar"]
```

**Usage:**

```bash
# Mount external configuration
docker run -d \
  -v /path/to/application.yml:/app/config/application.yml \
  -p 8080:8080 \
  myapp:latest
```

---

### Microservice with Dependencies

Microservices often need external dependencies (databases, message queues, etc.)

#### Microservice Dockerfile

```dockerfile
# ==============================================
# Build Stage
# ==============================================
FROM maven:3.9-eclipse-temurin-17-alpine AS build

WORKDIR /build

# Dependency caching
COPY pom.xml .
RUN mvn dependency:go-offline -B

# Build
COPY src ./src
RUN mvn clean package -DskipTests -B

# ==============================================
# Runtime Stage
# ==============================================
FROM eclipse-temurin:17-jre-alpine

# Install required tools
RUN apk add --no-cache \
    curl \
    ca-certificates \
    tini

# Create non-root user
RUN addgroup -g 1000 microservice && \
    adduser -D -u 1000 -G microservice microservice

WORKDIR /app

# Copy JAR
COPY --from=build --chown=microservice:microservice /build/target/*.jar app.jar

USER microservice

EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=5s --start-period=60s --retries=3 \
    CMD curl -f http://localhost:8080/health || exit 1

# Use tini as init system (handles signals properly)
ENTRYPOINT ["/sbin/tini", "--"]

# JVM options for microservice
CMD ["java", \
     "-XX:+UseContainerSupport", \
     "-XX:MaxRAMPercentage=75.0", \
     "-XX:+UseG1GC", \
     "-XX:MaxGCPauseMillis=200", \
     "-XX:+UseStringDeduplication", \
     "-Djava.security.egd=file:/dev/./urandom", \
     "-jar", "app.jar"]
```

#### With Wait-for-it Script (Wait for Dependencies)

```dockerfile
FROM eclipse-temurin:17-jre-alpine

RUN apk add --no-cache bash curl

WORKDIR /app

# Download wait-for-it script
ADD https://raw.githubusercontent.com/vishnubob/wait-for-it/master/wait-for-it.sh /usr/local/bin/wait-for-it
RUN chmod +x /usr/local/bin/wait-for-it

COPY --from=build /build/target/*.jar app.jar

# Wait for database before starting
CMD ["wait-for-it", "db:5432", "--", \
     "java", "-jar", "app.jar"]
```

**Usage with docker-compose:**

```yaml
version: '3.8'
services:
  db:
    image: postgres:15
    environment:
      POSTGRES_PASSWORD: secret
  
  app:
    build: .
    depends_on:
      - db
    environment:
      SPRING_DATASOURCE_URL: jdbc:postgresql://db:5432/mydb
```

---

### Multi-Module Maven Projects

Multi-module projects have a parent POM and multiple child modules.

**Project Structure:**

```
my-project/
├── pom.xml (parent)
├── common/
│   ├── pom.xml
│   └── src/
├── service-a/
│   ├── pom.xml
│   └── src/
└── service-b/
    ├── pom.xml
    └── src/
```

#### Multi-Module Dockerfile

```dockerfile
# ==============================================
# Build Stage
# ==============================================
FROM maven:3.9-eclipse-temurin-17 AS build

WORKDIR /build

# Copy all POMs first (for caching)
COPY pom.xml .
COPY common/pom.xml common/
COPY service-a/pom.xml service-a/
COPY service-b/pom.xml service-b/

# Download dependencies for all modules
RUN mvn dependency:go-offline -B

# Copy all source code
COPY common/src common/src
COPY service-a/src service-a/src
COPY service-b/src service-b/src

# Build all modules
RUN mvn clean package -DskipTests -B

# ==============================================
# Runtime Stage for Service A
# ==============================================
FROM eclipse-temurin:17-jre-jammy AS service-a

RUN groupadd -r app && useradd -r -g app app

WORKDIR /app

# Copy only service-a JAR (dependencies are already included)
COPY --from=build --chown=app:app /build/service-a/target/*.jar app.jar

USER app

EXPOSE 8080

ENTRYPOINT ["java", "-jar", "app.jar"]

# ==============================================
# Runtime Stage for Service B
# ==============================================
FROM eclipse-temurin:17-jre-jammy AS service-b

RUN groupadd -r app && useradd -r -g app app

WORKDIR /app

COPY --from=build --chown=app:app /build/service-b/target/*.jar app.jar

USER app

EXPOSE 8081

ENTRYPOINT ["java", "-jar", "app.jar"]
```

**Build specific service:**

```bash
# Build service-a
docker build --target service-a -t service-a:latest .

# Build service-b
docker build --target service-b -t service-b:latest .
```

#### Alternative: Separate Dockerfiles per Service

**common/Dockerfile:**

```dockerfile
# Build and publish common module to local Maven repo
FROM maven:3.9-eclipse-temurin-17 AS common-build

WORKDIR /build
COPY pom.xml .
COPY common/pom.xml common/
COPY common/src common/src

RUN mvn -pl common clean install -DskipTests -B
```

**service-a/Dockerfile:**

```dockerfile
FROM maven:3.9-eclipse-temurin-17 AS build

WORKDIR /build

# Copy parent POM
COPY pom.xml .

# Copy common module (built separately)
COPY --from=common-build /root/.m2 /root/.m2

# Copy service-a
COPY service-a/pom.xml service-a/
RUN mvn -pl service-a dependency:go-offline -B

COPY service-a/src service-a/src
RUN mvn -pl service-a clean package -DskipTests -B

# Runtime
FROM eclipse-temurin:17-jre-jammy

COPY --from=build /build/service-a/target/*.jar app.jar

CMD ["java", "-jar", "app.jar"]
```

---

### Gradle Applications

#### Basic Gradle Dockerfile

```dockerfile
# ==============================================
# Build Stage
# ==============================================
FROM gradle:8.5-jdk17 AS build

WORKDIR /build

# Copy Gradle wrapper and build files
COPY gradle/ gradle/
COPY gradlew settings.gradle build.gradle ./

# Download dependencies (cached layer)
RUN ./gradlew dependencies --no-daemon

# Copy source and build
COPY src ./src
RUN ./gradlew build -x test --no-daemon

# ==============================================
# Runtime Stage
# ==============================================
FROM eclipse-temurin:17-jre-jammy

RUN groupadd -r app && useradd -r -g app app

WORKDIR /app

# Copy JAR from build stage
COPY --from=build --chown=app:app /build/build/libs/*.jar app.jar

USER app

EXPOSE 8080

ENTRYPOINT ["java", "-jar", "app.jar"]
```

#### Optimized Gradle with Dependency Caching

```dockerfile
FROM gradle:8.5-jdk17 AS build

WORKDIR /build

# Copy only dependency-related files first
COPY build.gradle settings.gradle gradle.properties ./
COPY gradle/ gradle/
COPY gradlew ./

# Create empty source directories to satisfy Gradle
RUN mkdir -p src/main/java src/main/resources src/test/java

# Download dependencies (this layer is cached)
RUN ./gradlew build --no-daemon -x test || return 0

# Now copy actual source
COPY src ./src

# Build the application
RUN ./gradlew build -x test --no-daemon

# Runtime stage
FROM eclipse-temurin:17-jre-jammy

WORKDIR /app

COPY --from=build /build/build/libs/*.jar app.jar

CMD ["java", "-jar", "app.jar"]
```

#### Gradle Multi-Project Build

**Project Structure:**

```
my-project/
├── settings.gradle
├── build.gradle
├── module-a/
│   ├── build.gradle
│   └── src/
└── module-b/
    ├── build.gradle
    └── src/
```

**Dockerfile:**

```dockerfile
FROM gradle:8.5-jdk17 AS build

WORKDIR /build

# Copy Gradle configuration
COPY settings.gradle build.gradle gradle.properties ./
COPY gradle/ gradle/
COPY gradlew ./

# Copy all module build files
COPY module-a/build.gradle module-a/
COPY module-b/build.gradle module-b/

# Download dependencies
RUN ./gradlew dependencies --no-daemon || return 0

# Copy all source code
COPY module-a/src module-a/src
COPY module-b/src module-b/src

# Build all modules
RUN ./gradlew build -x test --no-daemon

# Runtime for module-a
FROM eclipse-temurin:17-jre-jammy AS module-a

WORKDIR /app
COPY --from=build /build/module-a/build/libs/*.jar app.jar
CMD ["java", "-jar", "app.jar"]

# Runtime for module-b
FROM eclipse-temurin:17-jre-jammy AS module-b

WORKDIR /app
COPY --from=build /build/module-b/build/libs/*.jar app.jar
CMD ["java", "-jar", "app.jar"]
```

---

## 2. Optimization Techniques

### Layer Caching Strategies

Docker caches each layer. Once a layer changes, all subsequent layers are rebuilt.

#### Layer Caching Rules:

1. **Order matters**: Put least-changing files first
2. **Invalidation**: Any change invalidates cache for that layer and all below
3. **Separate steps**: Separate dependency download from code compilation

#### ❌ Bad Caching Strategy:

```dockerfile
FROM maven:3.9-eclipse-temurin-17

WORKDIR /app

# Copies EVERYTHING - any file change invalidates cache
COPY . .

# Dependencies re-downloaded every time ANY file changes!
RUN mvn clean package -DskipTests

CMD ["java", "-jar", "target/app.jar"]
```

**Problem:** Changing a single Java file re-downloads all dependencies!

#### ✅ Good Caching Strategy:

```dockerfile
FROM maven:3.9-eclipse-temurin-17 AS build

WORKDIR /app

# Layer 1: Copy only dependency definitions (rarely changes)
COPY pom.xml .
COPY .mvn/ .mvn/
COPY mvnw .

# Layer 2: Download dependencies (cached unless pom.xml changes)
RUN ./mvnw dependency:go-offline -B

# Layer 3: Copy source code (changes frequently)
COPY src ./src

# Layer 4: Build (only rebuilds if src or pom.xml changed)
RUN ./mvnw clean package -DskipTests -B

# Runtime stage
FROM eclipse-temurin:17-jre-jammy
COPY --from=build /app/target/*.jar app.jar
CMD ["java", "-jar", "app.jar"]
```

**Build time comparison:**

```
First build: 3 minutes (downloads dependencies)
Code change: 30 seconds (dependencies cached!)
POM change: 2 minutes (re-downloads dependencies)
```

#### Advanced: Separate Dependency and Source Layers

```dockerfile
FROM maven:3.9-eclipse-temurin-17 AS dependencies

WORKDIR /app
COPY pom.xml .
RUN mvn dependency:go-offline -B && \
    mvn dependency:resolve-plugins -B

# Separate stage for build
FROM maven:3.9-eclipse-temurin-17 AS build

WORKDIR /app

# Copy cached dependencies from previous stage
COPY --from=dependencies /root/.m2 /root/.m2
COPY pom.xml .
COPY src ./src

RUN mvn package -DskipTests -B -o

# Runtime
FROM eclipse-temurin:17-jre-jammy
COPY --from=build /app/target/*.jar app.jar
CMD ["java", "-jar", "app.jar"]
```

#### Layer Caching with BuildKit

Enable BuildKit for better caching:

```dockerfile
# syntax=docker/dockerfile:1.4

FROM maven:3.9-eclipse-temurin-17 AS build

WORKDIR /app

# Use cache mount for Maven repository
COPY pom.xml .
RUN --mount=type=cache,target=/root/.m2 \
    mvn dependency:go-offline -B

COPY src ./src
RUN --mount=type=cache,target=/root/.m2 \
    mvn package -DskipTests -B

FROM eclipse-temurin:17-jre-jammy
COPY --from=build /app/target/*.jar app.jar
CMD ["java", "-jar", "app.jar"]
```

**Build with BuildKit:**

```bash
DOCKER_BUILDKIT=1 docker build -t myapp .
```

---

### .dockerignore Usage

`.dockerignore` excludes files from the build context (like `.gitignore` for Git).

#### Why Use .dockerignore?

1. **Faster builds**: Smaller context = faster upload to Docker daemon
2. **Smaller images**: Don't accidentally copy unnecessary files
3. **Security**: Don't copy secrets or sensitive files
4. **Cache efficiency**: Reduce false cache invalidations

#### Complete .dockerignore for Java Projects:

```
# Git
.git
.gitignore
.gitattributes

# IDE
.idea/
*.iml
.vscode/
.eclipse/
*.swp
*.swo

# Build outputs
target/
build/
out/
bin/

# Logs
*.log
logs/

# OS files
.DS_Store
Thumbs.db

# Documentation
README.md
CONTRIBUTING.md
docs/
*.md

# CI/CD
.github/
.gitlab-ci.yml
Jenkinsfile
.circleci/

# Docker
Dockerfile
docker-compose.yml
.dockerignore

# Dependencies (will be downloaded in container)
node_modules/
.m2/
.gradle/

# Environment files (NEVER include secrets!)
.env
.env.local
*.key
*.pem
*.p12

# Test files
src/test/

# Temporary files
tmp/
temp/
*.tmp

# Coverage reports
coverage/
*.coverage
```

#### Measuring Impact:

```bash
# Check build context size WITHOUT .dockerignore
docker build --no-cache -t myapp:test .
# Sending build context to Docker daemon: 500 MB

# Add .dockerignore, rebuild
docker build --no-cache -t myapp:test .
# Sending build context to Docker daemon: 50 MB

# 10x faster context upload!
```

#### Advanced .dockerignore Patterns:

```
# Ignore everything
*

# Then whitelist only what you need
!src/
!pom.xml
!.mvn/
!mvnw
!mvnw.cmd

# Ignore test sources
src/test/

# Ignore specific file types
**/*.log
**/*.tmp
**/.DS_Store
```

---

### Build-time vs Runtime Dependencies

Separate dependencies needed for building from those needed for running.

#### The Problem:

```dockerfile
# ❌ Bad: Build tools in production image
FROM maven:3.9-eclipse-temurin-17

WORKDIR /app
COPY . .
RUN mvn package

CMD ["java", "-jar", "target/app.jar"]

# Image includes:
# - Maven (50 MB)
# - Maven repository cache (200 MB)
# - JDK (300 MB) - only need JRE!
# - Source code (security risk!)
# Total: 600+ MB
```

#### The Solution: Multi-stage Builds

```dockerfile
# ==============================================
# BUILD-TIME DEPENDENCIES (Build Stage)
# ==============================================
FROM maven:3.9-eclipse-temurin-17 AS build

# Build tools available here:
# - Maven
# - JDK (includes compiler, javac)
# - Build plugins

WORKDIR /build
COPY pom.xml .
RUN mvn dependency:go-offline

COPY src ./src
RUN mvn package -DskipTests

# ==============================================
# RUNTIME DEPENDENCIES (Runtime Stage)
# ==============================================
FROM eclipse-temurin:17-jre-jammy

# Runtime needs only:
# - JRE (no compiler)
# - Application JAR
# - Runtime libraries (if any)

WORKDIR /app
COPY --from=build /build/target/*.jar app.jar

CMD ["java", "-jar", "app.jar"]

# Final image: 250 MB (only runtime dependencies!)
```

#### Dependency Categories:

**Build-time only:**

- Compilers (javac)
- Build tools (Maven, Gradle)
- Test frameworks (JUnit, Mockito)
- Code analysis tools (SonarQube, Checkstyle)
- Development utilities

**Runtime only:**

- JRE
- Database drivers (if not in fat JAR)
- Native libraries
- Configuration files
- Application JAR

**Both (rare):**

- Debugging tools (in dev images only)

#### Example with Native Dependencies:

```dockerfile
# Build stage - includes native build tools
FROM maven:3.9-eclipse-temurin-17 AS build

# Install native build tools (build-time only)
RUN apt-get update && \
    apt-get install -y \
        gcc \
        make \
        libssl-dev

WORKDIR /app
COPY . .
RUN mvn package -DskipTests

# Runtime stage - only runtime native libraries
FROM eclipse-temurin:17-jre-jammy

# Install only runtime libraries (NOT build tools)
RUN apt-get update && \
    apt-get install -y --no-install-recommends \
        libssl3 && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

COPY --from=build /app/target/*.jar app.jar

CMD ["java", "-jar", "app.jar"]
```

---

### JVM Tuning in Containers (Heap Size, GC)

JVM needs special configuration to work well in containers.

#### The Container Memory Problem

Before Java 10, JVM couldn't detect container memory limits:

```bash
# Container has 512 MB limit
docker run -m 512m myapp

# But JVM sees host memory (16 GB) and allocates huge heap!
# Result: Container gets killed by OOM!
```

#### Modern Solution: UseContainerSupport

**Java 10+** has built-in container awareness:

```dockerfile
CMD ["java", \
     "-XX:+UseContainerSupport", \
     "-XX:MaxRAMPercentage=75.0", \
     "-jar", "app.jar"]
```

**What this does:**

- JVM detects container memory limit
- Automatically sizes heap based on container memory
- Respects cgroup limits

#### JVM Memory Configuration Options:

**1. MaxRAMPercentage (Recommended):**

```dockerfile
# Use 75% of container memory for heap
ENV JAVA_OPTS="-XX:+UseContainerSupport -XX:MaxRAMPercentage=75.0"

# Why 75%? Reserve 25% for:
# - Non-heap memory (metaspace, code cache, threads)
# - Native memory
# - OS overhead
```

**2. Fixed Heap Size (Less Flexible):**

```dockerfile
# Set explicit heap size
ENV JAVA_OPTS="-Xms512m -Xmx512m"

# Pros: Predictable
# Cons: Not portable across different container sizes
```

**3. Adaptive Sizing:**

```dockerfile
# Let JVM decide initial heap
ENV JAVA_OPTS="-XX:+UseContainerSupport \
               -XX:MaxRAMPercentage=75.0 \
               -XX:InitialRAMPercentage=50.0"
```

#### Garbage Collection Tuning

**Default GC (G1GC - Recommended for most apps):**

```dockerfile
ENV JAVA_OPTS="-XX:+UseG1GC \
               -XX:MaxGCPauseMillis=200 \
               -XX:+UseStringDeduplication"
```

**For Low-Latency Applications:**

```dockerfile
# ZGC - Ultra-low pause times
ENV JAVA_OPTS="-XX:+UseZGC \
               -XX:ZCollectionInterval=5"
```

**For High-Throughput Applications:**

```dockerfile
# Parallel GC - Maximum throughput
ENV JAVA_OPTS="-XX:+UseParallelGC \
               -XX:ParallelGCThreads=4"
```

#### Complete JVM Configuration:

```dockerfile
FROM eclipse-temurin:17-jre-jammy

WORKDIR /app
COPY target/app.jar .

# Comprehensive JVM configuration
ENV JAVA_OPTS="\
    -XX:+UseContainerSupport \
    -XX:MaxRAMPercentage=75.0 \
    -XX:InitialRAMPercentage=50.0 \
    -XX:+UseG1GC \
    -XX:MaxGCPauseMillis=200 \
    -XX:+UseStringDeduplication \
    -XX:+ExitOnOutOfMemoryError \
    -Djava.security.egd=file:/dev/./urandom \
    -XX:+HeapDumpOnOutOfMemoryError \
    -XX:HeapDumpPath=/app/dumps"

ENTRYPOINT ["sh", "-c", "java ${JAVA_OPTS} -jar app.jar"]
```

#### Memory Sizing Guide:

|Container Memory|Heap (-Xmx)|Why|
|---|---|---|
|512 MB|384 MB (75%)|128 MB for non-heap|
|1 GB|768 MB (75%)|256 MB for non-heap|
|2 GB|1.5 GB (75%)|512 MB for non-heap|
|4 GB|3 GB (75%)|1 GB for non-heap|

#### Monitoring JVM in Container:

```bash
# Check actual heap size
docker exec myapp java -XX:+PrintFlagsFinal -version | grep MaxHeapSize

# Monitor memory usage
docker stats myapp

# Get heap dump
docker exec myapp jcmd 1 GC.heap_dump /app/dumps/heap.hprof
docker cp myapp:/app/dumps/heap.hprof .
```

#### Spring Boot-Specific Settings:

```dockerfile
ENV JAVA_OPTS="-XX:+UseContainerSupport \
               -XX:MaxRAMPercentage=75.0"

# Spring Boot Actuator exposes JVM metrics
ENV MANAGEMENT_METRICS_EXPORT_PROMETHEUS_ENABLED=true

CMD ["java", "${JAVA_OPTS}", "-jar", "app.jar"]
```

---

## 3. Security

### Non-Root Users

**WHY?** Running as root is a security risk. If container is compromised, attacker has root access!

#### ❌ Bad: Running as Root

```dockerfile
FROM eclipse-temurin:17-jre-jammy

WORKDIR /app
COPY target/app.jar .

# Runs as root (UID 0) by default!
CMD ["java", "-jar", "app.jar"]
```

**Risks:**

- Container compromise = root access to host
- Can modify system files
- Can install packages
- Can access other containers' data

#### ✅ Good: Non-Root User

```dockerfile
FROM eclipse-temurin:17-jre-jammy

# Create group and user
RUN groupadd -r appuser && \
    useradd -r -g appuser -u 1000 appuser

WORKDIR /app

# Copy files with correct ownership
COPY --chown=appuser:appuser target/app.jar .

# Switch to non-root user
USER appuser

# Now runs as appuser (UID 1000)
CMD ["java", "-jar", "app.jar"]
```

#### Alpine Linux Non-Root User:

```dockerfile
FROM eclipse-temurin:17-jre-alpine

# Alpine uses different commands
RUN addgroup -g 1000 appuser && \
    adduser -D -u 1000 -G appuser appuser

USER appuser

# Rest of Dockerfile...
```

#### Best Practices:

**1. Use specific UID/GID:**

```dockerfile
# Use consistent UID across environments
RUN groupadd -g 1000 appuser && \
    useradd -u 1000 -g appuser -m -s /bin/bash appuser
```

**2. Set file permissions:**

```dockerfile
# Ensure user can read/write necessary directories
RUN mkdir -p /app/logs /app/data && \
    chown -R appuser:appuser /app

USER appuser
```

**3. Use --chown in COPY:**

```dockerfile
# Set ownership during copy (more efficient)
COPY --chown=appuser:appuser target/app.jar .
```

**4. Read-only root filesystem:**

```dockerfile
# Even more secure - read-only filesystem
# Run with: docker run --read-only -v /tmp:/tmp myapp
```

#### Verify Non-Root:

```bash
# Check user inside container
docker run --rm myapp whoami
# Output: appuser (not root!)

# Check UID
docker run --rm myapp id
# Output: uid=1000(appuser) gid=1000(appuser)
```

---

### Distroless Images

Distroless images contain only your application and runtime dependencies. No shell, no package manager, no utilities!

#### Why Distroless?

**Benefits:**

- **Minimal attack surface**: No shell = can't execute shell commands
- **Smaller size**: No unnecessary tools
- **Security**: Can't install malware or tools
- **Compliance**: Meets strict security requirements

**Drawbacks:**

- **No debugging**: Can't docker exec into container
- **No shell**: Must use exec format in CMD
- **Limited troubleshooting**: Can't install tools at runtime

#### Basic Distroless Dockerfile:

```dockerfile
# Build stage
FROM maven:3.9-eclipse-temurin-17 AS build

WORKDIR /app
COPY pom.xml .
RUN mvn dependency:go-offline
COPY src ./src
RUN mvn package -DskipTests

# Distroless runtime
FROM gcr.io/distroless/java17-debian12

WORKDIR /app
COPY --from=build /app/target/*.jar app.jar

# MUST use exec format (no shell!)
CMD ["app.jar"]
```

#### Distroless with Non-Root User:

```dockerfile
FROM gcr.io/distroless/java17-debian12:nonroot

# Already configured with user 'nonroot' (UID 65532)
WORKDIR /app

COPY --from=build --chown=nonroot:nonroot /app/target/*.jar app.jar

CMD ["app.jar"]
```

#### Distroless Variants:

```dockerfile
# Latest (default)
FROM gcr.io/distroless/java17-debian12

# Debug variant (includes busybox shell)
FROM gcr.io/distroless/java17-debian12:debug

# Non-root (runs as UID 65532)
FROM gcr.io/distroless/java17-debian12:nonroot

# Debug + non-root
FROM gcr.io/distroless/java17-debian12:debug-nonroot
```

#### Debugging Distroless:

**Option 1: Use debug variant**

```dockerfile
# Development
FROM gcr.io/distroless/java17-debian12:debug AS dev
# ... app setup ...

# Production
FROM gcr.io/distroless/java17-debian12 AS prod
# ... app setup ...
```

```bash
# Build dev image
docker build --target dev -t myapp:dev .

# Can now exec into it
docker exec -it myapp sh
```

**Option 2: Debug from another container**

```bash
# Run debug container in same namespace
docker run -it --rm \
  --pid=container:myapp \
  --net=container:myapp \
  busybox sh

# Now you can inspect processes, network, etc.
```

#### Available Distroless Images:

```
gcr.io/distroless/java-base-debian12    # Minimal Java runtime
gcr.io/distroless/java17-debian12       # Java 17
gcr.io/distroless/java21-debian12       # Java 21
```

---

### Vulnerability Scanning

Regularly scan images for known vulnerabilities (CVEs).

#### Popular Scanning Tools:

**1. Trivy (Recommended - Free & Comprehensive)**

```bash
# Install Trivy
brew install trivy
# or
curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin

# Scan image
trivy image myapp:latest

# Scan and fail on HIGH/CRITICAL vulnerabilities
trivy image --severity HIGH,CRITICAL --exit-code 1 myapp:latest

# Output to JSON
trivy image -f json -o results.json myapp:latest

# Scan Dockerfile
trivy config Dockerfile
```

**2. Docker Scout (Built-in)**

```bash
# Enable Docker Scout
docker scout quickview myapp:latest

# Detailed CVE report
docker scout cves myapp:latest

# Compare with another image
docker scout compare myapp:latest --to myapp:previous
```

**3. Snyk (Commercial)**

```bash
# Install Snyk
npm install -g snyk

# Scan image
snyk container test myapp:latest

# Monitor continuously
snyk container monitor myapp:latest
```

**4. Clair (Open Source)**

```bash
# Run Clair server
docker run -d --name clair -p 6060:6060 quay.io/coreos/clair:latest

# Scan with clairctl
clairctl analyze myapp:latest
```

#### Integrate Scanning in CI/CD:

**GitHub Actions:**

```yaml
name: Container Scan
on: [push]

jobs:
  scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Build image
        run: docker build -t myapp:latest .
      
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'myapp:latest'
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
      
      - name: Upload results
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'
      
      - name: Fail on vulnerabilities
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'myapp:latest'
          exit-code: '1'
          severity: 'CRITICAL,HIGH'
```

**GitLab CI:**

```yaml
container_scan:
  stage: test
  image:
    name: aquasec/trivy:latest
    entrypoint: [""]
  script:
    - trivy image --exit-code 1 --severity HIGH,CRITICAL $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  only:
    - main
```

**Jenkins:**

```groovy
pipeline {
    agent any
    stages {
        stage('Build') {
            steps {
                sh 'docker build -t myapp:${BUILD_NUMBER} .'
            }
        }
        stage('Scan') {
            steps {
                sh '''
                    trivy image \
                        --severity HIGH,CRITICAL \
                        --exit-code 1 \
                        myapp:${BUILD_NUMBER}
                '''
            }
        }
    }
}
```

#### Vulnerability Remediation:

```bash
# 1. Scan image
trivy image myapp:latest

# 2. Identify vulnerable packages
# Output shows: vulnerability in "openssl 1.1.1"

# 3. Update base image
# Change FROM ubuntu:20.04
# To FROM ubuntu:22.04

# 4. Rebuild and rescan
docker build -t myapp:latest .
trivy image myapp:latest

# 5. If still vulnerable, wait for patch or use workaround
```

---

### Secrets Management (NOT in Image!)

**CRITICAL:** Never embed secrets in Docker images!

#### ❌ NEVER Do This:

```dockerfile
# ❌ NEVER hardcode secrets
FROM eclipse-temurin:17-jre-jammy
ENV DATABASE_PASSWORD=mysecretpassword
ENV API_KEY=abc123xyz

# ❌ NEVER copy secret files
COPY application.properties .
# application.properties contains:
# database.password=mysecretpassword

# ❌ NEVER pass secrets as build args
ARG DB_PASSWORD=secret
ENV DATABASE_PASSWORD=${DB_PASSWORD}
```

**Why?** Images can be inspected, extracted, and secrets revealed!

```bash
# Anyone can see your secrets!
docker history myapp:latest
docker inspect myapp:latest
```

#### ✅ Correct Methods:

**1. Environment Variables at Runtime:**

```dockerfile
FROM eclipse-temurin:17-jre-jammy
WORKDIR /app
COPY target/app.jar .

# NO secrets in image!
CMD ["java", "-jar", "app.jar"]
```

```bash
# Pass secrets at runtime
docker run -d \
  -e DATABASE_PASSWORD=mysecret \
  -e API_KEY=abc123 \
  myapp:latest

# Or use env file
docker run -d --env-file .env myapp:latest
```

**2. Docker Secrets (Swarm/Kubernetes):**

```yaml
# docker-compose.yml with secrets
version: '3.8'
services:
  app:
    image: myapp:latest
    secrets:
      - db_password
      - api_key

secrets:
  db_password:
    external: true
  api_key:
    external: true
```

```bash
# Create secrets
echo "mysecretpassword" | docker secret create db_password -

# Access in app: /run/secrets/db_password
```

**3. HashiCorp Vault:**

```dockerfile
FROM eclipse-temurin:17-jre-jammy

# Install Vault agent
RUN apt-get update && apt-get install -y vault

WORKDIR /app
COPY target/app.jar .

# Vault agent fetches secrets at startup
COPY vault-agent.hcl /etc/vault/

CMD ["vault", "agent", "-config=/etc/vault/vault-agent.hcl"]
```

**4. AWS Secrets Manager / Azure Key Vault:**

```dockerfile
FROM eclipse-temurin:17-jre-jammy

WORKDIR /app
COPY target/app.jar .

# App fetches secrets from AWS Secrets Manager at startup
ENV AWS_REGION=us-east-1
ENV SECRET_NAME=myapp/prod

CMD ["java", "-jar", "app.jar"]
```

```java
// In Spring Boot application
@Configuration
public class SecretsConfig {
    @Bean
    public DataSource dataSource() {
        String password = getSecretFromAWS("myapp/prod", "db.password");
        // Configure datasource with fetched password
    }
}
```

**5. Kubernetes Secrets:**

```yaml
# secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: app-secrets
type: Opaque
stringData:
  database-password: mysecretpassword
  api-key: abc123xyz

---
# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  template:
    spec:
      containers:
      - name: app
        image: myapp:latest
        env:
        - name: DATABASE_PASSWORD
          valueFrom:
            secretKeyRef:
              name: app-secrets
              key: database-password
```

**6. Build-Time Secrets (BuildKit):**

```dockerfile
# syntax=docker/dockerfile:1.4

FROM maven:3.9-eclipse-temurin-17 AS build

WORKDIR /app

# Mount secret during build (not stored in image!)
RUN --mount=type=secret,id=maven_settings \
    cp /run/secrets/maven_settings ~/.m2/settings.xml && \
    mvn dependency:go-offline

COPY src ./src
RUN mvn package -DskipTests

FROM eclipse-temurin:17-jre-jammy
COPY --from=build /app/target/*.jar app.jar
CMD ["java", "-jar", "app.jar"]
```

```bash
# Build with secret
DOCKER_BUILDKIT=1 docker build \
  --secret id=maven_settings,src=~/.m2/settings.xml \
  -t myapp:latest .
```

#### Best Practices:

1. **Never** commit secrets to Git
2. **Never** hardcode secrets in Dockerfile
3. **Never** pass secrets as build arguments (they're cached!)
4. **Always** use runtime environment variables or secret management systems
5. **Always** use `.env` in `.gitignore`
6. **Always** rotate secrets regularly
7. **Use** secret scanning tools (git-secrets, truffleHog)

```bash
# Scan for secrets in Git history
truffleHog filesystem /path/to/repo

# Prevent secrets in commits
git-secrets --install
git-secrets --register-aws
```

---

## 4. Multi-Stage Builds

### Separate Build and Runtime Stages

Multi-stage builds are **essential** for Java applications to achieve optimal image size and security.

#### Single-Stage Build (BAD):

```dockerfile
FROM maven:3.9-eclipse-temurin-17

WORKDIR /app
COPY . .
RUN mvn clean package -DskipTests

CMD ["java", "-jar", "target/app.jar"]

# Problems:
# - Final image: 750 MB
# - Contains Maven (unnecessary at runtime)
# - Contains source code (security risk)
# - Contains .m2 cache (hundreds of MB)
# - Contains JDK (only need JRE)
```

#### Multi-Stage Build (GOOD):

```dockerfile
# ==============================================
# Stage 1: BUILD
# ==============================================
FROM maven:3.9-eclipse-temurin-17 AS build

WORKDIR /build

# Copy and download dependencies
COPY pom.xml .
RUN mvn dependency:go-offline -B

# Copy source and build
COPY src ./src
RUN mvn clean package -DskipTests -B

# ==============================================
# Stage 2: RUNTIME
# ==============================================
FROM eclipse-temurin:17-jre-jammy

WORKDIR /app

# Copy ONLY the JAR (not source, not Maven, not dependencies)
COPY --from=build /build/target/*.jar app.jar

CMD ["java", "-jar", "app.jar"]

# Result:
# - Final image: 280 MB
# - No source code
# - No build tools
# - Only JRE + JAR
```

#### Named Stages for Clarity:

```dockerfile
FROM maven:3.9-eclipse-temurin-17 AS maven-build
# Build stage...

FROM eclipse-temurin:17-jre-jammy AS runtime
# Runtime stage...

FROM runtime AS production
# Production-specific configuration...
```

---

### Maven/Gradle Cache Optimization

Optimize dependency downloads by leveraging Docker layer caching.

#### Maven Cache Optimization:

**❌ Bad: No Caching**

```dockerfile
FROM maven:3.9-eclipse-temurin-17 AS build

WORKDIR /app
COPY . .                    # Copies everything
RUN mvn package -DskipTests  # Re-downloads deps every time!
```

**✅ Good: Dependency Caching**

```dockerfile
FROM maven:3.9-eclipse-temurin-17 AS build

WORKDIR /app

# Step 1: Copy only POM files (rarely change)
COPY pom.xml .
COPY .mvn/ .mvn/
COPY mvnw .

# Step 2: Download dependencies (cached layer)
RUN ./mvnw dependency:go-offline -B

# Step 3: Copy source (changes frequently)
COPY src ./src

# Step 4: Build (uses cached dependencies)
RUN ./mvnw package -DskipTests -B
```

**✅ Better: BuildKit Cache Mounts**

```dockerfile
# syntax=docker/dockerfile:1.4

FROM maven:3.9-eclipse-temurin-17 AS build

WORKDIR /app

COPY pom.xml .

# Mount Maven cache (persists between builds)
RUN --mount=type=cache,target=/root/.m2 \
    mvn dependency:go-offline -B

COPY src ./src

RUN --mount=type=cache,target=/root/.m2 \
    mvn package -DskipTests -B
```

**Build with BuildKit:**

```bash
DOCKER_BUILDKIT=1 docker build -t myapp:latest .

# First build: Downloads all dependencies
# Second build: Uses cached dependencies (10x faster!)
```

#### Gradle Cache Optimization:

**❌ Bad: No Caching**

```dockerfile
FROM gradle:8.5-jdk17 AS build

WORKDIR /app
COPY . .
RUN gradle build --no-daemon
```

**✅ Good: Dependency Caching**

```dockerfile
FROM gradle:8.5-jdk17 AS build

WORKDIR /app

# Step 1: Copy build configuration
COPY build.gradle settings.gradle gradle.properties ./
COPY gradle/ gradle/

# Step 2: Download dependencies (cached layer)
# Create dummy source to satisfy Gradle
RUN mkdir -p src/main/java && \
    gradle dependencies --no-daemon || return 0

# Step 3: Copy actual source
COPY src ./src

# Step 4: Build
RUN gradle build --no-daemon -x test
```

**✅ Better: BuildKit Cache Mounts**

```dockerfile
# syntax=docker/dockerfile:1.4

FROM gradle:8.5-jdk17 AS build

WORKDIR /app

COPY build.gradle settings.gradle ./

# Mount Gradle cache
RUN --mount=type=cache,target=/home/gradle/.gradle \
    gradle dependencies --no-daemon

COPY src ./src

RUN --mount=type=cache,target=/home/gradle/.gradle \
    gradle build --no-daemon -x test
```

#### Multi-Module Maven Cache:

```dockerfile
FROM maven:3.9-eclipse-temurin-17 AS build

WORKDIR /app

# Copy all POMs first
COPY pom.xml .
COPY module-a/pom.xml module-a/
COPY module-b/pom.xml module-b/
COPY module-c/pom.xml module-c/

# Download all dependencies (cached!)
RUN mvn dependency:go-offline -B

# Copy all source
COPY module-a/src module-a/src
COPY module-b/src module-b/src
COPY module-c/src module-c/src

# Build all modules
RUN mvn package -DskipTests -B
```

---

### Minimal Runtime Images

Use the smallest possible base image for runtime.

#### Runtime Image Size Comparison:

```
openjdk:17                  → 470 MB
eclipse-temurin:17-jdk      → 450 MB
eclipse-temurin:17-jre      → 280 MB
openjdk:17-jre-alpine       → 180 MB
gcr.io/distroless/java17    → 260 MB
```

#### Complete Example: Minimal Production Image

```dockerfile
# ==============================================
# Stage 1: Build with Full JDK
# ==============================================
FROM maven:3.9-eclipse-temurin-17-alpine AS build

WORKDIR /build

# Dependency caching
COPY pom.xml .mvn/ mvnw ./
RUN ./mvnw dependency:go-offline -B

# Build
COPY src ./src
RUN ./mvnw clean package -DskipTests -B && \
    # Extract built JAR
    mv target/*.jar target/app.jar && \
    # Remove unnecessary files
    rm -rf target/maven-* target/classes

# ==============================================
# Stage 2: Minimal Runtime with JRE
# ==============================================
FROM eclipse-temurin:17-jre-alpine

# Install only essential tools
RUN apk add --no-cache \
    ca-certificates \
    curl \
    tini && \
    # Create non-root user
    addgroup -g 1000 spring && \
    adduser -D -u 1000 -G spring spring && \
    # Create necessary directories
    mkdir -p /app/logs /app/config && \
    chown -R spring:spring /app

WORKDIR /app

# Copy only the JAR
COPY --from=build --chown=spring:spring /build/target/app.jar .

# Switch to non-root user
USER spring

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
    CMD curl -f http://localhost:8080/actuator/health || exit 1

# Use tini as init system (handles signals properly)
ENTRYPOINT ["/sbin/tini", "--"]

# Optimized JVM settings
CMD ["java", \
     "-XX:+UseContainerSupport", \
     "-XX:MaxRAMPercentage=75.0", \
     "-XX:+UseG1GC", \
     "-XX:MaxGCPauseMillis=200", \
     "-XX:+UseStringDeduplication", \
     "-XX:+ExitOnOutOfMemoryError", \
     "-Djava.security.egd=file:/dev/./urandom", \
     "-jar", "app.jar"]

# Final size: ~200 MB
```

#### Ultra-Minimal: Custom JRE with jlink

```dockerfile
# ==============================================
# Stage 1: Build
# ==============================================
FROM maven:3.9-eclipse-temurin-17 AS build

WORKDIR /build
COPY pom.xml .
RUN mvn dependency:go-offline -B
COPY src ./src
RUN mvn package -DskipTests -B

# ==============================================
# Stage 2: Create Custom JRE
# ==============================================
FROM eclipse-temurin:17-jdk-jammy AS jre-build

# Analyze JAR to find required modules
COPY --from=build /build/target/*.jar /app/app.jar
RUN jdeps --print-module-deps --ignore-missing-deps /app/app.jar > /modules.txt

# Create minimal JRE with only required modules
RUN jlink \
    --add-modules $(cat /modules.txt) \
    --strip-debug \
    --no-man-pages \
    --no-header-files \
    --compress=2 \
    --output /custom-jre

# ==============================================
# Stage 3: Minimal Runtime
# ==============================================
FROM debian:bookworm-slim

# Install minimal runtime dependencies
RUN apt-get update && \
    apt-get install -y --no-install-recommends \
        ca-certificates \
        curl && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

# Copy custom JRE
COPY --from=jre-build /custom-jre /opt/jre

# Create non-root user
RUN groupadd -r spring && useradd -r -g spring spring

WORKDIR /app

# Copy JAR
COPY --from=build --chown=spring:spring /build/target/*.jar app.jar

USER spring

EXPOSE 8080

CMD ["/opt/jre/bin/java", "-jar", "app.jar"]

# Final size: ~150 MB (smallest secure option!)
```

#### Distroless for Maximum Security:

```dockerfile
# Build stage
FROM maven:3.9-eclipse-temurin-17 AS build

WORKDIR /build
COPY pom.xml .
RUN mvn dependency:go-offline -B
COPY src ./src
RUN mvn package -DskipTests -B

# Distroless runtime (most secure)
FROM gcr.io/distroless/java17-debian12:nonroot

WORKDIR /app

COPY --from=build --chown=nonroot:nonroot /build/target/*.jar app.jar

# No shell, no package manager, no utilities
# Ultra-secure but can't debug easily
CMD ["app.jar"]

# Final size: ~260 MB
# Security: Maximum (no shell, no tools, non-root)
```

---

## Complete Production-Ready Example

Combining all best practices:

```dockerfile
# syntax=docker/dockerfile:1.4
# ==============================================
# Build Stage
# ==============================================
FROM maven:3.9-eclipse-temurin-17-alpine AS build

# Install build-time dependencies
RUN apk add --no-cache git

WORKDIR /build

# Layer 1: Copy dependency definitions (rarely changes)
COPY pom.xml .mvn/ mvnw ./

# Layer 2: Download dependencies with cache mount
RUN --mount=type=cache,target=/root/.m2 \
    ./mvnw dependency:go-offline -B

# Layer 3: Copy source (changes frequently)
COPY src ./src

# Layer 4: Build application
RUN --mount=type=cache,target=/root/.m2 \
    ./mvnw clean package -DskipTests -B && \
    mv target/*.jar target/app.jar

# ==============================================
# Runtime Stage
# ==============================================
FROM eclipse-temurin:17-jre-alpine

LABEL maintainer="your-team@company.com" \
      version="1.0.0" \
      description="Production Spring Boot application"

# Install runtime dependencies
RUN apk add --no-cache \
    ca-certificates \
    curl \
    tini && \
    # Create non-root user
    addgroup -g 1000 spring && \
    adduser -D -u 1000 -G spring spring && \
    # Create directories with proper permissions
    mkdir -p /app/logs /app/config /app/dumps && \
    chown -R spring:spring /app

WORKDIR /app

# Copy JAR from build stage
COPY --from=build --chown=spring:spring /build/target/app.jar .

# Switch to non-root user
USER spring

# Expose application port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=60s --retries=3 \
    CMD curl -f http://localhost:8080/actuator/health || exit 1

# JVM configuration
ENV JAVA_OPTS="-XX:+UseContainerSupport \
               -XX:MaxRAMPercentage=75.0 \
               -XX:InitialRAMPercentage=50.0 \
               -XX:+UseG1GC \
               -XX:MaxGCPauseMillis=200 \
               -XX:+UseStringDeduplication \
               -XX:+ExitOnOutOfMemoryError \
               -XX:+HeapDumpOnOutOfMemoryError \
               -XX:HeapDumpPath=/app/dumps \
               -Djava.security.egd=file:/dev/./urandom \
               -Duser.timezone=UTC"

# Use tini as init system
ENTRYPOINT ["/sbin/tini", "--"]

# Run application
CMD ["sh", "-c", "java ${JAVA_OPTS} -jar app.jar"]
```

**Features:**

- ✅ Multi-stage build (minimal runtime)
- ✅ Layer caching optimization
- ✅ BuildKit cache mounts
- ✅ Non-root user
- ✅ Minimal base image (Alpine)
- ✅ Health check
- ✅ Proper signal handling (tini)
- ✅ JVM tuning for containers
- ✅ Heap dumps on OOM
- ✅ Secure (no secrets, minimal tools)

**Build and run:**

```bash
# Build with BuildKit
DOCKER_BUILDKIT=1 docker build -t myapp:1.0.0 .

# Run with resource limits
docker run -d \
  --name myapp \
  -p 8080:8080 \
  -m 1g \
  --cpus 2 \
  -e SPRING_PROFILES_ACTIVE=prod \
  -v /path/to/config:/app/config \
  -v /path/to/logs:/app/logs \
  myapp:1.0.0

# Monitor
docker logs -f myapp
docker stats myapp
```

---

### Key Takeaways:

**Java Dockerfile Patterns:**

- Use multi-stage builds for all Java apps
- Separate dependencies from source code for caching
- Use layered JARs for Spring Boot (2.3+)
- Different patterns for Maven vs Gradle

**Optimization:**

- Order layers: dependencies → source → build
- Use .dockerignore to exclude unnecessary files
- Leverage BuildKit cache mounts for faster builds
- Configure JVM for containers (-XX:+UseContainerSupport)

**Security:**

- Always run as non-root user
- Use Distroless for production (most secure)
- Scan images regularly (Trivy, Docker Scout)
- Never embed secrets in images

**Multi-Stage Builds:**

- Build stage: Full JDK + Maven/Gradle
- Runtime stage: Minimal JRE only
- Result: 70% size reduction
- Consider custom JRE with jlink for even smaller images
