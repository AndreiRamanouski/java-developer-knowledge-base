
## 1. Core Concepts

### Images vs Containers (How They Differ)

**Docker Image:**

- A **read-only template** containing everything needed to run an application
- Think of it as a "snapshot" or "blueprint"
- Contains: application code, runtime, libraries, dependencies, configuration files
- Immutable - once built, it doesn't change
- Stored in layers (more on this later)
- Can be shared via registries (Docker Hub, private registries)

**Docker Container:**

- A **running instance** of an image
- Think of it as a "process" running from the blueprint
- Writable layer on top of the image (changes made here don't affect the image)
- Isolated execution environment
- Can be started, stopped, deleted
- Ephemeral by default (data is lost when container is removed, unless using volumes)

**Analogy:**

```
Image = Class (in Java)
Container = Object/Instance (of that class)

You can create multiple containers from one image,
just like you create multiple objects from one class.
```

**Example:**

```bash
# Pull an image (download the blueprint)
docker pull nginx:latest

# Run a container from that image (create an instance)
docker run -d --name my-nginx nginx:latest

# You can create multiple containers from the same image
docker run -d --name my-nginx-2 nginx:latest
docker run -d --name my-nginx-3 nginx:latest

# All three containers run independently but from the same image
```

---

### Dockerfile Anatomy (Every Instruction Explained)

A **Dockerfile** is a text file with instructions to build a Docker image.

#### Complete Dockerfile Reference:

```dockerfile
# 1. FROM - Base image (REQUIRED - must be first instruction)
# Specifies the starting point for your image
FROM openjdk:17-jdk-slim

# 2. LABEL - Metadata (key-value pairs)
# Used for organization, licensing, documentation
LABEL maintainer="yourname@example.com"
LABEL version="1.0"
LABEL description="Spring Boot application"

# 3. ENV - Environment variables
# Available during build AND runtime
ENV APP_HOME=/app \
    JAVA_OPTS="-Xmx512m -Xms256m"

# 4. ARG - Build-time variables
# Only available during build (not at runtime)
# Can be overridden: docker build --build-arg VERSION=2.0
ARG VERSION=1.0
ARG JAR_FILE=target/*.jar

# 5. WORKDIR - Set working directory
# Creates directory if it doesn't exist
# All subsequent commands run from this directory
WORKDIR ${APP_HOME}

# 6. COPY - Copy files from host to image
# COPY <source> <destination>
# Source is relative to build context
COPY ${JAR_FILE} app.jar
COPY config/ ./config/

# 7. ADD - Similar to COPY but with extra features
# Can extract tar files automatically
# Can download from URLs (not recommended - use COPY + RUN wget)
ADD https://example.com/file.tar.gz /tmp/
ADD archive.tar.gz /extracted/

# 8. RUN - Execute commands during build
# Creates a new layer in the image
# Use && to chain commands (reduces layers)
RUN apt-get update && \
    apt-get install -y curl && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

# 9. USER - Set user for subsequent instructions
# Security best practice: don't run as root
RUN groupadd -r appuser && useradd -r -g appuser appuser
USER appuser

# 10. EXPOSE - Document which ports the container listens on
# This is DOCUMENTATION only - doesn't actually publish ports
# Still need -p flag when running: docker run -p 8080:8080
EXPOSE 8080

# 11. VOLUME - Create mount point for persistent data
# Data in volumes persists even after container is removed
VOLUME ["/app/logs", "/app/data"]

# 12. CMD - Default command to run when container starts
# Can be overridden when running container
# Only ONE CMD per Dockerfile (last one wins)
CMD ["java", "-jar", "app.jar"]

# 13. ENTRYPOINT - Configure container as executable
# Not easily overridden (more "locked in" than CMD)
# CMD becomes arguments to ENTRYPOINT
ENTRYPOINT ["java", "-jar", "app.jar"]

# 14. HEALTHCHECK - Check container health
# Docker will mark container as unhealthy if check fails
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s \
  CMD curl -f http://localhost:8080/actuator/health || exit 1

# 15. ONBUILD - Trigger instructions when image is used as base
# Useful for creating base images
ONBUILD COPY . /app
ONBUILD RUN mvn clean package

# 16. STOPSIGNAL - Signal to stop container (default SIGTERM)
STOPSIGNAL SIGTERM

# 17. SHELL - Override default shell
# Default is ["/bin/sh", "-c"] on Linux
SHELL ["/bin/bash", "-c"]
```

#### CMD vs ENTRYPOINT - The Difference:

```dockerfile
# Example 1: CMD only
FROM ubuntu
CMD ["echo", "Hello World"]

# Run: docker run myimage
# Output: Hello World
# Run: docker run myimage echo "Goodbye"
# Output: Goodbye (CMD is overridden)

# Example 2: ENTRYPOINT only
FROM ubuntu
ENTRYPOINT ["echo", "Hello"]

# Run: docker run myimage
# Output: Hello
# Run: docker run myimage World
# Output: Hello World (arguments are appended)

# Example 3: Both ENTRYPOINT and CMD (BEST PRACTICE)
FROM ubuntu
ENTRYPOINT ["echo"]
CMD ["Hello World"]

# Run: docker run myimage
# Output: Hello World
# Run: docker run myimage Goodbye
# Output: Goodbye (CMD is replaced, ENTRYPOINT stays)
```

**Java Application Example:**

```dockerfile
FROM openjdk:17-jdk-slim

WORKDIR /app

COPY target/myapp.jar app.jar

# ENTRYPOINT = the executable
# CMD = default arguments (can be overridden)
ENTRYPOINT ["java"]
CMD ["-jar", "app.jar"]

# Now you can easily override JVM options:
# docker run myapp -Xmx1g -jar app.jar
```

---

### Layers and Caching (How Docker Builds Images Efficiently)

Docker images are built in **layers**. Each instruction in the Dockerfile creates a new layer.

#### How Layers Work:

```dockerfile
FROM openjdk:17-jdk-slim        # Layer 1 (base image)
WORKDIR /app                     # Layer 2 (filesystem change)
COPY pom.xml .                   # Layer 3 (add pom.xml)
RUN mvn dependency:go-offline    # Layer 4 (download dependencies)
COPY src ./src                   # Layer 5 (add source code)
RUN mvn package                  # Layer 6 (build application)
CMD ["java", "-jar", "target/app.jar"]  # Layer 7 (metadata only)
```

**Key Concepts:**

1. **Layers are cached**: Docker caches each layer. If nothing changed, it reuses the cached layer.
2. **Cache invalidation**: If a layer changes, all subsequent layers are rebuilt.
3. **Layers are shared**: Multiple images can share the same base layers (saves disk space).
4. **Read-only layers**: All image layers are read-only. Container adds a writable layer on top.

#### Build Cache Example:

```bash
# First build - everything is built
docker build -t myapp:v1 .
# Output shows: [1/7] FROM ..., [2/7] WORKDIR ..., etc.

# Second build (no changes) - uses cache
docker build -t myapp:v1 .
# Output shows: CACHED for all steps

# Modify source code, rebuild
# Layers 1-4 use cache, layers 5-7 rebuild
```

#### Optimizing Layer Order (CRITICAL for Java apps):

**âŒ Bad Order (cache frequently invalidated):**

```dockerfile
FROM openjdk:17-jdk-slim
WORKDIR /app
COPY . .                         # Copies EVERYTHING (src + pom.xml)
RUN mvn clean package            # Any code change = rebuild dependencies
CMD ["java", "-jar", "target/app.jar"]
```

Every time you change a single Java file, Maven re-downloads all dependencies! ğŸ˜±

**âœ… Good Order (maximizes cache usage):**

```dockerfile
FROM openjdk:17-jdk-slim
WORKDIR /app

# Copy dependency definitions first
COPY pom.xml .
COPY .mvn/ .mvn/
COPY mvnw .

# Download dependencies (this layer is cached unless pom.xml changes)
RUN ./mvnw dependency:go-offline

# NOW copy source code
COPY src ./src

# Build (only rebuilds if src or pom.xml changed)
RUN ./mvnw package -DskipTests

CMD ["java", "-jar", "target/app.jar"]
```

**Why this is better:**

- If you only change Java code, only the last 2 layers rebuild
- Dependencies (which rarely change) remain cached
- Build time: 2 minutes â†’ 30 seconds!

#### Inspecting Layers:

```bash
# See all layers in an image
docker history myapp:v1

# See detailed layer information
docker image inspect myapp:v1

# Analyze image size by layer
docker history --no-trunc --human myapp:v1
```

---

### Container Lifecycle (create, start, stop, rm)

A container goes through several states:

```
        docker create
            â†“
[CREATED] â”€â”€â†’ [RUNNING] â”€â”€â†’ [STOPPED] â”€â”€â†’ [REMOVED]
     â†‘    docker start   docker stop    docker rm
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           docker run = create + start
```

#### Container States Explained:

**1. CREATED**: Container exists but not started

```bash
# Create container without starting
docker create --name myapp nginx:latest

# View created containers
docker ps -a | grep Created
```

**2. RUNNING**: Container is actively running

```bash
# Start the created container
docker start myapp

# Or create + start in one command
docker run -d --name myapp2 nginx:latest

# View running containers
docker ps
```

**3. STOPPED (Exited)**: Container stopped but still exists

```bash
# Stop gracefully (sends SIGTERM, waits, then SIGKILL)
docker stop myapp

# Stop immediately (sends SIGKILL)
docker kill myapp

# View stopped containers
docker ps -a | grep Exited
```

**4. PAUSED**: Container processes frozen (rarely used)

```bash
docker pause myapp
docker unpause myapp
```

**5. REMOVED**: Container deleted

```bash
# Remove stopped container
docker rm myapp

# Force remove running container
docker rm -f myapp

# Remove all stopped containers
docker container prune
```

#### Complete Lifecycle Commands:

```bash
# === CREATE ===
docker create --name myapp -p 8080:8080 myimage:latest

# === START ===
docker start myapp                    # Start stopped container
docker start -a myapp                 # Start and attach to output
docker start -i myapp                 # Start and attach to input

# === RUN (create + start) ===
docker run --name myapp myimage       # Foreground (blocks terminal)
docker run -d --name myapp myimage    # Detached (background)
docker run -it --name myapp myimage   # Interactive with terminal
docker run --rm --name myapp myimage  # Auto-remove when stops

# === STOP ===
docker stop myapp                     # Graceful stop (10 sec timeout)
docker stop -t 30 myapp               # Graceful stop (30 sec timeout)
docker kill myapp                     # Force stop immediately

# === RESTART ===
docker restart myapp                  # Stop + Start
docker restart -t 30 myapp            # Custom timeout

# === PAUSE/UNPAUSE ===
docker pause myapp
docker unpause myapp

# === REMOVE ===
docker rm myapp                       # Remove stopped container
docker rm -f myapp                    # Force remove (stops if running)
docker rm -v myapp                    # Also remove associated volumes

# === INSPECT ===
docker ps                             # Running containers
docker ps -a                          # All containers (including stopped)
docker inspect myapp                  # Detailed JSON info
docker logs myapp                     # View container logs
docker logs -f myapp                  # Follow logs (real-time)
docker stats myapp                    # Resource usage stats
docker top myapp                      # Processes inside container

# === EXECUTE COMMANDS ===
docker exec myapp ls /app             # Run command in running container
docker exec -it myapp bash            # Interactive shell
docker exec -u root myapp whoami      # Run as different user

# === COPY FILES ===
docker cp myapp:/app/logs ./logs     # Copy from container to host
docker cp ./config.yml myapp:/app/    # Copy from host to container
```

#### Java Application Lifecycle Example:

```bash
# Build the image
docker build -t spring-app:1.0 .

# Run Spring Boot app
docker run -d \
  --name spring-app \
  -p 8080:8080 \
  -e SPRING_PROFILES_ACTIVE=prod \
  -v /var/logs:/app/logs \
  spring-app:1.0

# Check if it's running
docker ps

# View logs
docker logs -f spring-app

# Check health
docker exec spring-app curl localhost:8080/actuator/health

# Graceful shutdown (Spring Boot handles SIGTERM)
docker stop spring-app

# Restart
docker start spring-app

# Update to new version
docker stop spring-app
docker rm spring-app
docker run -d --name spring-app -p 8080:8080 spring-app:2.0

# Cleanup
docker rm -f spring-app
```

#### Important Notes:

**Data Persistence:**

- Container filesystem is ephemeral (deleted with container)
- Use **volumes** for persistent data:

```bash
docker run -v mydata:/app/data myimage
```

**Graceful Shutdown (Critical for Java apps):**

```dockerfile
# In Dockerfile, ensure app handles SIGTERM
STOPSIGNAL SIGTERM

# Spring Boot automatically handles this
# Waits for requests to complete before shutting down
```

**Container Exit Codes:**

```bash
# View exit code
docker ps -a

# Common exit codes:
# 0 = Success
# 1 = Application error
# 137 = Killed (SIGKILL or OOM)
# 143 = Graceful stop (SIGTERM)
```

---

## 2. Docker Architecture

### Docker Daemon vs Docker CLI

Docker uses a **client-server architecture**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Docker CLI  â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚  Docker Daemon   â”‚
â”‚  (client)   â”‚  REST   â”‚   (dockerd)      â”‚
â”‚             â”‚  API    â”‚                  â”‚
â”‚ docker run  â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ - Manages images â”‚
â”‚ docker ps   â”‚         â”‚ - Runs containersâ”‚
â”‚ docker buildâ”‚         â”‚ - Manages volumesâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚                          â”‚
      â”‚                          â–¼
      â”‚                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚                  â”‚  containerd  â”‚
      â”‚                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚                          â”‚
      â”‚                          â–¼
      â”‚                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚                  â”‚     runc     â”‚
      â”‚                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚                          â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼
                          [Container]
```

**Docker CLI:**

- The command-line tool you interact with
- Sends commands to Docker daemon via REST API
- Can connect to local or remote daemons
- Examples: `docker run`, `docker build`, `docker ps`

```bash
# CLI talks to local daemon by default
docker ps

# CLI can connect to remote daemon
docker -H tcp://remote-server:2376 ps

# Or set environment variable
export DOCKER_HOST=tcp://remote-server:2376
docker ps
```

**Docker Daemon (dockerd):**

- Background service that manages Docker objects
- Listens for Docker API requests
- Manages: images, containers, networks, volumes
- Does the heavy lifting (building, running, distributing)

```bash
# Check if daemon is running
systemctl status docker

# Daemon logs
journalctl -u docker

# Daemon configuration
cat /etc/docker/daemon.json
```

**Communication Flow:**

```bash
# When you run:
docker run nginx

# What happens:
1. CLI sends request to daemon (via /var/run/docker.sock)
2. Daemon checks if image exists locally
3. If not, daemon pulls from registry
4. Daemon tells containerd to create container
5. containerd uses runc to start container
6. CLI displays container ID
```

---

### containerd and runc

Docker daemon delegates the actual container execution to lower-level components:

**Architecture Layers:**

```
Docker CLI
    â†“
dockerd (Docker Daemon)
    â†“
containerd (Container runtime)
    â†“
runc (OCI runtime - actually creates containers)
    â†“
Linux Kernel (namespaces, cgroups)
```

**containerd:**

- Industry-standard container runtime
- Graduated CNCF project (used by Kubernetes, Docker)
- Manages container lifecycle
- Image management, storage, networking
- Supervises runc
- Can be used independently of Docker

```bash
# containerd CLI tool
ctr images list
ctr containers list

# Kubernetes uses containerd directly (not Docker daemon)
```

**runc:**

- Lightweight CLI tool for running containers
- Implements OCI (Open Container Initiative) specification
- Creates and runs containers according to OCI spec
- Written in Go
- Does the low-level Linux magic (namespaces, cgroups)

```bash
# runc is rarely used directly, but you can:
runc --version

# Create container from OCI bundle
runc create mycontainer

# Start it
runc start mycontainer
```

**Why this architecture?**

- **Modularity**: Each component has single responsibility
- **Standardization**: OCI standard allows different runtimes
- **Flexibility**: Can swap components (e.g., use different OCI runtime)
- **Kubernetes**: Uses containerd directly, bypassing dockerd

---

### How Containers Actually Work (namespaces, cgroups)

Containers are **not magic** - they're just Linux processes with isolation!

**Two Key Linux Features:**

#### 1. Namespaces (Isolation)

Namespaces provide isolation - making a process think it's alone in the system.

**Types of Namespaces:**

|Namespace|Isolates|What it means|
|---|---|---|
|PID|Process IDs|Container sees own process tree|
|NET|Network stack|Own IP, ports, routing tables|
|MNT|Filesystem mounts|Own filesystem tree|
|UTS|Hostname|Own hostname|
|IPC|Inter-process communication|Isolated message queues, semaphores|
|USER|User/Group IDs|Root in container â‰  root on host|

**Example - PID Namespace:**

```bash
# On host:
ps aux
# Shows ALL processes

# Inside container:
docker run -it ubuntu ps aux
# Shows ONLY container processes
# Init process (your app) has PID 1!
```

**Example - Network Namespace:**

```bash
# Container has its own network stack:
docker run -it ubuntu ip addr
# Shows: lo, eth0 (container's interfaces)

# Different from host:
ip addr
# Shows: different interfaces
```

#### 2. Control Groups (cgroups) - Resource Limiting

Cgroups limit and measure resource usage.

**What cgroups control:**

- **CPU**: How much CPU time
- **Memory**: RAM limits
- **Disk I/O**: Read/write speed limits
- **Network**: Bandwidth limits

**Example:**

```bash
# Run container with limits
docker run -d \
  --name limited-app \
  --cpus="1.5" \           # Max 1.5 CPU cores
  --memory="512m" \        # Max 512 MB RAM
  --memory-swap="1g" \     # Max 1 GB swap
  --pids-limit=100 \       # Max 100 processes
  myapp:latest

# Check resource usage
docker stats limited-app

# What happens if app exceeds memory?
# Linux OOM killer terminates container!
```

**Behind the scenes:**

```bash
# Docker creates cgroup for container:
/sys/fs/cgroup/cpu/docker/<container-id>/
/sys/fs/cgroup/memory/docker/<container-id>/

# View memory limit:
cat /sys/fs/cgroup/memory/docker/<container-id>/memory.limit_in_bytes
```

#### How It All Works Together:

```bash
# When you run:
docker run -it --name myapp ubuntu bash

# Docker does this:
1. Creates namespaces (PID, NET, MNT, UTS, IPC, USER)
2. Creates cgroups for resource limits
3. Sets up container filesystem (overlay/aufs)
4. Configures network (bridge, veth pair)
5. Executes: unshare --pid --net --mount ... bash
6. Process runs isolated, thinking it's in own system!
```

**You can see this yourself:**

```bash
# Run container
docker run -d --name test nginx

# Find container's main process
docker inspect test | grep Pid
# e.g., "Pid": 12345

# Check its namespaces
ls -la /proc/12345/ns/
# Each namespace has unique ID

# Compare to another container - different namespace IDs!
```

---

### Container vs VM (Deep Dive)

Both provide isolation, but **very different** under the hood!

#### Architecture Comparison:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Virtual Machines       â”‚  â”‚      Containers          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â” â”‚  â”‚  â”Œâ”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â” â”‚
â”‚  â”‚App1â”‚  â”‚App2â”‚  â”‚App3â”‚ â”‚  â”‚  â”‚App1â”‚  â”‚App2â”‚  â”‚App3â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”˜ â”‚  â”‚  â””â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚ Guest OS (full)      â”‚â”‚  â”‚  â”‚   Bins/Libs          â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚ Guest OS (full)      â”‚â”‚  â”‚  â”‚   Bins/Libs          â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚ Guest OS (full)      â”‚â”‚  â”‚  â”‚   Bins/Libs          â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚     Hypervisor           â”‚  â”‚  â”‚  Container Runtime   â”‚â”‚
â”‚  (VMware, VirtualBox)    â”‚  â”‚  â”‚   (Docker, runc)     â”‚â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚      Host OS             â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚       Host OS            â”‚
â”‚    Physical Server       â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    Physical Server       â”‚
                               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Key Differences:

|Aspect|Virtual Machine|Container|
|---|---|---|
|**OS**|Full guest OS (GB)|Shares host OS kernel|
|**Boot time**|Minutes|Seconds (< 1s)|
|**Size**|GBs (full OS)|MBs (app + dependencies)|
|**Performance**|Overhead (hypervisor)|Near-native (no hypervisor)|
|**Isolation**|Strong (hardware-level)|Process-level (namespaces)|
|**Portability**|Less portable|Highly portable|
|**Resource usage**|High (each VM = full OS)|Low (shared kernel)|
|**Startup**|Slow|Fast|

#### Detailed Comparison:

**1. Isolation Level:**

**VMs:** Hardware-level virtualization

- Separate kernel for each VM
- Complete OS isolation
- More secure (VM escape is rare)
- Can run different OS (Windows VM on Linux host)

**Containers:** OS-level virtualization

- Share host kernel
- Process isolation via namespaces
- Less isolated (container escape possible if misconfigured)
- Must be same OS type (Linux containers on Linux host)

**2. Resource Usage:**

**VMs:**

```bash
# Running 3 VMs:
VM1: 2 GB RAM (full OS + app)
VM2: 2 GB RAM (full OS + app)
VM3: 2 GB RAM (full OS + app)
Total: 6 GB RAM minimum
```

**Containers:**

```bash
# Running 3 containers:
Container1: 50 MB RAM (app only)
Container2: 50 MB RAM (app only)
Container3: 50 MB RAM (app only)
Total: 150 MB RAM
```

**3. Boot Time:**

```bash
# VM boot time:
1. Boot guest OS kernel
2. Init system services
3. Start application
Total: 30 seconds to 2 minutes

# Container start time:
1. Start application (no OS boot!)
Total: < 1 second

# Example:
time docker run --rm ubuntu echo "Hello"
# Real: 0.5 seconds

time VBoxManage startvm myvm --type headless
# Real: 45 seconds
```

**4. Density:**

```
On a server with 32 GB RAM:

VMs: 10-15 VMs (each needs 2-4 GB)
Containers: 100s-1000s (each needs 50-500 MB)
```

**5. Use Cases:**

**Use VMs when:**

- Need complete OS isolation
- Running different OS types (Windows + Linux)
- Regulatory/security requirements demand hardware isolation
- Legacy applications requiring specific kernel versions
- Multi-tenancy with strong isolation requirements

**Use Containers when:**

- Microservices architecture
- CI/CD pipelines
- Rapid deployment and scaling
- Development environments
- Cloud-native applications
- Cost efficiency is important

**6. Performance Comparison:**

```bash
# Container startup
time docker run --rm alpine echo "Hello"
# Real: 0.2 seconds

# Container I/O (near-native performance)
# No hypervisor overhead

# Container CPU (near-native performance)
# Shares host kernel directly
```

**7. Can You Mix Both?**

**Yes!** Common pattern:

```
Physical Server
  â””â”€ VM 1 (Linux)
      â”œâ”€ Container 1 (Nginx)
      â”œâ”€ Container 2 (Spring Boot)
      â””â”€ Container 3 (PostgreSQL)
  â””â”€ VM 2 (Linux)
      â”œâ”€ Container 4 (Redis)
      â””â”€ Container 5 (MongoDB)
```

Benefits:

- VM provides strong isolation between teams/customers
- Containers provide density and fast deployment within VM
- Best of both worlds!

---

## 3. Images Deep Dive

### Base Images (Alpine vs Ubuntu vs Distroless)

Choosing the right base image is critical for security, size, and performance.

#### Alpine Linux

**Pros:**

- **Tiny**: 5 MB base image
- **Fast**: Quick downloads and builds
- **Security**: Minimal attack surface (fewer packages)
- **Package manager**: apk (Alpine Package Keeper)

**Cons:**

- **musl libc**: Uses musl instead of glibc (can cause compatibility issues)
- **Different tools**: Uses busybox (limited compared to full GNU tools)
- **Debugging**: Fewer debugging tools available
- **Java issues**: Some Java apps have problems with musl

**Example:**

```dockerfile
FROM alpine:3.18

# Install packages
RUN apk add --no-cache \
    curl \
    bash \
    ca-certificates

# Size: ~10-20 MB
```

**For Java:**

```dockerfile
FROM openjdk:17-jdk-alpine

WORKDIR /app
COPY target/app.jar .

# Common Alpine + Java issue: DNS resolution
# May need to add: -Djava.net.preferIPv4Stack=true

CMD ["java", "-jar", "app.jar"]

# Size: ~150 MB
```

#### Ubuntu

**Pros:**

- **Familiar**: Most developers know Ubuntu
- **glibc**: Standard C library (best compatibility)
- **Full tooling**: All GNU tools available
- **Debugging**: Easy to debug (apt install anything)
- **Java-friendly**: No compatibility issues

**Cons:**

- **Large**: 77 MB base image
- **More packages**: Larger attack surface
- **Slower builds**: Larger download size

**Example:**

```dockerfile
FROM ubuntu:22.04

# Install packages
RUN apt-get update && \
    apt-get install -y \
        curl \
        ca-certificates && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

# Size: ~100-150 MB
```

**For Java:**

```dockerfile
FROM ubuntu:22.04

# Install Java
RUN apt-get update && \
    apt-get install -y openjdk-17-jdk && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

WORKDIR /app
COPY target/app.jar .

CMD ["java", "-jar", "app.jar"]

# Size: ~400 MB
```

#### Distroless

**Pros:**

- **Security**: NO package manager, NO shell, NO utilities
- **Minimal**: Only runtime + dependencies
- **Small**: Smaller than Ubuntu, bigger than Alpine
- **Immutable**: Can't install anything (security feature!)
- **Best practice**: Google's recommendation

**Cons:**

- **No shell**: Can't docker exec into container!
- **No debugging tools**: Must debug elsewhere
- **Limited flexibility**: Can't install anything at runtime

**Example:**

```dockerfile
# Build stage
FROM maven:3.9-eclipse-temurin-17 AS build
WORKDIR /app
COPY pom.xml .
RUN mvn dependency:go-offline
COPY src ./src
RUN mvn package -DskipTests

# Runtime stage
FROM gcr.io/distroless/java17-debian12

WORKDIR /app
COPY --from=build /app/target/app.jar .

# No shell, so must use exec form!
CMD ["app.jar"]

# Size: ~250 MB (smallest secure Java option)
```

**Distroless with debugging:**

```dockerfile
# Use debug variant (includes busybox shell)
FROM gcr.io/distroless/java17-debian12:debug

# Now you CAN docker exec -it container sh
```

#### Comparison Table:

|Feature|Alpine|Ubuntu|Distroless|
|---|---|---|---|
|**Base size**|5 MB|77 MB|20 MB|
|**Java app size**|150 MB|400 MB|250 MB|
|**C library**|musl|glibc|glibc|
|**Package manager**|apk|apt|None|
|**Shell**|sh|bash|None|
|**Java compatibility**|Some issues|Perfect|Perfect|
|**Debugging**|Easy|Easy|Hard|
|**Security**|Good|Fair|Excellent|
|**Best for**|Small images|Development|Production|

#### Recommendations:

**For Development:**

```dockerfile
FROM ubuntu:22.04
# Easy debugging, familiar environment
```

**For Production (Security-focused):**

```dockerfile
FROM gcr.io/distroless/java17-debian12
# Minimal attack surface, no shell
```

**For Production (Size-focused):**

```dockerfile
FROM openjdk:17-jdk-alpine
# Smallest size, but test thoroughly!
```

**Multi-stage build (BEST):**

```dockerfile
# Build with full tools
FROM maven:3.9-eclipse-temurin-17 AS build
# ... build steps ...

# Run with minimal runtime
FROM gcr.io/distroless/java17-debian12
COPY --from=build /app/target/app.jar .
CMD ["app.jar"]
```

---

### Image Layers (Inspect, Analyze)

Every Docker image is composed of layers stacked on top of each other.

#### Understanding Layers:

```dockerfile
FROM ubuntu:22.04              # Layer 1: Base (77 MB)
RUN apt-get update             # Layer 2: Package index (30 MB)
RUN apt-get install -y curl    # Layer 3: Install curl (5 MB)
COPY app.jar /app/             # Layer 4: Add JAR (50 MB)
CMD ["java", "-jar", "/app/app.jar"]  # Layer 5: Metadata (0 MB)

# Total image size: 162 MB
```

**Important:** Each RUN, COPY, ADD creates a new layer!

#### Inspecting Layers:

**1. docker history - See layer details:**

```bash
docker history myapp:latest

# Output:
IMAGE          CREATED        CREATED BY                                      SIZE
abc123def456   2 hours ago    CMD ["java" "-jar" "app.jar"]                   0B
def456ghi789   2 hours ago    COPY target/app.jar /app/ # buildkit           50MB
ghi789jkl012   2 hours ago    RUN /bin/sh -c apt-get install -y curl         5MB
jkl012mno345   2 hours ago    RUN /bin/sh -c apt-get update                  30MB
mno345pqr678   3 days ago     ubuntu:22.04                                    77MB
```

**2. docker inspect - JSON details:**

```bash
docker inspect myapp:latest

# Shows:
# - All layers (IDs)
# - Layer sizes
# - Build history
# - Environment variables
# - Entry point / CMD
```

**3. dive - Interactive layer explorer (BEST TOOL!):**

```bash
# Install dive
brew install dive
# or
wget https://github.com/wagoodman/dive/releases/download/v0.11.0/dive_0.11.0_linux_amd64.deb
sudo apt install ./dive_0.11.0_linux_amd64.deb

# Analyze image
dive myapp:latest

# Shows:
# - Layer contents (files added/modified/deleted)
# - Wasted space
# - Efficiency score
# - Interactive file browser
```

#### Layer Optimization Techniques:

**âŒ Bad: Multiple RUN commands**

```dockerfile
FROM ubuntu:22.04
RUN apt-get update           # Layer 1: 30 MB
RUN apt-get install -y curl  # Layer 2: 5 MB
RUN apt-get install -y wget  # Layer 3: 2 MB
RUN apt-get clean            # Layer 4: Still 37 MB total!
# Cleanup doesn't remove data from previous layers!
```

**âœ… Good: Chain commands**

```dockerfile
FROM ubuntu:22.04
RUN apt-get update && \
    apt-get install -y \
        curl \
        wget && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*  # Layer 1: 10 MB
# Cleanup in same layer reduces size!
```

**Why?** Each layer is immutable. Deleting files in a later layer doesn't reduce image size!

**âŒ Bad: Copying unnecessary files**

```dockerfile
FROM openjdk:17-jdk-slim
COPY . /app/  # Copies EVERYTHING including .git, target/, etc.
```

**âœ… Good: Use .dockerignore**

```dockerfile
# .dockerignore file:
.git
.gitignore
target/
*.log
README.md
Dockerfile

# Dockerfile:
FROM openjdk:17-jdk-slim
COPY . /app/  # Now only copies necessary files
```

**âŒ Bad: Large intermediate files**

```dockerfile
FROM ubuntu:22.04
RUN wget https://example.com/large-file.tar.gz  # 500 MB
RUN tar -xzf large-file.tar.gz                  # 500 MB still in layer!
RUN rm large-file.tar.gz                        # Doesn't help!
```

**âœ… Good: Cleanup in same layer**

```dockerfile
FROM ubuntu:22.04
RUN wget https://example.com/large-file.tar.gz && \
    tar -xzf large-file.tar.gz && \
    rm large-file.tar.gz  # All in one layer
```

#### Analyzing Layer Efficiency:

**Using dive to find wasted space:**

```bash
dive myapp:latest

# Look for:
# 1. Wasted space percentage (aim for < 10%)
# 2. Files in multiple layers (duplicates)
# 3. Large files that could be reduced
# 4. Unnecessary dependencies
```

**Example dive output:**

```
Layer 1: 100 MB (apt-get update)
  - /var/lib/apt/lists/* (unnecessary!)
Layer 2: 50 MB (install packages)
  - /usr/share/doc/* (unnecessary!)
  - /usr/share/man/* (unnecessary!)
Layer 3: 200 MB (COPY everything)
  - .git/ (shouldn't be here!)
  - target/ (build artifacts!)

Wasted space: 45%  âš ï¸
```

#### Layer Sharing:

Multiple images can share layers (saves disk space):

```bash
# Image 1:
FROM ubuntu:22.04          # Shared layer
RUN apt-get install java   # Unique layer
COPY app1.jar /app/

# Image 2:
FROM ubuntu:22.04          # SAME shared layer (no extra disk space!)
RUN apt-get install java   # SAME shared layer
COPY app2.jar /app/        # Unique layer

# Disk usage:
# ubuntu:22.04 layer: 77 MB (stored once)
# java install layer: 300 MB (stored once)
# app1.jar: 50 MB
# app2.jar: 60 MB
# Total: 487 MB (not 877 MB!)
```

---

### Image Tags and Versioning Strategy

Image tags identify specific versions of an image.

#### Tag Syntax:

```
registry/repository:tag

Examples:
docker.io/library/nginx:latest
docker.io/library/nginx:1.25.3
myregistry.com/myapp:v2.1.0
gcr.io/my-project/service:sha-abc123
```

**Components:**

- **registry**: Where image is stored (default: docker.io)
- **repository**: Image name (can include namespace)
- **tag**: Version identifier (default: latest)

#### Common Tagging Strategies:

**1. Semantic Versioning (RECOMMENDED)**

```bash
# Build and tag
docker build -t myapp:1.0.0 .
docker build -t myapp:1.0 .    # Also tag major.minor
docker build -t myapp:1 .      # Also tag major
docker build -t myapp:latest . # Also tag latest

# Push all tags
docker push myapp:1.0.0
docker push myapp:1.0
docker push myapp:1
docker push myapp:latest
```

**Benefits:**

- Clear versioning
- Can pin to specific version (1.0.0) or allow updates (1.0)
- Easy rollback

**2. Git Commit SHA**

```bash
# Get commit SHA
COMMIT_SHA=$(git rev-parse --short HEAD)

# Build with SHA tag
docker build -t myapp:${COMMIT_SHA} .
docker build -t myapp:latest .

# Push
docker push myapp:${COMMIT_SHA}
docker push myapp:latest
```

**Benefits:**

- Traceable to exact code version
- Immutable (SHA never changes)
- Perfect for CI/CD

**3. Build Number (CI/CD)**

```bash
# Jenkins/GitLab CI build number
docker build -t myapp:build-${BUILD_NUMBER} .
docker build -t myapp:build-456 .
```

**4. Environment-specific**

```bash
docker build -t myapp:dev .
docker build -t myapp:staging .
docker build -t myapp:prod .
```

**âš ï¸ Warning:** These tags are mutable (can be overwritten)

**5. Date-based**

```bash
docker build -t myapp:2024-11-14 .
docker build -t myapp:2024-11 .
```

#### Best Practices:

**âœ… DO:**

```bash
# Multiple tags for flexibility
docker build -t myapp:2.1.0 \
             -t myapp:2.1 \
             -t myapp:2 \
             -t myapp:latest .

# Use immutable tags in production
# deployment.yaml
image: myapp:2.1.0  # Specific version

# Use SHA tags for traceability
docker build -t myapp:sha-abc123 .
```

**âŒ DON'T:**

```bash
# Never use :latest in production!
image: myapp:latest  # Which version is this??

# Don't use mutable tags for important deployments
image: myapp:dev  # Could be anything!

# Don't use vague tags
docker build -t myapp:new .
docker build -t myapp:fixed .
docker build -t myapp:final .  # Famous last words
```

#### Complete Tagging Strategy Example:

```bash
# In CI/CD pipeline:

# 1. Get version info
VERSION=$(cat version.txt)        # e.g., 2.1.0
COMMIT_SHA=$(git rev-parse --short HEAD)
BUILD_DATE=$(date +%Y%m%d)

# 2. Build with multiple tags
docker build \
  -t myregistry.com/myapp:${VERSION} \
  -t myregistry.com/myapp:${VERSION}-${COMMIT_SHA} \
  -t myregistry.com/myapp:${VERSION}-${BUILD_DATE} \
  -t myregistry.com/myapp:latest \
  .

# 3. Push all tags
docker push myregistry.com/myapp:${VERSION}
docker push myregistry.com/myapp:${VERSION}-${COMMIT_SHA}
docker push myregistry.com/myapp:${VERSION}-${BUILD_DATE}
docker push myregistry.com/myapp:latest

# 4. Deploy using immutable tag
kubectl set image deployment/myapp \
  myapp=myregistry.com/myapp:${VERSION}-${COMMIT_SHA}
```

**Result:**

```
myapp:2.1.0
myapp:2.1.0-abc123
myapp:2.1.0-20241114
myapp:latest

All point to same image (same SHA-256 digest)
```

#### Inspecting Tags:

```bash
# List local tags
docker images myapp

# List remote tags (Docker Hub)
curl -s https://registry.hub.docker.com/v2/repositories/library/nginx/tags/ | jq

# Get image digest (immutable ID)
docker inspect myapp:2.1.0 --format='{{.RepoDigests}}'
# Output: myapp@sha256:abc123...

# Pull by digest (guaranteed immutable)
docker pull myapp@sha256:abc123...
```

#### Tag Management:

```bash
# Add tag to existing image
docker tag myapp:2.1.0 myapp:production

# Remove tag (doesn't delete image)
docker rmi myapp:production

# Delete image (all tags)
docker rmi myapp:2.1.0

# Delete untagged images (dangling)
docker image prune

# View all tags for an image
docker images myapp
```

---

### Multi-stage Builds (Critical for Java Apps)

Multi-stage builds use multiple FROM statements to create optimized images.

#### Why Multi-stage Builds?

**Problem:**

```dockerfile
# âŒ Single-stage build
FROM maven:3.9-eclipse-temurin-17
WORKDIR /app
COPY . .
RUN mvn clean package

CMD ["java", "-jar", "target/app.jar"]

# Issues:
# 1. Image includes Maven (not needed at runtime!)
# 2. Image includes source code (security risk!)
# 3. Image includes .m2 cache (100s of MB!)
# 4. Final image: 700+ MB
```

**Solution: Multi-stage build**

```dockerfile
# âœ… Multi-stage build

# Stage 1: Build
FROM maven:3.9-eclipse-temurin-17 AS build
WORKDIR /app
COPY pom.xml .
RUN mvn dependency:go-offline
COPY src ./src
RUN mvn package -DskipTests

# Stage 2: Runtime
FROM eclipse-temurin:17-jre-jammy
WORKDIR /app
COPY --from=build /app/target/app.jar .
CMD ["java", "-jar", "app.jar"]

# Final image: 250 MB (only JRE + JAR!)
```

#### How Multi-stage Builds Work:

```dockerfile
# Each FROM starts a new stage
FROM maven:3.9-eclipse-temurin-17 AS builder  # Stage 1
# ... build commands ...

FROM openjdk:17-jre-slim AS runtime           # Stage 2
# ... runtime setup ...

# Only the LAST stage is in final image!
# Previous stages are discarded (but cached)
```

#### Complete Java Multi-stage Example:

```dockerfile
# ==================================
# Stage 1: Build with Maven
# ==================================
FROM maven:3.9-eclipse-temurin-17 AS build

WORKDIR /build

# Copy dependency definitions
COPY pom.xml .
COPY .mvn/ .mvn/
COPY mvnw .

# Download dependencies (cached layer)
RUN ./mvnw dependency:go-offline -B

# Copy source code
COPY src ./src

# Build application
RUN ./mvnw clean package -DskipTests -B && \
    # Extract version from pom.xml
    VERSION=$(./mvnw help:evaluate -Dexpression=project.version -q -DforceStdout) && \
    # Rename JAR to app.jar
    mv target/myapp-${VERSION}.jar target/app.jar

# ==================================
# Stage 2: Runtime with JRE
# ==================================
FROM eclipse-temurin:17-jre-jammy

# Create non-root user
RUN groupadd -r appuser && useradd -r -g appuser appuser

WORKDIR /app

# Copy JAR from build stage
COPY --from=build --chown=appuser:appuser /build/target/app.jar .

# Switch to non-root user
USER appuser

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s \
  CMD curl -f http://localhost:8080/actuator/health || exit 1

# Run application
ENTRYPOINT ["java"]
CMD ["-XX:+UseContainerSupport", \
     "-XX:MaxRAMPercentage=75.0", \
     "-jar", "app.jar"]
```

#### Advanced: Multiple Build Stages

```dockerfile
# Stage 1: Download dependencies
FROM maven:3.9-eclipse-temurin-17 AS dependencies
WORKDIR /build
COPY pom.xml .
RUN mvn dependency:go-offline

# Stage 2: Compile code
FROM maven:3.9-eclipse-temurin-17 AS compile
WORKDIR /build
COPY --from=dependencies /root/.m2 /root/.m2
COPY pom.xml .
COPY src ./src
RUN mvn compile

# Stage 3: Run tests
FROM compile AS test
RUN mvn test

# Stage 4: Package
FROM compile AS package
RUN mvn package -DskipTests

# Stage 5: Runtime
FROM eclipse-temurin:17-jre-jammy
COPY --from=package /build/target/app.jar .
CMD ["java", "-jar", "app.jar"]
```

**Build specific stage:**

```bash
# Build only up to test stage
docker build --target test -t myapp:test .

# Build full image (runtime stage)
docker build -t myapp:latest .
```

#### Multi-stage with Different Base Images:

```dockerfile
# Build with full JDK
FROM eclipse-temurin:17-jdk AS build
# ... build steps ...

# Run with minimal Distroless
FROM gcr.io/distroless/java17-debian12
COPY --from=build /app/target/app.jar .
CMD ["app.jar"]
```

#### Gradle Multi-stage Example:

```dockerfile
# Stage 1: Build
FROM gradle:8.5-jdk17 AS build
WORKDIR /app
COPY build.gradle settings.gradle ./
COPY gradle/ gradle/
RUN gradle dependencies --no-daemon
COPY src ./src
RUN gradle build -x test --no-daemon

# Stage 2: Runtime
FROM eclipse-temurin:17-jre-jammy
WORKDIR /app
COPY --from=build /app/build/libs/app.jar .
CMD ["java", "-jar", "app.jar"]
```

#### Benefits of Multi-stage Builds:

1. **Smaller images**: Only runtime dependencies in final image
2. **Security**: No build tools or source code in production image
3. **Cleaner**: Separation of build and runtime concerns
4. **Flexible**: Can use different base images for each stage
5. **Cached builds**: Each stage is cached separately

#### Size Comparison:

```
Single-stage build:
- Base: Maven (700 MB)
- Source code: 5 MB
- .m2 cache: 150 MB
- JAR: 50 MB
Total: 905 MB

Multi-stage build:
- Base: JRE (250 MB)
- JAR: 50 MB
Total: 300 MB

Savings: 605 MB (67% reduction!)
```

---

### Image Optimization (Reducing Size)

Smaller images = faster builds, faster deployments, lower storage costs, reduced attack surface.

#### Optimization Techniques:

**1. Choose Smaller Base Image**

```dockerfile
# âŒ Bad: 700 MB
FROM openjdk:17

# âœ… Better: 450 MB
FROM openjdk:17-slim

# âœ… Even better: 180 MB
FROM eclipse-temurin:17-jre-jammy

# âœ… Best: 160 MB
FROM openjdk:17-jre-alpine

# âœ… Most secure: 250 MB
FROM gcr.io/distroless/java17-debian12
```

**2. Use Multi-stage Builds** (see previous section)

**3. Minimize Layers**

```dockerfile
# âŒ Bad: 5 layers
FROM ubuntu:22.04
RUN apt-get update
RUN apt-get install -y curl
RUN apt-get install -y wget
RUN apt-get install -y vim
RUN apt-get clean

# âœ… Good: 1 layer
FROM ubuntu:22.04
RUN apt-get update && \
    apt-get install -y \
        curl \
        wget \
        vim && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*
```

**4. Clean Up in Same Layer**

```dockerfile
# âŒ Bad: Cleanup doesn't reduce size
FROM ubuntu:22.04
RUN apt-get update && apt-get install -y python3  # Layer 1: 100 MB
RUN rm -rf /var/lib/apt/lists/*                   # Layer 2: Still 100 MB!

# âœ… Good: Cleanup in same layer
FROM ubuntu:22.04
RUN apt-get update && \
    apt-get install -y python3 && \
    rm -rf /var/lib/apt/lists/*  # Layer 1: 80 MB
```

**5. Use .dockerignore**

```
# .dockerignore
.git
.gitignore
.idea
*.md
target/
*.log
.DS_Store
node_modules/
.env
Dockerfile
docker-compose.yml
```

**6. Don't Install Unnecessary Packages**

```dockerfile
# âŒ Bad: Installs recommendations (extra packages)
RUN apt-get install -y openjdk-17-jdk

# âœ… Good: Skip recommendations
RUN apt-get install -y --no-install-recommends openjdk-17-jdk

# Saves: 100+ MB
```

**7. Use Specific Package Versions**

```dockerfile
# âœ… Pin versions for reproducibility
RUN apt-get install -y \
    curl=7.81.0-1ubuntu1.15 \
    wget=1.21.2-2ubuntu1
```

**8. Remove Build Dependencies**

```dockerfile
FROM alpine:3.18

# Install build dependencies
RUN apk add --no-cache --virtual .build-deps \
        gcc \
        musl-dev \
        python3-dev

# Compile something
RUN pip install some-package

# Remove build dependencies
RUN apk del .build-deps

# Saves: 200+ MB
```

**9. Optimize Java Applications**

```dockerfile
# âŒ Bad: Includes full JDK
FROM openjdk:17-jdk
COPY app.jar .
CMD ["java", "-jar", "app.jar"]

# âœ… Better: Use JRE instead of JDK
FROM openjdk:17-jre
COPY app.jar .
CMD ["java", "-jar", "app.jar"]

# Saves: 200 MB

# âœ… Best: Custom JRE with jlink
FROM openjdk:17-jdk AS build
COPY app.jar .
RUN jlink --add-modules java.base,java.logging,java.sql \
          --output /custom-jre \
          --strip-debug \
          --no-man-pages \
          --no-header-files \
          --compress=2

FROM debian:bookworm-slim
COPY --from=build /custom-jre /opt/jre
COPY --from=build /app.jar .
CMD ["/opt/jre/bin/java", "-jar", "app.jar"]

# Saves: 100+ MB more
```

**10. Compress Layers**

```dockerfile
# Use --squash flag (experimental)
docker build --squash -t myapp:latest .

# Combines all layers into one (reduces size but loses layer caching)
```

#### Complete Optimized Dockerfile:

```dockerfile
# ==============================================
# Build Stage
# ==============================================
FROM maven:3.9-eclipse-temurin-17-alpine AS build

WORKDIR /build

# Copy only dependency definitions (cache optimization)
COPY pom.xml .
RUN mvn dependency:go-offline -B

# Copy source and build
COPY src ./src
RUN mvn clean package -DskipTests -B && \
    mv target/*.jar target/app.jar

# ==============================================
# Runtime Stage
# ==============================================
FROM eclipse-temurin:17-jre-alpine

# Install only required packages
RUN apk add --no-cache \
        ca-certificates \
        curl && \
    # Create non-root user
    addgroup -g 1000 appuser && \
    adduser -D -u 1000 -G appuser appuser

WORKDIR /app

# Copy JAR from build stage
COPY --from=build --chown=appuser:appuser /build/target/app.jar .

# Switch to non-root user
USER appuser

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=30s \
    CMD curl -f http://localhost:8080/actuator/health || exit 1

# JVM optimizations for containers
ENV JAVA_OPTS="-XX:+UseContainerSupport \
               -XX:MaxRAMPercentage=75.0 \
               -XX:+UseG1GC \
               -XX:+UseStringDeduplication"

CMD ["sh", "-c", "java ${JAVA_OPTS} -jar app.jar"]
```

**Size comparison:**

```
Before optimization: 850 MB
After optimization:  180 MB
Reduction: 78%
```

#### Analyzing Image Size:

```bash
# Check image size
docker images myapp

# See layer sizes
docker history myapp:latest --human

# Analyze with dive
dive myapp:latest

# Export image and inspect
docker save myapp:latest -o myapp.tar
tar -tvf myapp.tar
```

#### Best Practices Summary:

|Technique|Typical Savings|
|---|---|
|Multi-stage builds|50-70%|
|Alpine base image|30-50%|
|JRE instead of JDK|20-30%|
|Remove package cache|10-20%|
|Minimize layers|5-10%|
|Use .dockerignore|5-15%|
|Custom JRE with jlink|10-20%|

**Target sizes for Java apps:**

- Development: 400-600 MB (full JDK, debug tools)
- Production: 150-250 MB (JRE, optimized)
- Minimal: 100-150 MB (Alpine + custom JRE)

---

**Key Takeaways:**

- Images are blueprints, containers are running instances
- Use multi-stage builds for Java apps (critical!)
- Order Dockerfile instructions for maximum cache efficiency
- Choose base images wisely (Alpine vs Ubuntu vs Distroless)
- Always use specific version tags in production (never :latest)
- Optimize image size for faster deployments and better security
