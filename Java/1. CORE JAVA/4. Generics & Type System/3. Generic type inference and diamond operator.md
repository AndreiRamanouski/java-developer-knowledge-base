# Generic Type Inference and Diamond Operator

## Overview

Type inference is one of the most powerful features of Java generics, allowing the compiler to automatically deduce type arguments. This guide covers the evolution from Java 5's basic inference through Java 7's diamond operator to Java 8+'s sophisticated target typing, with practical examples of when inference works and when it fails.


---

## 1. Type Inference in Method Calls

### How the Compiler Deduces Types

```java
/**
 * TYPE INFERENCE IN METHOD CALLS
 * 
 * Compiler automatically determines type arguments
 */

import java.util.*;

public class MethodTypeInference {
    
    /**
     * Basic type inference
     */
    public static <T> T identity(T value) {
        return value;
    }
    
    public static <T> List<T> asList(T... elements) {
        return Arrays.asList(elements);
    }
    
    public static void basicInference() {
        // Compiler infers T = String
        String s = identity("hello");
        
        // Compiler infers T = Integer
        Integer i = identity(42);
        
        // Compiler infers T = String
        List<String> strings = asList("a", "b", "c");
        
        // Compiler infers T = Integer
        List<Integer> numbers = asList(1, 2, 3);
        
        System.out.println("String: " + s);
        System.out.println("Integer: " + i);
        System.out.println("Strings: " + strings);
        System.out.println("Numbers: " + numbers);
        
        /**
         * HOW IT WORKS:
         * 
         * String s = identity("hello");
         * 
         * 1. Method signature: <T> T identity(T value)
         * 2. Argument: "hello" (String)
         * 3. Expected return: String (from variable type)
         * 4. Inference: T = String
         * 5. Call becomes: String s = identity<String>("hello");
         */
    }
    
    /**
     * Inference from return type
     */
    public static <T> List<T> emptyList() {
        return new ArrayList<>();
    }
    
    public static void returnTypeInference() {
        // Infers T = String from variable type
        List<String> strings = emptyList();
        
        // Infers T = Integer from variable type
        List<Integer> numbers = emptyList();
        
        // Java 7+: Can also infer from target type
        List<Double> doubles = emptyList();
        
        System.out.println("Created empty lists");
        
        /**
         * INFERENCE SOURCES:
         * 
         * 1. Argument types
         * 2. Return type (target type)
         * 3. Generic bounds
         * 
         * Compiler uses all available information
         */
    }
    
    /**
     * Inference with bounded types
     */
    public static <T extends Number> double sum(List<T> numbers) {
        double total = 0;
        for (T num : numbers) {
            total += num.doubleValue();
        }
        return total;
    }
    
    public static void boundedTypeInference() {
        List<Integer> integers = Arrays.asList(1, 2, 3);
        double intSum = sum(integers);  // T = Integer
        
        List<Double> doubles = Arrays.asList(1.5, 2.5);
        double doubleSum = sum(doubles);  // T = Double
        
        System.out.println("Integer sum: " + intSum);
        System.out.println("Double sum: " + doubleSum);
        
        // Compiler ensures T extends Number
        List<String> strings = Arrays.asList("a", "b");
        // double strSum = sum(strings);  // ERROR: String doesn't extend Number
    }
    
    /**
     * Multiple type parameters
     */
    public static <K, V> Map<K, V> createMap(K key, V value) {
        Map<K, V> map = new HashMap<>();
        map.put(key, value);
        return map;
    }
    
    public static void multipleTypeParametersInference() {
        // Infers K = String, V = Integer
        Map<String, Integer> map1 = createMap("age", 30);
        
        // Infers K = Integer, V = String
        Map<Integer, String> map2 = createMap(1, "one");
        
        System.out.println("Map 1: " + map1);
        System.out.println("Map 2: " + map2);
        
        /**
         * INFERENCE:
         * 
         * createMap("age", 30)
         * 
         * Parameters: K key, V value
         * Arguments: "age" (String), 30 (Integer)
         * 
         * K = String
         * V = Integer
         */
    }
    
    /**
     * Inference with wildcards
     */
    public static <T> void copy(List<? super T> dest, List<? extends T> src) {
        for (T item : src) {
            dest.add(item);
        }
    }
    
    public static void wildcardInference() {
        List<Integer> integers = Arrays.asList(1, 2, 3);
        List<Number> numbers = new ArrayList<>();
        
        // Infers T = Integer
        copy(numbers, integers);
        
        System.out.println("Copied: " + numbers);
        
        /**
         * WILDCARD INFERENCE:
         * 
         * copy(numbers, integers)
         * 
         * Method: <T> void copy(List<? super T>, List<? extends T>)
         * 
         * Arguments:
         * - List<Number> (? super T)
         * - List<Integer> (? extends T)
         * 
         * From List<? extends T> = List<Integer>
         * → T = Integer (or supertype)
         * 
         * From List<? super T> = List<Number>
         * → T = Number (or subtype)
         * 
         * Common type: T = Integer ✓
         */
    }
    
    /**
     * Chained method calls
     */
    static class Builder<T> {
        private T value;
        
        public Builder<T> setValue(T value) {
            this.value = value;
            return this;
        }
        
        public T getValue() {
            return value;
        }
    }
    
    public static <T> Builder<T> builder() {
        return new Builder<>();
    }
    
    public static void chainedInference() {
        // Infers T = String from setValue argument
        String result = builder()
            .setValue("hello")
            .getValue();
        
        System.out.println("Result: " + result);
        
        /**
         * CHAINED INFERENCE:
         * 
         * builder() returns Builder<T>
         * setValue("hello") → T = String
         * getValue() returns String
         * 
         * Inference propagates through chain
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Basic Inference ===");
        basicInference();
        
        System.out.println("\n=== Return Type Inference ===");
        returnTypeInference();
        
        System.out.println("\n=== Bounded Type Inference ===");
        boundedTypeInference();
        
        System.out.println("\n=== Multiple Type Parameters ===");
        multipleTypeParametersInference();
        
        System.out.println("\n=== Wildcard Inference ===");
        wildcardInference();
        
        System.out.println("\n=== Chained Inference ===");
        chainedInference();
    }
}
```

---

## 2. Diamond Operator (<>) in Java 7+

### Reducing Redundancy in Constructor Calls

```java
/**
 * DIAMOND OPERATOR
 * 
 * Java 7 feature to avoid repeating type arguments
 */

import java.util.*;

public class DiamondOperator {
    
    /**
     * Before Java 7: Redundant type arguments
     */
    public static void beforeJava7() {
        /**
         * JAVA 5-6: Must repeat type arguments
         */
        
        // Verbose - type appears twice
        List<String> list1 = new ArrayList<String>();
        Map<String, Integer> map1 = new HashMap<String, Integer>();
        
        // Even worse with nested generics
        Map<String, List<Integer>> nestedMap1 = 
            new HashMap<String, List<Integer>>();
        
        /**
         * PROBLEM:
         * - Redundant
         * - Harder to read
         * - More typing
         * - Error-prone (types can get out of sync)
         */
    }
    
    /**
     * Java 7+: Diamond operator
     */
    public static void java7Diamond() {
        /**
         * JAVA 7+: Diamond operator <>
         */
        
        // Concise - type inferred from left side
        List<String> list = new ArrayList<>();
        Map<String, Integer> map = new HashMap<>();
        
        // Much cleaner with nested generics
        Map<String, List<Integer>> nestedMap = new HashMap<>();
        
        System.out.println("Created collections with diamond operator");
        
        /**
         * COMPILER INFERS:
         * 
         * List<String> list = new ArrayList<>();
         *                                    ^^
         * Left side declares List<String>
         * Right side infers: new ArrayList<String>()
         * 
         * Type argument copied from variable declaration
         */
    }
    
    /**
     * Diamond with different constructors
     */
    static class Box<T> {
        private T value;
        
        public Box() {
        }
        
        public Box(T value) {
            this.value = value;
        }
        
        public T getValue() {
            return value;
        }
    }
    
    public static void diamondWithConstructors() {
        // Diamond with no-arg constructor
        Box<String> box1 = new Box<>();
        
        // Diamond with parameterized constructor
        Box<Integer> box2 = new Box<>(42);
        
        System.out.println("Box2 value: " + box2.getValue());
        
        /**
         * WORKS WITH ANY CONSTRUCTOR:
         * As long as compiler can infer type from left side
         */
    }
    
    /**
     * Nested generics
     */
    public static void nestedGenerics() {
        // Before Java 7
        Map<String, List<Integer>> map1 = 
            new HashMap<String, List<Integer>>();
        
        // Java 7+ with diamond
        Map<String, List<Integer>> map2 = new HashMap<>();
        
        // Even deeper nesting
        Map<String, Map<Integer, List<Double>>> complex = new HashMap<>();
        
        System.out.println("Created nested generic collections");
        
        /**
         * READABILITY IMPROVEMENT:
         * 
         * Before: new HashMap<String, Map<Integer, List<Double>>>()
         * After:  new HashMap<>()
         * 
         * Much cleaner!
         */
    }
    
    /**
     * Diamond in method arguments
     */
    public static void processMap(Map<String, Integer> map) {
        System.out.println("Map size: " + map.size());
    }
    
    public static void diamondInArguments() {
        // Diamond in argument - infers from parameter type
        processMap(new HashMap<>());
        
        /**
         * INFERENCE:
         * 
         * Method expects: Map<String, Integer>
         * Argument: new HashMap<>()
         * Inferred: new HashMap<String, Integer>()
         */
    }
    
    /**
     * Diamond in return statements
     */
    public static List<String> createList() {
        // Diamond in return - infers from method return type
        return new ArrayList<>();
        
        /**
         * INFERENCE:
         * 
         * Return type: List<String>
         * Return value: new ArrayList<>()
         * Inferred: new ArrayList<String>()
         */
    }
    
    /**
     * When diamond doesn't work (Java 7)
     */
    public static void diamondLimitations() {
        /**
         * JAVA 7 LIMITATIONS:
         */
        
        // Anonymous classes - doesn't work in Java 7
        // List<String> list = new ArrayList<>() {  // ERROR in Java 7
        //     {
        //         add("hello");
        //     }
        // };
        
        // WORKAROUND: Specify type explicitly
        List<String> list = new ArrayList<String>() {
            {
                add("hello");
            }
        };
        
        /**
         * FIXED IN JAVA 9:
         * Diamond with anonymous classes works in Java 9+
         */
    }
    
    /**
     * Best practices
     */
    public static void bestPractices() {
        /**
         * DO USE DIAMOND:
         */
        
        // ✓ When type is obvious from left side
        List<String> list = new ArrayList<>();
        Map<String, Integer> map = new HashMap<>();
        
        /**
         * DON'T USE DIAMOND:
         */
        
        // ✗ When using raw types (defeats the purpose)
        List rawList = new ArrayList<>();  // Still raw!
        
        // ✗ When type needs to be explicitly different
        // (Use explicit type argument instead)
        
        /**
         * GUIDELINE:
         * Always use diamond operator for generic constructors
         * Unless there's a specific reason not to
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Java 7+ Diamond ===");
        java7Diamond();
        
        System.out.println("\n=== Diamond with Constructors ===");
        diamondWithConstructors();
        
        System.out.println("\n=== Nested Generics ===");
        nestedGenerics();
        
        System.out.println("\n=== Diamond in Arguments ===");
        diamondInArguments();
    }
}
```

---

## 3. Target Typing in Java 8+

### Improved Inference from Context

```java
/**
 * TARGET TYPING (JAVA 8+)
 * 
 * Enhanced type inference using target context
 */

import java.util.*;
import java.util.function.*;

public class TargetTyping {
    
    /**
     * Lambda type inference
     */
    public static void lambdaInference() {
        // Lambda parameter types inferred from interface
        Comparator<String> byLength = (s1, s2) -> s1.length() - s2.length();
        
        // Explicitly typed (verbose)
        Comparator<String> byLengthExplicit = 
            (String s1, String s2) -> s1.length() - s2.length();
        
        List<String> words = Arrays.asList("java", "is", "awesome");
        words.sort(byLength);
        
        System.out.println("Sorted: " + words);
        
        /**
         * TARGET TYPING:
         * 
         * Comparator<String> byLength = (s1, s2) -> ...
         * 
         * Target type: Comparator<String>
         * Method signature: int compare(String o1, String o2)
         * 
         * Inferred: s1 is String, s2 is String
         */
    }
    
    /**
     * Method reference inference
     */
    public static void methodReferenceInference() {
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
        
        // Method reference - type inferred from context
        names.forEach(System.out::println);
        
        /**
         * TARGET TYPING:
         * 
         * forEach(Consumer<? super String> action)
         * 
         * Method reference: System.out::println
         * Matches: void println(Object x)
         * 
         * Inferred as: Consumer<String>
         */
    }
    
    /**
     * Generic method calls without type witness
     */
    public static <T> List<T> emptyList() {
        return new ArrayList<>();
    }
    
    public static void genericMethodCallInference() {
        /**
         * JAVA 7: Often needs type witness
         */
        
        // Type witness required
        List<String> list1 = Collections.<String>emptyList();
        
        /**
         * JAVA 8+: Target typing eliminates need
         */
        
        // Target type inferred from variable
        List<String> list2 = emptyList();
        
        // Target type inferred from method parameter
        processStringList(emptyList());
        
        // Target type inferred from return type
        List<String> list3 = createEmptyStringList();
        
        System.out.println("Created empty lists");
    }
    
    private static void processStringList(List<String> list) {
        System.out.println("Processing list");
    }
    
    private static List<String> createEmptyStringList() {
        return emptyList();  // Infers from return type
    }
    
    /**
     * Chained generic method calls
     */
    static class Stream<T> {
        private List<T> data;
        
        public Stream(List<T> data) {
            this.data = data;
        }
        
        public <R> Stream<R> map(Function<T, R> mapper) {
            List<R> result = new ArrayList<>();
            for (T item : data) {
                result.add(mapper.apply(item));
            }
            return new Stream<>(result);
        }
        
        public List<T> collect() {
            return new ArrayList<>(data);
        }
    }
    
    public static <T> Stream<T> stream(List<T> list) {
        return new Stream<>(list);
    }
    
    public static void chainedGenericCalls() {
        List<String> words = Arrays.asList("hello", "world");
        
        // Target typing through the chain
        List<Integer> lengths = stream(words)
            .map(s -> s.length())  // String -> Integer
            .collect();
        
        System.out.println("Lengths: " + lengths);
        
        /**
         * INFERENCE:
         * 
         * stream(words) → Stream<String>
         * .map(s -> s.length()) → Stream<Integer>
         * .collect() → List<Integer>
         * 
         * Each step infers from previous
         */
    }
    
    /**
     * Generic constructor inference
     */
    static class Pair<K, V> {
        private K key;
        private V value;
        
        public Pair(K key, V value) {
            this.key = key;
            this.value = value;
        }
        
        public K getKey() { return key; }
        public V getValue() { return value; }
    }
    
    public static void genericConstructorInference() {
        // Java 8+: Constructor type arguments inferred
        Pair<String, Integer> pair1 = new Pair<>("age", 30);
        
        // Also works with diamond
        Pair<String, Integer> pair2 = new Pair<>("name", 100);
        
        // In method arguments
        processPair(new Pair<>("key", "value"));
        
        System.out.println("Pair: " + pair1.getKey() + "=" + pair1.getValue());
    }
    
    private static void processPair(Pair<String, String> pair) {
        System.out.println("Processing pair");
    }
    
    /**
     * Overload resolution
     */
    public static void process(List<String> list) {
        System.out.println("Processing String list");
    }
    
    public static void process(List<Integer> list) {
        System.out.println("Processing Integer list");
    }
    
    public static void overloadResolution() {
        // Correct overload selected based on target type
        process(Arrays.asList("a", "b"));  // String version
        process(Arrays.asList(1, 2, 3));   // Integer version
        
        /**
         * TARGET TYPING:
         * 
         * Arrays.asList() is generic
         * Compiler infers type from which overload can accept it
         */
    }
    
    /**
     * Conditional expressions
     */
    public static void conditionalExpressions() {
        boolean condition = true;
        
        // Target type inferred from variable
        List<String> list = condition ? 
            new ArrayList<>() : 
            new LinkedList<>();
        
        System.out.println("Created list");
        
        /**
         * JAVA 8+ IMPROVEMENT:
         * 
         * Both branches must have compatible type
         * Result type inferred as their common supertype
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Lambda Inference ===");
        lambdaInference();
        
        System.out.println("\n=== Method Reference Inference ===");
        methodReferenceInference();
        
        System.out.println("\n=== Generic Method Call Inference ===");
        genericMethodCallInference();
        
        System.out.println("\n=== Chained Generic Calls ===");
        chainedGenericCalls();
        
        System.out.println("\n=== Generic Constructor Inference ===");
        genericConstructorInference();
        
        System.out.println("\n=== Overload Resolution ===");
        overloadResolution();
        
        System.out.println("\n=== Conditional Expressions ===");
        conditionalExpressions();
    }
}
```

---

## 4. Type Witness in Method Calls

### Explicit Type Arguments

```java
/**
 * TYPE WITNESS
 * 
 * Explicitly specifying type arguments
 */

import java.util.*;

public class TypeWitness {
    
    /**
     * When type witness is needed
     */
    public static <T> List<T> emptyList() {
        return new ArrayList<>();
    }
    
    public static void whenNeeded() {
        /**
         * INFERENCE FAILS - Need type witness
         */
        
        // Java 7: Cannot infer from void method
        // emptyList().add("hello");  // ERROR: infers List<Object>
        
        // Solution: Type witness
        List<String>.<String>emptyList().add("hello");  // Explicit
        
        /**
         * BETTER: Use target type
         */
        List<String> list = emptyList();
        list.add("hello");
        
        System.out.println("List: " + list);
    }
    
    /**
     * Syntax of type witness
     */
    public static <T> T identity(T value) {
        return value;
    }
    
    public static <K, V> Map<K, V> singletonMap(K key, V value) {
        Map<K, V> map = new HashMap<>();
        map.put(key, value);
        return map;
    }
    
    public static void typeWitnessSyntax() {
        /**
         * SYNTAX:
         * 
         * object.<TypeArgs>methodName(args)
         * ClassName.<TypeArgs>staticMethod(args)
         */
        
        // Static method with type witness
        String s = TypeWitness.<String>identity("hello");
        
        // Multiple type arguments
        Map<String, Integer> map = 
            TypeWitness.<String, Integer>singletonMap("age", 30);
        
        System.out.println("String: " + s);
        System.out.println("Map: " + map);
        
        /**
         * RARELY NEEDED:
         * Target typing usually handles it
         * 
         * Without type witness (preferred):
         */
        String s2 = identity("hello");
        Map<String, Integer> map2 = singletonMap("age", 30);
    }
    
    /**
     * Type witness with instance methods
     */
    static class Container<T> {
        private T value;
        
        public <U> U transform(Function<T, U> mapper) {
            return mapper.apply(value);
        }
    }
    
    @FunctionalInterface
    interface Function<T, R> {
        R apply(T t);
    }
    
    public static void instanceMethodTypeWitness() {
        Container<String> container = new Container<>();
        
        // Type witness for instance method
        Integer length = container.<Integer>transform(s -> s.length());
        
        // Usually not needed - inferred from lambda
        Integer length2 = container.transform(s -> s.length());
        
        System.out.println("Length: " + length);
    }
    
    /**
     * Ambiguous inference
     */
    public static <T> void process(T value, List<T> list) {
        list.add(value);
    }
    
    public static void ambiguousInference() {
        // Ambiguous - what is T?
        // process(42, new ArrayList<String>());  // ERROR
        
        // Type witness disambiguates
        TypeWitness.<Number>process(42, new ArrayList<>());
        
        /**
         * INFERENCE CONFLICT:
         * 
         * From first arg: T = Integer
         * From second arg: T = String
         * 
         * Incompatible!
         * 
         * Type witness: T = Number
         * - Integer extends Number ✓
         * - List<Number> ✓
         */
    }
    
    /**
     * Forcing specific supertype
     */
    public static <T> List<T> asList(T... elements) {
        return Arrays.asList(elements);
    }
    
    public static void forcingSupertype() {
        // Infers T = Integer
        List<Integer> integers = asList(1, 2, 3);
        
        // Force T = Number
        List<Number> numbers = TypeWitness.<Number>asList(1, 2, 3);
        
        System.out.println("Integers: " + integers);
        System.out.println("Numbers: " + numbers);
        
        /**
         * USE CASE:
         * 
         * Want List<Number> not List<Integer>
         * Can add Double, Long, etc. later
         */
    }
    
    /**
     * Recursive bounds
     */
    public static <T extends Comparable<? super T>> T max(T a, T b) {
        return a.compareTo(b) > 0 ? a : b;
    }
    
    public static void recursiveBoundsWitness() {
        // Usually infers correctly
        Integer maxInt = max(5, 10);
        
        // Type witness can help with complex hierarchies
        Number maxNum = TypeWitness.<Integer>max(5, 10);
        
        System.out.println("Max: " + maxInt);
    }
    
    /**
     * When to use type witness
     */
    public static void whenToUseTypeWitness() {
        /**
         * USE TYPE WITNESS WHEN:
         * 
         * 1. Inference fails or is ambiguous
         * 2. Need to force specific supertype
         * 3. Complex generic hierarchies
         * 4. Clarifying intent (rarely)
         * 
         * 
         * PREFER TARGET TYPING:
         * 
         * Instead of:
         * List<String> list = this.<String>emptyList();
         * 
         * Use:
         * List<String> list = emptyList();
         * 
         * 
         * MODERN JAVA:
         * Type witness rarely needed thanks to improved inference
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== When Needed ===");
        whenNeeded();
        
        System.out.println("\n=== Type Witness Syntax ===");
        typeWitnessSyntax();
        
        System.out.println("\n=== Instance Method ===");
        instanceMethodTypeWitness();
        
        System.out.println("\n=== Forcing Supertype ===");
        forcingSupertype();
    }
}
```

---

## 5. Improved Type Inference in Newer Java Versions

### Evolution Across Java Releases

```java
/**
 * TYPE INFERENCE IMPROVEMENTS
 * 
 * How inference evolved from Java 5 to Java 21+
 */

import java.util.*;

public class InferenceImprovements {
    
    /**
     * Java 5-6: Basic inference
     */
    public static void java5Inference() {
        /**
         * JAVA 5-6: Limited inference
         * 
         * Method calls: ✓ Basic inference
         * Constructors: ✗ Must specify type
         */
        
        // Method call inference works
        List<String> list1 = Collections.emptyList();
        
        // Constructor requires explicit type
        List<String> list2 = new ArrayList<String>();
        
        // Nested generics painful
        Map<String, List<Integer>> map = 
            new HashMap<String, List<Integer>>();
    }
    
    /**
     * Java 7: Diamond operator
     */
    public static void java7Diamond() {
        /**
         * JAVA 7: Diamond operator <>
         * 
         * NEW: Constructor type inference
         */
        
        // Diamond operator introduced
        List<String> list = new ArrayList<>();
        
        // Works with nested generics
        Map<String, List<Integer>> map = new HashMap<>();
        
        // LIMITATION: Not with anonymous classes
        // List<String> list2 = new ArrayList<>() {  // ERROR in Java 7
        //     { add("hello"); }
        // };
        
        System.out.println("Java 7 diamond operator");
    }
    
    /**
     * Java 8: Target typing
     */
    public static void java8TargetTyping() {
        /**
         * JAVA 8: Enhanced target typing
         * 
         * NEW: Lambda parameter inference
         * NEW: Method reference inference
         * NEW: Better generic method inference
         */
        
        // Lambda parameter types inferred
        Comparator<String> comp = (s1, s2) -> s1.length() - s2.length();
        
        // Method reference inference
        List<String> list = Arrays.asList("a", "b", "c");
        list.forEach(System.out::println);
        
        // Generic method inference improved
        List<String> empty = Collections.emptyList();  // No type witness needed
        
        System.out.println("Java 8 target typing");
    }
    
    /**
     * Java 9: Diamond with anonymous classes
     */
    public static void java9AnonymousDiamond() {
        /**
         * JAVA 9: Diamond with anonymous classes
         * 
         * NEW: Can use <> with anonymous classes
         */
        
        // Now works in Java 9+
        List<String> list = new ArrayList<>() {
            {
                add("hello");
                add("world");
            }
        };
        
        System.out.println("Java 9 anonymous diamond: " + list);
        
        /**
         * INFERENCE:
         * 
         * Variable type: List<String>
         * Constructor: new ArrayList<>()
         * Inferred: new ArrayList<String>()
         * 
         * Works even with anonymous class body
         */
    }
    
    /**
     * Java 10: var (local variable type inference)
     */
    public static void java10Var() {
        /**
         * JAVA 10: var keyword
         * 
         * NEW: Infer local variable types from initializer
         */
        
        // Type inferred from right side
        var list = new ArrayList<String>();  // ArrayList<String>
        var map = new HashMap<String, Integer>();  // HashMap<String, Integer>
        var number = 42;  // int
        var text = "hello";  // String
        
        // Still statically typed!
        // list = new HashMap<>();  // ERROR: incompatible types
        
        System.out.println("Java 10 var");
        
        /**
         * LIMITATIONS:
         * 
         * - Only for local variables
         * - Must have initializer
         * - Cannot be null
         * - Cannot use with lambda without explicit target type
         */
    }
    
    /**
     * var with generics
     */
    public static void varWithGenerics() {
        // Type fully inferred
        var list = new ArrayList<String>();
        list.add("hello");
        
        // Type: ArrayList<String>
        String first = list.get(0);
        
        // Works with diamond
        var map = new HashMap<String, Integer>();
        map.put("age", 30);
        
        // Nested generics
        var nested = new HashMap<String, List<Integer>>();
        
        System.out.println("Var with generics");
        
        /**
         * READABILITY:
         * 
         * Before:
         * Map<String, List<Integer>> map = new HashMap<>();
         * 
         * With var:
         * var map = new HashMap<String, List<Integer>>();
         * 
         * Trade-off: Less redundancy vs. explicit type
         */
    }
    
    /**
     * var in loops
     */
    public static void varInLoops() {
        var list = List.of("a", "b", "c");
        
        // Enhanced for loop
        for (var item : list) {  // item is String
            System.out.println(item.toUpperCase());
        }
        
        // Traditional for loop
        for (var i = 0; i < list.size(); i++) {  // i is int
            System.out.println(list.get(i));
        }
        
        /**
         * CLARITY:
         * 
         * var in loops can improve readability
         * Type obvious from context
         */
    }
    
    /**
     * Java 11-17: Incremental improvements
     */
    public static void java11to17Improvements() {
        /**
         * JAVA 11-17: Refinements
         * 
         * - Better error messages
         * - More robust inference algorithm
         * - Performance improvements
         * 
         * No major new features, but:
         * - Edge cases handled better
         * - More scenarios infer correctly
         */
        
        // Example that works better in later versions
        var result = List.of(1, 2, 3)
            .stream()
            .map(i -> i * 2)
            .toList();
        
        System.out.println("Result: " + result);
    }
    
    /**
     * Java 16+: Records and sealed classes
     */
    public static void java16RecordsInference() {
        /**
         * JAVA 16+: Pattern matching improvements
         * 
         * Type inference works with records
         */
        
        record Point(int x, int y) {}
        
        var points = List.of(
            new Point(1, 2),
            new Point(3, 4)
        );
        
        // Type: List<Point>
        for (var point : points) {
            System.out.println(point.x() + ", " + point.y());
        }
    }
    
    /**
     * Best practices across versions
     */
    public static void bestPractices() {
        /**
         * BEST PRACTICES:
         * 
         * 1. USE DIAMOND OPERATOR (Java 7+)
         *    List<String> list = new ArrayList<>();
         *    ✓ Always use <> for constructors
         * 
         * 2. LEVERAGE TARGET TYPING (Java 8+)
         *    List<String> list = Collections.emptyList();
         *    ✓ No need for type witness
         * 
         * 3. USE VAR JUDICIOUSLY (Java 10+)
         *    var list = new ArrayList<String>();
         *    ✓ When type is obvious from right side
         *    ✗ When type needs to be documented
         * 
         * 4. AVOID EXPLICIT TYPE ARGUMENTS
         *    Collections.<String>emptyList()
         *    ✓ Let compiler infer
         *    ✗ Only use type witness when needed
         * 
         * 5. PREFER FACTORY METHODS (Java 9+)
         *    var list = List.of("a", "b", "c");
         *    ✓ Cleaner than new ArrayList<>()
         */
    }
    
    /**
     * Migration guide
     */
    public static void migrationGuide() {
        /**
         * UPGRADING TO NEWER JAVA:
         * 
         * JAVA 5/6 → JAVA 7:
         * - Replace new ArrayList<Type>() with new ArrayList<>()
         * - Replace new HashMap<K, V>() with new HashMap<>()
         * 
         * JAVA 7 → JAVA 8:
         * - Remove type witnesses where target typing works
         * - Use lambda parameter inference
         * 
         * JAVA 8 → JAVA 10+:
         * - Consider var for local variables
         * - Keep explicit types for public APIs
         * 
         * GENERAL:
         * - Let IDE suggest improvements
         * - Ensure code remains readable
         * - Don't sacrifice clarity for brevity
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Java 7 Diamond ===");
        java7Diamond();
        
        System.out.println("\n=== Java 8 Target Typing ===");
        java8TargetTyping();
        
        System.out.println("\n=== Java 9 Anonymous Diamond ===");
        java9AnonymousDiamond();
        
        System.out.println("\n=== Java 10 var ===");
        java10Var();
        
        System.out.println("\n=== var with Generics ===");
        varWithGenerics();
        
        System.out.println("\n=== var in Loops ===");
        varInLoops();
        
        System.out.println("\n=== Java 11-17 Improvements ===");
        java11to17Improvements();
        
        System.out.println("\n=== Java 16+ Records ===");
        java16RecordsInference();
    }
}
```

---

## 6. When Inference Fails

### Common Pitfalls and Solutions

```java
/**
 * WHEN INFERENCE FAILS
 * 
 * Understanding limitations and workarounds
 */

import java.util.*;
import java.io.Serializable;

public class InferenceFailures {
    
    /**
     * Failure case 1: No target type
     */
    public static <T> List<T> emptyList() {
        return new ArrayList<>();
    }
    
    public static void noTargetType() {
        /**
         * FAILS: No target type to infer from
         */
        
        // ERROR: Cannot infer type
        // emptyList().add("hello");
        
        /**
         * WHY:
         * emptyList() returns List<T>
         * No variable to infer T from
         * Compiler defaults to List<Object>
         * 
         * SOLUTIONS:
         */
        
        // 1. Assign to variable (provides target type)
        List<String> list1 = emptyList();
        list1.add("hello");
        
        // 2. Use type witness
        TypeWitness.<String>emptyList().add("hello");
        
        // 3. Chain with explicit type
        List<String> list2 = emptyList();
        
        System.out.println("List: " + list1);
    }
    
    /**
     * Failure case 2: Ambiguous type arguments
     */
    public static <T> void process(T value, List<T> list) {
        list.add(value);
    }
    
    public static void ambiguousTypes() {
        /**
         * FAILS: Conflicting type inference
         */
        
        // ERROR: Incompatible types
        // process(42, new ArrayList<String>());
        
        /**
         * WHY:
         * From first arg: T = Integer
         * From second arg: T = String
         * Contradiction!
         * 
         * SOLUTIONS:
         */
        
        // 1. Make types compatible
        List<Integer> intList = new ArrayList<>();
        process(42, intList);
        
        // 2. Use common supertype with type witness
        List<Number> numList = new ArrayList<>();
        TypeWitness.<Number>process(42, numList);
        
        // 3. Use wildcards in method signature (better design)
        // public static <T> void process(T value, List<? super T> list)
        
        System.out.println("Processed");
    }
    
    /**
     * Failure case 3: Multiple bounds conflict
     */
    public static <T extends Number & Comparable<T>> T max(T a, T b) {
        return a.compareTo(b) > 0 ? a : b;
    }
    
    public static void multipleBoundsConflict() {
        /**
         * WORKS: Integer satisfies both bounds
         */
        Integer maxInt = max(5, 10);
        
        /**
         * FAILS: Would need type that doesn't exist
         */
        
        // Custom class that doesn't implement Comparable<itself>
        // max(new CustomNumber(), new CustomNumber());  // ERROR
        
        /**
         * WHY:
         * Need T that:
         * - extends Number
         * - implements Comparable<T>
         * 
         * If CustomNumber implements Comparable<Number>, not Comparable<CustomNumber>
         * Doesn't satisfy bound
         * 
         * SOLUTION:
         * Implement Comparable<CustomNumber>
         */
        
        System.out.println("Max: " + maxInt);
    }
    
    /**
     * Failure case 4: Overloaded methods
     */
    public static void process(List<String> list) {
        System.out.println("Processing String list");
    }
    
    public static void process(Set<String> set) {
        System.out.println("Processing String set");
    }
    
    public static void overloadAmbiguity() {
        /**
         * WORKS: Explicit type
         */
        process(new ArrayList<String>());  // Calls List version
        process(new HashSet<String>());    // Calls Set version
        
        /**
         * FAILS: Diamond with ambiguity
         */
        
        // Which overload?
        // process(new ArrayList<>());  // ERROR: Ambiguous
        
        /**
         * WHY:
         * new ArrayList<>() needs target type
         * Two overloads available
         * Compiler can't decide
         * 
         * SOLUTION:
         * Provide explicit type
         */
        
        List<String> list = new ArrayList<>();
        process(list);
    }
    
    /**
     * Failure case 5: Null literal
     */
    public static <T> List<T> singletonList(T element) {
        return Collections.singletonList(element);
    }
    
    public static void nullLiteral() {
        /**
         * FAILS: null has no type
         */
        
        // ERROR: Cannot infer T from null
        // List<String> list = singletonList(null);
        
        /**
         * WHY:
         * null can be any reference type
         * No way to infer T
         * 
         * SOLUTIONS:
         */
        
        // 1. Type witness
        List<String> list1 = TypeWitness.<String>singletonList(null);
        
        // 2. Cast null
        List<String> list2 = singletonList((String) null);
        
        // 3. Use Collections.singletonList directly (knows about this)
        List<String> list3 = Collections.singletonList(null);
        
        System.out.println("Lists created");
    }
    
    /**
     * Failure case 6: Complex generic hierarchies
     */
    interface Producer<T> {
        T produce();
    }
    
    static class StringProducer implements Producer<String> {
        @Override
        public String produce() {
            return "hello";
        }
    }
    
    public static <T, P extends Producer<T>> T getFromProducer(P producer) {
        return producer.produce();
    }
    
    public static void complexHierarchy() {
        /**
         * SOMETIMES FAILS: Complex type relationships
         */
        
        StringProducer producer = new StringProducer();
        
        // May need type witness with complex hierarchies
        String result = getFromProducer(producer);
        
        // Or explicit type
        String result2 = TypeWitness.<String, StringProducer>getFromProducer(producer);
        
        System.out.println("Result: " + result);
        
        /**
         * WHY:
         * Compiler must infer:
         * - T from return type
         * - P from argument
         * - Relationship between them
         * 
         * Can be too complex
         */
    }
    
    /**
     * Failure case 7: Recursive type bounds
     */
    public static <T extends Comparable<? super T>> T max(List<T> list) {
        if (list.isEmpty()) {
            throw new IllegalArgumentException();
        }
        T max = list.get(0);
        for (T item : list) {
            if (item.compareTo(max) > 0) {
                max = item;
            }
        }
        return max;
    }
    
    public static void recursiveBounds() {
        /**
         * WORKS: Standard case
         */
        List<Integer> integers = Arrays.asList(1, 5, 3);
        Integer maxInt = max(integers);
        
        /**
         * FAILS: Inherited Comparable
         */
        
        class Animal implements Comparable<Animal> {
            @Override
            public int compareTo(Animal other) {
                return 0;
            }
        }
        
        class Dog extends Animal {
            // Inherits Comparable<Animal>, not Comparable<Dog>
        }
        
        List<Dog> dogs = new ArrayList<>();
        // Dog maxDog = max(dogs);  // May fail depending on Java version
        
        /**
         * WHY:
         * Dog is Comparable<Animal>
         * Bound expects Comparable<? super Dog>
         * Animal is super Dog ✓
         * But inference can be tricky
         * 
         * SOLUTION:
         * Java 8+ handles this better
         * Or use type witness
         */
        
        System.out.println("Max: " + maxInt);
    }
    
    /**
     * Failure case 8: Array creation
     */
    public static <T> T[] createArray(int size) {
        // return new T[size];  // ERROR: Cannot create array of type parameter
        
        /**
         * WHY:
         * Type erasure - T not known at runtime
         * Arrays need reified type
         * 
         * SOLUTIONS:
         */
        
        // 1. Return List instead
        // public static <T> List<T> createList(int size) {
        //     return new ArrayList<>(size);
        // }
        
        // 2. Use Array.newInstance with Class token
        // @SuppressWarnings("unchecked")
        // public static <T> T[] createArray(Class<T> type, int size) {
        //     return (T[]) Array.newInstance(type, size);
        // }
        
        return null;  // Placeholder
    }
    
    /**
     * Common workarounds summary
     */
    public static void workaroundsSummary() {
        /**
         * WHEN INFERENCE FAILS:
         * 
         * 1. NO TARGET TYPE:
         *    → Assign to variable
         *    → Use type witness
         * 
         * 2. AMBIGUOUS TYPES:
         *    → Make types compatible
         *    → Use type witness with common supertype
         *    → Redesign method signature
         * 
         * 3. OVERLOAD AMBIGUITY:
         *    → Provide explicit type
         *    → Use intermediate variable
         * 
         * 4. NULL LITERAL:
         *    → Type witness
         *    → Cast null
         * 
         * 5. COMPLEX HIERARCHIES:
         *    → Type witness
         *    → Simplify type relationships
         * 
         * 6. ARRAY CREATION:
         *    → Use List instead
         *    → Pass Class token
         * 
         * 
         * GENERAL STRATEGY:
         * 1. Let compiler infer (preferred)
         * 2. Add type to variable if needed
         * 3. Use type witness as last resort
         * 4. Consider redesigning if repeatedly failing
         */
    }
    
    /**
     * Debugging inference failures
     */
    public static void debuggingInference() {
        /**
         * DEBUGGING TECHNIQUES:
         * 
         * 1. CHECK COMPILER ERROR:
         *    Read carefully - often explains what's wrong
         * 
         * 2. ADD INTERMEDIATE VARIABLES:
         *    Break complex expressions into steps
         *    See what types are inferred
         * 
         * 3. USE EXPLICIT TYPES:
         *    Start with explicit, then try inference
         * 
         * 4. ENABLE VERBOSE COMPILER OUTPUT:
         *    javac -XDverboseResolution=all
         *    Shows inference steps
         * 
         * 5. CHECK JAVA VERSION:
         *    Newer versions have better inference
         *    Upgrade if possible
         * 
         * 6. SIMPLIFY:
         *    Remove complexity until it works
         *    Add back gradually
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== No Target Type ===");
        noTargetType();
        
        System.out.println("\n=== Ambiguous Types ===");
        ambiguousTypes();
        
        System.out.println("\n=== Multiple Bounds Conflict ===");
        multipleBoundsConflict();
        
        System.out.println("\n=== Overload Ambiguity ===");
        overloadAmbiguity();
        
        System.out.println("\n=== Null Literal ===");
        nullLiteral();
        
        System.out.println("\n=== Complex Hierarchy ===");
        complexHierarchy();
        
        System.out.println("\n=== Recursive Bounds ===");
        recursiveBounds();
    }
}
```

---

## Summary

### Quick Reference

**Type Inference Evolution:**

```
Java 5-6:  Basic method call inference
Java 7:    Diamond operator <>
Java 8:    Target typing, lambda inference
Java 9:    Diamond with anonymous classes
Java 10:   var keyword
Java 11+:  Incremental improvements
```

**Diamond Operator:**

```java
// Before Java 7
List<String> list = new ArrayList<String>();

// Java 7+
List<String> list = new ArrayList<>();  ✅

// Nested generics
Map<String, List<Integer>> map = new HashMap<>();  ✅
```

**Target Typing (Java 8+):**

```java
// Method arguments
processMap(new HashMap<>());  // Infers from parameter type

// Return statements
return new ArrayList<>();  // Infers from return type

// Lambda parameters
Comparator<String> c = (s1, s2) -> s1.length() - s2.length();
// s1 and s2 inferred as String
```

**Type Witness:**

```java
// Syntax
ClassName.<TypeArgs>methodName(args)

// Example
List<String> list = Collections.<String>emptyList();

// Rarely needed - prefer target typing
List<String> list = Collections.emptyList();  ✅
```

**var (Java 10+):**

```java
// Type inferred from right side
var list = new ArrayList<String>();  // ArrayList<String>
var map = new HashMap<String, Integer>();  // HashMap<String, Integer>

// Still statically typed!
// list = "hello";  // ERROR
```

### When Inference Fails

```
1. No target type → Assign to variable
2. Ambiguous types → Use type witness
3. Overload ambiguity → Provide explicit type
4. Null literal → Cast or type witness
5. Complex hierarchies → Simplify or type witness
6. Array creation → Use List or Class token
```

### Best Practices

**1. Always use diamond operator:**

```java
// ✅ GOOD
List<String> list = new ArrayList<>();

// ❌ BAD
List<String> list = new ArrayList<String>();
```

**2. Let target typing work:**

```java
// ✅ GOOD
List<String> list = Collections.emptyList();

// ❌ BAD (unnecessary type witness)
List<String> list = Collections.<String>emptyList();
```

**3. Use var judiciously:**

```java
// ✅ GOOD: Type obvious
var list = new ArrayList<String>();
var count = 0;

// ❌ BAD: Type not obvious
var result = process();  // What type is this?
```

**4. Avoid explicit types when inference works:**

```java
// ✅ GOOD
Map<String, Integer> map = createMap("age", 30);

// ❌ BAD (redundant type witness)
Map<String, Integer> map = TypeWitness.<String, Integer>createMap("age", 30);
```

**5. Break complex expressions:**

```java
// ❌ BAD: Complex, inference may fail
process(transform(filter(source)));

// ✅ GOOD: Clear types
var filtered = filter(source);
var transformed = transform(filtered);
process(transformed);
```

---
