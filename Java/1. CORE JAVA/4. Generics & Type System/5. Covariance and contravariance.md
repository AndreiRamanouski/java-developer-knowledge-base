# Covariance and Contravariance

## Overview

Variance describes how subtyping relationships work with parameterized types. Understanding variance is crucial for mastering Java generics and explains why arrays behave differently from generics, why PECS exists, and how to write safe, flexible APIs. This guide covers the fundamental concepts and practical applications that will make you an expert in Java's type system.

---

## 1. Arrays are Covariant (ArrayStoreException Risk)

### Why Arrays Allow Polymorphism but Can Fail at Runtime

```java
/**
 * ARRAY COVARIANCE
 * 
 * Arrays preserve subtyping relationships
 * But this causes runtime risks
 */

import java.util.*;

public class ArrayCovariance {
    
    /**
     * What is covariance?
     */
    public static void whatIsCovariance() {
        /**
         * COVARIANCE:
         * 
         * If Dog extends Animal, then
         * Dog[] is a subtype of Animal[]
         * 
         * Subtyping relationship is PRESERVED
         * 
         * Dog → Animal
         *  ↓       ↓
         * Dog[] → Animal[]
         * 
         * This is called COVARIANCE
         */
    }
    
    /**
     * Arrays are covariant
     */
    static class Animal {
        String name;
        
        Animal(String name) {
            this.name = name;
        }
    }
    
    static class Dog extends Animal {
        Dog(String name) {
            super(name);
        }
        
        void bark() {
            System.out.println(name + " barks!");
        }
    }
    
    static class Cat extends Animal {
        Cat(String name) {
            super(name);
        }
        
        void meow() {
            System.out.println(name + " meows!");
        }
    }
    
    public static void arraysAreCovariant() {
        Dog[] dogs = new Dog[3];
        dogs[0] = new Dog("Rex");
        dogs[1] = new Dog("Buddy");
        
        // Array covariance: Dog[] is Animal[]
        Animal[] animals = dogs;  // Legal! ✓
        
        System.out.println("First animal: " + animals[0].name);
        
        /**
         * COVARIANCE IN ACTION:
         * 
         * Dog[] is a subtype of Animal[]
         * Can assign Dog[] to Animal[] reference
         * 
         * This seems convenient...
         * But creates a problem!
         */
    }
    
    /**
     * The ArrayStoreException problem
     */
    public static void arrayStoreExceptionProblem() {
        Dog[] dogs = new Dog[3];
        dogs[0] = new Dog("Rex");
        
        // Covariance: Assign to Animal[]
        Animal[] animals = dogs;
        
        System.out.println("Trying to add a Cat...");
        
        try {
            // Compile-time: Legal (Cat is Animal)
            // Runtime: ArrayStoreException!
            animals[1] = new Cat("Whiskers");  // BOOM! ✗
            
        } catch (ArrayStoreException e) {
            System.out.println("ERROR: " + e.getMessage());
            System.out.println("Can't put Cat in Dog array!");
        }
        
        /**
         * WHY IT FAILS:
         * 
         * Animal[] animals = dogs;
         * 
         * Compile-time:
         * - animals is Animal[]
         * - Cat is Animal
         * - Should be legal ✓
         * 
         * Runtime:
         * - animals actually points to Dog[]
         * - Can't put Cat in Dog[]
         * - ArrayStoreException! ✗
         * 
         * 
         * ARRAY REMEMBERS COMPONENT TYPE:
         * 
         * Arrays are REIFIED
         * Know component type at runtime
         * Check every assignment
         * 
         * Dog[] knows it's Dog[]
         * Rejects Cat even through Animal[] reference
         */
    }
    
    /**
     * Runtime type checking
     */
    public static void runtimeTypeChecking() {
        Object[] objects = new String[3];  // Covariance
        
        // Compile-time OK (Object accepts anything)
        // Runtime check
        objects[0] = "hello";      // ✓ String goes in String[]
        objects[1] = "world";      // ✓
        
        try {
            objects[2] = 42;       // ✗ Integer can't go in String[]
        } catch (ArrayStoreException e) {
            System.out.println("Can't put Integer in String array");
        }
        
        /**
         * EVERY ARRAY WRITE IS CHECKED:
         * 
         * Performance cost!
         * Every assignment does runtime type check
         * 
         * But prevents corruption
         */
    }
    
    /**
     * Why arrays are covariant
     */
    public static void whyArraysAreCovariant() {
        /**
         * HISTORICAL REASON:
         * 
         * Before generics (Java 1.0), needed to write:
         * 
         * void sort(Object[] array) {
         *     // Sort any array
         * }
         * 
         * String[] strings = {"c", "a", "b"};
         * sort(strings);  // Needs covariance
         * 
         * Without covariance, couldn't sort String[]
         * Would need sort method for every type
         * 
         * 
         * GENERIC ALTERNATIVE:
         * 
         * <T> void sort(T[] array) {
         *     // Type-safe sort
         * }
         * 
         * Generics solve this better!
         * But arrays keep covariance for backwards compatibility
         */
    }
    
    /**
     * Safe array operations
     */
    public static void safeArrayOperations() {
        Dog[] dogs = {new Dog("Rex"), new Dog("Buddy")};
        Animal[] animals = dogs;  // Covariant assignment
        
        // SAFE: Reading
        for (Animal animal : animals) {
            System.out.println("Animal: " + animal.name);  // ✓
        }
        
        // SAFE: Reading and using Animal methods
        Animal first = animals[0];
        System.out.println("First: " + first.name);
        
        // UNSAFE: Writing (except null)
        // animals[0] = new Cat("Whiskers");  // ArrayStoreException
        animals[0] = null;  // ✓ null is always safe
        
        /**
         * PATTERN:
         * 
         * Covariant arrays safe for READING
         * Dangerous for WRITING
         * 
         * Same pattern as <? extends T>!
         */
    }
    
    /**
     * Generic method replacing array covariance
     */
    public static void printAnimals(Animal[] animals) {
        for (Animal animal : animals) {
            System.out.println(animal.name);
        }
    }
    
    public static <T> void printArray(T[] array) {
        for (T element : array) {
            System.out.println(element);
        }
    }
    
    public static void genericReplacement() {
        Dog[] dogs = {new Dog("Rex"), new Dog("Buddy")};
        
        // Old way: Covariance needed
        printAnimals(dogs);  // Works due to covariance
        
        // Modern way: Generics
        printArray(dogs);    // Type-safe, no covariance needed
        
        /**
         * GENERICS ARE BETTER:
         * 
         * Type-safe at compile-time
         * No runtime overhead
         * More flexible
         * 
         * Arrays use covariance for backwards compatibility
         * New code should use generics
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Arrays are Covariant ===");
        arraysAreCovariant();
        
        System.out.println("\n=== ArrayStoreException Problem ===");
        arrayStoreExceptionProblem();
        
        System.out.println("\n=== Runtime Type Checking ===");
        runtimeTypeChecking();
        
        System.out.println("\n=== Safe Array Operations ===");
        safeArrayOperations();
        
        System.out.println("\n=== Generic Replacement ===");
        genericReplacement();
    }
}
```

---

## 2. Generics are Invariant

### Why List<Dog> is NOT a Subtype of List<Animal>

```java
/**
 * GENERIC INVARIANCE
 * 
 * Generics do NOT preserve subtyping
 * This is by design for type safety
 */

import java.util.*;

public class GenericInvariance {
    
    /**
     * What is invariance?
     */
    public static void whatIsInvariance() {
        /**
         * INVARIANCE:
         * 
         * If Dog extends Animal, then
         * List<Dog> is NOT a subtype of List<Animal>
         * 
         * Subtyping relationship is NOT preserved
         * 
         * Dog → Animal
         *  ↓       ↑
         * List<Dog> ↛ List<Animal>
         * 
         * No relationship!
         * This is called INVARIANCE
         */
    }
    
    /**
     * Generics are invariant
     */
    static class Animal {
        String name;
        Animal(String name) { this.name = name; }
    }
    
    static class Dog extends Animal {
        Dog(String name) { super(name); }
        void bark() { System.out.println(name + " barks!"); }
    }
    
    static class Cat extends Animal {
        Cat(String name) { super(name); }
        void meow() { System.out.println(name + " meows!"); }
    }
    
    public static void genericsAreInvariant() {
        List<Dog> dogs = new ArrayList<>();
        dogs.add(new Dog("Rex"));
        dogs.add(new Dog("Buddy"));
        
        // ILLEGAL: List<Dog> is NOT List<Animal>
        // List<Animal> animals = dogs;  // COMPILE ERROR ✗
        
        /**
         * DOES NOT COMPILE:
         * 
         * List<Dog> is not a subtype of List<Animal>
         * Even though Dog extends Animal
         * 
         * Generics are INVARIANT
         */
        
        System.out.println("Dogs: " + dogs.size());
    }
    
    /**
     * Why generics are invariant
     */
    public static void whyGenericsAreInvariant() {
        /**
         * IMAGINE IF GENERICS WERE COVARIANT:
         * 
         * List<Dog> dogs = new ArrayList<>();
         * List<Animal> animals = dogs;  // Imagine this was legal
         * 
         * animals.add(new Cat("Whiskers"));  // Add Cat to Animal list
         * 
         * Dog dog = dogs.get(0);  // Get from Dog list
         * // Got a Cat from Dog list! Type system broken!
         * 
         * 
         * PROBLEM:
         * 
         * If covariant, could add Cat to List<Dog>
         * Type safety violated
         * ClassCastException at runtime
         * 
         * 
         * SOLUTION:
         * 
         * Make generics INVARIANT
         * List<Dog> is NOT List<Animal>
         * Can't assign one to the other
         * Type safety preserved!
         */
        
        // This is exactly the array problem
        // But arrays can't prevent it (covariance)
        // Generics CAN prevent it (invariance)
    }
    
    /**
     * Type erasure and invariance
     */
    public static void typeErasureAndInvariance() {
        List<Dog> dogs = new ArrayList<>();
        List<Cat> cats = new ArrayList<>();
        
        // Runtime: Both are just ArrayList
        System.out.println(dogs.getClass() == cats.getClass());  // true
        
        /**
         * TYPE ERASURE:
         * 
         * At runtime:
         * List<Dog> → List (raw)
         * List<Cat> → List (raw)
         * 
         * Both erased to List
         * No runtime type checking!
         * 
         * 
         * WHY INVARIANCE NEEDED:
         * 
         * Arrays: Runtime checking prevents corruption
         * Generics: No runtime checking, need compile-time prevention
         * 
         * Invariance provides compile-time safety
         */
    }
    
    /**
     * The flexibility problem
     */
    public static void flexibilityProblem() {
        /**
         * INVARIANCE IS SAFE:
         * 
         * But creates usability issues
         * 
         * 
         * EXAMPLE:
         */
        
        List<Dog> dogs = Arrays.asList(new Dog("Rex"), new Dog("Buddy"));
        
        // Want to count animals
        // int count = countAnimals(dogs);  // ERROR!
        
        // Can't pass List<Dog> to method expecting List<Animal>
        // Even though we just want to READ
        
        /**
         * SOLUTION:
         * 
         * Wildcards!
         * <? extends Animal> for reading (covariance)
         * <? super Dog> for writing (contravariance)
         * 
         * This is USE-SITE variance
         * Flexibility where needed, safety by default
         */
    }
    
    /**
     * Working with invariance
     */
    public static void processAnimals(List<Animal> animals) {
        for (Animal animal : animals) {
            System.out.println(animal.name);
        }
    }
    
    public static void workingWithInvariance() {
        List<Dog> dogs = Arrays.asList(new Dog("Rex"), new Dog("Buddy"));
        
        // DOESN'T WORK: Invariance
        // processAnimals(dogs);  // ERROR
        
        // SOLUTION 1: Convert to List<Animal>
        List<Animal> animals = new ArrayList<>(dogs);
        processAnimals(animals);
        
        // SOLUTION 2: Use wildcard (better - see next section)
        // processAnimalsFlexible(dogs);  // With <? extends Animal>
        
        System.out.println("Processed animals");
    }
    
    /**
     * Subtyping with same type argument
     */
    public static void subtypingWithSameTypeArgument() {
        /**
         * SAME TYPE ARGUMENT:
         * 
         * ArrayList<String> IS a subtype of List<String> ✓
         * 
         * ArrayList<String> → List<String>
         * 
         * Type argument SAME (String)
         * Container type relationship preserved
         * 
         * 
         * DIFFERENT TYPE ARGUMENTS:
         * 
         * ArrayList<Dog> NOT a subtype of List<Animal> ✗
         * 
         * ArrayList<Dog> ↛ List<Animal>
         * 
         * Type argument DIFFERENT (Dog vs Animal)
         * No relationship despite Dog extends Animal
         */
        
        ArrayList<String> arrayList = new ArrayList<>();
        List<String> list = arrayList;  // ✓ Legal
        
        ArrayList<Dog> dogList = new ArrayList<>();
        // List<Animal> animals = dogList;  // ✗ Illegal
    }
    
    /**
     * Invariance comparison table
     */
    public static void invarianceComparison() {
        /**
         * ARRAYS VS GENERICS:
         * 
         * Arrays:
         * - Covariant (preserve subtyping)
         * - Runtime type checking
         * - ArrayStoreException possible
         * 
         * Generics:
         * - Invariant (no subtyping)
         * - Compile-time type safety
         * - No runtime exceptions
         * 
         * 
         * DESIGN TRADE-OFF:
         * 
         * Arrays: Flexible but unsafe
         * Generics: Safe but inflexible (without wildcards)
         * 
         * Wildcards add flexibility back safely!
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Generics are Invariant ===");
        genericsAreInvariant();
        
        System.out.println("\n=== Type Erasure and Invariance ===");
        typeErasureAndInvariance();
        
        System.out.println("\n=== Working with Invariance ===");
        workingWithInvariance();
    }
}
```

---

## 3. Wildcard Variance

### Use-Site Variance with Bounded Wildcards

```java
/**
 * WILDCARD VARIANCE
 * 
 * Java's solution: Use-site variance
 */

import java.util.*;

public class WildcardVariance {
    
    /**
     * Variance terminology
     */
    public static void varianceTerminology() {
        /**
         * VARIANCE TERMINOLOGY:
         * 
         * COVARIANCE (with extends):
         * <? extends T>
         * Preserves subtyping for reading
         * List<Dog> → List<? extends Animal>
         * 
         * CONTRAVARIANCE (with super):
         * <? super T>
         * Reverses subtyping for writing
         * List<Animal> → List<? super Dog>
         * 
         * INVARIANCE (no wildcard):
         * List<T>
         * No subtyping relationship
         * List<Dog> ↛ List<Animal>
         * 
         * BIVARIANCE (unbounded):
         * List<?>
         * Accepts any type
         * But can't read or write (except null/Object)
         */
    }
    
    static class Animal {
        String name;
        Animal(String name) { this.name = name; }
    }
    
    static class Dog extends Animal {
        Dog(String name) { super(name); }
        void bark() { System.out.println(name + " barks!"); }
    }
    
    static class Cat extends Animal {
        Cat(String name) { super(name); }
        void meow() { System.out.println(name + " meows!"); }
    }
    
    /**
     * Covariance with extends (Producer)
     */
    public static void countAnimals(List<? extends Animal> animals) {
        int count = 0;
        for (Animal animal : animals) {  // Can read as Animal ✓
            System.out.println(animal.name);
            count++;
        }
        System.out.println("Total: " + count);
    }
    
    public static void covarianceWithExtends() {
        List<Dog> dogs = Arrays.asList(new Dog("Rex"), new Dog("Buddy"));
        List<Cat> cats = Arrays.asList(new Cat("Whiskers"), new Cat("Mittens"));
        
        // Both work! Covariance
        countAnimals(dogs);  // List<Dog> → List<? extends Animal> ✓
        countAnimals(cats);  // List<Cat> → List<? extends Animal> ✓
        
        /**
         * COVARIANCE:
         * 
         * List<Dog> is a subtype of List<? extends Animal>
         * List<Cat> is a subtype of List<? extends Animal>
         * 
         * Subtyping preserved for reading
         * 
         * 
         * WHY SAFE:
         * 
         * Can only READ
         * Everything is at least Animal
         * Safe to treat as Animal
         */
    }
    
    /**
     * Contravariance with super (Consumer)
     */
    public static void addDogs(List<? super Dog> list) {
        list.add(new Dog("Rex"));      // Can write Dog ✓
        list.add(new Dog("Buddy"));    // Can write Dog ✓
        
        // Can't read as Dog
        // Dog dog = list.get(0);  // ERROR: get() returns Object
        Object obj = list.get(0);  // Can only read as Object
        
        System.out.println("Added dogs");
    }
    
    public static void contravarianceWithSuper() {
        List<Animal> animals = new ArrayList<>();
        List<Object> objects = new ArrayList<>();
        
        // Both work! Contravariance
        addDogs(animals);  // List<Animal> → List<? super Dog> ✓
        addDogs(objects);  // List<Object> → List<? super Dog> ✓
        
        System.out.println("Animals: " + animals.size());
        System.out.println("Objects: " + objects.size());
        
        /**
         * CONTRAVARIANCE:
         * 
         * List<Animal> is a subtype of List<? super Dog>
         * List<Object> is a subtype of List<? super Dog>
         * 
         * Subtyping REVERSED for writing
         * 
         * 
         * WHY SAFE:
         * 
         * Can only WRITE Dog
         * Dog fits in Animal list ✓
         * Dog fits in Object list ✓
         * Always safe
         */
    }
    
    /**
     * Declaration-site vs Use-site variance
     */
    public static void declarationSiteVsUseSite() {
        /**
         * DECLARATION-SITE VARIANCE:
         * (C#, Scala, Kotlin)
         * 
         * interface IEnumerable<out T> {  // Covariant
         *     T get();
         * }
         * 
         * interface IConsumer<in T> {  // Contravariant
         *     void accept(T t);
         * }
         * 
         * Variance declared at interface level
         * 
         * 
         * USE-SITE VARIANCE:
         * (Java)
         * 
         * interface List<T> {  // Invariant by default
         *     T get(int index);
         *     void add(T element);
         * }
         * 
         * void process(List<? extends Animal> list)  // Covariant use
         * void consume(List<? super Dog> list)       // Contravariant use
         * 
         * Variance chosen at call site
         * More flexible but more verbose
         */
    }
    
    /**
     * Variance and PECS
     */
    public static void varianceAndPECS() {
        /**
         * PECS PRINCIPLE:
         * 
         * Producer Extends (Covariance)
         * - <? extends T>
         * - Reading from collection
         * - Covariant: List<Dog> → List<? extends Animal>
         * 
         * Consumer Super (Contravariance)
         * - <? super T>
         * - Writing to collection
         * - Contravariant: List<Animal> → List<? super Dog>
         * 
         * 
         * VARIANCE CONNECTION:
         * 
         * PECS describes which variance to use
         * Extends = Covariance
         * Super = Contravariance
         */
    }
    
    /**
     * Combining variance
     */
    public static <T> void copy(
            List<? super T> dest,      // Contravariant (Consumer)
            List<? extends T> src) {   // Covariant (Producer)
        
        for (T item : src) {    // Read from covariant
            dest.add(item);     // Write to contravariant
        }
    }
    
    public static void combiningVariance() {
        List<Dog> dogs = Arrays.asList(new Dog("Rex"), new Dog("Buddy"));
        List<Animal> animals = new ArrayList<>();
        
        // Copy Dog → Animal
        copy(animals, dogs);
        
        System.out.println("Copied " + animals.size() + " animals");
        
        /**
         * VARIANCE IN ACTION:
         * 
         * src: List<? extends T>
         * - Covariant
         * - List<Dog> → List<? extends Dog>
         * - Can read
         * 
         * dest: List<? super T>
         * - Contravariant
         * - List<Animal> → List<? super Dog>
         * - Can write
         * 
         * Both variances working together!
         */
    }
    
    /**
     * Get and Put principle
     */
    public static void getAndPutPrinciple() {
        /**
         * GET AND PUT PRINCIPLE:
         * 
         * If you GET from it:
         * - Use <? extends T> (covariance)
         * - Preserves subtyping
         * - Safe to read
         * 
         * If you PUT into it:
         * - Use <? super T> (contravariance)
         * - Reverses subtyping
         * - Safe to write
         * 
         * If you do BOTH:
         * - Use <T> (invariance)
         * - No variance
         * - Exact type needed
         */
    }
    
    /**
     * Variance with method return types
     */
    public static List<? extends Animal> getAnimals() {
        // Can return List<Dog>, List<Cat>, or List<Animal>
        return Arrays.asList(new Dog("Rex"), new Cat("Whiskers"));
    }
    
    public static void processAnimals(List<? extends Animal> animals) {
        for (Animal animal : animals) {
            System.out.println(animal.name);
        }
    }
    
    public static void varianceInReturnTypes() {
        List<? extends Animal> animals = getAnimals();
        processAnimals(animals);
        
        /**
         * RETURN TYPE COVARIANCE:
         * 
         * Can return any subtype of Animal list
         * Caller receives as List<? extends Animal>
         * 
         * Flexible for producer
         * Safe for consumer
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Covariance with extends ===");
        covarianceWithExtends();
        
        System.out.println("\n=== Contravariance with super ===");
        contravarianceWithSuper();
        
        System.out.println("\n=== Combining Variance ===");
        combiningVariance();
        
        System.out.println("\n=== Variance in Return Types ===");
        varianceInReturnTypes();
    }
}
```

---

## 4. Producer (Covariance) vs Consumer (Contravariance)

### Deep Dive into Reading and Writing

```java
/**
 * PRODUCER VS CONSUMER
 * 
 * Understanding when to use extends vs super
 */

import java.util.*;
import java.util.function.*;

public class ProducerVsConsumer {
    
    static class Animal {
        String name;
        Animal(String name) { this.name = name; }
    }
    
    static class Dog extends Animal {
        Dog(String name) { super(name); }
        void bark() { System.out.println(name + " barks!"); }
    }
    
    static class Beagle extends Dog {
        Beagle(String name) { super(name); }
        void sniff() { System.out.println(name + " sniffs!"); }
    }
    
    /**
     * Producer: Reading values (Covariance)
     */
    public static double sumNumbers(List<? extends Number> numbers) {
        // PRODUCER: We READ from the list
        double sum = 0;
        for (Number num : numbers) {  // Read as Number ✓
            sum += num.doubleValue();
        }
        
        // Can't write (except null)
        // numbers.add(42);      // ERROR ✗
        // numbers.add(3.14);    // ERROR ✗
        numbers.add(null);       // Only null ✓
        
        return sum;
    }
    
    public static void producerExample() {
        List<Integer> integers = Arrays.asList(1, 2, 3);
        List<Double> doubles = Arrays.asList(1.5, 2.5, 3.5);
        
        // Both work - covariance
        double intSum = sumNumbers(integers);
        double doubleSum = sumNumbers(doubles);
        
        System.out.println("Integer sum: " + intSum);
        System.out.println("Double sum: " + doubleSum);
        
        /**
         * PRODUCER PATTERN:
         * 
         * List<? extends Number> numbers
         * 
         * The list PRODUCES Number values
         * We read from it
         * 
         * Covariant:
         * - List<Integer> → List<? extends Number> ✓
         * - List<Double> → List<? extends Number> ✓
         * 
         * Safe because:
         * - We only READ
         * - Everything is at least Number
         */
    }
    
    /**
     * Consumer: Writing values (Contravariance)
     */
    public static void addDogs(List<? super Dog> dogs) {
        // CONSUMER: We WRITE to the list
        dogs.add(new Dog("Rex"));      // Write Dog ✓
        dogs.add(new Beagle("Buddy")); // Write Beagle ✓
        
        // Can read, but only as Object
        Object obj = dogs.get(0);      // Read as Object ✓
        // Dog dog = dogs.get(0);      // ERROR ✗
        
        System.out.println("Added " + dogs.size() + " dogs");
    }
    
    public static void consumerExample() {
        List<Dog> dogList = new ArrayList<>();
        List<Animal> animalList = new ArrayList<>();
        List<Object> objectList = new ArrayList<>();
        
        // All work - contravariance
        addDogs(dogList);     // List<Dog> → List<? super Dog> ✓
        addDogs(animalList);  // List<Animal> → List<? super Dog> ✓
        addDogs(objectList);  // List<Object> → List<? super Dog> ✓
        
        System.out.println("Dog list: " + dogList.size());
        System.out.println("Animal list: " + animalList.size());
        System.out.println("Object list: " + objectList.size());
        
        /**
         * CONSUMER PATTERN:
         * 
         * List<? super Dog> dogs
         * 
         * The list CONSUMES Dog values
         * We write to it
         * 
         * Contravariant:
         * - List<Dog> → List<? super Dog> ✓
         * - List<Animal> → List<? super Dog> ✓
         * - List<Object> → List<? super Dog> ✓
         * 
         * Safe because:
         * - We only WRITE Dog
         * - Dog fits in Dog, Animal, Object lists
         */
    }
    
    /**
     * Both reading and writing (Invariance)
     */
    public static <T extends Comparable<T>> void sort(List<T> list) {
        // BOTH: We READ and WRITE
        list.sort(Comparator.naturalOrder());
        
        /**
         * INVARIANT:
         * 
         * List<T> list
         * 
         * Need exact type T
         * No variance
         * 
         * Because:
         * - Read: T item = list.get(0)
         * - Write: list.set(0, item)
         * 
         * Both operations needed
         * Can't use wildcards
         */
    }
    
    public static void invarianceExample() {
        List<String> strings = new ArrayList<>(Arrays.asList("c", "a", "b"));
        
        sort(strings);  // Exact type: List<String>
        
        System.out.println("Sorted: " + strings);
    }
    
    /**
     * Real-world: Collections.copy
     */
    public static <T> void copy(
            List<? super T> dest,      // Consumer ✓
            List<? extends T> src) {   // Producer ✓
        
        if (dest.size() < src.size()) {
            throw new IndexOutOfBoundsException("Destination too small");
        }
        
        for (int i = 0; i < src.size(); i++) {
            T item = src.get(i);    // READ from producer
            dest.set(i, item);      // WRITE to consumer
        }
    }
    
    public static void collectionsCopyExample() {
        List<Dog> dogs = Arrays.asList(new Dog("Rex"), new Dog("Buddy"));
        List<Animal> animals = new ArrayList<>(Arrays.asList(null, null, null));
        
        copy(animals, dogs);  // Dog → Animal ✓
        
        System.out.println("Copied animals: " + animals.size());
        
        /**
         * PERFECT PECS:
         * 
         * src: List<? extends T>
         * - Producer: we READ
         * - Covariant
         * 
         * dest: List<? super T>
         * - Consumer: we WRITE
         * - Contravariant
         * 
         * Maximum flexibility!
         */
    }
    
    /**
     * Function interfaces and variance
     */
    public static void processAnimals(
            List<? extends Animal> animals,           // Producer
            Consumer<? super Animal> action) {        // Consumer
        
        for (Animal animal : animals) {  // Read from producer
            action.accept(animal);       // Write to consumer
        }
    }
    
    public static void functionInterfaceVariance() {
        List<Dog> dogs = Arrays.asList(new Dog("Rex"), new Dog("Buddy"));
        
        // Consumer<Object> can consume Animal
        Consumer<Object> objectConsumer = obj -> 
            System.out.println("Processing: " + obj);
        
        processAnimals(dogs, objectConsumer);
        
        /**
         * FUNCTION VARIANCE:
         * 
         * Consumer<? super Animal>
         * - Can accept Consumer<Animal>
         * - Can accept Consumer<Object>
         * - Contravariant consumer
         * 
         * This is how functional interfaces work with variance!
         */
    }
    
    /**
     * Comparator variance
     */
    public static void sortWithComparator(
            List<Dog> dogs,
            Comparator<? super Dog> comparator) {
        
        dogs.sort(comparator);
    }
    
    public static void comparatorVariance() {
        List<Dog> dogs = new ArrayList<>(Arrays.asList(
            new Dog("Rex"),
            new Dog("Buddy"),
            new Dog("Charlie")
        ));
        
        // Comparator<Animal> can compare Dogs
        Comparator<Animal> animalComparator = 
            Comparator.comparing(animal -> animal.name);
        
        sortWithComparator(dogs, animalComparator);
        
        System.out.println("Sorted dogs");
        
        /**
         * COMPARATOR<? SUPER T>:
         * 
         * Contravariant
         * Comparator<Animal> can compare Dog
         * More general comparator works for specific type
         * 
         * Common pattern in Java APIs!
         */
    }
    
    /**
     * Decision tree
     */
    public static void decisionTree() {
        /**
         * VARIANCE DECISION TREE:
         * 
         * Do you only READ from the collection?
         *   YES → Use <? extends T> (Producer/Covariant)
         *   Example: double sum(List<? extends Number> numbers)
         *   ↓
         * Do you only WRITE to the collection?
         *   YES → Use <? super T> (Consumer/Contravariant)
         *   Example: void add(List<? super Dog> list)
         *   ↓
         * Do you BOTH read AND write?
         *   YES → Use <T> (Invariant)
         *   Example: <T> void sort(List<T> list)
         *   ↓
         * Do you only use size(), isEmpty(), etc.?
         *   YES → Use <?> (Unbounded)
         *   Example: int size(List<?> list)
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Producer Example ===");
        producerExample();
        
        System.out.println("\n=== Consumer Example ===");
        consumerExample();
        
        System.out.println("\n=== Invariance Example ===");
        invarianceExample();
        
        System.out.println("\n=== Collections.copy Example ===");
        collectionsCopyExample();
        
        System.out.println("\n=== Function Interface Variance ===");
        functionInterfaceVariance();
        
        System.out.println("\n=== Comparator Variance ===");
        comparatorVariance();
    }
}
```

---

## 5. Return Type Covariance in Methods

### Overriding with More Specific Return Types

```java
/**
 * RETURN TYPE COVARIANCE
 * 
 * Methods can return subtypes when overriding
 */

import java.util.*;

public class ReturnTypeCovariance {
    
    /**
     * Basic return type covariance
     */
    static class Animal {
        String name;
        Animal(String name) { this.name = name; }
        
        Animal reproduce() {
            return new Animal("offspring");
        }
    }
    
    static class Dog extends Animal {
        Dog(String name) { super(name); }
        
        @Override
        Dog reproduce() {  // More specific return type! ✓
            return new Dog("puppy");
        }
        
        void bark() { System.out.println(name + " barks!"); }
    }
    
    public static void basicReturnTypeCovariance() {
        Animal animal = new Dog("Rex");
        
        // Calls Dog.reproduce()
        Animal offspring = animal.reproduce();
        System.out.println("Offspring: " + offspring.name);
        
        // With Dog reference
        Dog dog = new Dog("Buddy");
        Dog puppy = dog.reproduce();  // Returns Dog directly ✓
        puppy.bark();
        
        /**
         * RETURN TYPE COVARIANCE:
         * 
         * Parent: Animal reproduce()
         * Child:  Dog reproduce()
         * 
         * Override returns more specific type
         * Legal since Java 5
         * 
         * Dog is subtype of Animal
         * Safe to return Dog where Animal expected
         */
    }
    
    /**
     * Why return type covariance is safe
     */
    public static void whyItsSafe() {
        /**
         * COVARIANCE IS SAFE FOR RETURN TYPES:
         * 
         * class Parent {
         *     Animal getAnimal() { ... }
         * }
         * 
         * class Child extends Parent {
         *     Dog getAnimal() { ... }  // Returns Dog
         * }
         * 
         * Parent p = new Child();
         * Animal a = p.getAnimal();  // Gets Dog, stores as Animal ✓
         * 
         * 
         * WHY SAFE:
         * 
         * Dog IS-A Animal
         * Returning Dog where Animal expected is safe
         * Caller can always treat Dog as Animal
         * 
         * This is exactly how polymorphism works!
         */
    }
    
    /**
     * Clone method example
     */
    static class CloneableAnimal implements Cloneable {
        String name;
        
        CloneableAnimal(String name) {
            this.name = name;
        }
        
        @Override
        public CloneableAnimal clone() {  // Covariant return! ✓
            try {
                return (CloneableAnimal) super.clone();
            } catch (CloneNotSupportedException e) {
                throw new AssertionError();
            }
        }
    }
    
    static class CloneableDog extends CloneableAnimal {
        CloneableDog(String name) {
            super(name);
        }
        
        @Override
        public CloneableDog clone() {  // More specific! ✓
            return (CloneableDog) super.clone();
        }
    }
    
    public static void cloneExample() {
        CloneableDog dog = new CloneableDog("Rex");
        
        // Clone returns CloneableDog directly
        CloneableDog clonedDog = dog.clone();  // No cast needed! ✓
        
        System.out.println("Original: " + dog.name);
        System.out.println("Clone: " + clonedDog.name);
        
        /**
         * BEFORE JAVA 5:
         * 
         * Object clone() throws CloneNotSupportedException
         * 
         * CloneableDog dog = new CloneableDog("Rex");
         * CloneableDog clone = (CloneableDog) dog.clone();  // Cast needed
         * 
         * 
         * JAVA 5+:
         * 
         * CloneableDog clone() { ... }
         * 
         * CloneableDog clone = dog.clone();  // No cast! ✓
         * 
         * Covariant return types improve usability
         */
    }
    
    /**
     * Builder pattern with covariant returns
     */
    static class AnimalBuilder {
        protected String name;
        
        public AnimalBuilder setName(String name) {
            this.name = name;
            return this;  // Returns AnimalBuilder
        }
        
        public Animal build() {
            return new Animal(name);
        }
    }
    
    static class DogBuilder extends AnimalBuilder {
        private boolean trained;
        
        @Override
        public DogBuilder setName(String name) {  // Covariant! ✓
            super.setName(name);
            return this;  // Returns DogBuilder
        }
        
        public DogBuilder setTrained(boolean trained) {
            this.trained = trained;
            return this;
        }
        
        @Override
        public Dog build() {  // Covariant! ✓
            return new Dog(name);
        }
    }
    
    public static void builderPatternCovariance() {
        // Fluent API with specific type
        Dog dog = new DogBuilder()
            .setName("Rex")      // Returns DogBuilder ✓
            .setTrained(true)    // Can chain Dog-specific methods ✓
            .build();            // Returns Dog ✓
        
        System.out.println("Built dog: " + dog.name);
        
        /**
         * WITHOUT COVARIANT RETURNS:
         * 
         * AnimalBuilder setName(String name)  // Returns AnimalBuilder
         * 
         * new DogBuilder()
         *     .setName("Rex")      // Returns AnimalBuilder
         *     .setTrained(true)    // ERROR: not available on AnimalBuilder
         * 
         * 
         * WITH COVARIANT RETURNS:
         * 
         * DogBuilder setName(String name)  // Returns DogBuilder
         * 
         * Fluent API works correctly!
         * Can chain subclass-specific methods
         */
    }
    
    /**
     * Factory method pattern
     */
    static abstract class AnimalFactory {
        public abstract Animal createAnimal();
    }
    
    static class DogFactory extends AnimalFactory {
        @Override
        public Dog createAnimal() {  // Covariant return ✓
            return new Dog("Factory Dog");
        }
    }
    
    public static void factoryMethodCovariance() {
        DogFactory factory = new DogFactory();
        
        Dog dog = factory.createAnimal();  // Returns Dog directly ✓
        dog.bark();
        
        /**
         * FACTORY PATTERN BENEFIT:
         * 
         * Specific factory returns specific type
         * No casting needed
         * Type-safe
         */
    }
    
    /**
     * Limitations
     */
    public static void limitations() {
        /**
         * COVARIANCE ONLY FOR RETURN TYPES:
         * 
         * ✓ Legal: Override with more specific return
         * ✗ Illegal: Override with more specific parameter
         * 
         * 
         * EXAMPLE:
         * 
         * class Parent {
         *     void process(Animal a) { }
         * }
         * 
         * class Child extends Parent {
         *     void process(Dog d) { }  // NOT an override!
         * }
         * 
         * This is OVERLOAD, not OVERRIDE
         * 
         * 
         * WHY NOT PARAMETERS:
         * 
         * Parent p = new Child();
         * p.process(new Cat());  // Which method?
         * 
         * Parent.process expects Animal
         * Child.process expects Dog
         * Cat is Animal but not Dog
         * Would break!
         * 
         * Parameters are CONTRAVARIANT in theory
         * But Java doesn't allow this
         */
    }
    
    /**
     * Comparison with parameter types
     */
    public static void comparisonWithParameters() {
        /**
         * RETURN TYPES (Covariant):
         * 
         * Parent: Animal getAnimal()
         * Child:  Dog getAnimal() ✓
         * 
         * Safe because:
         * Dog can be used where Animal expected
         * 
         * 
         * PARAMETER TYPES (Would be Contravariant):
         * 
         * Parent: void process(Dog d)
         * Child:  void process(Animal a) ✗
         * 
         * Not allowed because:
         * Would need to accept MORE types
         * Liskov Substitution Principle violation
         * 
         * 
         * ACTUAL PARAMETER OVERRIDE:
         * 
         * Parent: void process(Animal a)
         * Child:  void process(Animal a) ✓
         * 
         * Must be SAME type
         * Invariant
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Basic Return Type Covariance ===");
        basicReturnTypeCovariance();
        
        System.out.println("\n=== Clone Example ===");
        cloneExample();
        
        System.out.println("\n=== Builder Pattern ===");
        builderPatternCovariance();
        
        System.out.println("\n=== Factory Method ===");
        factoryMethodCovariance();
    }
}
```

---

## 6. Real-World Application

### Practical Examples in Production Code

```java
/**
 * REAL-WORLD VARIANCE
 * 
 * How variance is used in actual applications
 */

import java.util.*;
import java.util.function.*;
import java.util.stream.*;

public class RealWorldVariance {
    
    /**
     * Stream API variance
     */
    public static void streamAPIVariance() {
        List<String> words = Arrays.asList("hello", "world", "java");
        
        // map: Function<? super String, ? extends Integer>
        // Contravariant input, covariant output
        List<Integer> lengths = words.stream()
            .map(String::length)  // String -> Integer
            .collect(Collectors.toList());
        
        System.out.println("Lengths: " + lengths);
        
        /**
         * STREAM VARIANCE:
         * 
         * <R> Stream<R> map(Function<? super T, ? extends R> mapper)
         * 
         * Function:
         * - Input: ? super T (contravariant)
         * - Output: ? extends R (covariant)
         * 
         * Maximum flexibility!
         */
    }
    
    /**
     * Comparator variance in sorting
     */
    static class Person {
        String name;
        int age;
        
        Person(String name, int age) {
            this.name = name;
            this.age = age;
        }
        
        @Override
        public String toString() {
            return name + "(" + age + ")";
        }
    }
    
    static class Employee extends Person {
        String department;
        
        Employee(String name, int age, String department) {
            super(name, age);
            this.department = department;
        }
    }
    
    public static void comparatorVariance() {
        List<Employee> employees = Arrays.asList(
            new Employee("Alice", 30, "IT"),
            new Employee("Bob", 25, "HR"),
            new Employee("Charlie", 35, "IT")
        );
        
        // Comparator<Person> can compare Employee
        Comparator<Person> byAge = Comparator.comparingInt(p -> p.age);
        
        employees.sort(byAge);  // Works! ✓
        
        System.out.println("Sorted employees: " + employees);
        
        /**
         * LIST.SORT SIGNATURE:
         * 
         * void sort(Comparator<? super E> c)
         * 
         * Contravariant comparator
         * Comparator<Person> works for List<Employee>
         * 
         * More general comparator for specific type
         */
    }
    
    /**
     * Event handling with variance
     */
    interface Event {
        long getTimestamp();
    }
    
    static class UserEvent implements Event {
        private long timestamp = System.currentTimeMillis();
        private String userId;
        private String action;
        
        UserEvent(String userId, String action) {
            this.userId = userId;
            this.action = action;
        }
        
        @Override
        public long getTimestamp() {
            return timestamp;
        }
        
        public String getUserId() {
            return userId;
        }
        
        public String getAction() {
            return action;
        }
    }
    
    static class EventBus {
        private final Map<Class<?>, List<Consumer<?>>> handlers = new HashMap<>();
        
        public <E extends Event> void subscribe(
                Class<E> eventType,
                Consumer<? super E> handler) {  // Contravariant! ✓
            
            handlers.computeIfAbsent(eventType, k -> new ArrayList<>())
                   .add(handler);
        }
        
        @SuppressWarnings("unchecked")
        public <E extends Event> void publish(E event) {
            Class<?> eventClass = event.getClass();
            List<Consumer<?>> eventHandlers = handlers.get(eventClass);
            
            if (eventHandlers != null) {
                for (Consumer<?> handler : eventHandlers) {
                    ((Consumer<E>) handler).accept(event);
                }
            }
        }
    }
    
    public static void eventHandlingVariance() {
        EventBus bus = new EventBus();
        
        // Handler for general Event
        Consumer<Event> generalHandler = event ->
            System.out.println("Event at: " + event.getTimestamp());
        
        // Handler for specific UserEvent
        Consumer<UserEvent> userHandler = event ->
            System.out.println("User " + event.getUserId() + 
                             " did: " + event.getAction());
        
        // Both work due to contravariance!
        bus.subscribe(UserEvent.class, generalHandler);  // Event → UserEvent ✓
        bus.subscribe(UserEvent.class, userHandler);     // UserEvent → UserEvent ✓
        
        bus.publish(new UserEvent("user123", "login"));
        
        /**
         * CONTRAVARIANT CONSUMER:
         * 
         * Consumer<? super E>
         * 
         * Can accept:
         * - Consumer<UserEvent>
         * - Consumer<Event>
         * - Consumer<Object>
         * 
         * General handler works for specific events
         */
    }
    
    /**
     * Repository pattern with variance
     */
    interface Entity {
        Long getId();
    }
    
    static class User implements Entity {
        private Long id;
        private String name;
        
        User(Long id, String name) {
            this.id = id;
            this.name = name;
        }
        
        @Override
        public Long getId() {
            return id;
        }
        
        public String getName() {
            return name;
        }
    }
    
    interface Repository<T extends Entity> {
        void save(T entity);
        T findById(Long id);
        
        // Covariant: Can return any subtype list
        List<? extends T> findAll();
        
        // Contravariant: Can accept any supertype list
        void saveAll(Collection<? extends T> entities);
    }
    
    static class UserRepository implements Repository<User> {
        private final Map<Long, User> storage = new HashMap<>();
        
        @Override
        public void save(User entity) {
            storage.put(entity.getId(), entity);
        }
        
        @Override
        public User findById(Long id) {
            return storage.get(id);
        }
        
        @Override
        public List<? extends User> findAll() {
            return new ArrayList<>(storage.values());
        }
        
        @Override
        public void saveAll(Collection<? extends User> entities) {
            for (User entity : entities) {
                save(entity);
            }
        }
    }
    
    public static void repositoryPatternVariance() {
        UserRepository repo = new UserRepository();
        
        List<User> users = Arrays.asList(
            new User(1L, "Alice"),
            new User(2L, "Bob")
        );
        
        repo.saveAll(users);  // Covariance in action
        
        List<? extends User> allUsers = repo.findAll();
        System.out.println("Users: " + allUsers.size());
        
        /**
         * REPOSITORY VARIANCE:
         * 
         * saveAll(Collection<? extends T>)
         * - Producer: Read from collection
         * - Covariant
         * 
         * findAll() returns List<? extends T>
         * - Producer: Return collection
         * - Covariant
         * 
         * Flexible and type-safe!
         */
    }
    
    /**
     * Functional programming with variance
     */
    public static <T, R> List<R> map(
            List<? extends T> list,              // Covariant input
            Function<? super T, ? extends R> fn) {  // Contravariant → Covariant
        
        List<R> result = new ArrayList<>();
        for (T item : list) {
            result.add(fn.apply(item));
        }
        return result;
    }
    
    public static void functionalProgrammingVariance() {
        List<Employee> employees = Arrays.asList(
            new Employee("Alice", 30, "IT"),
            new Employee("Bob", 25, "HR")
        );
        
        // Function<Person, String> works for Employee
        Function<Person, String> getName = person -> person.name;
        
        List<String> names = map(employees, getName);
        
        System.out.println("Names: " + names);
        
        /**
         * VARIANCE IN FUNCTIONAL STYLE:
         * 
         * map(List<? extends T>, Function<? super T, ? extends R>)
         * 
         * Input list: Covariant (read from)
         * Function input: Contravariant (accepts supertypes)
         * Function output: Covariant (returns subtypes)
         * 
         * Maximum type flexibility!
         */
    }
    
    /**
     * Collecting results with variance
     */
    public static <T> void addToCollection(
            Collection<? super T> collection,
            List<? extends T> items) {
        
        for (T item : items) {  // Read from covariant
            collection.add(item);  // Write to contravariant
        }
    }
    
    public static void collectingResultsVariance() {
        List<Employee> employees = Arrays.asList(
            new Employee("Alice", 30, "IT")
        );
        
        List<Person> people = new ArrayList<>();
        
        addToCollection(people, employees);  // Employee → Person ✓
        
        System.out.println("People: " + people.size());
        
        /**
         * VARIANCE FOR COLLECTING:
         * 
         * Read from: List<? extends T> (covariant)
         * Write to: Collection<? super T> (contravariant)
         * 
         * Classic PECS pattern
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Stream API Variance ===");
        streamAPIVariance();
        
        System.out.println("\n=== Comparator Variance ===");
        comparatorVariance();
        
        System.out.println("\n=== Event Handling Variance ===");
        eventHandlingVariance();
        
        System.out.println("\n=== Repository Pattern ===");
        repositoryPatternVariance();
        
        System.out.println("\n=== Functional Programming ===");
        functionalProgrammingVariance();
        
        System.out.println("\n=== Collecting Results ===");
        collectingResultsVariance();
    }
}
```

---

## Summary

### Quick Reference

**Variance Types:**

```
Covariance (extends):
  Preserves subtyping for reading
  List<Dog> → List<? extends Animal> ✓
  Safe to read, unsafe to write

Contravariance (super):
  Reverses subtyping for writing
  List<Animal> → List<? super Dog> ✓
  Safe to write, can only read as Object

Invariance (no wildcard):
  No subtyping relationship
  List<Dog> ↛ List<Animal> ✗
  Exact type required
```

**Arrays vs Generics:**

```
Arrays:
✓ Covariant (Dog[] → Animal[])
✗ Runtime checking (ArrayStoreException)
✗ Performance cost
✗ Can fail at runtime

Generics:
✓ Invariant by default
✓ Compile-time safety
✓ No runtime overhead
✓ Use wildcards for flexibility
```

**PECS Principle:**

```
Producer Extends (Covariance):
  <? extends T>
  Read from collection
  List<Dog> → List<? extends Animal>

Consumer Super (Contravariance):
  <? super T>
  Write to collection
  List<Animal> → List<? super Dog>

Example:
  <T> void copy(
      List<? super T> dest,    // Consumer
      List<? extends T> src)   // Producer
```

**Return Type Covariance:**

```
Override with more specific return:

class Animal {
    Animal reproduce() { ... }
}

class Dog extends Animal {
    @Override
    Dog reproduce() { ... }  // ✓ Covariant return
}

Safe because Dog is Animal
```

### Variance Decision Tree

```
Need to work with parameterized type?
  ↓
Only READING values?
  YES → <? extends T> (Covariance)
  Example: double sum(List<? extends Number>)
  ↓
Only WRITING values?
  YES → <? super T> (Contravariance)
  Example: void addAll(List<? super Dog>)
  ↓
Both READING and WRITING?
  YES → <T> (Invariance)
  Example: <T> void sort(List<T>)
  ↓
Only metadata access?
  YES → <?> (Unbounded)
  Example: int size(List<?>)
```

### Key Patterns

**1. Collections.copy:**

```java
public static <T> void copy(
    List<? super T> dest,      // Write here
    List<? extends T> src)     // Read from here
```

**2. Comparator:**

```java
void sort(Comparator<? super E> c)
// General comparator for specific type
```

**3. Function:**

```java
<R> Stream<R> map(
    Function<? super T, ? extends R> mapper)
// Contravariant input, covariant output
```

**4. Repository:**

```java
void saveAll(Collection<? extends T> entities)
List<? extends T> findAll()
// Covariant for reading collections
```

### Best Practices

**1. Arrays - avoid covariance:**

```java
// ❌ BAD: Covariance risk
Object[] objects = new String[10];
objects[0] = 42;  // ArrayStoreException

// ✅ GOOD: Use generics
List<Object> objects = new ArrayList<>();
List<String> strings = new ArrayList<>();
// objects = strings;  // Compile error
```

**2. Use wildcards for flexibility:**

```java
// ❌ BAD: Too restrictive
public void process(List<Animal> animals)

// ✅ GOOD: Accepts any Animal subtype
public void process(List<? extends Animal> animals)
```

**3. Apply PECS consistently:**

```java
// ✅ GOOD: PECS applied
public <T> void copy(
    List<? super T> dest,
    List<? extends T> src)
```

**4. Return type covariance for builders:**

```java
class Builder {
    Builder setName(String name) {
        return this;
    }
}

class SpecificBuilder extends Builder {
    @Override
    SpecificBuilder setName(String name) {  // Covariant
        return (SpecificBuilder) super.setName(name);
    }
    
    SpecificBuilder setSpecific() {
        return this;
    }
}
```

---
