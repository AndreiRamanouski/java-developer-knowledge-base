# Advanced Generic Patterns

## Overview

Advanced generic patterns represent the pinnacle of Java generics expertise. These patterns are used throughout the JDK (Enum, Comparable) and sophisticated libraries. Mastering them enables you to design elegant, type-safe APIs that would be impossible without generics. This guide covers the most powerful patterns in production use.


---

## 1. Recursive Type Bounds (Enum Pattern)

### The Self-Constraining Type Parameter

```java
/**
 * RECURSIVE TYPE BOUNDS
 * 
 * Type parameter constrained by itself
 * Most famous: Enum<E extends Enum<E>>
 */

import java.util.*;

public class RecursiveTypeBounds {
    
    /**
     * The Enum pattern
     */
    public static void enumPattern() {
        /**
         * JAVA.LANG.ENUM DECLARATION:
         * 
         * public abstract class Enum<E extends Enum<E>>
         *                           ^^^^^^^^^^^^^^^^^^^
         * Recursive type bound!
         * 
         * E extends Enum<E>
         * 
         * E must be a subtype of Enum<E>
         * 
         * EXAMPLE:
         * 
         * enum Color extends Enum<Color> {
         *     RED, GREEN, BLUE
         * }
         * 
         * Color extends Enum<Color> ✓
         * Type parameter = Color
         * Bound = Enum<Color>
         * Satisfies constraint!
         * 
         * 
         * WHY THIS PATTERN:
         * 
         * Ensures enum type knows its own type
         * Enables type-safe comparison
         * Prevents mixing different enum types
         */
    }
    
    /**
     * Comparable pattern
     */
    public static void comparablePattern() {
        /**
         * JAVA.LANG.COMPARABLE DECLARATION:
         * 
         * public interface Comparable<T> {
         *     int compareTo(T o);
         * }
         * 
         * COMMON USAGE:
         * 
         * class Person implements Comparable<Person> {
         *     public int compareTo(Person other) {
         *         // Compare with same type
         *     }
         * }
         * 
         * 
         * RECURSIVE BOUND IN METHODS:
         * 
         * public static <T extends Comparable<T>> T max(T a, T b) {
         *                ^^^^^^^^^^^^^^^^^^^^^^^^^^^
         *     return a.compareTo(b) > 0 ? a : b;
         * }
         * 
         * T must be comparable to itself!
         */
    }
    
    /**
     * Why recursive bounds?
     */
    static class Person implements Comparable<Person> {
        String name;
        int age;
        
        Person(String name, int age) {
            this.name = name;
            this.age = age;
        }
        
        @Override
        public int compareTo(Person other) {
            return Integer.compare(this.age, other.age);
        }
    }
    
    public static <T extends Comparable<T>> T max(T a, T b) {
        return a.compareTo(b) > 0 ? a : b;
    }
    
    public static void whyRecursiveBounds() {
        Person alice = new Person("Alice", 30);
        Person bob = new Person("Bob", 25);
        
        Person older = max(alice, bob);
        System.out.println("Older: " + older.name);
        
        /**
         * WITHOUT RECURSIVE BOUND:
         * 
         * class Parent implements Comparable<Parent> { }
         * class Child extends Parent { }
         * 
         * Child doesn't implement Comparable<Child>
         * It inherits Comparable<Parent>
         * 
         * max(child1, child2) would use Parent.compareTo
         * Not Child.compareTo if overridden
         * 
         * 
         * WITH RECURSIVE BOUND:
         * 
         * <T extends Comparable<T>>
         * 
         * Ensures T is comparable to T
         * Not to some supertype
         * Type-safe comparison!
         */
    }
    
    /**
     * Relaxed recursive bound
     */
    public static <T extends Comparable<? super T>> T maxRelaxed(T a, T b) {
        return a.compareTo(b) > 0 ? a : b;
    }
    
    public static void relaxedRecursiveBound() {
        /**
         * PROBLEM WITH STRICT BOUND:
         * 
         * class Fruit implements Comparable<Fruit> { }
         * class Apple extends Fruit { }
         * 
         * Apple doesn't implement Comparable<Apple>
         * Inherits Comparable<Fruit>
         * 
         * <T extends Comparable<T>> T max(T a, T b)
         * 
         * Won't accept Apple!
         * Apple not Comparable<Apple>
         * 
         * 
         * SOLUTION: RELAX THE BOUND:
         * 
         * <T extends Comparable<? super T>>
         * 
         * T can be comparable to supertype
         * Apple is Comparable<Fruit> ✓
         * Fruit is super Apple ✓
         * 
         * This is the pattern used in Collections.max()!
         */
        
        System.out.println("Relaxed bound allows inheritance");
    }
    
    /**
     * Custom recursive bound
     */
    interface SelfComparable<T extends SelfComparable<T>> {
        boolean isBetterThan(T other);
    }
    
    static class Score implements SelfComparable<Score> {
        int value;
        
        Score(int value) {
            this.value = value;
        }
        
        @Override
        public boolean isBetterThan(Score other) {
            return this.value > other.value;
        }
    }
    
    public static <T extends SelfComparable<T>> T best(T a, T b) {
        return a.isBetterThan(b) ? a : b;
    }
    
    public static void customRecursiveBound() {
        Score score1 = new Score(100);
        Score score2 = new Score(150);
        
        Score highest = best(score1, score2);
        System.out.println("Best score: " + highest.value);
        
        /**
         * CUSTOM PATTERN:
         * 
         * interface SelfComparable<T extends SelfComparable<T>>
         * 
         * Same pattern as Comparable
         * Custom comparison logic
         * Type-safe
         */
    }
    
    /**
     * Multiple recursive bounds
     */
    interface Mergeable<T extends Mergeable<T>> {
        T merge(T other);
    }
    
    interface Splittable<T extends Splittable<T>> {
        List<T> split();
    }
    
    static class DataChunk implements 
            Mergeable<DataChunk>, 
            Splittable<DataChunk> {
        
        private String data;
        
        DataChunk(String data) {
            this.data = data;
        }
        
        @Override
        public DataChunk merge(DataChunk other) {
            return new DataChunk(this.data + other.data);
        }
        
        @Override
        public List<DataChunk> split() {
            int mid = data.length() / 2;
            return Arrays.asList(
                new DataChunk(data.substring(0, mid)),
                new DataChunk(data.substring(mid))
            );
        }
    }
    
    public static <T extends Mergeable<T> & Splittable<T>> 
    T process(T data) {
        System.out.println("Processing data");
        return data;
    }
    
    public static void multipleRecursiveBounds() {
        DataChunk chunk = new DataChunk("HelloWorld");
        DataChunk processed = process(chunk);
        
        /**
         * MULTIPLE RECURSIVE BOUNDS:
         * 
         * <T extends Mergeable<T> & Splittable<T>>
         * 
         * T must be:
         * - Mergeable with itself
         * - Splittable into itself
         * 
         * Type-safe operations guaranteed!
         */
    }
    
    /**
     * Limitations and gotchas
     */
    public static void limitationsAndGotchas() {
        /**
         * GOTCHA 1: Can't instantiate
         * 
         * <T extends Comparable<T>> T create() {
         *     return new T();  // ERROR
         * }
         * 
         * Type parameter can't be instantiated
         * 
         * 
         * GOTCHA 2: Inheritance confusion
         * 
         * class Parent implements Comparable<Parent> { }
         * class Child extends Parent { }
         * 
         * Child is NOT Comparable<Child>
         * Use relaxed bound: <? super T>
         * 
         * 
         * GOTCHA 3: Type inference challenges
         * 
         * max(new Child(), new Child())
         * 
         * May fail to infer if bound too strict
         * Compiler error "type parameter not within bounds"
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Why Recursive Bounds ===");
        whyRecursiveBounds();
        
        System.out.println("\n=== Relaxed Recursive Bound ===");
        relaxedRecursiveBound();
        
        System.out.println("\n=== Custom Recursive Bound ===");
        customRecursiveBound();
        
        System.out.println("\n=== Multiple Recursive Bounds ===");
        multipleRecursiveBounds();
    }
}
```

---

## 2. Self-Referential Generics

### Fluent APIs and Builder Patterns

```java
/**
 * SELF-REFERENTIAL GENERICS
 * 
 * Type parameter refers to the class itself
 * Enables fluent APIs and method chaining
 */

import java.util.*;

public class SelfReferentialGenerics {
    
    /**
     * Basic self-reference pattern
     */
    static class BasicBuilder<T extends BasicBuilder<T>> {
        protected String name;
        
        @SuppressWarnings("unchecked")
        protected T self() {
            return (T) this;
        }
        
        public T setName(String name) {
            this.name = name;
            return self();
        }
        
        public String getName() {
            return name;
        }
    }
    
    static class SpecificBuilder extends BasicBuilder<SpecificBuilder> {
        private int value;
        
        public SpecificBuilder setValue(int value) {
            this.value = value;
            return self();
        }
        
        public int getValue() {
            return value;
        }
    }
    
    public static void basicSelfReference() {
        SpecificBuilder builder = new SpecificBuilder()
            .setName("test")     // Returns SpecificBuilder ✓
            .setValue(42)        // Can chain specific methods ✓
            .setName("updated"); // Still SpecificBuilder ✓
        
        System.out.println("Name: " + builder.getName());
        System.out.println("Value: " + builder.getValue());
        
        /**
         * SELF-REFERENCE PATTERN:
         * 
         * class BasicBuilder<T extends BasicBuilder<T>>
         *                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^
         * 
         * T is the subclass type
         * Methods return T
         * Enables fluent chaining in subclasses
         * 
         * 
         * WITHOUT SELF-REFERENCE:
         * 
         * class BasicBuilder {
         *     BasicBuilder setName(String name) { return this; }
         * }
         * 
         * class SpecificBuilder extends BasicBuilder {
         *     SpecificBuilder setValue(int v) { return this; }
         * }
         * 
         * new SpecificBuilder()
         *     .setName("x")    // Returns BasicBuilder
         *     .setValue(42)    // ERROR: not on BasicBuilder
         */
    }
    
    /**
     * Abstract builder pattern
     */
    static abstract class Entity<T extends Entity<T>> {
        protected Long id;
        protected String createdAt;
        
        @SuppressWarnings("unchecked")
        protected T self() {
            return (T) this;
        }
        
        public T setId(Long id) {
            this.id = id;
            return self();
        }
        
        public T setCreatedAt(String createdAt) {
            this.createdAt = createdAt;
            return self();
        }
    }
    
    static class User extends Entity<User> {
        private String email;
        
        public User setEmail(String email) {
            this.email = email;
            return self();
        }
        
        public String getEmail() {
            return email;
        }
    }
    
    public static void abstractBuilderPattern() {
        User user = new User()
            .setId(1L)               // From Entity, returns User ✓
            .setEmail("a@b.com")     // User-specific ✓
            .setCreatedAt("2025")    // From Entity, returns User ✓
            .setEmail("c@d.com");    // Still chaining ✓
        
        System.out.println("User email: " + user.getEmail());
        
        /**
         * ABSTRACT PATTERN:
         * 
         * Base class provides common methods
         * Returns T (subclass type)
         * Subclass can chain with both base and specific methods
         * 
         * Perfect for entity hierarchies!
         */
    }
    
    /**
     * Simulated self-types (curiously recurring template pattern)
     */
    static abstract class Animal<T extends Animal<T>> {
        protected String name;
        
        public Animal(String name) {
            this.name = name;
        }
        
        @SuppressWarnings("unchecked")
        protected T self() {
            return (T) this;
        }
        
        public abstract T reproduce();
        
        public T setName(String name) {
            this.name = name;
            return self();
        }
    }
    
    static class Dog extends Animal<Dog> {
        public Dog(String name) {
            super(name);
        }
        
        @Override
        public Dog reproduce() {
            return new Dog(this.name + " Jr.");
        }
        
        public Dog train() {
            System.out.println(name + " is trained");
            return self();
        }
    }
    
    public static void simulatedSelfTypes() {
        Dog dog = new Dog("Rex");
        
        Dog offspring = dog
            .setName("Rex Sr.")  // Returns Dog ✓
            .train()             // Returns Dog ✓
            .reproduce();        // Returns Dog ✓
        
        System.out.println("Offspring: " + offspring.name);
        
        /**
         * CURIOUSLY RECURRING TEMPLATE PATTERN (CRTP):
         * 
         * class Dog extends Animal<Dog>
         *                           ^^^
         * Passes itself as type parameter
         * 
         * Known as CRTP from C++
         * Simulates self-types
         * 
         * Benefits:
         * - Type-safe method chaining
         * - Covariant return types
         * - No casting in subclass
         */
    }
    
    /**
     * Fluent API design
     */
    static class QueryBuilder<T extends QueryBuilder<T>> {
        protected StringBuilder query = new StringBuilder();
        
        @SuppressWarnings("unchecked")
        protected T self() {
            return (T) this;
        }
        
        public T select(String... fields) {
            query.append("SELECT ").append(String.join(", ", fields));
            return self();
        }
        
        public T from(String table) {
            query.append(" FROM ").append(table);
            return self();
        }
        
        public T where(String condition) {
            query.append(" WHERE ").append(condition);
            return self();
        }
        
        public String build() {
            return query.toString();
        }
    }
    
    static class UserQueryBuilder extends QueryBuilder<UserQueryBuilder> {
        public UserQueryBuilder whereActive() {
            return where("active = true");
        }
        
        public UserQueryBuilder whereRole(String role) {
            return where("role = '" + role + "'");
        }
    }
    
    public static void fluentAPIDesign() {
        String query = new UserQueryBuilder()
            .select("id", "name")    // From base, returns UserQueryBuilder ✓
            .from("users")           // From base, returns UserQueryBuilder ✓
            .whereActive()           // User-specific ✓
            .whereRole("admin")      // Can continue chaining ✓
            .build();
        
        System.out.println("Query: " + query);
        
        /**
         * FLUENT API PATTERN:
         * 
         * Methods return this/self
         * Enables method chaining
         * Self-reference ensures correct return type
         * 
         * Used extensively in:
         * - Query builders (jOOQ, QueryDSL)
         * - Test frameworks (AssertJ)
         * - Configuration APIs
         */
    }
    
    /**
     * Multiple inheritance simulation
     */
    interface Loggable<T extends Loggable<T>> {
        @SuppressWarnings("unchecked")
        default T log(String message) {
            System.out.println("[LOG] " + message);
            return (T) this;
        }
    }
    
    interface Validatable<T extends Validatable<T>> {
        boolean isValid();
        
        @SuppressWarnings("unchecked")
        default T validate() {
            if (!isValid()) {
                throw new IllegalStateException("Validation failed");
            }
            return (T) this;
        }
    }
    
    static class Form implements Loggable<Form>, Validatable<Form> {
        private String data;
        
        public Form setData(String data) {
            this.data = data;
            return this;
        }
        
        @Override
        public boolean isValid() {
            return data != null && !data.isEmpty();
        }
    }
    
    public static void multipleInheritanceSimulation() {
        Form form = new Form()
            .setData("test")      // Form method ✓
            .log("Data set")      // Loggable method ✓
            .validate()           // Validatable method ✓
            .log("Validated");    // Continue chaining ✓
        
        /**
         * MIXIN PATTERN:
         * 
         * Multiple interfaces with self-reference
         * Each provides fluent methods
         * Class implements all, gets all methods
         * All return correct type for chaining
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Basic Self-Reference ===");
        basicSelfReference();
        
        System.out.println("\n=== Abstract Builder Pattern ===");
        abstractBuilderPattern();
        
        System.out.println("\n=== Simulated Self-Types ===");
        simulatedSelfTypes();
        
        System.out.println("\n=== Fluent API Design ===");
        fluentAPIDesign();
        
        System.out.println("\n=== Multiple Inheritance Simulation ===");
        multipleInheritanceSimulation();
    }
}
```

---

## 3. Generic Builder Pattern

### Type-Safe Object Construction

```java
/**
 * GENERIC BUILDER PATTERN
 * 
 * Compile-time verification of required fields
 * Progressive type narrowing
 */

import java.util.*;

public class GenericBuilderPattern {
    
    /**
     * Basic builder
     */
    static class User {
        private final String name;
        private final String email;
        private final int age;
        
        private User(Builder builder) {
            this.name = builder.name;
            this.email = builder.email;
            this.age = builder.age;
        }
        
        static class Builder {
            private String name;
            private String email;
            private int age;
            
            public Builder setName(String name) {
                this.name = name;
                return this;
            }
            
            public Builder setEmail(String email) {
                this.email = email;
                return this;
            }
            
            public Builder setAge(int age) {
                this.age = age;
                return this;
            }
            
            public User build() {
                // Problem: No compile-time verification
                if (name == null || email == null) {
                    throw new IllegalStateException("Missing required fields");
                }
                return new User(this);
            }
        }
    }
    
    public static void basicBuilder() {
        User user = new User.Builder()
            .setName("Alice")
            .setEmail("alice@example.com")
            .setAge(30)
            .build();
        
        // PROBLEM: This compiles but fails at runtime
        try {
            User invalid = new User.Builder()
                .setName("Bob")
                // Missing email!
                .build();  // Runtime error!
        } catch (IllegalStateException e) {
            System.out.println("Error: " + e.getMessage());
        }
        
        /**
         * BASIC BUILDER PROBLEM:
         * 
         * Can forget required fields
         * Fails at RUNTIME, not compile-time
         * No type-safety for build order
         */
    }
    
    /**
     * Type-safe builder with phantom types
     */
    static class TypeSafeUser {
        private final String name;
        private final String email;
        private final int age;
        
        private TypeSafeUser(String name, String email, int age) {
            this.name = name;
            this.email = email;
            this.age = age;
        }
        
        // Phantom types: Never instantiated
        static class NoName {}
        static class HasName {}
        static class NoEmail {}
        static class HasEmail {}
        
        static class Builder<N, E> {
            private String name;
            private String email;
            private int age;
            
            // Only available when no name
            public Builder<HasName, E> setName(String name) {
                Builder<HasName, E> builder = new Builder<>();
                builder.name = name;
                builder.email = this.email;
                builder.age = this.age;
                return builder;
            }
            
            // Only available when has name
            public Builder<N, HasEmail> setEmail(String email) {
                Builder<N, HasEmail> builder = new Builder<>();
                builder.name = this.name;
                builder.email = email;
                builder.age = this.age;
                return builder;
            }
            
            public Builder<N, E> setAge(int age) {
                this.age = age;
                return this;
            }
            
            // Only callable when both present
            public TypeSafeUser build() {
                return new TypeSafeUser(name, email, age);
            }
        }
        
        public static Builder<NoName, NoEmail> builder() {
            return new Builder<>();
        }
    }
    
    public static void typeSafeBuilder() {
        // Compile-time verification!
        TypeSafeUser user = TypeSafeUser.builder()
            .setName("Alice")
            .setEmail("alice@example.com")
            .setAge(30)
            .build();
        
        // Won't compile - missing email!
        // TypeSafeUser invalid = TypeSafeUser.builder()
        //     .setName("Bob")
        //     .build();  // ERROR: build() not available
        
        /**
         * TYPE-SAFE BUILDER:
         * 
         * Builder<NoName, NoEmail> starts
         * .setName() → Builder<HasName, NoEmail>
         * .setEmail() → Builder<HasName, HasEmail>
         * .build() only available on Builder<HasName, HasEmail>
         * 
         * Compiler enforces required fields!
         * Impossible to build invalid object!
         */
        
        System.out.println("Type-safe builder works!");
    }
    
    /**
     * Step builder pattern
     */
    static class Order {
        private final String customer;
        private final String product;
        private final int quantity;
        private final String address;
        
        private Order(String customer, String product, int quantity, String address) {
            this.customer = customer;
            this.product = product;
            this.quantity = quantity;
            this.address = address;
        }
        
        interface CustomerStep {
            ProductStep customer(String customer);
        }
        
        interface ProductStep {
            QuantityStep product(String product);
        }
        
        interface QuantityStep {
            AddressStep quantity(int quantity);
        }
        
        interface AddressStep {
            BuildStep address(String address);
        }
        
        interface BuildStep {
            Order build();
        }
        
        static class Builder implements 
                CustomerStep, ProductStep, QuantityStep, AddressStep, BuildStep {
            
            private String customer;
            private String product;
            private int quantity;
            private String address;
            
            @Override
            public ProductStep customer(String customer) {
                this.customer = customer;
                return this;
            }
            
            @Override
            public QuantityStep product(String product) {
                this.product = product;
                return this;
            }
            
            @Override
            public AddressStep quantity(int quantity) {
                this.quantity = quantity;
                return this;
            }
            
            @Override
            public BuildStep address(String address) {
                this.address = address;
                return this;
            }
            
            @Override
            public Order build() {
                return new Order(customer, product, quantity, address);
            }
        }
        
        public static CustomerStep builder() {
            return new Builder();
        }
    }
    
    public static void stepBuilder() {
        Order order = Order.builder()
            .customer("Alice")      // Returns ProductStep
            .product("Laptop")      // Returns QuantityStep
            .quantity(2)            // Returns AddressStep
            .address("123 Main St") // Returns BuildStep
            .build();               // Returns Order
        
        // Can't skip steps!
        // Order.builder()
        //     .customer("Alice")
        //     .quantity(2)  // ERROR: quantity() not on ProductStep
        
        /**
         * STEP BUILDER PATTERN:
         * 
         * Each step returns different interface
         * Next method only on that interface
         * Forces correct order
         * Compile-time verification
         * 
         * Used in:
         * - Configuration builders
         * - Test data builders
         * - Workflow APIs
         */
        
        System.out.println("Step builder completed");
    }
    
    /**
     * Generic builder factory
     */
    static abstract class GenericBuilder<T, B extends GenericBuilder<T, B>> {
        @SuppressWarnings("unchecked")
        protected B self() {
            return (B) this;
        }
        
        public abstract T build();
    }
    
    static class Product {
        String name;
        double price;
        
        Product(String name, double price) {
            this.name = name;
            this.price = price;
        }
        
        static class Builder extends GenericBuilder<Product, Builder> {
            private String name;
            private double price;
            
            public Builder setName(String name) {
                this.name = name;
                return self();
            }
            
            public Builder setPrice(double price) {
                this.price = price;
                return self();
            }
            
            @Override
            public Product build() {
                return new Product(name, price);
            }
        }
    }
    
    public static void genericBuilderFactory() {
        Product product = new Product.Builder()
            .setName("Widget")
            .setPrice(19.99)
            .build();
        
        System.out.println("Product: " + product.name);
        
        /**
         * GENERIC BUILDER BASE:
         * 
         * GenericBuilder<T, B>
         * - T: Product type
         * - B: Builder type (self-reference)
         * 
         * Provides self() method
         * Enforces build() method
         * Reusable across builders
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Basic Builder ===");
        basicBuilder();
        
        System.out.println("\n=== Type-Safe Builder ===");
        typeSafeBuilder();
        
        System.out.println("\n=== Step Builder ===");
        stepBuilder();
        
        System.out.println("\n=== Generic Builder Factory ===");
        genericBuilderFactory();
    }
}
```

---

## 4. Type-Safe Heterogeneous Containers

### The Favorites Pattern

```java
/**
 * TYPE-SAFE HETEROGENEOUS CONTAINERS
 * 
 * Store different types in single container
 * Maintain type safety with Class tokens
 * 
 * Famous example: Favorites from Effective Java
 */

import java.util.*;

public class TypeSafeHeterogeneousContainers {
    
    /**
     * The Favorites pattern (Effective Java)
     */
    static class Favorites {
        private final Map<Class<?>, Object> favorites = new HashMap<>();
        
        public <T> void putFavorite(Class<T> type, T instance) {
            favorites.put(
                Objects.requireNonNull(type),
                type.cast(instance)  // Runtime type check
            );
        }
        
        public <T> T getFavorite(Class<T> type) {
            return type.cast(favorites.get(type));
        }
    }
    
    public static void favoritesPattern() {
        Favorites favorites = new Favorites();
        
        // Store different types
        favorites.putFavorite(String.class, "Java");
        favorites.putFavorite(Integer.class, 42);
        favorites.putFavorite(Class.class, Favorites.class);
        
        // Retrieve with type safety
        String favoriteString = favorites.getFavorite(String.class);
        Integer favoriteInteger = favorites.getFavorite(Integer.class);
        Class<?> favoriteClass = favorites.getFavorite(Class.class);
        
        System.out.println("Favorite string: " + favoriteString);
        System.out.println("Favorite integer: " + favoriteInteger);
        System.out.println("Favorite class: " + favoriteClass);
        
        /**
         * FAVORITES PATTERN:
         * 
         * Map<Class<?>, Object> favorites
         * 
         * Key: Class<T> (typed key)
         * Value: Object (any type)
         * 
         * putFavorite(Class<T> type, T instance)
         * - Type-safe put
         * - T matches class
         * 
         * T getFavorite(Class<T> type)
         * - Type-safe get
         * - Returns T
         * 
         * Different types in one map!
         * Type-safe despite heterogeneous storage!
         */
    }
    
    /**
     * Bounded type tokens
     */
    static class BoundedFavorites {
        private final Map<Class<?>, Object> favorites = new HashMap<>();
        
        public <T extends Number> void putFavorite(Class<T> type, T instance) {
            favorites.put(type, instance);
        }
        
        public <T extends Number> T getFavorite(Class<T> type) {
            return type.cast(favorites.get(type));
        }
    }
    
    public static void boundedTypeTokens() {
        BoundedFavorites favorites = new BoundedFavorites();
        
        favorites.putFavorite(Integer.class, 42);
        favorites.putFavorite(Double.class, 3.14);
        
        // Won't compile - String not Number
        // favorites.putFavorite(String.class, "Hello");
        
        Integer num = favorites.getFavorite(Integer.class);
        System.out.println("Number: " + num);
        
        /**
         * BOUNDED VERSION:
         * 
         * <T extends Number>
         * 
         * Only accept Number subclasses
         * Provides additional type safety
         */
    }
    
    /**
     * Type-safe registry
     */
    static class ServiceRegistry {
        private final Map<Class<?>, Object> services = new HashMap<>();
        
        public <T> void registerService(Class<T> serviceClass, T implementation) {
            if (services.containsKey(serviceClass)) {
                throw new IllegalArgumentException(
                    "Service already registered: " + serviceClass);
            }
            services.put(serviceClass, implementation);
        }
        
        @SuppressWarnings("unchecked")
        public <T> T getService(Class<T> serviceClass) {
            Object service = services.get(serviceClass);
            if (service == null) {
                throw new IllegalArgumentException(
                    "Service not found: " + serviceClass);
            }
            return (T) service;
        }
        
        public <T> boolean hasService(Class<T> serviceClass) {
            return services.containsKey(serviceClass);
        }
    }
    
    interface EmailService {
        void sendEmail(String to, String message);
    }
    
    interface LogService {
        void log(String message);
    }
    
    static class EmailServiceImpl implements EmailService {
        @Override
        public void sendEmail(String to, String message) {
            System.out.println("Sending to " + to + ": " + message);
        }
    }
    
    static class LogServiceImpl implements LogService {
        @Override
        public void log(String message) {
            System.out.println("LOG: " + message);
        }
    }
    
    public static void typeSafeRegistry() {
        ServiceRegistry registry = new ServiceRegistry();
        
        // Register services
        registry.registerService(EmailService.class, new EmailServiceImpl());
        registry.registerService(LogService.class, new LogServiceImpl());
        
        // Retrieve with type safety
        EmailService emailService = registry.getService(EmailService.class);
        LogService logService = registry.getService(LogService.class);
        
        emailService.sendEmail("user@example.com", "Hello!");
        logService.log("Services initialized");
        
        /**
         * SERVICE REGISTRY:
         * 
         * Common in dependency injection
         * Type-safe service lookup
         * Different service types in one registry
         * 
         * Used in:
         * - Spring Framework
         * - Google Guice
         * - Custom DI containers
         */
    }
    
    /**
     * Attribute map with type safety
     */
    static class TypeSafeAttributes {
        private final Map<Key<?>, Object> attributes = new HashMap<>();
        
        static class Key<T> {
            private final String name;
            private final Class<T> type;
            
            public Key(String name, Class<T> type) {
                this.name = name;
                this.type = type;
            }
            
            @Override
            public boolean equals(Object o) {
                if (this == o) return true;
                if (!(o instanceof Key)) return false;
                Key<?> key = (Key<?>) o;
                return name.equals(key.name);
            }
            
            @Override
            public int hashCode() {
                return name.hashCode();
            }
        }
        
        public <T> void put(Key<T> key, T value) {
            attributes.put(key, value);
        }
        
        @SuppressWarnings("unchecked")
        public <T> T get(Key<T> key) {
            return (T) attributes.get(key);
        }
    }
    
    public static void typeSafeAttributes() {
        TypeSafeAttributes attrs = new TypeSafeAttributes();
        
        // Define typed keys
        TypeSafeAttributes.Key<String> nameKey = 
            new TypeSafeAttributes.Key<>("name", String.class);
        TypeSafeAttributes.Key<Integer> ageKey = 
            new TypeSafeAttributes.Key<>("age", Integer.class);
        
        // Type-safe put
        attrs.put(nameKey, "Alice");
        attrs.put(ageKey, 30);
        
        // Type-safe get
        String name = attrs.get(nameKey);  // String
        Integer age = attrs.get(ageKey);   // Integer
        
        System.out.println("Name: " + name + ", Age: " + age);
        
        /**
         * TYPED KEY PATTERN:
         * 
         * Key<T> carries type information
         * put/get use Key<T> for type safety
         * Different types in same map
         * 
         * Similar to:
         * - ThreadLocal
         * - HTTP request attributes
         * - Session attributes
         */
    }
    
    /**
     * Limitations and workarounds
     */
    public static void limitationsAndWorkarounds() {
        /**
         * LIMITATION 1: Can't use List<String>.class
         * 
         * Favorites favorites = new Favorites();
         * favorites.put(List<String>.class, list);  // ERROR
         * 
         * List<String>.class doesn't exist
         * Only raw List.class
         * 
         * WORKAROUND: TypeReference/TypeToken
         * 
         * Use Guava TypeToken or custom TypeReference
         * 
         * 
         * LIMITATION 2: Raw type vulnerability
         * 
         * Favorites favorites = new Favorites();
         * favorites.putFavorite((Class)Integer.class, "Not an integer");
         * 
         * Raw type bypasses compile-time check
         * 
         * WORKAROUND: Runtime check in putFavorite
         * 
         * type.cast(instance)  // Throws ClassCastException
         * 
         * 
         * LIMITATION 3: Non-reifiable types
         * 
         * Can't store List<String> vs List<Integer>
         * Both use List.class
         * 
         * WORKAROUND: Use TypeToken from Guava
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Favorites Pattern ===");
        favoritesPattern();
        
        System.out.println("\n=== Bounded Type Tokens ===");
        boundedTypeTokens();
        
        System.out.println("\n=== Type-Safe Registry ===");
        typeSafeRegistry();
        
        System.out.println("\n=== Type-Safe Attributes ===");
        typeSafeAttributes();
    }
}
```

---

## 5. Generic Singleton Pattern

### Type-Safe Single Instances

```java
/**
 * GENERIC SINGLETON PATTERN
 * 
 * Singleton with type parameters
 * Different instances for different types
 */

import java.util.*;
import java.util.concurrent.*;

public class GenericSingletonPattern {
    
    /**
     * Basic generic singleton
     */
    static class Cache<T> {
        private static final Map<Class<?>, Cache<?>> instances = 
            new ConcurrentHashMap<>();
        
        private final Map<String, T> data = new ConcurrentHashMap<>();
        
        private Cache() {}
        
        @SuppressWarnings("unchecked")
        public static <T> Cache<T> getInstance(Class<T> type) {
            return (Cache<T>) instances.computeIfAbsent(type, k -> new Cache<>());
        }
        
        public void put(String key, T value) {
            data.put(key, value);
        }
        
        public T get(String key) {
            return data.get(key);
        }
        
        public int size() {
            return data.size();
        }
    }
    
    public static void basicGenericSingleton() {
        Cache<String> stringCache = Cache.getInstance(String.class);
        Cache<Integer> intCache = Cache.getInstance(Integer.class);
        
        stringCache.put("key1", "value1");
        intCache.put("key2", 42);
        
        // Same instance for same type
        Cache<String> stringCache2 = Cache.getInstance(String.class);
        System.out.println("Same instance: " + (stringCache == stringCache2));
        
        // Different instances for different types
        System.out.println("Different instances: " + (stringCache != intCache));
        
        /**
         * GENERIC SINGLETON:
         * 
         * One Cache instance per type
         * Cache<String> singleton
         * Cache<Integer> singleton
         * 
         * Type-safe access
         * Separate storage per type
         */
    }
    
    /**
     * Factory registry singleton
     */
    static class FactoryRegistry {
        private static final Map<Class<?>, Factory<?>> factories = 
            new ConcurrentHashMap<>();
        
        interface Factory<T> {
            T create();
        }
        
        public static <T> void registerFactory(Class<T> type, Factory<T> factory) {
            factories.put(type, factory);
        }
        
        @SuppressWarnings("unchecked")
        public static <T> Factory<T> getFactory(Class<T> type) {
            return (Factory<T>) factories.get(type);
        }
        
        public static <T> T create(Class<T> type) {
            Factory<T> factory = getFactory(type);
            if (factory == null) {
                throw new IllegalArgumentException("No factory for " + type);
            }
            return factory.create();
        }
    }
    
    static class User {
        String name;
        User(String name) { this.name = name; }
    }
    
    static class Product {
        String sku;
        Product(String sku) { this.sku = sku; }
    }
    
    public static void factoryRegistrySingleton() {
        // Register factories
        FactoryRegistry.registerFactory(
            User.class,
            () -> new User("Default User")
        );
        
        FactoryRegistry.registerFactory(
            Product.class,
            () -> new Product("SKU-001")
        );
        
        // Create instances
        User user = FactoryRegistry.create(User.class);
        Product product = FactoryRegistry.create(Product.class);
        
        System.out.println("User: " + user.name);
        System.out.println("Product: " + product.sku);
        
        /**
         * FACTORY REGISTRY:
         * 
         * Central registry of factories
         * Type-safe factory lookup
         * Type-safe instance creation
         */
    }
    
    /**
     * Enum singleton with generics
     */
    static enum GenericService {
        INSTANCE;
        
        private final Map<Class<?>, Object> services = new ConcurrentHashMap<>();
        
        public <T> void register(Class<T> type, T service) {
            services.put(type, service);
        }
        
        @SuppressWarnings("unchecked")
        public <T> T get(Class<T> type) {
            return (T) services.get(type);
        }
    }
    
    public static void enumSingletonWithGenerics() {
        GenericService registry = GenericService.INSTANCE;
        
        registry.register(String.class, "Singleton String");
        registry.register(Integer.class, 42);
        
        String str = registry.get(String.class);
        Integer num = registry.get(Integer.class);
        
        System.out.println("String: " + str);
        System.out.println("Integer: " + num);
        
        /**
         * ENUM SINGLETON:
         * 
         * Best singleton implementation (Joshua Bloch)
         * Thread-safe by default
         * Serialization-safe
         * 
         * Combined with generics:
         * Type-safe heterogeneous storage
         */
    }
    
    /**
     * Lazy initialization holder
     */
    static class LazyGenericSingleton<T> {
        private final Map<String, T> data = new HashMap<>();
        
        private LazyGenericSingleton() {}
        
        private static class Holder {
            static final Map<Class<?>, LazyGenericSingleton<?>> INSTANCES = 
                new ConcurrentHashMap<>();
        }
        
        @SuppressWarnings("unchecked")
        public static <T> LazyGenericSingleton<T> getInstance(Class<T> type) {
            return (LazyGenericSingleton<T>) Holder.INSTANCES.computeIfAbsent(
                type, 
                k -> new LazyGenericSingleton<>()
            );
        }
    }
    
    public static void lazyInitializationHolder() {
        LazyGenericSingleton<String> singleton1 = 
            LazyGenericSingleton.getInstance(String.class);
        
        LazyGenericSingleton<String> singleton2 = 
            LazyGenericSingleton.getInstance(String.class);
        
        System.out.println("Lazy singleton: " + (singleton1 == singleton2));
        
        /**
         * LAZY HOLDER PATTERN:
         * 
         * Thread-safe lazy initialization
         * No synchronization overhead
         * Initialized on first use
         * 
         * Holder class loaded only when accessed
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Basic Generic Singleton ===");
        basicGenericSingleton();
        
        System.out.println("\n=== Factory Registry Singleton ===");
        factoryRegistrySingleton();
        
        System.out.println("\n=== Enum Singleton with Generics ===");
        enumSingletonWithGenerics();
        
        System.out.println("\n=== Lazy Initialization Holder ===");
        lazyInitializationHolder();
    }
}
```

---

## 6. Generic Factory Pattern

### Type-Safe Object Creation

```java
/**
 * GENERIC FACTORY PATTERN
 * 
 * Factory methods with type parameters
 * Abstract factories with generics
 */

import java.util.*;
import java.util.function.*;

public class GenericFactoryPattern {
    
    /**
     * Simple generic factory
     */
    static class Factory<T> {
        private final Supplier<T> constructor;
        
        public Factory(Supplier<T> constructor) {
            this.constructor = constructor;
        }
        
        public T create() {
            return constructor.get();
        }
        
        public List<T> createBatch(int count) {
            List<T> batch = new ArrayList<>();
            for (int i = 0; i < count; i++) {
                batch.add(create());
            }
            return batch;
        }
    }
    
    public static void simpleGenericFactory() {
        Factory<String> stringFactory = new Factory<>(() -> "new string");
        Factory<ArrayList<Integer>> listFactory = 
            new Factory<>(() -> new ArrayList<>());
        
        String str = stringFactory.create();
        ArrayList<Integer> list = listFactory.create();
        
        List<String> strings = stringFactory.createBatch(5);
        
        System.out.println("Created " + strings.size() + " strings");
        
        /**
         * SIMPLE FACTORY:
         * 
         * Factory<T>
         * - Stores constructor reference
         * - create() returns T
         * - Type-safe
         */
    }
    
    /**
     * Parameterized factory
     */
    static class ParameterizedFactory<T> {
        @FunctionalInterface
        interface Constructor<T, P> {
            T create(P parameter);
        }
        
        private final Constructor<T, ?> constructor;
        
        public <P> ParameterizedFactory(Constructor<T, P> constructor) {
            this.constructor = constructor;
        }
        
        @SuppressWarnings("unchecked")
        public <P> T create(P parameter) {
            return ((Constructor<T, P>) constructor).create(parameter);
        }
    }
    
    static class User {
        String name;
        User(String name) { this.name = name; }
    }
    
    public static void parameterizedFactory() {
        ParameterizedFactory<User> userFactory = 
            new ParameterizedFactory<>(User::new);
        
        User user = userFactory.create("Alice");
        System.out.println("Created user: " + user.name);
        
        /**
         * PARAMETERIZED FACTORY:
         * 
         * Takes parameter to create instance
         * Type-safe parameter
         * Flexible construction
         */
    }
    
    /**
     * Abstract factory with generics
     */
    interface Animal {
        void makeSound();
    }
    
    static class Dog implements Animal {
        @Override
        public void makeSound() {
            System.out.println("Woof!");
        }
    }
    
    static class Cat implements Animal {
        @Override
        public void makeSound() {
            System.out.println("Meow!");
        }
    }
    
    interface AnimalFactory<T extends Animal> {
        T createAnimal();
        
        default List<T> createAnimals(int count) {
            List<T> animals = new ArrayList<>();
            for (int i = 0; i < count; i++) {
                animals.add(createAnimal());
            }
            return animals;
        }
    }
    
    static class DogFactory implements AnimalFactory<Dog> {
        @Override
        public Dog createAnimal() {
            return new Dog();
        }
    }
    
    static class CatFactory implements AnimalFactory<Cat> {
        @Override
        public Cat createAnimal() {
            return new Cat();
        }
    }
    
    public static void abstractFactoryWithGenerics() {
        AnimalFactory<Dog> dogFactory = new DogFactory();
        AnimalFactory<Cat> catFactory = new CatFactory();
        
        Dog dog = dogFactory.createAnimal();
        Cat cat = catFactory.createAnimal();
        
        dog.makeSound();
        cat.makeSound();
        
        List<Dog> dogs = dogFactory.createAnimals(3);
        System.out.println("Created " + dogs.size() + " dogs");
        
        /**
         * ABSTRACT FACTORY WITH GENERICS:
         * 
         * AnimalFactory<T extends Animal>
         * - Specific factory returns specific type
         * - DogFactory returns Dog
         * - CatFactory returns Cat
         * - Type-safe, no casting
         */
    }
    
    /**
     * Registry-based factory
     */
    static class RegistryFactory<T> {
        private final Map<String, Supplier<T>> registry = new HashMap<>();
        
        public void register(String key, Supplier<T> constructor) {
            registry.put(key, constructor);
        }
        
        public T create(String key) {
            Supplier<T> constructor = registry.get(key);
            if (constructor == null) {
                throw new IllegalArgumentException("Unknown key: " + key);
            }
            return constructor.get();
        }
        
        public Set<String> getRegisteredKeys() {
            return registry.keySet();
        }
    }
    
    public static void registryBasedFactory() {
        RegistryFactory<Animal> factory = new RegistryFactory<>();
        
        factory.register("dog", Dog::new);
        factory.register("cat", Cat::new);
        
        Animal dog = factory.create("dog");
        Animal cat = factory.create("cat");
        
        dog.makeSound();
        cat.makeSound();
        
        System.out.println("Registered: " + factory.getRegisteredKeys());
        
        /**
         * REGISTRY FACTORY:
         * 
         * Register constructors by key
         * Create by key
         * Dynamic factory registration
         * 
         * Used in:
         * - Plugin systems
         * - Deserialization
         * - Extensible frameworks
         */
    }
    
    /**
     * Builder factory
     */
    static class BuilderFactory<T, B> {
        private final Supplier<B> builderConstructor;
        private final Function<B, T> buildMethod;
        
        public BuilderFactory(
                Supplier<B> builderConstructor,
                Function<B, T> buildMethod) {
            this.builderConstructor = builderConstructor;
            this.buildMethod = buildMethod;
        }
        
        public B builder() {
            return builderConstructor.get();
        }
        
        public T build(B builder) {
            return buildMethod.apply(builder);
        }
        
        public T create(Consumer<B> configurator) {
            B builder = builder();
            configurator.accept(builder);
            return build(builder);
        }
    }
    
    static class Config {
        String host;
        int port;
        
        static class Builder {
            String host = "localhost";
            int port = 8080;
            
            public Builder setHost(String host) {
                this.host = host;
                return this;
            }
            
            public Builder setPort(int port) {
                this.port = port;
                return this;
            }
            
            public Config build() {
                Config config = new Config();
                config.host = host;
                config.port = port;
                return config;
            }
        }
    }
    
    public static void builderFactory() {
        BuilderFactory<Config, Config.Builder> factory = new BuilderFactory<>(
            Config.Builder::new,
            Config.Builder::build
        );
        
        Config config = factory.create(builder ->
            builder.setHost("example.com")
                   .setPort(9090)
        );
        
        System.out.println("Config: " + config.host + ":" + config.port);
        
        /**
         * BUILDER FACTORY:
         * 
         * Combines factory and builder patterns
         * Fluent configuration
         * Type-safe building
         */
    }
    
    /**
     * Multi-type factory
     */
    static class MultiFactory {
        private final Map<Class<?>, Supplier<?>> factories = new HashMap<>();
        
        public <T> void registerFactory(Class<T> type, Supplier<T> factory) {
            factories.put(type, factory);
        }
        
        @SuppressWarnings("unchecked")
        public <T> T create(Class<T> type) {
            Supplier<?> factory = factories.get(type);
            if (factory == null) {
                throw new IllegalArgumentException("No factory for " + type);
            }
            return (T) factory.get();
        }
    }
    
    public static void multiTypeFactory() {
        MultiFactory factory = new MultiFactory();
        
        factory.registerFactory(String.class, () -> "Hello");
        factory.registerFactory(Integer.class, () -> 42);
        factory.registerFactory(Dog.class, Dog::new);
        
        String str = factory.create(String.class);
        Integer num = factory.create(Integer.class);
        Dog dog = factory.create(Dog.class);
        
        System.out.println("Created: " + str + ", " + num);
        dog.makeSound();
        
        /**
         * MULTI-TYPE FACTORY:
         * 
         * One factory for multiple types
         * Type-safe creation
         * Class token as key
         * 
         * Similar to ServiceLocator pattern
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Simple Generic Factory ===");
        simpleGenericFactory();
        
        System.out.println("\n=== Parameterized Factory ===");
        parameterizedFactory();
        
        System.out.println("\n=== Abstract Factory ===");
        abstractFactoryWithGenerics();
        
        System.out.println("\n=== Registry Factory ===");
        registryBasedFactory();
        
        System.out.println("\n=== Builder Factory ===");
        builderFactory();
        
        System.out.println("\n=== Multi-Type Factory ===");
        multiTypeFactory();
    }
}
```

---

## Summary

### Pattern Catalog

**1. Recursive Type Bounds:**

```java
// Enum pattern
public abstract class Enum<E extends Enum<E>>

// Usage
enum Color extends Enum<Color> { RED, GREEN, BLUE }

// Method signature
public static <T extends Comparable<T>> T max(T a, T b)

// Relaxed for inheritance
public static <T extends Comparable<? super T>> T max(T a, T b)
```

**2. Self-Referential Generics:**

```java
// CRTP (Curiously Recurring Template Pattern)
class Builder<T extends Builder<T>> {
    @SuppressWarnings("unchecked")
    protected T self() {
        return (T) this;
    }
    
    public T setName(String name) {
        this.name = name;
        return self();
    }
}

class SpecificBuilder extends Builder<SpecificBuilder> {
    public SpecificBuilder setValue(int value) {
        return self();  // Returns SpecificBuilder
    }
}
```

**3. Generic Builder Pattern:**

```java
// Type-safe builder with phantom types
class Builder<N, E> {
    public Builder<HasName, E> setName(String name) { }
    public Builder<N, HasEmail> setEmail(String email) { }
    public User build() { }  // Only on Builder<HasName, HasEmail>
}

// Step builder
interface CustomerStep {
    ProductStep customer(String customer);
}
interface ProductStep {
    BuildStep product(String product);
}
```

**4. Type-Safe Heterogeneous Containers:**

```java
// Favorites pattern (Effective Java)
class Favorites {
    private Map<Class<?>, Object> favorites = new HashMap<>();
    
    public <T> void putFavorite(Class<T> type, T instance) {
        favorites.put(type, type.cast(instance));
    }
    
    public <T> T getFavorite(Class<T> type) {
        return type.cast(favorites.get(type));
    }
}

// Different types in one container
favorites.putFavorite(String.class, "Java");
favorites.putFavorite(Integer.class, 42);
```

**5. Generic Singleton Pattern:**

```java
// Per-type singleton
class Cache<T> {
    private static Map<Class<?>, Cache<?>> instances = ...;
    
    public static <T> Cache<T> getInstance(Class<T> type) {
        return (Cache<T>) instances.computeIfAbsent(
            type, k -> new Cache<>());
    }
}

// Different singleton per type
Cache<String> stringCache = Cache.getInstance(String.class);
Cache<Integer> intCache = Cache.getInstance(Integer.class);
```

**6. Generic Factory Pattern:**

```java
// Abstract factory
interface Factory<T extends Animal> {
    T createAnimal();
}

class DogFactory implements Factory<Dog> {
    public Dog createAnimal() { return new Dog(); }
}

// Registry factory
class RegistryFactory<T> {
    private Map<String, Supplier<T>> registry = ...;
    
    public void register(String key, Supplier<T> factory) { }
    public T create(String key) { }
}
```

### When to Use Each Pattern

```
Recursive Type Bounds:
✓ Comparable/Enum-like interfaces
✓ Self-comparison operations
✓ Type-safe operations on same type

Self-Referential Generics:
✓ Fluent APIs
✓ Builder patterns with inheritance
✓ Method chaining across hierarchy

Generic Builder:
✓ Complex object construction
✓ Compile-time validation of required fields
✓ Progressive type narrowing

Type-Safe Heterogeneous Containers:
✓ Storing different types in one map
✓ Service registries
✓ Attribute maps with type safety

Generic Singleton:
✓ Different singleton per type
✓ Type-specific caches
✓ Per-type service instances

Generic Factory:
✓ Type-safe object creation
✓ Abstract factories
✓ Plugin systems
```

### Best Practices

**1. Use relaxed recursive bounds for inheritance:**

```java
// ❌ TOO STRICT
<T extends Comparable<T>>

// ✅ ALLOWS INHERITANCE
<T extends Comparable<? super T>>
```

**2. Provide self() helper in CRTP:**

```java
// ✅ GOOD
@SuppressWarnings("unchecked")
protected T self() {
    return (T) this;
}
```

**3. Runtime type check in heterogeneous containers:**

```java
// ✅ GOOD: Prevents raw type abuse
public <T> void put(Class<T> type, T instance) {
    favorites.put(type, type.cast(instance));
}
```

**4. Use enum for simple singletons:**

```java
// ✅ BEST SINGLETON
enum GenericService {
    INSTANCE;
    // Add type-safe map here
}
```

---
