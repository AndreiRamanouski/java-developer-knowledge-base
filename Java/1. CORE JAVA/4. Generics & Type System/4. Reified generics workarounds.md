# Reified Generics Workarounds

## Overview

Java's type erasure means generic type information isn't available at runtime. This guide covers all the practical workarounds used in production code - from simple Class tokens to sophisticated type capture techniques used by Guava and Jackson. These patterns are essential for framework development, serialization, and advanced generic programming.

---

## 1. Type Tokens and TypeReference

### The Core Pattern for Runtime Type Information

```java
/**
 * TYPE TOKENS
 * 
 * Capturing generic type information at runtime
 */

import java.lang.reflect.*;
import java.util.*;

public class TypeTokens {
    
    /**
     * The problem: Type erasure
     */
    public static void theProblem() {
        /**
         * TYPE ERASURE PROBLEM:
         * 
         * List<String> stringList = new ArrayList<>();
         * List<Integer> intList = new ArrayList<>();
         * 
         * At runtime:
         * stringList.getClass() == intList.getClass()  // true!
         * 
         * Both are just ArrayList
         * Type parameter information lost
         * 
         * 
         * WHEN THIS MATTERS:
         * 
         * 1. Deserialization:
         *    JSON → List<User>
         *    Need to know it's User, not just Object
         * 
         * 2. Dependency injection:
         *    @Inject List<Service> services;
         *    Need to know Service type
         * 
         * 3. Generic factory:
         *    <T> T create()
         *    Need to instantiate T
         * 
         * 4. Generic array creation:
         *    T[] array = new T[10]  // ERROR
         *    Need runtime type
         */
    }
    
    /**
     * Solution 1: Simple type token (Class<T>)
     */
    static class SimpleTypeToken<T> {
        private final Class<T> type;
        
        public SimpleTypeToken(Class<T> type) {
            this.type = type;
        }
        
        public Class<T> getType() {
            return type;
        }
        
        public T newInstance() throws Exception {
            return type.getDeclaredConstructor().newInstance();
        }
    }
    
    public static void simpleTypeToken() throws Exception {
        // Create type token for String
        SimpleTypeToken<String> stringToken = new SimpleTypeToken<>(String.class);
        
        // Create instance
        String instance = stringToken.newInstance();
        System.out.println("Created: " + instance);
        
        // Type available at runtime
        Class<String> type = stringToken.getType();
        System.out.println("Type: " + type);
        
        /**
         * LIMITATION:
         * 
         * Only works for non-generic types!
         * 
         * SimpleTypeToken<List<String>> token = 
         *     new SimpleTypeToken<>(List.class);  // Loses <String>!
         * 
         * List.class doesn't capture <String>
         * Need more sophisticated approach
         */
    }
    
    /**
     * Solution 2: Super type token
     */
    static abstract class TypeReference<T> {
        private final Type type;
        
        protected TypeReference() {
            // Get the actual type argument
            Type superclass = getClass().getGenericSuperclass();
            
            if (superclass instanceof ParameterizedType) {
                this.type = ((ParameterizedType) superclass).getActualTypeArguments()[0];
            } else {
                throw new IllegalArgumentException("TypeReference must be parameterized");
            }
        }
        
        public Type getType() {
            return type;
        }
        
        @Override
        public String toString() {
            return "TypeReference<" + type + ">";
        }
    }
    
    public static void superTypeToken() {
        /**
         * SUPER TYPE TOKEN PATTERN:
         * 
         * Create anonymous subclass that captures type
         */
        
        // Anonymous class captures List<String>
        TypeReference<List<String>> listType = new TypeReference<List<String>>() {};
        
        System.out.println("Type: " + listType.getType());
        // Output: java.util.List<java.lang.String>
        
        // Works with complex types
        TypeReference<Map<String, List<Integer>>> complexType = 
            new TypeReference<Map<String, List<Integer>>>() {};
        
        System.out.println("Complex type: " + complexType.getType());
        // Output: java.util.Map<java.lang.String, java.util.List<java.lang.Integer>>
        
        /**
         * HOW IT WORKS:
         * 
         * new TypeReference<List<String>>() {}
         *                                   ^^
         * Anonymous subclass!
         * 
         * At compile time:
         * class Anonymous extends TypeReference<List<String>> {}
         * 
         * Generic superclass stores: TypeReference<List<String>>
         * This information IS reified (for superclasses)!
         * 
         * At runtime:
         * getGenericSuperclass() returns ParameterizedType
         * Extract type argument: List<String>
         */
    }
    
    /**
     * Extracting type information
     */
    public static void extractingTypeInfo() {
        TypeReference<List<String>> listRef = new TypeReference<List<String>>() {};
        
        Type type = listRef.getType();
        
        if (type instanceof ParameterizedType) {
            ParameterizedType paramType = (ParameterizedType) type;
            
            // Raw type: List
            Type rawType = paramType.getRawType();
            System.out.println("Raw type: " + rawType);
            
            // Type arguments: [String]
            Type[] typeArgs = paramType.getActualTypeArguments();
            System.out.println("Type arguments: " + Arrays.toString(typeArgs));
            
            // First type argument: String
            Type elementType = typeArgs[0];
            System.out.println("Element type: " + elementType);
        }
        
        /**
         * OUTPUT:
         * Raw type: interface java.util.List
         * Type arguments: [class java.lang.String]
         * Element type: class java.lang.String
         * 
         * FULL TYPE INFORMATION CAPTURED!
         */
    }
    
    /**
     * Common mistake: Not using anonymous class
     */
    public static void commonMistake() {
        /**
         * WRONG:
         */
        
        // Does NOT work - no anonymous class
        // TypeReference<List<String>> ref = new TypeReference<>();  // ERROR
        
        // Type parameter T erased at runtime
        // Can't capture it
        
        /**
         * CORRECT:
         */
        
        // Anonymous class required
        TypeReference<List<String>> ref = new TypeReference<List<String>>() {};
        //                                                                 ^^
        // Empty braces create anonymous subclass
        
        System.out.println("Correct: " + ref);
    }
    
    /**
     * Real-world use case: Generic JSON deserializer
     */
    static class JsonDeserializer {
        @SuppressWarnings("unchecked")
        public <T> T deserialize(String json, TypeReference<T> typeRef) {
            Type type = typeRef.getType();
            
            // In real implementation, parse JSON based on type
            System.out.println("Deserializing to: " + type);
            
            // Placeholder
            return null;
        }
    }
    
    public static void jsonDeserializerExample() {
        JsonDeserializer deserializer = new JsonDeserializer();
        
        String json = "[{\"name\":\"Alice\"}, {\"name\":\"Bob\"}]";
        
        // Deserialize to List<User>
        List<User> users = deserializer.deserialize(
            json,
            new TypeReference<List<User>>() {}
        );
        
        /**
         * WITHOUT TYPE TOKEN:
         * List<User> users = deserializer.deserialize(json);
         * 
         * Compiler knows List<User>
         * But runtime only knows List
         * Deserializer creates List<LinkedHashMap>!
         * 
         * WITH TYPE TOKEN:
         * Deserializer knows it's List<User>
         * Creates proper User objects
         */
    }
    
    static class User {
        String name;
    }
    
    public static void main(String[] args) throws Exception {
        System.out.println("=== Simple Type Token ===");
        simpleTypeToken();
        
        System.out.println("\n=== Super Type Token ===");
        superTypeToken();
        
        System.out.println("\n=== Extracting Type Info ===");
        extractingTypeInfo();
        
        System.out.println("\n=== Common Mistake ===");
        commonMistake();
        
        System.out.println("\n=== JSON Deserializer ===");
        jsonDeserializerExample();
    }
}
```

---

## 2. Passing Class<T> as Parameter

### The Most Common Workaround

```java
/**
 * CLASS TOKEN PATTERN
 * 
 * Passing Class<T> to preserve type information
 */

import java.lang.reflect.*;
import java.util.*;

public class ClassTokenPattern {
    
    /**
     * Basic pattern
     */
    static class Factory {
        public <T> T create(Class<T> type) throws Exception {
            return type.getDeclaredConstructor().newInstance();
        }
    }
    
    public static void basicPattern() throws Exception {
        Factory factory = new Factory();
        
        // Create String
        String s = factory.create(String.class);
        System.out.println("Created String: " + s);
        
        // Create ArrayList
        ArrayList<String> list = factory.create(ArrayList.class);
        System.out.println("Created ArrayList: " + list);
        
        /**
         * PATTERN:
         * 
         * public <T> T create(Class<T> type)
         *                     ^^^^^^^^^^^^
         * Type information passed explicitly
         * 
         * Available at runtime
         * Can use for instantiation, reflection, etc.
         */
    }
    
    /**
     * Generic array creation
     */
    @SuppressWarnings("unchecked")
    public static <T> T[] createArray(Class<T> type, int size) {
        // Use Array.newInstance with Class token
        return (T[]) Array.newInstance(type, size);
    }
    
    public static void genericArrayCreation() {
        // Create String array
        String[] strings = createArray(String.class, 10);
        strings[0] = "hello";
        
        // Create Integer array
        Integer[] integers = createArray(Integer.class, 5);
        integers[0] = 42;
        
        System.out.println("String array: " + strings[0]);
        System.out.println("Integer array: " + integers[0]);
        
        /**
         * WITHOUT CLASS TOKEN:
         * 
         * public static <T> T[] create(int size) {
         *     return new T[size];  // ERROR: Can't create generic array
         * }
         * 
         * WITH CLASS TOKEN:
         * 
         * Array.newInstance(type, size)
         * Returns Object[] with correct component type
         * Type-safe cast to T[]
         */
    }
    
    /**
     * Generic collection with runtime type
     */
    static class TypedList<T> {
        private final Class<T> elementType;
        private final List<T> elements = new ArrayList<>();
        
        public TypedList(Class<T> elementType) {
            this.elementType = elementType;
        }
        
        public void add(T element) {
            // Runtime type check
            if (!elementType.isInstance(element)) {
                throw new IllegalArgumentException(
                    "Element must be " + elementType);
            }
            elements.add(element);
        }
        
        public Class<T> getElementType() {
            return elementType;
        }
        
        public List<T> getElements() {
            return new ArrayList<>(elements);
        }
    }
    
    public static void typedList() {
        TypedList<String> stringList = new TypedList<>(String.class);
        stringList.add("hello");
        stringList.add("world");
        
        // Runtime type information available
        System.out.println("Element type: " + stringList.getElementType());
        
        // Could enforce type safety at runtime
        try {
            @SuppressWarnings("unchecked")
            TypedList<String> list = (TypedList<String>) (TypedList<?>) 
                new TypedList<>(Integer.class);
            
            list.add("hello");  // Runtime error!
        } catch (IllegalArgumentException e) {
            System.out.println("Type mismatch: " + e.getMessage());
        }
    }
    
    /**
     * Dependency injection pattern
     */
    static class Container {
        private final Map<Class<?>, Object> instances = new HashMap<>();
        
        public <T> void register(Class<T> type, T instance) {
            instances.put(type, instance);
        }
        
        @SuppressWarnings("unchecked")
        public <T> T get(Class<T> type) {
            return (T) instances.get(type);
        }
    }
    
    public static void dependencyInjection() {
        Container container = new Container();
        
        // Register instances
        container.register(String.class, "Hello, World!");
        container.register(Integer.class, 42);
        
        // Retrieve with type safety
        String str = container.get(String.class);
        Integer num = container.get(Integer.class);
        
        System.out.println("String: " + str);
        System.out.println("Integer: " + num);
        
        /**
         * CLASS TOKEN AS KEY:
         * 
         * Map<Class<?>, Object>
         * 
         * Class acts as type-safe key
         * Retrieval is type-safe
         * Common in DI frameworks
         */
    }
    
    /**
     * DAO pattern with Class token
     */
    interface Entity {
        Long getId();
    }
    
    static class User implements Entity {
        private Long id;
        private String name;
        
        public User() {}
        
        public User(Long id, String name) {
            this.id = id;
            this.name = name;
        }
        
        @Override
        public Long getId() {
            return id;
        }
        
        public String getName() {
            return name;
        }
    }
    
    static class GenericDao<T extends Entity> {
        private final Class<T> entityType;
        private final Map<Long, T> storage = new HashMap<>();
        
        public GenericDao(Class<T> entityType) {
            this.entityType = entityType;
        }
        
        public void save(T entity) {
            storage.put(entity.getId(), entity);
        }
        
        public T findById(Long id) {
            return storage.get(id);
        }
        
        public Class<T> getEntityType() {
            return entityType;
        }
    }
    
    public static void daoPattern() {
        GenericDao<User> userDao = new GenericDao<>(User.class);
        
        User user = new User(1L, "Alice");
        userDao.save(user);
        
        User found = userDao.findById(1L);
        System.out.println("Found user: " + found.getName());
        
        // Type information available
        System.out.println("Entity type: " + userDao.getEntityType());
        
        /**
         * FRAMEWORK USAGE:
         * 
         * Hibernate, JPA, Spring Data all use this pattern
         * 
         * class UserRepository extends JpaRepository<User, Long> {
         *     // Framework knows User type at runtime
         *     // Can generate queries, etc.
         * }
         */
    }
    
    /**
     * Multiple Class tokens
     */
    static class Converter<F, T> {
        private final Class<F> fromType;
        private final Class<T> toType;
        
        public Converter(Class<F> fromType, Class<T> toType) {
            this.fromType = fromType;
            this.toType = toType;
        }
        
        public T convert(F from) {
            System.out.println("Converting " + fromType.getSimpleName() + 
                             " to " + toType.getSimpleName());
            // Actual conversion logic
            return null;
        }
    }
    
    public static void multipleClassTokens() {
        Converter<String, Integer> converter = 
            new Converter<>(String.class, Integer.class);
        
        converter.convert("123");
        
        /**
         * MULTIPLE TYPE PARAMETERS:
         * 
         * Each type parameter needs its own Class token
         * Common in conversion frameworks
         */
    }
    
    /**
     * Limitations of Class tokens
     */
    public static void limitations() {
        /**
         * LIMITATIONS:
         * 
         * 1. Only for non-generic types:
         *    Class<String> ✓
         *    Class<List<String>> ✗ (List.class loses <String>)
         * 
         * 2. Verbosity:
         *    Must pass Class argument
         *    new GenericDao<>(User.class)
         * 
         * 3. Can't capture wildcards:
         *    Class<? extends Number> is Class object
         *    Not useful for instantiation
         * 
         * 
         * FOR GENERIC TYPES:
         * Use TypeReference or Guava TypeToken
         */
    }
    
    public static void main(String[] args) throws Exception {
        System.out.println("=== Basic Pattern ===");
        basicPattern();
        
        System.out.println("\n=== Generic Array Creation ===");
        genericArrayCreation();
        
        System.out.println("\n=== Typed List ===");
        typedList();
        
        System.out.println("\n=== Dependency Injection ===");
        dependencyInjection();
        
        System.out.println("\n=== DAO Pattern ===");
        daoPattern();
        
        System.out.println("\n=== Multiple Class Tokens ===");
        multipleClassTokens();
    }
}
```

---

## 3. Guava TypeToken

### Google's Industrial-Strength Solution

```java
/**
 * GUAVA TYPETOKEN
 * 
 * Google Guava's implementation of super type tokens
 */

import com.google.common.reflect.TypeToken;
import java.lang.reflect.*;
import java.util.*;

/**
 * Maven dependency:
 * <dependency>
 *     <groupId>com.google.guava</groupId>
 *     <artifactId>guava</artifactId>
 *     <version>32.1.3-jre</version>
 * </dependency>
 */

public class GuavaTypeToken {
    
    /**
     * Basic usage
     */
    public static void basicUsage() {
        // Capture List<String>
        TypeToken<List<String>> listToken = new TypeToken<List<String>>() {};
        
        System.out.println("Type: " + listToken.getType());
        System.out.println("Raw type: " + listToken.getRawType());
        
        // Get component type
        TypeToken<?> elementToken = listToken.resolveType(
            List.class.getTypeParameters()[0]);
        System.out.println("Element type: " + elementToken);
        
        /**
         * OUTPUT:
         * Type: java.util.List<java.lang.String>
         * Raw type: interface java.util.List
         * Element type: java.lang.String
         */
    }
    
    /**
     * Complex generic types
     */
    public static void complexTypes() {
        // Nested generics
        TypeToken<Map<String, List<Integer>>> mapToken = 
            new TypeToken<Map<String, List<Integer>>>() {};
        
        System.out.println("Map type: " + mapToken.getType());
        
        // Array types
        TypeToken<String[]> arrayToken = new TypeToken<String[]>() {};
        System.out.println("Array type: " + arrayToken);
        
        // Wildcard types
        TypeToken<List<? extends Number>> wildcardToken = 
            new TypeToken<List<? extends Number>>() {};
        System.out.println("Wildcard type: " + wildcardToken);
    }
    
    /**
     * Type hierarchy navigation
     */
    public static void typeHierarchy() {
        TypeToken<ArrayList<String>> token = new TypeToken<ArrayList<String>>() {};
        
        // Get supertypes
        System.out.println("Supertypes:");
        for (TypeToken<?> supertype : token.getTypes()) {
            System.out.println("  " + supertype);
        }
        
        /**
         * OUTPUT:
         * Supertypes:
         *   java.util.ArrayList<java.lang.String>
         *   java.util.AbstractList<java.lang.String>
         *   java.util.List<java.lang.String>
         *   java.util.AbstractCollection<java.lang.String>
         *   java.util.Collection<java.lang.String>
         *   ...
         * 
         * FULL GENERIC HIERARCHY!
         */
    }
    
    /**
     * Type checking
     */
    public static void typeChecking() {
        TypeToken<ArrayList<String>> arrayListToken = 
            new TypeToken<ArrayList<String>>() {};
        
        TypeToken<List<String>> listToken = 
            new TypeToken<List<String>>() {};
        
        // Subtype check
        boolean isSubtype = arrayListToken.isSubtypeOf(listToken);
        System.out.println("ArrayList<String> subtype of List<String>: " + isSubtype);
        
        // Assignability
        boolean isAssignable = listToken.isSupertypeOf(arrayListToken);
        System.out.println("List<String> is supertype: " + isAssignable);
        
        /**
         * TYPE-SAFE CHECKS:
         * Including generic type parameters!
         */
    }
    
    /**
     * Resolving type variables
     */
    static class StringList extends ArrayList<String> {}
    
    public static void resolvingTypeVariables() {
        // Get TypeToken from class
        TypeToken<StringList> token = TypeToken.of(StringList.class);
        
        // Resolve List's type parameter
        TypeToken<?> listType = token.getSupertype(List.class);
        System.out.println("List supertype: " + listType);
        
        /**
         * OUTPUT:
         * List supertype: java.util.List<java.lang.String>
         * 
         * Resolved E to String!
         */
    }
    
    /**
     * Generic method with TypeToken
     */
    static class GenericSerializer {
        @SuppressWarnings("unchecked")
        public <T> String serialize(T object, TypeToken<T> typeToken) {
            Class<? super T> rawType = typeToken.getRawType();
            Type type = typeToken.getType();
            
            System.out.println("Serializing " + rawType.getSimpleName());
            System.out.println("Full type: " + type);
            
            // Actual serialization logic
            return object.toString();
        }
    }
    
    public static void genericMethodExample() {
        GenericSerializer serializer = new GenericSerializer();
        
        List<String> list = Arrays.asList("a", "b", "c");
        
        String json = serializer.serialize(
            list,
            new TypeToken<List<String>>() {}
        );
        
        System.out.println("Serialized: " + json);
    }
    
    /**
     * Creating instances with TypeToken
     */
    @SuppressWarnings("unchecked")
    public static <T> T createInstance(TypeToken<T> typeToken) throws Exception {
        Class<? super T> rawType = typeToken.getRawType();
        
        // Create instance of raw type
        return (T) rawType.getDeclaredConstructor().newInstance();
    }
    
    public static void creatingInstances() throws Exception {
        // Create ArrayList<String>
        List<String> list = createInstance(new TypeToken<ArrayList<String>>() {});
        list.add("hello");
        
        System.out.println("Created: " + list);
        
        /**
         * NOTE:
         * Creates ArrayList, but generic type only at compile time
         * Runtime still doesn't have type parameter
         */
    }
    
    /**
     * Comparing with Class token
     */
    public static void comparisonWithClassToken() {
        /**
         * CLASS TOKEN:
         * 
         * Class<String> clazz = String.class;
         * 
         * ✓ Simple for non-generic types
         * ✗ Can't capture generic type parameters
         * ✗ Limited API
         * 
         * 
         * TYPETOKEN:
         * 
         * TypeToken<List<String>> token = new TypeToken<>() {};
         * 
         * ✓ Captures full generic types
         * ✓ Rich API (subtype checking, hierarchy, etc.)
         * ✓ Type-safe
         * ✗ Requires anonymous class
         * ✗ More verbose
         * 
         * 
         * WHEN TO USE:
         * 
         * Class token: Non-generic types (String, Integer, User)
         * TypeToken: Generic types (List<String>, Map<K, V>)
         */
    }
    
    /**
     * Real-world use case: Generic cache
     */
    static class TypeSafeCache {
        private final Map<TypeToken<?>, Object> cache = new HashMap<>();
        
        public <T> void put(TypeToken<T> type, T value) {
            cache.put(type, value);
        }
        
        @SuppressWarnings("unchecked")
        public <T> T get(TypeToken<T> type) {
            return (T) cache.get(type);
        }
    }
    
    public static void typeSafeCache() {
        TypeSafeCache cache = new TypeSafeCache();
        
        // Store List<String>
        cache.put(
            new TypeToken<List<String>>() {},
            Arrays.asList("a", "b", "c")
        );
        
        // Store Map<String, Integer>
        Map<String, Integer> map = new HashMap<>();
        map.put("age", 30);
        cache.put(
            new TypeToken<Map<String, Integer>>() {},
            map
        );
        
        // Retrieve with full type safety
        List<String> list = cache.get(new TypeToken<List<String>>() {});
        Map<String, Integer> retrievedMap = cache.get(new TypeToken<Map<String, Integer>>() {});
        
        System.out.println("List: " + list);
        System.out.println("Map: " + retrievedMap);
        
        /**
         * TYPE SAFETY:
         * 
         * Different TypeTokens for:
         * - List<String>
         * - List<Integer>
         * - Map<String, Integer>
         * 
         * Each is distinct key in cache
         */
    }
    
    public static void main(String[] args) throws Exception {
        System.out.println("=== Basic Usage ===");
        basicUsage();
        
        System.out.println("\n=== Complex Types ===");
        complexTypes();
        
        System.out.println("\n=== Type Hierarchy ===");
        typeHierarchy();
        
        System.out.println("\n=== Type Checking ===");
        typeChecking();
        
        System.out.println("\n=== Resolving Type Variables ===");
        resolvingTypeVariables();
        
        System.out.println("\n=== Generic Method ===");
        genericMethodExample();
        
        System.out.println("\n=== Creating Instances ===");
        creatingInstances();
        
        System.out.println("\n=== Type-Safe Cache ===");
        typeSafeCache();
    }
}
```

---

## 4. Jackson TypeReference

### JSON Deserialization with Generic Types

```java
/**
 * JACKSON TYPEREFERENCE
 * 
 * Popular pattern for JSON deserialization
 */

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.util.*;

/**
 * Maven dependency:
 * <dependency>
 *     <groupId>com.fasterxml.jackson.core</groupId>
 *     <artifactId>jackson-databind</artifactId>
 *     <version>2.15.2</version>
 * </dependency>
 */

public class JacksonTypeReference {
    
    /**
     * The problem without TypeReference
     */
    public static void problemWithoutTypeReference() throws Exception {
        ObjectMapper mapper = new ObjectMapper();
        
        String json = "[{\"name\":\"Alice\",\"age\":30}, {\"name\":\"Bob\",\"age\":25}]";
        
        // Without TypeReference - loses type information
        List users = mapper.readValue(json, List.class);
        
        // What's in the list?
        Object first = users.get(0);
        System.out.println("First element type: " + first.getClass());
        // Output: class java.util.LinkedHashMap
        
        // Not User objects! Just LinkedHashMap
        
        /**
         * PROBLEM:
         * 
         * mapper.readValue(json, List.class)
         * 
         * Jackson knows: List
         * Jackson doesn't know: List<User>
         * 
         * Creates List<LinkedHashMap>
         * Not List<User>!
         */
    }
    
    /**
     * Solution: TypeReference
     */
    static class User {
        private String name;
        private int age;
        
        // Getters and setters required for Jackson
        public String getName() { return name; }
        public void setName(String name) { this.name = name; }
        public int getAge() { return age; }
        public void setAge(int age) { this.age = age; }
        
        @Override
        public String toString() {
            return "User{name='" + name + "', age=" + age + "}";
        }
    }
    
    public static void solutionWithTypeReference() throws Exception {
        ObjectMapper mapper = new ObjectMapper();
        
        String json = "[{\"name\":\"Alice\",\"age\":30}, {\"name\":\"Bob\",\"age\":25}]";
        
        // With TypeReference - captures List<User>
        List<User> users = mapper.readValue(
            json,
            new TypeReference<List<User>>() {}
        );
        
        // Now we have actual User objects!
        User first = users.get(0);
        System.out.println("First user: " + first);
        System.out.println("Name: " + first.getName());
        
        /**
         * SOLUTION:
         * 
         * new TypeReference<List<User>>() {}
         *                                 ^^
         * Anonymous class captures type
         * 
         * Jackson can deserialize to proper User objects
         */
    }
    
    /**
     * Complex generic types
     */
    public static void complexGenericTypes() throws Exception {
        ObjectMapper mapper = new ObjectMapper();
        
        String json = "{\"users\":[{\"name\":\"Alice\",\"age\":30}], " +
                     "\"count\":1}";
        
        // Map<String, Object> with specific types
        Map<String, Object> result = mapper.readValue(
            json,
            new TypeReference<Map<String, Object>>() {}
        );
        
        System.out.println("Result: " + result);
        
        // Nested generics
        String listMapJson = "[{\"key\":\"value\"}]";
        
        List<Map<String, String>> listOfMaps = mapper.readValue(
            listMapJson,
            new TypeReference<List<Map<String, String>>>() {}
        );
        
        System.out.println("List of maps: " + listOfMaps);
    }
    
    /**
     * Reusable TypeReference instances
     */
    public static class TypeReferences {
        public static final TypeReference<List<User>> USER_LIST = 
            new TypeReference<List<User>>() {};
        
        public static final TypeReference<Map<String, User>> USER_MAP = 
            new TypeReference<Map<String, User>>() {};
        
        public static final TypeReference<List<Map<String, Object>>> LIST_MAP = 
            new TypeReference<List<Map<String, Object>>>() {};
    }
    
    public static void reusableTypeReferences() throws Exception {
        ObjectMapper mapper = new ObjectMapper();
        
        String json = "[{\"name\":\"Alice\",\"age\":30}]";
        
        // Use predefined TypeReference
        List<User> users = mapper.readValue(json, TypeReferences.USER_LIST);
        
        System.out.println("Users: " + users);
        
        /**
         * BEST PRACTICE:
         * 
         * Define commonly used TypeReferences as constants
         * Avoid creating anonymous classes repeatedly
         * Better performance and readability
         */
    }
    
    /**
     * Generic method with TypeReference
     */
    static class JsonUtil {
        private static final ObjectMapper mapper = new ObjectMapper();
        
        public static <T> T fromJson(String json, TypeReference<T> typeRef) 
                throws Exception {
            return mapper.readValue(json, typeRef);
        }
        
        public static <T> String toJson(T object) throws Exception {
            return mapper.writeValueAsString(object);
        }
    }
    
    public static void genericJsonUtil() throws Exception {
        String json = "[{\"name\":\"Alice\",\"age\":30}]";
        
        // Deserialize with type safety
        List<User> users = JsonUtil.fromJson(
            json,
            new TypeReference<List<User>>() {}
        );
        
        System.out.println("Deserialized: " + users);
        
        // Serialize
        String serialized = JsonUtil.toJson(users);
        System.out.println("Serialized: " + serialized);
    }
    
    /**
     * Jackson vs Guava TypeToken
     */
    public static void jacksonVsGuava() {
        /**
         * JACKSON TypeReference:
         * 
         * ✓ Built specifically for JSON deserialization
         * ✓ Widely used in REST APIs
         * ✓ Simple API
         * ✗ Limited to Jackson
         * 
         * 
         * GUAVA TypeToken:
         * 
         * ✓ Rich API for type manipulation
         * ✓ Subtype checking, hierarchy navigation
         * ✓ General purpose
         * ✗ More complex
         * 
         * 
         * WHEN TO USE:
         * 
         * Jackson TypeReference: JSON deserialization
         * Guava TypeToken: Complex type manipulation
         */
    }
    
    public static void main(String[] args) throws Exception {
        System.out.println("=== Problem Without TypeReference ===");
        problemWithoutTypeReference();
        
        System.out.println("\n=== Solution With TypeReference ===");
        solutionWithTypeReference();
        
        System.out.println("\n=== Complex Generic Types ===");
        complexGenericTypes();
        
        System.out.println("\n=== Reusable TypeReferences ===");
        reusableTypeReferences();
        
        System.out.println("\n=== Generic JSON Util ===");
        genericJsonUtil();
    }
}
```

---

## 5. Creating Generic Arrays

### Solutions for Array Creation with Type Parameters

```java
/**
 * GENERIC ARRAY CREATION
 * 
 * Workarounds for new T[size] limitation
 */

import java.lang.reflect.*;
import java.util.*;

public class GenericArrayCreation {
    
    /**
     * The problem
     */
    public static void theProblem() {
        /**
         * CANNOT CREATE GENERIC ARRAYS:
         * 
         * public static <T> T[] create(int size) {
         *     return new T[size];  // ERROR
         * }
         * 
         * 
         * WHY NOT:
         * 
         * T erased to Object at runtime
         * new T[size] would be new Object[size]
         * 
         * Arrays are reified (know component type)
         * Generics are erased (don't know type)
         * 
         * Incompatible!
         * 
         * 
         * ALSO ILLEGAL:
         * 
         * new List<String>[10]  // ERROR
         * new T[10]             // ERROR
         * new E[]               // ERROR
         */
    }
    
    /**
     * Solution 1: Array.newInstance with Class token
     */
    @SuppressWarnings("unchecked")
    public static <T> T[] createArray(Class<T> componentType, int size) {
        return (T[]) Array.newInstance(componentType, size);
    }
    
    public static void arrayNewInstance() {
        // Create String array
        String[] strings = createArray(String.class, 10);
        strings[0] = "hello";
        strings[1] = "world";
        
        System.out.println("String array: " + Arrays.toString(strings));
        
        // Create Integer array
        Integer[] integers = createArray(Integer.class, 5);
        integers[0] = 42;
        
        System.out.println("Integer array: " + Arrays.toString(integers));
        
        /**
         * ARRAY.NEWINSTANCE:
         * 
         * Array.newInstance(componentType, size)
         * 
         * Creates array with proper runtime type
         * Returns Object[]
         * Safe to cast to T[] because we control component type
         * 
         * LIMITATION:
         * Must pass Class<T> parameter
         */
    }
    
    /**
     * Solution 2: Constructor with varargs
     */
    @SafeVarargs
    public static <T> T[] arrayOf(T... elements) {
        return elements;
    }
    
    public static void varargsApproach() {
        // Create array from elements
        String[] strings = arrayOf("a", "b", "c");
        Integer[] integers = arrayOf(1, 2, 3, 4, 5);
        
        System.out.println("Strings: " + Arrays.toString(strings));
        System.out.println("Integers: " + Arrays.toString(integers));
        
        /**
         * VARARGS TRICK:
         * 
         * Compiler creates array from varargs
         * Type inferred from arguments
         * 
         * WARNING:
         * Heap pollution possible with generic varargs
         * Use @SafeVarargs to suppress warnings
         */
    }
    
    /**
     * Solution 3: Use ArrayList internally
     */
    static class GenericStack<T> {
        private final List<T> elements = new ArrayList<>();
        
        public void push(T element) {
            elements.add(element);
        }
        
        public T pop() {
            if (elements.isEmpty()) {
                throw new EmptyStackException();
            }
            return elements.remove(elements.size() - 1);
        }
        
        @SuppressWarnings("unchecked")
        public T[] toArray(Class<T> componentType) {
            return elements.toArray((T[]) Array.newInstance(componentType, 0));
        }
    }
    
    public static void arrayListApproach() {
        GenericStack<String> stack = new GenericStack<>();
        stack.push("a");
        stack.push("b");
        stack.push("c");
        
        // Convert to array when needed
        String[] array = stack.toArray(String.class);
        System.out.println("Array: " + Arrays.toString(array));
        
        /**
         * BEST PRACTICE:
         * 
         * Use List<T> internally
         * Convert to array only when needed
         * Avoids generic array creation issues
         */
    }
    
    /**
     * Solution 4: Object array with cast
     */
    static class SimpleGenericArray<T> {
        private final Object[] array;
        
        @SuppressWarnings("unchecked")
        public SimpleGenericArray(int size) {
            this.array = new Object[size];
        }
        
        @SuppressWarnings("unchecked")
        public T get(int index) {
            return (T) array[index];
        }
        
        public void set(int index, T value) {
            array[index] = value;
        }
        
        public int length() {
            return array.length;
        }
    }
    
    public static void objectArrayCast() {
        SimpleGenericArray<String> array = new SimpleGenericArray<>(10);
        array.set(0, "hello");
        array.set(1, "world");
        
        String first = array.get(0);
        System.out.println("First: " + first);
        
        /**
         * OBJECT ARRAY APPROACH:
         * 
         * Store as Object[]
         * Cast on get()
         * 
         * LIMITATION:
         * Can't get T[] out
         * No runtime type checking
         * 
         * array.set(0, "string") compiles
         * array.set(1, 42) also compiles (type erased)
         * Only fails when you get() and cast
         */
    }
    
    /**
     * Real-world: ArrayList implementation
     */
    static class SimpleArrayList<E> {
        private static final int DEFAULT_CAPACITY = 10;
        
        // ArrayList uses Object[] internally
        private Object[] elementData;
        private int size = 0;
        
        public SimpleArrayList() {
            this.elementData = new Object[DEFAULT_CAPACITY];
        }
        
        public void add(E element) {
            if (size == elementData.length) {
                grow();
            }
            elementData[size++] = element;
        }
        
        @SuppressWarnings("unchecked")
        public E get(int index) {
            if (index >= size) {
                throw new IndexOutOfBoundsException();
            }
            return (E) elementData[index];
        }
        
        private void grow() {
            int newCapacity = elementData.length * 2;
            elementData = Arrays.copyOf(elementData, newCapacity);
        }
        
        public int size() {
            return size;
        }
        
        @SuppressWarnings("unchecked")
        public E[] toArray(E[] a) {
            if (a.length < size) {
                // Create array of proper type
                return (E[]) Arrays.copyOf(elementData, size, a.getClass());
            }
            System.arraycopy(elementData, 0, a, 0, size);
            if (a.length > size) {
                a[size] = null;
            }
            return a;
        }
    }
    
    public static void arrayListImplementation() {
        SimpleArrayList<String> list = new SimpleArrayList<>();
        list.add("a");
        list.add("b");
        list.add("c");
        
        System.out.println("Size: " + list.size());
        System.out.println("Get(0): " + list.get(0));
        
        // Convert to array
        String[] array = list.toArray(new String[0]);
        System.out.println("Array: " + Arrays.toString(array));
        
        /**
         * REAL ARRAYLIST:
         * 
         * Uses Object[] internally
         * Cast on get()
         * toArray() creates properly typed array
         * 
         * This is how the actual java.util.ArrayList works!
         */
    }
    
    /**
     * Comparison of approaches
     */
    public static void comparisonOfApproaches() {
        /**
         * APPROACHES COMPARISON:
         * 
         * 1. Array.newInstance(Class<T>, size):
         *    ✓ Proper runtime type
         *    ✓ Type-safe
         *    ✗ Requires Class token
         *    Use: When you need real T[]
         * 
         * 2. Varargs (T... elements):
         *    ✓ No Class token needed
         *    ✓ Convenient
         *    ⚠  Heap pollution warnings
         *    Use: Creating array from elements
         * 
         * 3. List<T> internally:
         *    ✓ No generic array issues
         *    ✓ Dynamic size
         *    ✗ Slight overhead
         *    Use: Most cases (recommended)
         * 
         * 4. Object[] with cast:
         *    ✓ Simple
         *    ✗ No runtime type
         *    ✗ Can't get T[] out
         *    Use: Internal implementation
         * 
         * 
         * RECOMMENDATION:
         * Use List<T> unless you specifically need array
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Array.newInstance ===");
        arrayNewInstance();
        
        System.out.println("\n=== Varargs Approach ===");
        varargsApproach();
        
        System.out.println("\n=== ArrayList Approach ===");
        arrayListApproach();
        
        System.out.println("\n=== Object Array Cast ===");
        objectArrayCast();
        
        System.out.println("\n=== ArrayList Implementation ===");
        arrayListImplementation();
    }
}
```

---

## 6. Reflection with Generics

### Accessing Generic Type Information via Reflection

```java
/**
 * REFLECTION WITH GENERICS
 * 
 * Using reflection to access generic type information
 */

import java.lang.reflect.*;
import java.util.*;

public class ReflectionWithGenerics {
    
    /**
     * Type hierarchy in reflection
     */
    public static void typeHierarchy() {
        /**
         * TYPE HIERARCHY:
         * 
         * Type (interface)
         *   ├── Class<T>
         *   ├── ParameterizedType     (e.g., List<String>)
         *   ├── GenericArrayType      (e.g., T[])
         *   ├── TypeVariable<D>       (e.g., T, E, K, V)
         *   └── WildcardType          (e.g., ?, ? extends Number)
         * 
         * 
         * Class<T>:
         * - Regular classes, interfaces, enums
         * - String.class, Integer.class
         * 
         * ParameterizedType:
         * - Generic type with type arguments
         * - List<String>, Map<K, V>
         * 
         * GenericArrayType:
         * - Array of type variable or parameterized type
         * - T[], List<String>[]
         * 
         * TypeVariable:
         * - Type parameter declaration
         * - T, E, K, V
         * 
         * WildcardType:
         * - Wildcard with bounds
         * - ?, ? extends Number, ? super Integer
         */
    }
    
    /**
     * Inspecting field types
     */
    static class Container {
        private List<String> stringList;
        private Map<String, Integer> stringIntMap;
        private String[] stringArray;
        private List<String>[] arrayOfLists;
    }
    
    public static void inspectingFields() throws Exception {
        Class<?> clazz = Container.class;
        
        for (Field field : clazz.getDeclaredFields()) {
            System.out.println("\nField: " + field.getName());
            
            // Generic type
            Type genericType = field.getGenericType();
            System.out.println("  Generic type: " + genericType);
            System.out.println("  Type class: " + genericType.getClass().getSimpleName());
            
            // Analyze type
            analyzeType(genericType);
        }
        
        /**
         * OUTPUT:
         * 
         * Field: stringList
         *   Generic type: java.util.List<java.lang.String>
         *   Type class: ParameterizedTypeImpl
         *   Raw type: interface java.util.List
         *   Type arguments: [class java.lang.String]
         * 
         * Field: stringIntMap
         *   Generic type: java.util.Map<java.lang.String, java.lang.Integer>
         *   Type class: ParameterizedTypeImpl
         *   Raw type: interface java.util.Map
         *   Type arguments: [class java.lang.String, class java.lang.Integer]
         */
    }
    
    private static void analyzeType(Type type) {
        if (type instanceof ParameterizedType) {
            ParameterizedType paramType = (ParameterizedType) type;
            
            System.out.println("  Raw type: " + paramType.getRawType());
            System.out.println("  Type arguments: " + 
                Arrays.toString(paramType.getActualTypeArguments()));
            
        } else if (type instanceof GenericArrayType) {
            GenericArrayType arrayType = (GenericArrayType) type;
            
            System.out.println("  Component type: " + 
                arrayType.getGenericComponentType());
            
        } else if (type instanceof TypeVariable) {
            TypeVariable<?> typeVar = (TypeVariable<?>) type;
            
            System.out.println("  Type variable: " + typeVar.getName());
            System.out.println("  Bounds: " + 
                Arrays.toString(typeVar.getBounds()));
            
        } else if (type instanceof Class) {
            System.out.println("  Regular class: " + type);
        }
    }
    
    /**
     * Inspecting method signatures
     */
    static class Service {
        public <T extends Comparable<T>> T max(List<T> list) {
            return null;
        }
        
        public void process(Map<String, ? extends Number> map) {
        }
        
        public <K, V> Map<K, V> createMap(K key, V value) {
            return null;
        }
    }
    
    public static void inspectingMethods() throws Exception {
        Class<?> clazz = Service.class;
        
        for (Method method : clazz.getDeclaredMethods()) {
            System.out.println("\nMethod: " + method.getName());
            
            // Type parameters
            TypeVariable<Method>[] typeParams = method.getTypeParameters();
            if (typeParams.length > 0) {
                System.out.println("  Type parameters:");
                for (TypeVariable<Method> typeParam : typeParams) {
                    System.out.println("    " + typeParam.getName() + 
                        " extends " + Arrays.toString(typeParam.getBounds()));
                }
            }
            
            // Parameter types
            Type[] paramTypes = method.getGenericParameterTypes();
            System.out.println("  Parameter types:");
            for (Type paramType : paramTypes) {
                System.out.println("    " + paramType);
            }
            
            // Return type
            Type returnType = method.getGenericReturnType();
            System.out.println("  Return type: " + returnType);
        }
        
        /**
         * OUTPUT:
         * 
         * Method: max
         *   Type parameters:
         *     T extends [interface java.lang.Comparable]
         *   Parameter types:
         *     java.util.List<T>
         *   Return type: T
         * 
         * Method: process
         *   Parameter types:
         *     java.util.Map<java.lang.String, ? extends java.lang.Number>
         *   Return type: void
         */
    }
    
    /**
     * Inspecting class type parameters
     */
    static class GenericClass<T extends Number, U> {
        private T value1;
        private U value2;
    }
    
    public static void inspectingClassTypeParameters() {
        Class<?> clazz = GenericClass.class;
        
        TypeVariable<?>[] typeParams = clazz.getTypeParameters();
        
        System.out.println("Class type parameters:");
        for (TypeVariable<?> typeParam : typeParams) {
            System.out.println("  Name: " + typeParam.getName());
            System.out.println("  Bounds: " + Arrays.toString(typeParam.getBounds()));
        }
        
        /**
         * OUTPUT:
         * Class type parameters:
         *   Name: T
         *   Bounds: [class java.lang.Number]
         *   Name: U
         *   Bounds: [class java.lang.Object]
         */
    }
    
    /**
     * Resolving type variables in subclass
     */
    static abstract class AbstractRepository<T> {
        private final Class<T> entityType;
        
        @SuppressWarnings("unchecked")
        protected AbstractRepository() {
            // Resolve T from subclass
            Type superclass = getClass().getGenericSuperclass();
            
            if (superclass instanceof ParameterizedType) {
                ParameterizedType paramType = (ParameterizedType) superclass;
                this.entityType = (Class<T>) paramType.getActualTypeArguments()[0];
            } else {
                throw new IllegalStateException("Must specify entity type");
            }
        }
        
        public Class<T> getEntityType() {
            return entityType;
        }
    }
    
    static class User {
        private String name;
        
        public User(String name) {
            this.name = name;
        }
        
        public String getName() {
            return name;
        }
    }
    
    static class UserRepository extends AbstractRepository<User> {
    }
    
    public static void resolvingTypeVariables() {
        UserRepository repo = new UserRepository();
        
        Class<User> entityType = repo.getEntityType();
        System.out.println("Entity type: " + entityType);
        
        /**
         * HOW IT WORKS:
         * 
         * UserRepository extends AbstractRepository<User>
         * 
         * At compile time:
         * class UserRepository extends AbstractRepository<User> {}
         * 
         * Generic superclass info preserved!
         * 
         * getGenericSuperclass() returns:
         * AbstractRepository<User>
         * 
         * Extract type argument: User
         * 
         * LIMITATION:
         * Only works if you extend with concrete type
         * Won't work with type variables
         */
    }
    
    /**
     * Wildcard reflection
     */
    static class WildcardExample {
        public void process(List<? extends Number> numbers) {
        }
        
        public void consume(List<? super Integer> ints) {
        }
    }
    
    public static void wildcardReflection() throws Exception {
        Method processMethod = WildcardExample.class.getMethod(
            "process", List.class);
        
        Type paramType = processMethod.getGenericParameterTypes()[0];
        
        if (paramType instanceof ParameterizedType) {
            ParameterizedType parameterizedType = (ParameterizedType) paramType;
            Type[] typeArgs = parameterizedType.getActualTypeArguments();
            
            Type wildcardType = typeArgs[0];
            
            if (wildcardType instanceof WildcardType) {
                WildcardType wildcard = (WildcardType) wildcardType;
                
                System.out.println("Upper bounds: " + 
                    Arrays.toString(wildcard.getUpperBounds()));
                System.out.println("Lower bounds: " + 
                    Arrays.toString(wildcard.getLowerBounds()));
            }
        }
        
        /**
         * OUTPUT:
         * Upper bounds: [class java.lang.Number]
         * Lower bounds: []
         * 
         * ? extends Number has upper bound
         * ? super Integer has lower bound
         */
    }
    
    /**
     * Practical use: Generic DAO factory
     */
    static class DaoFactory {
        @SuppressWarnings("unchecked")
        public static <T> GenericDao<T> createDao(Class<T> entityType) {
            // Could use reflection to instantiate
            // For now, just create generic DAO
            return new GenericDao<>(entityType);
        }
    }
    
    static class GenericDao<T> {
        private final Class<T> entityType;
        private final Map<Object, T> storage = new HashMap<>();
        
        public GenericDao(Class<T> entityType) {
            this.entityType = entityType;
        }
        
        public void save(T entity) {
            // In real impl, extract ID
            storage.put(System.identityHashCode(entity), entity);
        }
        
        public Class<T> getEntityType() {
            return entityType;
        }
    }
    
    public static void practicalDaoFactory() {
        GenericDao<User> userDao = DaoFactory.createDao(User.class);
        
        User user = new User("Alice");
        userDao.save(user);
        
        System.out.println("DAO entity type: " + userDao.getEntityType());
        
        /**
         * REAL-WORLD USAGE:
         * 
         * Frameworks use reflection to:
         * - Discover entity types
         * - Generate SQL queries
         * - Map results to objects
         * - Inject dependencies
         */
    }
    
    public static void main(String[] args) throws Exception {
        System.out.println("=== Inspecting Fields ===");
        inspectingFields();
        
        System.out.println("\n=== Inspecting Methods ===");
        inspectingMethods();
        
        System.out.println("\n=== Inspecting Class Type Parameters ===");
        inspectingClassTypeParameters();
        
        System.out.println("\n=== Resolving Type Variables ===");
        resolvingTypeVariables();
        
        System.out.println("\n=== Wildcard Reflection ===");
        wildcardReflection();
        
        System.out.println("\n=== Practical DAO Factory ===");
        practicalDaoFactory();
    }
}
```

---

## Summary

### Quick Reference

**Type Capture Patterns:**

```java
// 1. Class token
public <T> T create(Class<T> type) { }
create(String.class)

// 2. TypeReference (super type token)
TypeReference<List<String>> ref = new TypeReference<List<String>>() {};
                                                                     ^^
// Anonymous class required!

// 3. Guava TypeToken
TypeToken<List<String>> token = new TypeToken<List<String>>() {};

// 4. Jackson TypeReference
List<User> users = mapper.readValue(json, 
    new TypeReference<List<User>>() {});
```

**Generic Array Creation:**

```java
// 1. Array.newInstance
@SuppressWarnings("unchecked")
public <T> T[] create(Class<T> type, int size) {
    return (T[]) Array.newInstance(type, size);
}

// 2. Varargs
@SafeVarargs
public <T> T[] arrayOf(T... elements) {
    return elements;
}

// 3. Use List (recommended)
List<T> list = new ArrayList<>();
```

**Reflection Type Hierarchy:**

```
Type (interface)
  ├── Class<T>              // String.class
  ├── ParameterizedType     // List<String>
  ├── GenericArrayType      // T[]
  ├── TypeVariable<D>       // T, E, K, V
  └── WildcardType          // ?, ? extends Number
```

### Comparison Table

```
┌──────────────────┬─────────────┬─────────────┬──────────────┐
│ Approach         │ Captures    │ Use Case    │ Complexity   │
├──────────────────┼─────────────┼─────────────┼──────────────┤
│ Class<T>         │ Raw type    │ Simple      │ Low ✅       │
│ TypeReference    │ Full type   │ JSON        │ Medium       │
│ Guava TypeToken  │ Full type   │ Advanced    │ High         │
│ Reflection       │ Full type   │ Frameworks  │ Very High    │
└──────────────────┴─────────────┴─────────────┴──────────────┘
```

### Best Practices

**1. Choose the right tool:**

```java
// Non-generic types → Class token
create(String.class)

// Generic types → TypeReference or TypeToken
new TypeReference<List<String>>() {}

// JSON deserialization → Jackson TypeReference
mapper.readValue(json, new TypeReference<List<User>>() {})
```

**2. Avoid generic arrays:**

```java
// ❌ BAD: Generic array
public <T> T[] create() {
    return new T[10];  // ERROR
}

// ✅ GOOD: Use List
public <T> List<T> create() {
    return new ArrayList<>();
}
```

**3. Remember anonymous class:**

```java
// ❌ BAD: Forgets anonymous class
// TypeReference<List<String>> ref = new TypeReference<>();

// ✅ GOOD: Anonymous class captures type
TypeReference<List<String>> ref = new TypeReference<List<String>>() {};
//                                                                   ^^
```

**4. Cache TypeReferences:**

```java
// ✅ GOOD: Reusable constant
public static final TypeReference<List<User>> USER_LIST_TYPE = 
    new TypeReference<List<User>>() {};

// Use repeatedly
List<User> users1 = mapper.readValue(json1, USER_LIST_TYPE);
List<User> users2 = mapper.readValue(json2, USER_LIST_TYPE);
```

---
