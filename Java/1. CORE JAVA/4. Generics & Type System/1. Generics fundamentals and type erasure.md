# Generics Fundamentals and Type Erasure

## Overview

Generics are one of Java's most powerful features, providing compile-time type safety and eliminating casts. However, Java's implementation through type erasure creates unique challenges and limitations. This guide covers everything from basic generics to the deep mechanics of type erasure, bridge methods, and practical workarounds.


---

## 1. Generic Classes, Interfaces, Methods

### The Foundation of Type Safety

```java
/**
 * GENERIC CLASSES
 * 
 * Parameterized types for reusable, type-safe code
 */

public class GenericClasses {
    
    /**
     * Basic generic class
     */
    static class Box<T> {
        private T content;
        
        public void set(T content) {
            this.content = content;
        }
        
        public T get() {
            return content;
        }
    }
    
    public static void basicGenericClass() {
        // Type-safe: T = String
        Box<String> stringBox = new Box<>();
        stringBox.set("Hello");
        String value = stringBox.get();  // No cast needed!
        
        // Type-safe: T = Integer
        Box<Integer> intBox = new Box<>();
        intBox.set(42);
        Integer number = intBox.get();
        
        // Compile error - type safety!
        // stringBox.set(42);  // ERROR: incompatible types
        
        /**
         * BENEFITS:
         * - Compile-time type checking
         * - No casts required
         * - Catches errors early
         * - Self-documenting code
         */
    }
    
    /**
     * Multiple type parameters
     */
    static class Pair<K, V> {
        private K key;
        private V value;
        
        public Pair(K key, V value) {
            this.key = key;
            this.value = value;
        }
        
        public K getKey() {
            return key;
        }
        
        public V getValue() {
            return value;
        }
        
        @Override
        public String toString() {
            return key + "=" + value;
        }
    }
    
    public static void multipleTypeParameters() {
        Pair<String, Integer> pair = new Pair<>("age", 30);
        System.out.println("Pair: " + pair);
        
        String key = pair.getKey();      // No cast
        Integer value = pair.getValue(); // No cast
        
        /**
         * CONVENTIONS:
         * K - Key
         * V - Value
         * E - Element
         * T - Type
         * N - Number
         * 
         * You can use any identifier, but conventions help readability
         */
    }
    
    /**
     * Generic interfaces
     */
    interface Comparable<T> {
        int compareTo(T other);
    }
    
    static class Person implements Comparable<Person> {
        String name;
        int age;
        
        Person(String name, int age) {
            this.name = name;
            this.age = age;
        }
        
        @Override
        public int compareTo(Person other) {
            return Integer.compare(this.age, other.age);
        }
    }
    
    public static void genericInterfaces() {
        Person p1 = new Person("Alice", 30);
        Person p2 = new Person("Bob", 25);
        
        // Type-safe comparison
        int result = p1.compareTo(p2);
        System.out.println("Comparison: " + result);
        
        /**
         * GENERIC INTERFACES:
         * - Comparable<T>
         * - Iterable<T>
         * - Iterator<E>
         * - Collection<E>
         * - List<E>
         * - Set<E>
         * - Map<K, V>
         * 
         * All collections use generics for type safety
         */
    }
    
    /**
     * Generic methods
     */
    public static <T> T getFirst(T[] array) {
        if (array == null || array.length == 0) {
            return null;
        }
        return array[0];
    }
    
    public static <T> void swap(T[] array, int i, int j) {
        T temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
    
    public static <K, V> Pair<K, V> makePair(K key, V value) {
        return new Pair<>(key, value);
    }
    
    public static void genericMethods() {
        // Type inference
        String[] strings = {"a", "b", "c"};
        String first = getFirst(strings);  // Infers T = String
        
        swap(strings, 0, 2);  // Infers T = String
        System.out.println("After swap: " + String.join(",", strings));
        
        // Explicit type argument (rare)
        String result = GenericClasses.<String>getFirst(strings);
        
        // Type inference with method
        Pair<String, Integer> pair = makePair("age", 30);
        
        /**
         * GENERIC METHOD SYNTAX:
         * 
         * public <T> T methodName(T parameter)
         *         ^^^
         *         Type parameter before return type
         * 
         * Can be static or instance method
         * Type parameters independent of class type parameters
         */
    }
    
    /**
     * Bounded type parameters
     */
    static class NumberBox<T extends Number> {
        private T number;
        
        public NumberBox(T number) {
            this.number = number;
        }
        
        public double doubleValue() {
            return number.doubleValue();  // Can call Number methods
        }
    }
    
    public static <T extends Comparable<T>> T max(T a, T b) {
        return a.compareTo(b) > 0 ? a : b;
    }
    
    public static void boundedTypeParameters() {
        // OK: Integer extends Number
        NumberBox<Integer> intBox = new NumberBox<>(42);
        System.out.println("Double value: " + intBox.doubleValue());
        
        // ERROR: String does not extend Number
        // NumberBox<String> stringBox = new NumberBox<>("hello");
        
        // Bounded method
        Integer maxInt = max(10, 20);
        String maxStr = max("apple", "banana");
        
        System.out.println("Max int: " + maxInt);
        System.out.println("Max string: " + maxStr);
        
        /**
         * UPPER BOUNDS:
         * <T extends Type>
         * - T must be Type or subtype
         * - Can call methods of Type
         * - Can have multiple bounds: <T extends Class & Interface1 & Interface2>
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Basic Generic Class ===");
        basicGenericClass();
        
        System.out.println("\n=== Multiple Type Parameters ===");
        multipleTypeParameters();
        
        System.out.println("\n=== Generic Methods ===");
        genericMethods();
        
        System.out.println("\n=== Bounded Type Parameters ===");
        boundedTypeParameters();
    }
}
```

---

## 2. Type Parameters (T, E, K, V)

### Naming Conventions and Best Practices

```java
/**
 * TYPE PARAMETER CONVENTIONS
 * 
 * Standard naming for generic type parameters
 */

import java.util.*;

public class TypeParameterConventions {
    
    /**
     * Standard conventions
     */
    public static void standardConventions() {
        /**
         * SINGLE LETTER CONVENTIONS:
         * 
         * T - Type (generic type)
         *     class Box<T>
         *     <T> T getValue()
         * 
         * E - Element (collections)
         *     interface List<E>
         *     interface Set<E>
         * 
         * K - Key (maps)
         *     interface Map<K, V>
         * 
         * V - Value (maps)
         *     interface Map<K, V>
         * 
         * N - Number (numeric types)
         *     class Calculator<N extends Number>
         * 
         * R - Result/Return type
         *     interface Function<T, R>
         * 
         * U, S - Additional types
         *     class Triple<T, U, S>
         * 
         * 
         * EXAMPLES FROM JDK:
         */
        
        List<String> list = new ArrayList<>();           // E = String
        Set<Integer> set = new HashSet<>();              // E = Integer
        Map<String, Integer> map = new HashMap<>();      // K = String, V = Integer
        Comparator<String> comp = String::compareTo;     // T = String
    }
    
    /**
     * Descriptive names (when appropriate)
     */
    static class Cache<KEY, VALUE> {
        private Map<KEY, VALUE> data = new HashMap<>();
        
        public void put(KEY key, VALUE value) {
            data.put(key, value);
        }
        
        public VALUE get(KEY key) {
            return data.get(key);
        }
    }
    
    static class Converter<INPUT, OUTPUT> {
        public OUTPUT convert(INPUT input) {
            // Conversion logic
            return null;
        }
    }
    
    public static void descriptiveNames() {
        /**
         * WHEN TO USE DESCRIPTIVE NAMES:
         * 
         * - Complex domain logic
         * - Many type parameters
         * - Public APIs (self-documenting)
         * 
         * Example:
         * class RequestHandler<REQUEST, RESPONSE>
         * class Transformer<SOURCE, TARGET>
         * 
         * AVOID:
         * - Simple, standard patterns (use conventions)
         * - Too long names
         */
    }
    
    /**
     * Multiple bounds
     */
    interface Drawable {
        void draw();
    }
    
    interface Movable {
        void move(int x, int y);
    }
    
    static class GameObject<T extends Drawable & Movable> {
        private T object;
        
        public GameObject(T object) {
            this.object = object;
        }
        
        public void render() {
            object.draw();   // Can call Drawable methods
            object.move(0, 0); // Can call Movable methods
        }
    }
    
    public static void multipleBounds() {
        /**
         * MULTIPLE BOUNDS SYNTAX:
         * 
         * <T extends Class & Interface1 & Interface2>
         * 
         * RULES:
         * - Class must be first (if present)
         * - Followed by interfaces
         * - Separated by &
         * 
         * Example:
         * <T extends Number & Comparable<T> & Serializable>
         */
    }
    
    /**
     * Recursive bounds (F-bounded polymorphism)
     */
    interface Comparable<T extends Comparable<T>> {
        int compareTo(T other);
    }
    
    static class Employee implements Comparable<Employee> {
        String name;
        int salary;
        
        Employee(String name, int salary) {
            this.name = name;
            this.salary = salary;
        }
        
        @Override
        public int compareTo(Employee other) {
            return Integer.compare(this.salary, other.salary);
        }
    }
    
    public static <T extends Comparable<T>> T max(List<T> list) {
        if (list.isEmpty()) {
            throw new IllegalArgumentException("Empty list");
        }
        
        T max = list.get(0);
        for (T item : list) {
            if (item.compareTo(max) > 0) {
                max = item;
            }
        }
        return max;
    }
    
    public static void recursiveBounds() {
        /**
         * RECURSIVE TYPE BOUNDS:
         * 
         * <T extends Comparable<T>>
         * 
         * Means: T must be comparable to itself
         * 
         * BENEFITS:
         * - Type-safe comparisons
         * - Prevents comparing incompatible types
         * - Common in collections and algorithms
         * 
         * Example:
         * String implements Comparable<String>
         * Integer implements Comparable<Integer>
         * 
         * But NOT:
         * class A implements Comparable<B>  // Different type
         */
    }
}
```

---

## 3. Type Erasure at Compile Time

### The Core Mechanism of Java Generics

```java
/**
 * TYPE ERASURE
 * 
 * How generics are implemented in Java
 */

import java.util.*;

public class TypeErasure {
    
    /**
     * What is type erasure?
     */
    public static void whatIsTypeErasure() {
        /**
         * TYPE ERASURE:
         * 
         * Java generics are implemented via "type erasure"
         * - Compile time: Full type information
         * - Runtime: Type parameters erased
         * 
         * PROCESS:
         * 1. Compiler checks types (compile-time safety)
         * 2. Generates bytecode with casts
         * 3. Erases type parameters
         * 
         * 
         * EXAMPLE:
         * 
         * Source code:
         * List<String> list = new ArrayList<>();
         * list.add("hello");
         * String s = list.get(0);
         * 
         * After type erasure (bytecode equivalent):
         * List list = new ArrayList();
         * list.add("hello");
         * String s = (String) list.get(0);  // Cast inserted!
         * 
         * 
         * WHY TYPE ERASURE?
         * - Backward compatibility with pre-generics code (Java 1.4)
         * - Single bytecode for all type parameters
         * - No runtime overhead
         */
    }
    
    /**
     * Erasure examples
     */
    static class Box<T> {
        private T value;
        
        public void set(T value) {
            this.value = value;
        }
        
        public T get() {
            return value;
        }
    }
    
    public static void erasureExample() {
        /**
         * BEFORE ERASURE:
         * 
         * class Box<T> {
         *     private T value;
         *     
         *     public void set(T value) {
         *         this.value = value;
         *     }
         *     
         *     public T get() {
         *         return value;
         *     }
         * }
         * 
         * 
         * AFTER ERASURE:
         * 
         * class Box {
         *     private Object value;  // T → Object
         *     
         *     public void set(Object value) {  // T → Object
         *         this.value = value;
         *     }
         *     
         *     public Object get() {  // T → Object
         *         return value;
         *     }
         * }
         * 
         * 
         * USAGE:
         * 
         * Source:
         * Box<String> box = new Box<>();
         * box.set("hello");
         * String s = box.get();
         * 
         * After erasure + compiler-inserted casts:
         * Box box = new Box();
         * box.set("hello");
         * String s = (String) box.get();  // Cast inserted by compiler
         */
    }
    
    /**
     * Bounded type erasure
     */
    static class NumberBox<T extends Number> {
        private T number;
        
        public NumberBox(T number) {
            this.number = number;
        }
        
        public double doubleValue() {
            return number.doubleValue();
        }
    }
    
    public static void boundedErasure() {
        /**
         * BEFORE ERASURE:
         * 
         * class NumberBox<T extends Number> {
         *     private T number;
         *     
         *     public NumberBox(T number) {
         *         this.number = number;
         *     }
         *     
         *     public double doubleValue() {
         *         return number.doubleValue();
         *     }
         * }
         * 
         * 
         * AFTER ERASURE:
         * 
         * class NumberBox {
         *     private Number number;  // T → Number (not Object!)
         *     
         *     public NumberBox(Number number) {  // T → Number
         *         this.number = number;
         *     }
         *     
         *     public double doubleValue() {
         *         return number.doubleValue();  // Works! Number has this method
         *     }
         * }
         * 
         * 
         * RULE:
         * Unbounded type parameter (T) → Object
         * Bounded type parameter (T extends Type) → Type
         */
    }
    
    /**
     * Multiple bounds erasure
     */
    interface Drawable {
        void draw();
    }
    
    static class Shape<T extends Number & Drawable> {
        private T shape;
        
        public void render() {
            shape.draw();
            double value = shape.doubleValue();
        }
    }
    
    public static void multipleBoundsErasure() {
        /**
         * BEFORE ERASURE:
         * 
         * class Shape<T extends Number & Drawable> {
         *     private T shape;
         *     
         *     public void render() {
         *         shape.draw();
         *         double value = shape.doubleValue();
         *     }
         * }
         * 
         * 
         * AFTER ERASURE:
         * 
         * class Shape {
         *     private Number shape;  // T → First bound (Number)
         *     
         *     public void render() {
         *         ((Drawable) shape).draw();  // Cast to Drawable
         *         double value = shape.doubleValue();
         *     }
         * }
         * 
         * 
         * RULE:
         * Multiple bounds: T → First bound
         * Casts inserted for other bounds
         * 
         * IMPORTANT:
         * Class must be first bound if present!
         */
    }
    
    /**
     * Runtime type information loss
     */
    public static void runtimeInformationLoss() {
        List<String> stringList = new ArrayList<>();
        List<Integer> intList = new ArrayList<>();
        
        // At runtime, both are just List
        System.out.println("String list class: " + stringList.getClass());
        System.out.println("Integer list class: " + intList.getClass());
        System.out.println("Same class? " + 
            (stringList.getClass() == intList.getClass()));
        
        /**
         * OUTPUT:
         * String list class: class java.util.ArrayList
         * Integer list class: class java.util.ArrayList
         * Same class? true
         * 
         * TYPE INFORMATION LOST:
         * - No difference between List<String> and List<Integer> at runtime
         * - Both are just List
         * - Cannot use instanceof with type parameters
         * - Cannot create arrays of generic types
         */
    }
    
    /**
     * What you cannot do due to erasure
     */
    public static void erasureLimitations() {
        /**
         * CANNOT DO:
         * 
         * 1. instanceof with type parameter:
         *    if (obj instanceof T) { }  // ERROR
         *    if (obj instanceof List<String>) { }  // ERROR
         * 
         * 2. Create instances:
         *    T obj = new T();  // ERROR
         * 
         * 3. Create arrays:
         *    T[] array = new T[10];  // ERROR
         * 
         * 4. Class literals:
         *    Class<T> clazz = T.class;  // ERROR
         * 
         * 5. Static fields of type parameter:
         *    static T staticField;  // ERROR
         * 
         * 6. Catch type parameter:
         *    catch (T e) { }  // ERROR
         * 
         * 7. Overload with erasure collision:
         *    void method(List<String> list) { }
         *    void method(List<Integer> list) { }  // ERROR: same erasure
         * 
         * 
         * WHY?
         * Type parameters don't exist at runtime!
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Runtime Information Loss ===");
        runtimeInformationLoss();
    }
}
```

---

## 4. Bridge Methods

### Synthetic Methods for Type Safety

```java
/**
 * BRIDGE METHODS
 * 
 * Compiler-generated methods to maintain type safety after erasure
 */

public class BridgeMethods {
    
    /**
     * Why bridge methods exist
     */
    static class Node<T> {
        private T data;
        
        public Node(T data) {
            this.data = data;
        }
        
        public void setData(T data) {
            this.data = data;
        }
        
        public T getData() {
            return data;
        }
    }
    
    static class IntNode extends Node<Integer> {
        public IntNode(Integer data) {
            super(data);
        }
        
        // Override with specific type
        @Override
        public void setData(Integer data) {
            System.out.println("IntNode.setData(" + data + ")");
            super.setData(data);
        }
        
        @Override
        public Integer getData() {
            System.out.println("IntNode.getData()");
            return super.getData();
        }
    }
    
    public static void bridgeMethodExample() {
        /**
         * SOURCE CODE:
         * 
         * class Node<T> {
         *     public void setData(T data) { ... }
         *     public T getData() { ... }
         * }
         * 
         * class IntNode extends Node<Integer> {
         *     public void setData(Integer data) { ... }
         *     public Integer getData() { ... }
         * }
         * 
         * 
         * AFTER TYPE ERASURE:
         * 
         * class Node {
         *     public void setData(Object data) { ... }  // T → Object
         *     public Object getData() { ... }           // T → Object
         * }
         * 
         * class IntNode extends Node {
         *     public void setData(Integer data) { ... }  // Original method
         *     public Integer getData() { ... }           // Original method
         *     
         *     // Bridge methods (compiler-generated):
         *     public void setData(Object data) {         // Bridge!
         *         setData((Integer) data);
         *     }
         *     
         *     public Object getData() {                  // Bridge!
         *         return getData();  // Calls Integer version
         *     }
         * }
         * 
         * 
         * WHY NEEDED?
         * - After erasure, parent has setData(Object)
         * - Child has setData(Integer)
         * - Without bridge, no override!
         * - Bridge delegates to specific type method
         */
        
        Node<Integer> node = new IntNode(42);
        node.setData(100);  // Calls bridge → calls IntNode.setData(Integer)
        Integer value = node.getData();  // Calls bridge → calls IntNode.getData()
        
        System.out.println("Value: " + value);
    }
    
    /**
     * Bridge method visibility
     */
    public static void inspectBridgeMethods() {
        /**
         * REFLECTION SHOWS BRIDGE METHODS:
         */
        
        Class<?> clazz = IntNode.class;
        System.out.println("Methods in IntNode:");
        
        for (java.lang.reflect.Method method : clazz.getDeclaredMethods()) {
            System.out.println("  " + method.getName() + 
                " - bridge: " + method.isBridge() + 
                " - synthetic: " + method.isSynthetic());
        }
        
        /**
         * OUTPUT (typical):
         * Methods in IntNode:
         *   setData - bridge: false - synthetic: false   // Your method
         *   setData - bridge: true - synthetic: true     // Bridge method
         *   getData - bridge: false - synthetic: false   // Your method
         *   getData - bridge: true - synthetic: true     // Bridge method
         * 
         * SYNTHETIC METHODS:
         * - Generated by compiler
         * - Not present in source code
         * - Marked with ACC_SYNTHETIC flag
         * - Bridge methods are synthetic
         */
    }
    
    /**
     * Covariant return types with generics
     */
    static abstract class Animal {
        public abstract Animal reproduce();
    }
    
    static class Dog extends Animal {
        @Override
        public Dog reproduce() {  // Covariant return type
            return new Dog();
        }
    }
    
    public static void covariantReturnTypes() {
        /**
         * COVARIANT RETURN TYPES:
         * 
         * Subclass can override with more specific return type
         * 
         * class Animal {
         *     public Animal reproduce() { ... }
         * }
         * 
         * class Dog extends Animal {
         *     public Dog reproduce() { ... }  // More specific!
         * }
         * 
         * 
         * AFTER ERASURE + BRIDGE:
         * 
         * class Dog extends Animal {
         *     public Dog reproduce() { ... }      // Your method
         *     
         *     // Bridge method:
         *     public Animal reproduce() {         // Bridge!
         *         return reproduce();  // Calls Dog version
         *     }
         * }
         * 
         * Bridge maintains override contract
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Bridge Method Example ===");
        bridgeMethodExample();
        
        System.out.println("\n=== Inspect Bridge Methods ===");
        inspectBridgeMethods();
    }
}
```

---

## 5. Raw Types (Legacy Compatibility)

### Pre-Generics Code Compatibility

```java
/**
 * RAW TYPES
 * 
 * Using generic types without type parameters
 */

import java.util.*;

public class RawTypes {
    
    /**
     * What is a raw type?
     */
    public static void whatIsRawType() {
        /**
         * RAW TYPE:
         * 
         * Generic type used without type parameter
         * 
         * Generic type:  List<String>
         * Raw type:      List
         * 
         * Example:
         * List list = new ArrayList();  // Raw type
         * list.add("hello");
         * list.add(42);  // No type checking!
         * 
         * 
         * WHY THEY EXIST:
         * Backward compatibility with pre-Java 5 code
         * 
         * Pre-generics (Java 1.4):
         * List list = new ArrayList();
         * list.add("hello");
         * String s = (String) list.get(0);  // Manual cast
         * 
         * With generics (Java 5+):
         * List<String> list = new ArrayList<>();
         * list.add("hello");
         * String s = list.get(0);  // No cast!
         */
    }
    
    /**
     * Raw type dangers
     */
    public static void rawTypeDangers() {
        // Raw type - no type safety!
        List rawList = new ArrayList();
        rawList.add("hello");
        rawList.add(42);        // No compile error!
        rawList.add(new Date()); // No compile error!
        
        // Runtime error!
        try {
            String s = (String) rawList.get(1);  // ClassCastException
        } catch (ClassCastException e) {
            System.out.println("ClassCastException: " + e.getMessage());
        }
        
        /**
         * PROBLEM:
         * - No compile-time safety
         * - Errors only at runtime
         * - Hard to debug
         * - No IDE help
         * 
         * AVOID RAW TYPES!
         */
    }
    
    /**
     * Generic to raw assignment
     */
    public static void genericToRaw() {
        List<String> stringList = new ArrayList<>();
        stringList.add("hello");
        
        // Assign to raw type (allowed but warns)
        List rawList = stringList;  // Unchecked warning
        
        // Can add anything!
        rawList.add(42);  // No compile error!
        
        // Now stringList is corrupted!
        try {
            for (String s : stringList) {  // Iterate as String
                System.out.println(s);
            }
        } catch (ClassCastException e) {
            System.out.println("List corrupted: " + e.getMessage());
        }
        
        /**
         * OUTPUT:
         * hello
         * List corrupted: java.lang.Integer cannot be cast to java.lang.String
         * 
         * LESSON:
         * Raw types break type safety!
         * Heap pollution - generic collection contains wrong type
         */
    }
    
    /**
     * Raw to generic assignment
     */
    public static void rawToGeneric() {
        List rawList = new ArrayList();
        rawList.add("hello");
        rawList.add(42);  // Mixed types!
        
        // Assign to generic type
        List<String> stringList = rawList;  // Unchecked warning
        
        // Looks type-safe, but isn't!
        try {
            for (String s : stringList) {
                System.out.println(s);
            }
        } catch (ClassCastException e) {
            System.out.println("Runtime error: " + e.getMessage());
        }
        
        /**
         * UNCHECKED WARNING:
         * 
         * warning: [unchecked] unchecked conversion
         * List<String> stringList = rawList;
         *                           ^
         *   required: List<String>
         *   found:    List
         * 
         * Compiler warns but allows
         */
    }
    
    /**
     * Proper migration from raw types
     */
    public static void properMigration() {
        /**
         * LEGACY CODE:
         */
        List legacyList = new ArrayList();
        legacyList.add("hello");
        legacyList.add("world");
        
        /**
         * SAFE CONVERSION:
         */
        List<String> safeList = new ArrayList<>();
        for (Object obj : legacyList) {
            if (obj instanceof String) {
                safeList.add((String) obj);
            } else {
                System.out.println("Skipping non-String: " + obj);
            }
        }
        
        /**
         * OR USE GENERIC METHOD:
         */
        List<String> converted = convertToGeneric(legacyList, String.class);
        
        System.out.println("Converted: " + converted);
    }
    
    @SuppressWarnings("unchecked")
    private static <T> List<T> convertToGeneric(List rawList, Class<T> type) {
        List<T> result = new ArrayList<>();
        for (Object obj : rawList) {
            if (type.isInstance(obj)) {
                result.add((T) obj);  // Safe cast
            }
        }
        return result;
    }
    
    /**
     * When you might see raw types
     */
    public static void whenYouSeeRawTypes() {
        /**
         * LEGACY CODE:
         * 
         * Pre-Java 5 code still using raw types
         * 
         * Vector v = new Vector();
         * Hashtable h = new Hashtable();
         * 
         * 
         * REFLECTION:
         * 
         * Class<?> clazz = obj.getClass();
         * // Sometimes need raw types with reflection
         * 
         * 
         * INTEROPERABILITY:
         * 
         * Old libraries that haven't been updated
         * 
         * 
         * RECOMMENDATION:
         * - Never write new code with raw types
         * - Migrate legacy code gradually
         * - Suppress warnings only when safe
         * - Add @SuppressWarnings("unchecked") with comment
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Raw Type Dangers ===");
        rawTypeDangers();
        
        System.out.println("\n=== Generic to Raw ===");
        genericToRaw();
        
        System.out.println("\n=== Raw to Generic ===");
        rawToGeneric();
        
        System.out.println("\n=== Proper Migration ===");
        properMigration();
    }
}
```

---

## 6. Reification vs Erasure

### Runtime Type Information

```java
/**
 * REIFICATION VS ERASURE
 * 
 * Understanding what type information is available at runtime
 */

import java.util.*;
import java.lang.reflect.*;

public class ReificationVsErasure {
    
    /**
     * What is reification?
     */
    public static void whatIsReification() {
        /**
         * REIFICATION:
         * 
         * Type information available at runtime
         * 
         * REIFIED TYPES IN JAVA:
         * - Primitive types: int, double, boolean
         * - Non-generic classes: String, Integer
         * - Raw types: List, Map
         * - Arrays of reified types: String[], int[]
         * 
         * 
         * NON-REIFIED (ERASED) TYPES:
         * - Generic type parameters: T, E, K, V
         * - Parameterized types: List<String>, Map<K, V>
         * 
         * 
         * EXAMPLE:
         * 
         * int x;              // Reified - type known at runtime
         * String s;           // Reified - type known at runtime
         * List<String> list;  // NOT reified - List known, String erased
         */
    }
    
    /**
     * Arrays are reified
     */
    public static void arraysAreReified() {
        String[] stringArray = new String[10];
        Object[] objectArray = stringArray;
        
        try {
            objectArray[0] = "hello";  // OK
            objectArray[1] = 42;       // Runtime error!
        } catch (ArrayStoreException e) {
            System.out.println("ArrayStoreException: " + e.getMessage());
        }
        
        /**
         * OUTPUT:
         * ArrayStoreException: java.lang.Integer
         * 
         * ARRAYS KNOW THEIR TYPE:
         * - String[] knows it's an array of String
         * - Runtime check on every assignment
         * - Prevents type corruption
         * 
         * This is REIFICATION
         */
    }
    
    /**
     * Generics are NOT reified
     */
    public static void genericsNotReified() {
        List<String> stringList = new ArrayList<>();
        List<Object> objectList = (List<Object>) (List) stringList;  // Ugly but compiles
        
        // No runtime check!
        objectList.add(42);  // Compiles, no runtime error here
        
        // Error only when we use it
        try {
            String s = stringList.get(0);  // ClassCastException
        } catch (ClassCastException e) {
            System.out.println("ClassCastException: " + e.getMessage());
        }
        
        /**
         * GENERICS DON'T KNOW THEIR TYPE:
         * - List<String> becomes just List at runtime
         * - No runtime check on add()
         * - Error only when cast inserted by compiler
         * 
         * This is TYPE ERASURE
         */
    }
    
    /**
     * Generic arrays not allowed
     */
    public static void genericArraysNotAllowed() {
        /**
         * CANNOT CREATE GENERIC ARRAYS:
         * 
         * List<String>[] arrayOfLists = new List<String>[10];  // ERROR
         * 
         * T[] array = new T[10];  // ERROR
         * 
         * 
         * WHY NOT ALLOWED?
         * 
         * Suppose it was allowed:
         * 
         * List<String>[] stringLists = new List<String>[1];
         * Object[] objects = stringLists;  // Arrays are covariant
         * objects[0] = new ArrayList<Integer>();  // Would compile!
         * String s = stringLists[0].get(0);  // Runtime error!
         * 
         * Arrays are reified (know their type)
         * Generics are erased (don't know their type)
         * INCOMPATIBLE!
         * 
         * 
         * WORKAROUNDS:
         */
        
        // 1. Array of raw type
        @SuppressWarnings("unchecked")
        List<String>[] arrayOfLists = (List<String>[]) new List[10];
        
        // 2. Use List instead of array
        List<List<String>> listOfLists = new ArrayList<>();
        
        // 3. Use varargs (compiler handles it)
        printLists(
            Arrays.asList("a", "b"),
            Arrays.asList("c", "d")
        );
    }
    
    @SafeVarargs
    private static void printLists(List<String>... lists) {
        for (List<String> list : lists) {
            System.out.println(list);
        }
    }
    
    /**
     * instanceof with generics
     */
    public static void instanceofWithGenerics() {
        List<String> stringList = new ArrayList<>();
        
        // This works (checks raw type)
        if (stringList instanceof List) {
            System.out.println("Is a List");
        }
        
        // This works (ArrayList is reified)
        if (stringList instanceof ArrayList) {
            System.out.println("Is an ArrayList");
        }
        
        // This DOESN'T work (type parameter erased)
        // if (stringList instanceof List<String>) { }  // ERROR
        
        /**
         * INSTANCEOF RULES:
         * 
         * ✓ instanceof RawType
         * ✓ instanceof ConcreteClass
         * ✗ instanceof GenericType<T>
         * 
         * Why? Type parameters erased at runtime!
         */
    }
    
    /**
     * Class literals
     */
    public static void classLiterals() {
        // These work (reified types)
        Class<String> stringClass = String.class;
        Class<Integer> intClass = Integer.class;
        Class<List> listClass = List.class;
        
        // This DOESN'T work (type parameter)
        // Class<T> tClass = T.class;  // ERROR
        
        // This DOESN'T work (parameterized type)
        // Class<List<String>> listStringClass = List<String>.class;  // ERROR
        
        /**
         * CLASS LITERAL RULES:
         * 
         * ✓ String.class
         * ✓ int.class
         * ✓ List.class (raw type)
         * ✗ T.class (type parameter)
         * ✗ List<String>.class (parameterized)
         * 
         * Only reified types have .class
         */
    }
    
    /**
     * Type tokens (workaround for erasure)
     */
    static class TypeToken<T> {
        private final Class<T> type;
        
        public TypeToken(Class<T> type) {
            this.type = type;
        }
        
        public Class<T> getType() {
            return type;
        }
        
        public T create() throws Exception {
            return type.getDeclaredConstructor().newInstance();
        }
    }
    
    public static void typeTokens() throws Exception {
        // Pass type information explicitly
        TypeToken<String> stringToken = new TypeToken<>(String.class);
        TypeToken<ArrayList> listToken = new TypeToken<>(ArrayList.class);
        
        String s = stringToken.create();
        ArrayList list = listToken.create();
        
        System.out.println("Created String: " + s);
        System.out.println("Created ArrayList: " + list);
        
        /**
         * TYPE TOKENS:
         * 
         * Pass Class<T> to preserve type information
         * Common pattern in frameworks (Gson, Jackson)
         * 
         * Example:
         * List<User> users = gson.fromJson(json, 
         *     new TypeToken<List<User>>(){}.getType());
         */
    }
    
    /**
     * Reflection and generics
     */
    public static void reflectionAndGenerics() {
        List<String> list = new ArrayList<>();
        
        // Get actual class
        Class<?> clazz = list.getClass();
        System.out.println("Class: " + clazz);  // ArrayList
        
        // Get generic superclass
        Type genericSuper = clazz.getGenericSuperclass();
        System.out.println("Generic superclass: " + genericSuper);
        
        // Get type parameters
        TypeVariable<?>[] typeParams = ArrayList.class.getTypeParameters();
        System.out.println("Type parameters: " + Arrays.toString(typeParams));
        
        /**
         * OUTPUT:
         * Class: class java.util.ArrayList
         * Generic superclass: java.util.AbstractList<E>
         * Type parameters: [E]
         * 
         * SOME TYPE INFO AVAILABLE:
         * - Class structure knows about E
         * - But specific E=String is erased
         * - Can see "there's a type parameter E"
         * - Can't see "E is bound to String"
         */
    }
    
    public static void main(String[] args) throws Exception {
        System.out.println("=== Arrays Are Reified ===");
        arraysAreReified();
        
        System.out.println("\n=== Generics Not Reified ===");
        genericsNotReified();
        
        System.out.println("\n=== instanceof with Generics ===");
        instanceofWithGenerics();
        
        System.out.println("\n=== Type Tokens ===");
        typeTokens();
        
        System.out.println("\n=== Reflection and Generics ===");
        reflectionAndGenerics();
    }
}
```

---

## 7. Limitations Due to Erasure

### What You Cannot Do and Workarounds

```java
/**
 * ERASURE LIMITATIONS
 * 
 * Comprehensive list of what you cannot do and why
 */

import java.util.*;
import java.lang.reflect.*;

public class ErasureLimitations {
    
    /**
     * Cannot instantiate type parameters
     */
    static class Box<T> {
        // ERROR: Cannot instantiate
        // private T instance = new T();
        
        // Workaround 1: Pass factory
        private T instance1;
        
        public Box(Supplier<T> factory) {
            this.instance1 = factory.get();
        }
        
        // Workaround 2: Pass Class
        private T instance2;
        
        public Box(Class<T> type) throws Exception {
            this.instance2 = type.getDeclaredConstructor().newInstance();
        }
    }
    
    @FunctionalInterface
    interface Supplier<T> {
        T get();
    }
    
    public static void cannotInstantiate() throws Exception {
        /**
         * PROBLEM:
         * T erased to Object
         * new T() would be new Object() - wrong type!
         * 
         * WORKAROUNDS:
         */
        
        // 1. Factory method
        Box<String> box1 = new Box<>(String::new);
        
        // 2. Class token
        Box<String> box2 = new Box<>(String.class);
        
        System.out.println("Created instances successfully");
    }
    
    /**
     * Cannot create arrays of type parameters
     */
    static class GenericArray<T> {
        // ERROR: Cannot create array
        // private T[] array = new T[10];
        
        // Workaround 1: Object array with cast
        @SuppressWarnings("unchecked")
        private T[] array1 = (T[]) new Object[10];
        
        // Workaround 2: Array.newInstance with Class
        private T[] array2;
        
        @SuppressWarnings("unchecked")
        public GenericArray(Class<T> type, int size) {
            this.array2 = (T[]) Array.newInstance(type, size);
        }
        
        // Workaround 3: Use List instead
        private List<T> list = new ArrayList<>();
    }
    
    public static void cannotCreateArrays() {
        /**
         * PROBLEM:
         * Generic arrays would break type safety
         * (see reification section)
         * 
         * WORKAROUNDS:
         */
        
        // 1. Object array (loses runtime type)
        GenericArray<String> ga1 = new GenericArray<>(null, 0);
        
        // 2. Class token (preserves runtime type)
        GenericArray<String> ga2 = new GenericArray<>(String.class, 10);
        
        // 3. Use List (recommended)
        List<String> list = new ArrayList<>();
        
        System.out.println("Array workarounds demonstrated");
    }
    
    /**
     * Cannot use instanceof with type parameters
     */
    public static <T> boolean isInstance(Object obj) {
        // ERROR: Cannot use instanceof
        // if (obj instanceof T) { }
        
        // Workaround: Pass Class
        return isInstanceWorkaround(obj, Object.class);  // Need actual class
    }
    
    public static <T> boolean isInstanceWorkaround(Object obj, Class<T> type) {
        return type.isInstance(obj);
    }
    
    public static void cannotUseInstanceof() {
        /**
         * PROBLEM:
         * T erased at runtime
         * instanceof checks runtime type
         * 
         * WORKAROUND:
         * Pass Class<T> and use Class.isInstance()
         */
        
        Object obj = "hello";
        boolean isString = isInstanceWorkaround(obj, String.class);
        System.out.println("Is String: " + isString);
    }
    
    /**
     * Cannot use static fields with type parameters
     */
    static class StaticFieldError<T> {
        // ERROR: Non-static type parameter
        // private static T staticField;
        
        // OK: Instance field
        private T instanceField;
        
        // OK: Static field of concrete type
        private static String staticString;
    }
    
    public static void cannotUseStaticFields() {
        /**
         * PROBLEM:
         * Static fields shared across all instances
         * Different instances have different T
         * What would staticField's type be?
         * 
         * Example:
         * Box<String> stringBox;
         * Box<Integer> intBox;
         * 
         * Both share same static field - what type?
         * 
         * NO WORKAROUND:
         * This is a design limitation
         */
    }
    
    /**
     * Cannot catch type parameter exceptions
     */
    static class ExceptionError<T extends Exception> {
        public void method() {
            try {
                // Some code
            }
            // ERROR: Cannot catch type parameter
            // catch (T e) { }
        }
    }
    
    public static void cannotCatchTypeParameter() {
        /**
         * PROBLEM:
         * Exception handling needs runtime type
         * T erased at runtime
         * 
         * NO GOOD WORKAROUND:
         * Catch specific exceptions or Exception
         */
    }
    
    /**
     * Cannot overload with same erasure
     */
    static class OverloadError {
        // ERROR: Same erasure (both become List)
        // public void method(List<String> list) { }
        // public void method(List<Integer> list) { }
        
        // Workaround: Different names
        public void methodForStrings(List<String> list) { }
        public void methodForIntegers(List<Integer> list) { }
    }
    
    public static void cannotOverloadSameErasure() {
        /**
         * PROBLEM:
         * After erasure:
         * method(List<String>) → method(List)
         * method(List<Integer>) → method(List)
         * 
         * Same signature - clash!
         * 
         * WORKAROUND:
         * Use different method names
         */
    }
    
    /**
     * Cannot create instances of parameterized types
     */
    public static void cannotCreateParameterizedInstances() {
        /**
         * ERRORS:
         */
        
        // Cannot create
        // new ArrayList<T>();  // ERROR
        
        // Cannot create array
        // new ArrayList<String>[10];  // ERROR
        
        // Cannot use as class literal
        // Class<List<String>> c = List<String>.class;  // ERROR
        
        /**
         * WORKAROUNDS:
         */
        
        // Use raw type + cast
        @SuppressWarnings("unchecked")
        List<String>[] array = (List<String>[]) new ArrayList[10];
        
        // Use Class<?> or Class<?>
        Class<?> listClass = List.class;
        
        System.out.println("Parameterized type workarounds shown");
    }
    
    /**
     * Complete workaround: Generic array creation
     */
    static class SafeGenericArray<T> {
        private final Class<T> type;
        private final T[] array;
        
        @SuppressWarnings("unchecked")
        public SafeGenericArray(Class<T> type, int size) {
            this.type = type;
            this.array = (T[]) Array.newInstance(type, size);
        }
        
        public void set(int index, T value) {
            array[index] = value;
        }
        
        public T get(int index) {
            return array[index];
        }
        
        public int length() {
            return array.length;
        }
        
        // Type-safe because we enforce T at construction
        public T[] getArray() {
            return array;
        }
    }
    
    public static void safeGenericArrayExample() {
        SafeGenericArray<String> stringArray = 
            new SafeGenericArray<>(String.class, 10);
        
        stringArray.set(0, "hello");
        stringArray.set(1, "world");
        
        String value = stringArray.get(0);
        System.out.println("Safe generic array: " + value);
        
        // Get actual String[] (type-safe!)
        String[] actualArray = stringArray.getArray();
        System.out.println("Array length: " + actualArray.length);
    }
    
    /**
     * Summary of limitations
     */
    public static void limitationsSummary() {
        /**
         * CANNOT DO:
         * 
         * 1. new T()
         *    → Pass Class<T> or factory
         * 
         * 2. new T[10]
         *    → Array.newInstance(type, size)
         *    → Or use List<T>
         * 
         * 3. obj instanceof T
         *    → Pass Class<T>, use type.isInstance(obj)
         * 
         * 4. T.class
         *    → Pass Class<T> as parameter
         * 
         * 5. static T field
         *    → No workaround, design limitation
         * 
         * 6. catch (T e)
         *    → Catch specific exception types
         * 
         * 7. void method(List<String>) + void method(List<Integer>)
         *    → Use different method names
         * 
         * 8. new ArrayList<T>()
         *    → Possible, but T erased
         * 
         * 9. new List<String>[10]
         *    → Use List<List<String>> or raw type cast
         * 
         * 
         * ROOT CAUSE:
         * All due to type erasure!
         * Type parameters don't exist at runtime
         */
    }
    
    public static void main(String[] args) throws Exception {
        System.out.println("=== Cannot Instantiate ===");
        cannotInstantiate();
        
        System.out.println("\n=== Cannot Create Arrays ===");
        cannotCreateArrays();
        
        System.out.println("\n=== Cannot Use instanceof ===");
        cannotUseInstanceof();
        
        System.out.println("\n=== Safe Generic Array ===");
        safeGenericArrayExample();
    }
}
```

---

## Summary

### Quick Reference

**Generic Syntax:**

```java
// Generic class
class Box<T> {
    private T value;
    public void set(T value) { this.value = value; }
    public T get() { return value; }
}

// Multiple type parameters
class Pair<K, V> {
    private K key;
    private V value;
}

// Bounded type parameter
class NumberBox<T extends Number> {
    private T number;
}

// Generic method
public static <T> T getFirst(List<T> list) {
    return list.get(0);
}
```

**Type Erasure:**

```java
// Before erasure
class Box<T> {
    private T value;
    public T get() { return value; }
}

// After erasure
class Box {
    private Object value;  // T → Object
    public Object get() { return value; }
}

// Usage with casts
Box<String> box = new Box<>();
String s = box.get();  // Compiler inserts: (String)box.get()
```

**Limitations:**

```
✗ new T()              → Pass Class<T> or factory
✗ new T[10]            → Use List<T> or Array.newInstance()
✗ instanceof T         → Pass Class<T>
✗ T.class              → Pass Class<T> as parameter
✗ static T field       → Not possible
✗ catch (T e)          → Not possible
✗ List<String>[]       → Use List<List<String>>
```

### Key Takeaways

**1. Type erasure is fundamental:**

```
Compile time: Full type information, type checking
Runtime: Type parameters erased, only raw types remain
```

**2. Bridge methods maintain compatibility:**

```java
class Node<T> {
    public T getData() { ... }
}

class IntNode extends Node<Integer> {
    public Integer getData() { ... }     // Your method
    public Object getData() { ... }      // Bridge (synthetic)
}
```

**3. Arrays vs Generics:**

```
Arrays: Reified (runtime type checking)
Generics: Erased (compile-time only)
→ Cannot create generic arrays
```

**4. Raw types break safety:**

```java
List rawList = new ArrayList();  // NO TYPE CHECKING
rawList.add("hello");
rawList.add(42);  // Compiles! Runtime error later
```

**5. Workarounds exist:**

```java
// Pass type information
public <T> T create(Class<T> type) throws Exception {
    return type.getDeclaredConstructor().newInstance();
}

// Type tokens
new TypeToken<List<String>>() {}
```

---

