# Bounded Type Parameters and Wildcards

## Overview

Wildcards and bounded type parameters are essential for writing flexible, reusable generic code. This guide covers upper bounds, lower bounds, the critical PECS principle (Producer Extends Consumer Super), and real-world applications that will make you a generics expert.


---

## 1. Upper Bounds (extends)

### Restricting Type Parameters to Subtypes

```java
/**
 * UPPER BOUNDS
 * 
 * <T extends Type> - T must be Type or subtype
 * <? extends Type> - unknown subtype of Type
 */

import java.util.*;

public class UpperBounds {
    
    /**
     * Bounded type parameter vs bounded wildcard
     */
    public static void boundedTypeParameterVsWildcard() {
        /**
         * BOUNDED TYPE PARAMETER: <T extends Type>
         * 
         * Use when you need to:
         * - Refer to T multiple times
         * - Call methods on T
         * - Return T
         * 
         * Example:
         */
        class NumberProcessor<T extends Number> {
            private T number;
            
            public NumberProcessor(T number) {
                this.number = number;
            }
            
            public T getNumber() {
                return number;  // Can return T
            }
            
            public double doubleValue() {
                return number.doubleValue();  // Can call Number methods
            }
        }
        
        /**
         * BOUNDED WILDCARD: <? extends Type>
         * 
         * Use when you need to:
         * - Accept any subtype
         * - Only read from collection
         * - Don't care about specific type
         * 
         * Example:
         */
        class NumberUtil {
            public static double sum(List<? extends Number> numbers) {
                double total = 0;
                for (Number num : numbers) {  // Can read as Number
                    total += num.doubleValue();
                }
                return total;
            }
        }
        
        /**
         * USAGE:
         */
        List<Integer> integers = Arrays.asList(1, 2, 3);
        List<Double> doubles = Arrays.asList(1.5, 2.5, 3.5);
        
        double intSum = NumberUtil.sum(integers);    // Works!
        double doubleSum = NumberUtil.sum(doubles);  // Works!
        
        System.out.println("Integer sum: " + intSum);
        System.out.println("Double sum: " + doubleSum);
    }
    
    /**
     * Upper bound enables polymorphism
     */
    interface Shape {
        double area();
    }
    
    static class Circle implements Shape {
        private double radius;
        
        public Circle(double radius) {
            this.radius = radius;
        }
        
        @Override
        public double area() {
            return Math.PI * radius * radius;
        }
    }
    
    static class Rectangle implements Shape {
        private double width, height;
        
        public Rectangle(double width, double height) {
            this.width = width;
            this.height = height;
        }
        
        @Override
        public double area() {
            return width * height;
        }
    }
    
    public static double totalArea(List<? extends Shape> shapes) {
        double total = 0;
        for (Shape shape : shapes) {
            total += shape.area();
        }
        return total;
    }
    
    public static void upperBoundPolymorphism() {
        List<Circle> circles = Arrays.asList(
            new Circle(1.0),
            new Circle(2.0)
        );
        
        List<Rectangle> rectangles = Arrays.asList(
            new Rectangle(2.0, 3.0),
            new Rectangle(4.0, 5.0)
        );
        
        // Both work with <? extends Shape>
        double circleArea = totalArea(circles);
        double rectArea = totalArea(rectangles);
        
        System.out.println("Total circle area: " + circleArea);
        System.out.println("Total rectangle area: " + rectArea);
        
        /**
         * WITHOUT WILDCARD:
         * 
         * public static double totalArea(List<Shape> shapes)
         * 
         * Would NOT accept List<Circle> or List<Rectangle>
         * Why? List<Circle> is NOT a subtype of List<Shape>
         * 
         * WITH WILDCARD:
         * 
         * public static double totalArea(List<? extends Shape> shapes)
         * 
         * Accepts List<Circle>, List<Rectangle>, List<Shape>
         * Any list of Shape or subtype
         */
    }
    
    /**
     * Reading is safe, writing is not
     */
    public static void readingSafeWritingNot() {
        List<Integer> integers = new ArrayList<>(Arrays.asList(1, 2, 3));
        List<? extends Number> numbers = integers;
        
        // Reading is SAFE
        Number num = numbers.get(0);  // OK - guaranteed to be Number
        System.out.println("Read: " + num);
        
        // Writing is NOT SAFE
        // numbers.add(42);           // ERROR: Can't add Integer
        // numbers.add(3.14);         // ERROR: Can't add Double
        // numbers.add(new Object()); // ERROR: Can't add Object
        
        /**
         * WHY CAN'T WRITE?
         * 
         * List<? extends Number> numbers = integers;
         * 
         * Compiler knows: numbers is "some list of Number subtype"
         * But which subtype? Integer? Double? Long?
         * 
         * If we could add:
         * numbers.add(3.14);  // Add Double
         * 
         * Now integers contains a Double!
         * Integer i = integers.get(...);  // ClassCastException!
         * 
         * To prevent this, writing is FORBIDDEN
         * 
         * Exception: Can add null
         * numbers.add(null);  // OK - null is subtype of everything
         */
        
        numbers.add(null);  // Only null allowed
        System.out.println("After adding null: " + numbers);
    }
    
    /**
     * Upper bound with Comparable
     */
    public static <T extends Comparable<T>> T max(List<T> list) {
        if (list.isEmpty()) {
            throw new IllegalArgumentException("Empty list");
        }
        
        T max = list.get(0);
        for (T item : list) {
            if (item.compareTo(max) > 0) {
                max = item;
            }
        }
        return max;
    }
    
    public static void upperBoundComparable() {
        List<Integer> integers = Arrays.asList(5, 2, 8, 1, 9);
        List<String> strings = Arrays.asList("apple", "zebra", "banana");
        
        Integer maxInt = max(integers);
        String maxStr = max(strings);
        
        System.out.println("Max integer: " + maxInt);
        System.out.println("Max string: " + maxStr);
        
        /**
         * WHY <T extends Comparable<T>>?
         * 
         * Need to call compareTo() on T
         * T must implement Comparable<T>
         * 
         * Without bound:
         * public static <T> T max(List<T> list)
         * 
         * ERROR: Can't call compareTo() on arbitrary T
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Bounded Type Parameter vs Wildcard ===");
        boundedTypeParameterVsWildcard();
        
        System.out.println("\n=== Upper Bound Polymorphism ===");
        upperBoundPolymorphism();
        
        System.out.println("\n=== Reading Safe, Writing Not ===");
        readingSafeWritingNot();
        
        System.out.println("\n=== Upper Bound with Comparable ===");
        upperBoundComparable();
    }
}
```

---

## 2. Lower Bounds (super)

### Accepting Supertypes for Writing

```java
/**
 * LOWER BOUNDS
 * 
 * <? super Type> - unknown supertype of Type
 * Only available for wildcards, not type parameters!
 */

import java.util.*;

public class LowerBounds {
    
    /**
     * Lower bound basics
     */
    public static void lowerBoundBasics() {
        /**
         * LOWER BOUND: <? super Type>
         * 
         * Accepts Type or any supertype
         * 
         * Example:
         * List<? super Integer>
         * 
         * Accepts:
         * - List<Integer>    ✓ (Integer)
         * - List<Number>     ✓ (supertype)
         * - List<Object>     ✓ (supertype)
         * 
         * Does NOT accept:
         * - List<Double>     ✗ (not supertype)
         * - List<String>     ✗ (unrelated)
         */
    }
    
    /**
     * Writing is safe, reading is limited
     */
    public static void writingSafeReadingLimited() {
        List<Number> numbers = new ArrayList<>();
        List<? super Integer> target = numbers;
        
        // Writing is SAFE
        target.add(42);           // OK - Integer is subtype of ?
        target.add(100);          // OK
        
        // Reading gives Object
        Object obj = target.get(0);  // Can only read as Object
        System.out.println("Read as Object: " + obj);
        
        // Cannot read as specific type
        // Integer i = target.get(0);  // ERROR
        // Number n = target.get(0);   // ERROR
        
        /**
         * WHY CAN WRITE?
         * 
         * List<? super Integer> target = numbers;
         * 
         * Compiler knows: target is "some list of Integer supertype"
         * Could be List<Integer>, List<Number>, or List<Object>
         * 
         * Adding Integer is safe:
         * target.add(42);
         * 
         * Works for all possibilities:
         * - List<Integer>.add(42)  ✓
         * - List<Number>.add(42)   ✓ (Integer is Number)
         * - List<Object>.add(42)   ✓ (Integer is Object)
         * 
         * 
         * WHY CAN'T READ SPECIFIC TYPE?
         * 
         * target could be List<Object>
         * List<Object> can contain anything!
         * Object obj = target.get(0);  // Could be String, Date, etc.
         * 
         * Can't guarantee it's Integer or Number
         * So only Object is safe
         */
    }
    
    /**
     * Use case: Adding to collection
     */
    public static void addAll(List<? super Integer> dest, List<Integer> src) {
        for (Integer i : src) {
            dest.add(i);  // Safe - can add Integer to ? super Integer
        }
    }
    
    public static void lowerBoundUseCase() {
        List<Integer> source = Arrays.asList(1, 2, 3);
        
        // Add to List<Integer>
        List<Integer> intList = new ArrayList<>();
        addAll(intList, source);
        System.out.println("Integer list: " + intList);
        
        // Add to List<Number>
        List<Number> numList = new ArrayList<>();
        addAll(numList, source);
        System.out.println("Number list: " + numList);
        
        // Add to List<Object>
        List<Object> objList = new ArrayList<>();
        addAll(objList, source);
        System.out.println("Object list: " + objList);
        
        /**
         * WITHOUT LOWER BOUND:
         * 
         * public static void addAll(List<Integer> dest, List<Integer> src)
         * 
         * Only accepts List<Integer>
         * Can't add to List<Number> or List<Object>
         * 
         * WITH LOWER BOUND:
         * 
         * public static void addAll(List<? super Integer> dest, ...)
         * 
         * Accepts List<Integer>, List<Number>, List<Object>
         * Maximum flexibility!
         */
    }
    
    /**
     * Comparator example
     */
    public static void sort(List<Integer> list, 
                           Comparator<? super Integer> comparator) {
        // Collections.sort implementation concept
        list.sort(comparator);
    }
    
    public static void lowerBoundComparator() {
        List<Integer> numbers = Arrays.asList(5, 2, 8, 1, 9);
        
        // Comparator<Integer>
        Comparator<Integer> intComp = Integer::compare;
        sort(numbers, intComp);
        System.out.println("Sorted with Integer comparator: " + numbers);
        
        // Comparator<Number> - also works!
        Comparator<Number> numComp = (n1, n2) -> 
            Double.compare(n1.doubleValue(), n2.doubleValue());
        sort(numbers, numComp);
        System.out.println("Sorted with Number comparator: " + numbers);
        
        // Comparator<Object> - also works!
        Comparator<Object> objComp = (o1, o2) -> 
            o1.toString().compareTo(o2.toString());
        sort(numbers, objComp);
        System.out.println("Sorted with Object comparator: " + numbers);
        
        /**
         * WHY <? super Integer>?
         * 
         * Comparator<Number> can compare any Number
         * Including Integer
         * So it's valid for List<Integer>
         * 
         * Same for Comparator<Object>
         * 
         * Without lower bound:
         * void sort(List<Integer> list, Comparator<Integer> comparator)
         * 
         * Only accepts Comparator<Integer>
         * Can't use more general comparators
         */
    }
    
    /**
     * Why no lower bound for type parameters?
     */
    public static void noLowerBoundForTypeParameters() {
        /**
         * ILLEGAL:
         * 
         * class Box<T super Integer> { }  // ERROR
         * 
         * public <T super Integer> void method(T t) { }  // ERROR
         * 
         * 
         * WHY NOT ALLOWED?
         * 
         * Lower bounds only make sense for wildcards
         * 
         * Type parameter: Need specific type T
         * - Create instances
         * - Return values
         * - Store in fields
         * 
         * Lower bound: Unknown supertype
         * - Can't instantiate unknown type
         * - Can't return unknown type
         * - Can't store unknown type
         * 
         * 
         * USE WILDCARD INSTEAD:
         * 
         * public void method(List<? super Integer> list) { }
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Writing Safe, Reading Limited ===");
        writingSafeReadingLimited();
        
        System.out.println("\n=== Lower Bound Use Case ===");
        lowerBoundUseCase();
        
        System.out.println("\n=== Lower Bound with Comparator ===");
        lowerBoundComparator();
    }
}
```

---

## 3. Unbounded Wildcards (?)

### Maximum Flexibility with Unknown Type

```java
/**
 * UNBOUNDED WILDCARDS
 * 
 * <?> - completely unknown type
 */

import java.util.*;

public class UnboundedWildcards {
    
    /**
     * When to use unbounded wildcard
     */
    public static void whenToUseUnbounded() {
        /**
         * USE <?> WHEN:
         * 
         * 1. Don't care about type
         * 2. Only use Object methods
         * 3. Only read container metadata (size, isEmpty)
         * 
         * EQUIVALENT:
         * List<?> is roughly equivalent to List<? extends Object>
         * But clearer intent: "I don't care about type"
         */
    }
    
    /**
     * Unbounded wildcard examples
     */
    public static void printSize(List<?> list) {
        System.out.println("Size: " + list.size());
        // Don't care what's in the list
    }
    
    public static void printList(List<?> list) {
        for (Object obj : list) {  // Can read as Object
            System.out.println(obj);
        }
    }
    
    public static boolean isEmpty(Collection<?> collection) {
        return collection.isEmpty();
    }
    
    public static void unboundedExamples() {
        List<String> strings = Arrays.asList("a", "b", "c");
        List<Integer> integers = Arrays.asList(1, 2, 3);
        
        printSize(strings);   // Works
        printSize(integers);  // Works
        
        System.out.println("String list:");
        printList(strings);
        
        System.out.println("Integer list:");
        printList(integers);
        
        System.out.println("Is empty: " + isEmpty(strings));
    }
    
    /**
     * Unbounded wildcard limitations
     */
    public static void unboundedLimitations() {
        List<?> unknownList = new ArrayList<String>();
        unknownList.add("hello");  // Compiles with warning
        
        // Cannot add anything (except null)
        // unknownList.add("hello");  // ERROR
        // unknownList.add(42);       // ERROR
        // unknownList.add(new Object());  // ERROR
        
        unknownList.add(null);  // Only null allowed
        
        // Can only read as Object
        Object obj = unknownList.get(0);
        
        /**
         * WHY CAN'T ADD?
         * 
         * List<?> unknownList;
         * 
         * Could be List<String>, List<Integer>, or any type
         * Don't know what to add safely
         * 
         * What if it's List<String>?
         * unknownList.add(42);  // Would corrupt it!
         * 
         * So nothing allowed (except null)
         */
    }
    
    /**
     * Unbounded vs Object
     */
    public static void unboundedVsObject() {
        /**
         * List<?> vs List<Object>
         * 
         * NOT THE SAME!
         * 
         * List<?>:
         * - Unknown type
         * - List of something, don't know what
         * - Can read as Object
         * - Can't add anything
         * 
         * List<Object>:
         * - Specific type: Object
         * - List that explicitly holds Object
         * - Can read as Object
         * - Can add any Object
         */
        
        List<String> strings = Arrays.asList("a", "b");
        
        // Works - List<String> is List<?>
        List<?> unknown = strings;  // OK
        
        // Doesn't work - List<String> is NOT List<Object>
        // List<Object> objects = strings;  // ERROR
        
        // Different semantics
        List<Object> objectList = new ArrayList<>();
        objectList.add("string");
        objectList.add(42);
        objectList.add(new Date());  // Can add anything
        
        List<?> unknownList = objectList;
        // unknownList.add("string");  // Can't add
    }
    
    /**
     * Capture conversion
     */
    public static void reverse(List<?> list) {
        reverseHelper(list);  // Capture conversion
    }
    
    private static <T> void reverseHelper(List<T> list) {
        // Now we have a type parameter T
        // Can use it for operations
        int size = list.size();
        for (int i = 0; i < size / 2; i++) {
            T temp = list.get(i);
            list.set(i, list.get(size - 1 - i));
            list.set(size - 1 - i, temp);
        }
    }
    
    public static void captureConversion() {
        List<String> strings = new ArrayList<>(Arrays.asList("a", "b", "c"));
        
        System.out.println("Before: " + strings);
        reverse(strings);
        System.out.println("After: " + strings);
        
        /**
         * CAPTURE CONVERSION:
         * 
         * reverse(List<?> list) accepts any list
         * Delegates to reverseHelper(List<T> list)
         * 
         * Compiler captures wildcard as type parameter T
         * Now can use T for operations
         * 
         * PATTERN:
         * Public API: Use wildcard for flexibility
         * Private helper: Use type parameter for operations
         */
    }
    
    /**
     * Multiple wildcards
     */
    public static void copy(List<?> dest, List<?> src) {
        // ERROR: Can't implement this way!
        // dest and src have unrelated types
        
        // Need to use bounded wildcards
        // See PECS section
    }
    
    public static void main(String[] args) {
        System.out.println("=== Unbounded Examples ===");
        unboundedExamples();
        
        System.out.println("\n=== Capture Conversion ===");
        captureConversion();
    }
}
```

---

## 4. PECS (Producer Extends Consumer Super)

### The Golden Rule of Wildcards

```java
/**
 * PECS PRINCIPLE
 * 
 * Producer Extends, Consumer Super
 * 
 * The most important rule for wildcards!
 */

import java.util.*;

public class PECSPrinciple {
    
    /**
     * What is PECS?
     */
    public static void whatIsPECS() {
        /**
         * PECS: Producer Extends, Consumer Super
         * 
         * PRODUCER (you read FROM it):
         * Use <? extends T>
         * - Produces T values
         * - You read from collection
         * - Can't add (except null)
         * 
         * CONSUMER (you write TO it):
         * Use <? super T>
         * - Consumes T values
         * - You add to collection
         * - Reading gives Object
         * 
         * MNEMONIC:
         * PECS - Producer Extends Consumer Super
         * 
         * GET = Producer = Extends
         * PUT = Consumer = Super
         */
    }
    
    /**
     * PECS example: copy method
     */
    public static <T> void copy(
            List<? super T> dest,      // Consumer - writing to it
            List<? extends T> src) {   // Producer - reading from it
        
        for (T item : src) {      // Read from producer
            dest.add(item);       // Write to consumer
        }
    }
    
    public static void pecsExample() {
        List<Integer> integers = Arrays.asList(1, 2, 3);
        List<Number> numbers = new ArrayList<>();
        List<Object> objects = new ArrayList<>();
        
        // Copy Integer to Number
        copy(numbers, integers);
        System.out.println("Numbers: " + numbers);
        
        // Copy Integer to Object
        copy(objects, integers);
        System.out.println("Objects: " + objects);
        
        /**
         * WHY IT WORKS:
         * 
         * src = List<? extends T> = List<Integer>
         * - Producer: Read Integer as T
         * - T = Integer
         * 
         * dest = List<? super T> = List<Number>
         * - Consumer: Write Integer (T) to Number list
         * - Works: Integer is Number
         * 
         * 
         * WITHOUT PECS:
         * 
         * public static void copy(List<T> dest, List<T> src)
         * 
         * Both must be same type!
         * Can't copy List<Integer> to List<Number>
         */
    }
    
    /**
     * Real-world: Collections.addAll
     */
    public static <T> boolean addAll(
            Collection<? super T> dest,      // Consumer
            Collection<? extends T> src) {   // Producer
        
        boolean modified = false;
        for (T item : src) {
            if (dest.add(item)) {
                modified = true;
            }
        }
        return modified;
    }
    
    public static void collectionsAddAll() {
        List<Integer> integers = Arrays.asList(1, 2, 3);
        List<Double> doubles = Arrays.asList(1.5, 2.5);
        
        // Add to List<Number>
        List<Number> numbers = new ArrayList<>();
        addAll(numbers, integers);  // Integer extends Number
        addAll(numbers, doubles);   // Double extends Number
        
        System.out.println("Combined: " + numbers);
        
        /**
         * ACTUAL JDK METHOD:
         * 
         * public static <T> boolean addAll(
         *     Collection<? super T> c,
         *     Collection<? extends T> elements)
         * 
         * Exact same signature!
         */
    }
    
    /**
     * Real-world: Collections.max
     */
    public static <T extends Comparable<? super T>> T max(
            Collection<? extends T> coll) {  // Producer
        
        if (coll.isEmpty()) {
            throw new NoSuchElementException();
        }
        
        Iterator<? extends T> it = coll.iterator();
        T max = it.next();
        
        while (it.hasNext()) {
            T item = it.next();
            if (item.compareTo(max) > 0) {
                max = item;
            }
        }
        
        return max;
    }
    
    public static void collectionsMax() {
        /**
         * SIGNATURE BREAKDOWN:
         * 
         * <T extends Comparable<? super T>>
         *                     ^^^^^^^^^^^^^^
         *                     T can compare with supertype
         * 
         * Collection<? extends T> coll
         *            ^^^^^^^^^^^
         *            Collection of T or subtype
         * 
         * 
         * WHY <? super T> in Comparable?
         * 
         * Consider:
         * class Fruit implements Comparable<Fruit> { }
         * class Apple extends Fruit { }
         * 
         * Apple doesn't implement Comparable<Apple>
         * It inherits Comparable<Fruit>
         * 
         * So Apple is Comparable<Fruit> (supertype)
         * Need <? super Apple> to accept this
         */
        
        List<Integer> numbers = Arrays.asList(5, 2, 8, 1, 9);
        Integer max = max(numbers);
        System.out.println("Max: " + max);
    }
    
    /**
     * PECS decision tree
     */
    public static void pecsDecisionTree() {
        /**
         * DECISION TREE:
         * 
         * Method parameter is a collection/container
         *   ↓
         * Do you ONLY READ from it?
         *   YES → Use <? extends T>
         *   Example: sum(List<? extends Number> numbers)
         *   ↓
         * Do you ONLY WRITE to it?
         *   YES → Use <? super T>
         *   Example: addAll(List<? super Integer> dest, ...)
         *   ↓
         * Do you BOTH read AND write?
         *   YES → Use <T> (no wildcard)
         *   Example: sort(List<T> list)
         *   ↓
         * Do you only use container methods (size, isEmpty)?
         *   YES → Use <?> (unbounded)
         *   Example: printSize(List<?> list)
         */
    }
    
    /**
     * Common mistakes
     */
    public static void commonMistakes() {
        /**
         * MISTAKE 1: Wrong wildcard direction
         */
        
        // BAD: Reversed
        // public static void addAll(
        //     List<? extends Integer> dest,  // Can't add!
        //     List<? super Integer> src)     // Can't read specific type!
        
        // GOOD: Correct PECS
        // public static void addAll(
        //     List<? super Integer> dest,    // Consumer
        //     List<? extends Integer> src)   // Producer
        
        /**
         * MISTAKE 2: Overusing wildcards
         */
        
        // BAD: Wildcard in return type
        // public static List<? extends Number> getNumbers() { }
        // Caller can't do anything with it!
        
        // GOOD: Concrete type in return
        // public static List<Number> getNumbers() { }
        
        /**
         * MISTAKE 3: Wildcard when not needed
         */
        
        // BAD: Read and write
        // public static void sort(List<? extends Comparable<?>> list)
        // Can't modify list!
        
        // GOOD: Type parameter
        // public static <T extends Comparable<T>> void sort(List<T> list)
    }
    
    public static void main(String[] args) {
        System.out.println("=== PECS Example ===");
        pecsExample();
        
        System.out.println("\n=== Collections.addAll ===");
        collectionsAddAll();
        
        System.out.println("\n=== Collections.max ===");
        collectionsMax();
    }
}
```

---

## 5. Multiple Bounds

### Combining Type Constraints

```java
/**
 * MULTIPLE BOUNDS
 * 
 * <T extends Class & Interface1 & Interface2>
 */

import java.io.Serializable;
import java.util.*;

public class MultipleBounds {
    
    /**
     * Multiple interface bounds
     */
    interface Drawable {
        void draw();
    }
    
    interface Movable {
        void move(int x, int y);
    }
    
    static class GameObject<T extends Drawable & Movable> {
        private T object;
        
        public GameObject(T object) {
            this.object = object;
        }
        
        public void render() {
            object.draw();      // Can call Drawable methods
            object.move(10, 20); // Can call Movable methods
        }
    }
    
    static class Player implements Drawable, Movable {
        @Override
        public void draw() {
            System.out.println("Drawing player");
        }
        
        @Override
        public void move(int x, int y) {
            System.out.println("Moving player to (" + x + ", " + y + ")");
        }
    }
    
    public static void multipleInterfaceBounds() {
        Player player = new Player();
        GameObject<Player> gameObject = new GameObject<>(player);
        
        gameObject.render();
        
        /**
         * T MUST IMPLEMENT ALL BOUNDS:
         * Player implements Drawable ✓
         * Player implements Movable ✓
         * 
         * Can call methods from both interfaces
         */
    }
    
    /**
     * Class and interface bounds
     */
    static abstract class Animal {
        abstract String getName();
    }
    
    static class Dog extends Animal implements Comparable<Dog>, Serializable {
        private String name;
        
        Dog(String name) {
            this.name = name;
        }
        
        @Override
        String getName() {
            return name;
        }
        
        @Override
        public int compareTo(Dog other) {
            return this.name.compareTo(other.name);
        }
    }
    
    public static <T extends Animal & Comparable<T> & Serializable> 
    void processAnimal(T animal) {
        // Can use Animal methods
        String name = animal.getName();
        
        // Can compare
        // animal.compareTo(another);
        
        // Can serialize
        // serialize(animal);
        
        System.out.println("Processing: " + name);
    }
    
    public static void classAndInterfaceBounds() {
        Dog dog = new Dog("Rex");
        processAnimal(dog);
        
        /**
         * RULES:
         * 
         * 1. Class must be first (if present)
         *    <T extends Animal & Comparable<T>>  ✓
         *    <T extends Comparable<T> & Animal>  ✗ ERROR
         * 
         * 2. Can have at most one class
         *    <T extends Animal & Dog>  ✗ ERROR (two classes)
         * 
         * 3. Can have multiple interfaces
         *    <T extends Class & I1 & I2 & I3>  ✓
         * 
         * 4. Order: Class & Interface1 & Interface2 & ...
         */
    }
    
    /**
     * Multiple bounds with wildcards
     */
    public static void processComparableAnimals(
            List<? extends Animal & Comparable<?>> animals) {
        
        for (Animal animal : animals) {
            System.out.println(animal.getName());
        }
        
        // Can't sort easily because Comparable<?> not specific enough
        // Better approach: use type parameter
    }
    
    public static <T extends Animal & Comparable<? super T>> 
    void sortAnimals(List<T> animals) {
        animals.sort(Comparator.naturalOrder());
    }
    
    public static void multipleBoundsWithWildcards() {
        /**
         * WILDCARD WITH BOUNDS:
         * 
         * <? extends Type1 & Type2>
         * 
         * Valid but rarely used
         * Usually better to use type parameter
         * 
         * 
         * TYPE PARAMETER PREFERRED:
         * 
         * <T extends Type1 & Type2>
         * 
         * More flexible and useful
         */
    }
    
    /**
     * Real-world: Cloneable and Serializable
     */
    public static <T extends Cloneable & Serializable> 
    T cloneAndSerialize(T object) throws CloneNotSupportedException {
        // Can clone (Cloneable marker)
        @SuppressWarnings("unchecked")
        T cloned = (T) ((Object) object).getClass()
            .getMethod("clone")
            .invoke(object);
        
        // Can serialize (Serializable marker)
        // ... serialization logic ...
        
        return cloned;
    }
    
    public static void main(String[] args) {
        System.out.println("=== Multiple Interface Bounds ===");
        multipleInterfaceBounds();
        
        System.out.println("\n=== Class and Interface Bounds ===");
        classAndInterfaceBounds();
    }
}
```

---

## 6. Generic Methods vs Generic Classes

### When to Use Each

```java
/**
 * GENERIC METHODS VS GENERIC CLASSES
 * 
 * Choosing the right approach
 */

import java.util.*;

public class MethodsVsClasses {
    
    /**
     * Generic class: Type applies to entire class
     */
    static class Box<T> {
        private T value;
        
        public Box(T value) {
            this.value = value;
        }
        
        public T get() {
            return value;
        }
        
        public void set(T value) {
            this.value = value;
        }
        
        // Instance method uses class type parameter
        public boolean isSameType(Box<T> other) {
            return true;  // Same T
        }
    }
    
    /**
     * Generic method: Type applies to single method
     */
    static class Util {
        // Static generic method
        public static <T> T getFirst(List<T> list) {
            return list.isEmpty() ? null : list.get(0);
        }
        
        // Generic method with different type than class
        public static <T> List<T> asList(T... elements) {
            return Arrays.asList(elements);
        }
    }
    
    public static void whenToUseEach() {
        /**
         * USE GENERIC CLASS when:
         * 
         * - Type applies to multiple methods
         * - Store values of generic type
         * - Class represents container/wrapper
         * 
         * Examples:
         * - List<E>
         * - Map<K, V>
         * - Optional<T>
         * - Box<T>
         */
        
        Box<String> stringBox = new Box<>("hello");
        String value = stringBox.get();  // T = String for whole class
        
        /**
         * USE GENERIC METHOD when:
         * 
         * - Type only needed for one method
         * - Static utility method
         * - Type independent of class
         * 
         * Examples:
         * - Collections.sort()
         * - Arrays.asList()
         * - Stream.of()
         */
        
        List<Integer> numbers = Util.asList(1, 2, 3);
        Integer first = Util.getFirst(numbers);
    }
    
    /**
     * Generic method in generic class
     */
    static class Container<T> {
        private T value;
        
        public Container(T value) {
            this.value = value;
        }
        
        // Uses class type parameter T
        public T getValue() {
            return value;
        }
        
        // New type parameter U (independent of T)
        public <U> U transform(Function<T, U> transformer) {
            return transformer.apply(value);
        }
        
        // Multiple type parameters
        public <K, V> Map<K, V> createMap(K key, Function<T, V> valueMapper) {
            Map<K, V> map = new HashMap<>();
            map.put(key, valueMapper.apply(value));
            return map;
        }
    }
    
    @FunctionalInterface
    interface Function<T, R> {
        R apply(T t);
    }
    
    public static void genericMethodInGenericClass() {
        Container<String> container = new Container<>("hello");
        
        // T = String (from class)
        String value = container.getValue();
        
        // U = Integer (from method)
        Integer length = container.transform(String::length);
        
        System.out.println("Value: " + value);
        System.out.println("Length: " + length);
        
        /**
         * METHOD TYPE PARAMETER INDEPENDENT OF CLASS:
         * 
         * Container<String>
         * - T = String
         * 
         * transform(Function<T, U>)
         * - T = String (from class)
         * - U = Integer (from method call)
         * 
         * Two different type parameters!
         */
    }
    
    /**
     * Type parameter scope
     */
    public static void typeParameterScope() {
        /**
         * CLASS TYPE PARAMETER:
         * 
         * class Box<T> {
         *     private T value;  // T from class
         *     
         *     public T get() { return value; }  // T from class
         * }
         * 
         * Scope: Entire class
         * All instance members can use T
         * 
         * 
         * METHOD TYPE PARAMETER:
         * 
         * public <T> T getFirst(List<T> list) {
         *     return list.get(0);  // T from method
         * }
         * 
         * Scope: Just this method
         * Independent of any class type parameter
         * 
         * 
         * SHADOWING:
         * 
         * class Box<T> {
         *     public <T> void method(T param) {  // Shadows class T!
         *         // T here refers to method T, not class T
         *     }
         * }
         * 
         * AVOID: Don't reuse same name
         * Use different names: <U>, <R>, etc.
         */
    }
    
    /**
     * Static methods cannot use class type parameter
     */
    static class StaticExample<T> {
        // ERROR: Non-static type parameter in static context
        // public static T createDefault() {  // ERROR
        //     return null;
        // }
        
        // CORRECT: Static method with own type parameter
        public static <U> U createDefault() {
            return null;
        }
        
        // CORRECT: Instance method can use T
        public T getInstance() {
            return null;
        }
    }
    
    public static void staticMethodRestriction() {
        /**
         * WHY STATIC CAN'T USE CLASS TYPE PARAMETER?
         * 
         * Static methods belong to class, not instance
         * Class type parameter is per-instance
         * 
         * Example:
         * Box<String> stringBox = new Box<>();
         * Box<Integer> intBox = new Box<>();
         * 
         * Both share same static methods
         * What would T be?
         * 
         * SOLUTION:
         * Static methods must have own type parameters
         */
    }
    
    /**
     * When wildcards vs type parameters
     */
    public static void wildcardsVsTypeParameters() {
        /**
         * USE TYPE PARAMETER when:
         * 
         * 1. Need to refer to type multiple times
         *    <T> void copy(List<T> dest, List<T> src)
         *    ↑ Both lists same type
         * 
         * 2. Need to return the type
         *    <T> T getFirst(List<T> list)
         *    ↑ Return value is T
         * 
         * 3. Need relationship between parameters
         *    <T extends Comparable<T>> T max(T a, T b)
         *    ↑ Both must be comparable to each other
         * 
         * 
         * USE WILDCARD when:
         * 
         * 1. Type mentioned only once
         *    void print(List<?> list)
         *    ↑ Don't need type name
         * 
         * 2. Only reading (producer)
         *    double sum(List<? extends Number> numbers)
         *    ↑ Read any Number subtype
         * 
         * 3. Only writing (consumer)
         *    void addAll(List<? super Integer> dest, ...)
         *    ↑ Write to Integer supertype
         * 
         * 
         * GUIDELINE:
         * Prefer wildcards for simplicity
         * Use type parameters when you need to name the type
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Generic Method in Generic Class ===");
        genericMethodInGenericClass();
    }
}
```

---

## 7. Real-World Examples

### Practical Applications

```java
/**
 * REAL-WORLD EXAMPLES
 * 
 * Practical uses of bounded wildcards
 */

import java.util.*;
import java.util.function.*;

public class RealWorldExamples {
    
    /**
     * Example 1: Data processing pipeline
     */
    interface Processor<T, R> {
        R process(T input);
    }
    
    static class Pipeline<T> {
        private List<T> data;
        
        public Pipeline(List<? extends T> data) {  // Producer extends
            this.data = new ArrayList<>(data);
        }
        
        public <R> Pipeline<R> map(Processor<? super T, ? extends R> processor) {
            List<R> results = new ArrayList<>();
            for (T item : data) {
                results.add(processor.process(item));
            }
            return new Pipeline<>(results);
        }
        
        public void forEach(Consumer<? super T> action) {  // Consumer super
            for (T item : data) {
                action.accept(item);
            }
        }
        
        public List<T> collect() {
            return new ArrayList<>(data);
        }
    }
    
    @FunctionalInterface
    interface Consumer<T> {
        void accept(T t);
    }
    
    public static void dataPipeline() {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        
        Pipeline<Integer> pipeline = new Pipeline<>(numbers);
        
        // Map to strings
        Pipeline<String> strings = pipeline.map(
            new Processor<Integer, String>() {
                @Override
                public String process(Integer input) {
                    return "Number: " + input;
                }
            }
        );
        
        // Print each
        strings.forEach(System.out::println);
        
        /**
         * PECS IN ACTION:
         * 
         * Pipeline<Integer>
         * map(Processor<? super Integer, ? extends String>)
         * 
         * Accepts:
         * - Processor<Integer, String>
         * - Processor<Number, String>
         * - Processor<Object, String>
         * 
         * Returns Pipeline<String>
         */
    }
    
    /**
     * Example 2: Repository pattern
     */
    interface Entity {
        Long getId();
    }
    
    static class User implements Entity {
        private Long id;
        private String name;
        
        public User(Long id, String name) {
            this.id = id;
            this.name = name;
        }
        
        @Override
        public Long getId() {
            return id;
        }
        
        public String getName() {
            return name;
        }
    }
    
    static class Repository<T extends Entity> {
        private Map<Long, T> storage = new HashMap<>();
        
        public void save(T entity) {
            storage.put(entity.getId(), entity);
        }
        
        public T findById(Long id) {
            return storage.get(id);
        }
        
        public List<T> findAll() {
            return new ArrayList<>(storage.values());
        }
        
        // Accept any subtype of T
        public void saveAll(Collection<? extends T> entities) {  // Producer
            for (T entity : entities) {
                save(entity);
            }
        }
        
        // Copy to any supertype collection
        public void copyTo(Collection<? super T> dest) {  // Consumer
            dest.addAll(storage.values());
        }
    }
    
    public static void repositoryPattern() {
        Repository<User> userRepo = new Repository<>();
        
        User user1 = new User(1L, "Alice");
        User user2 = new User(2L, "Bob");
        
        userRepo.save(user1);
        userRepo.save(user2);
        
        List<User> allUsers = userRepo.findAll();
        System.out.println("Users: " + allUsers.size());
        
        // Copy to Entity collection (supertype)
        List<Entity> entities = new ArrayList<>();
        userRepo.copyTo(entities);
        System.out.println("Entities: " + entities.size());
    }
    
    /**
     * Example 3: Builder pattern with generics
     */
    static class QueryBuilder<T> {
        private StringBuilder query = new StringBuilder();
        
        public QueryBuilder<T> select(String... fields) {
            query.append("SELECT ").append(String.join(", ", fields));
            return this;
        }
        
        public QueryBuilder<T> from(Class<T> entityClass) {
            query.append(" FROM ").append(entityClass.getSimpleName());
            return this;
        }
        
        public QueryBuilder<T> where(String condition) {
            query.append(" WHERE ").append(condition);
            return this;
        }
        
        public String build() {
            return query.toString();
        }
        
        // Type-safe result processing
        public <R> R execute(ResultProcessor<? super T, R> processor) {
            String sql = build();
            // Execute query and process results
            return processor.process(sql);
        }
    }
    
    @FunctionalInterface
    interface ResultProcessor<T, R> {
        R process(String query);
    }
    
    public static void builderPattern() {
        String query = new QueryBuilder<User>()
            .select("id", "name")
            .from(User.class)
            .where("age > 18")
            .build();
        
        System.out.println("Query: " + query);
    }
    
    /**
     * Example 4: Event handling
     */
    interface Event {
        long getTimestamp();
    }
    
    static class UserEvent implements Event {
        private long timestamp;
        private String action;
        
        public UserEvent(String action) {
            this.timestamp = System.currentTimeMillis();
            this.action = action;
        }
        
        @Override
        public long getTimestamp() {
            return timestamp;
        }
        
        public String getAction() {
            return action;
        }
    }
    
    interface EventHandler<E extends Event> {
        void handle(E event);
    }
    
    static class EventBus {
        private Map<Class<?>, List<EventHandler<?>>> handlers = new HashMap<>();
        
        // Register handler for event type or supertype
        public <E extends Event> void register(
                Class<E> eventType,
                EventHandler<? super E> handler) {  // Consumer super
            
            handlers.computeIfAbsent(eventType, k -> new ArrayList<>())
                   .add(handler);
        }
        
        // Publish event
        @SuppressWarnings("unchecked")
        public <E extends Event> void publish(E event) {
            Class<?> eventClass = event.getClass();
            List<EventHandler<?>> eventHandlers = handlers.get(eventClass);
            
            if (eventHandlers != null) {
                for (EventHandler<?> handler : eventHandlers) {
                    ((EventHandler<E>) handler).handle(event);
                }
            }
        }
    }
    
    public static void eventHandling() {
        EventBus eventBus = new EventBus();
        
        // Register handler for UserEvent
        eventBus.register(UserEvent.class, event -> {
            System.out.println("User action: " + event.getAction());
        });
        
        // Register general Event handler (supertype)
        eventBus.register(UserEvent.class, 
            (EventHandler<Event>) event -> {
                System.out.println("Timestamp: " + event.getTimestamp());
            });
        
        // Publish event
        eventBus.publish(new UserEvent("login"));
    }
    
    /**
     * Example 5: Comparator combining
     */
    public static <T> Comparator<T> combining(
            Comparator<? super T> first,
            Comparator<? super T> second) {
        
        return (o1, o2) -> {
            int result = first.compare(o1, o2);
            return result != 0 ? result : second.compare(o1, o2);
        };
    }
    
    public static void comparatorCombining() {
        List<User> users = Arrays.asList(
            new User(3L, "Alice"),
            new User(1L, "Bob"),
            new User(2L, "Alice")
        );
        
        // Sort by name, then by ID
        Comparator<User> byName = Comparator.comparing(User::getName);
        Comparator<User> byId = Comparator.comparing(User::getId);
        
        Comparator<User> combined = combining(byName, byId);
        users.sort(combined);
        
        System.out.println("Sorted users:");
        for (User user : users) {
            System.out.println(user.getName() + " (ID: " + user.getId() + ")");
        }
        
        /**
         * WHY <? super T>?
         * 
         * Comparator<User> can also be:
         * - Comparator<Entity> (supertype)
         * - Comparator<Object> (supertype)
         * 
         * All can compare Users
         * <? super T> accepts them all
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Data Pipeline ===");
        dataPipeline();
        
        System.out.println("\n=== Repository Pattern ===");
        repositoryPattern();
        
        System.out.println("\n=== Builder Pattern ===");
        builderPattern();
        
        System.out.println("\n=== Event Handling ===");
        eventHandling();
        
        System.out.println("\n=== Comparator Combining ===");
        comparatorCombining();
    }
}
```

---

## Summary

### Quick Reference

**Bounded Type Parameters vs Wildcards:**

```java
// Type parameter - can name and refer to type
<T extends Number> T max(List<T> list)
// ↑ T appears multiple times, can return T

// Wildcard - anonymous type
double sum(List<? extends Number> numbers)
// ↑ Type used once, only reading
```

**PECS Rule:**

```java
// Producer Extends - reading from it
<? extends T>  // Get values OUT (produce)

// Consumer Super - writing to it
<? super T>    // Put values IN (consume)

// Example: Collections.copy
public static <T> void copy(
    List<? super T> dest,      // Consumer - write to
    List<? extends T> src)     // Producer - read from
```

**Upper Bounds:**

```
<T extends Type>         // Type parameter
<? extends Type>         // Wildcard

Reading: ✅ Safe - get Type or subtype
Writing: ❌ Unsafe - don't know exact type
```

**Lower Bounds:**

```
<? super Type>           // Wildcard only!

Reading: ❌ Limited - only Object
Writing: ✅ Safe - can add Type
```

**Unbounded Wildcard:**

```
<?>                      // Unknown type

Reading: ✅ As Object
Writing: ❌ Only null
Use when: Don't care about type
```

**Multiple Bounds:**

```
<T extends Class & Interface1 & Interface2>

Rules:
- Class first (if present)
- At most one class
- Multiple interfaces OK
```

### Decision Tree

```
Need to work with collection?
  ↓
Only READING from it?
  YES → <? extends T>
  Example: sum(List<? extends Number>)
  ↓
Only WRITING to it?
  YES → <? super T>
  Example: addAll(List<? super Integer> dest)
  ↓
Both READ and WRITE?
  YES → <T> (no wildcard)
  Example: sort(List<T> list)
  ↓
Only metadata (size, isEmpty)?
  YES → <?>
  Example: printSize(List<?>)
```

### Best Practices

**1. Apply PECS:**

```java
// ✅ GOOD: PECS applied
public static <T> void copy(
    List<? super T> dest,
    List<? extends T> src)

// ❌ BAD: PECS reversed
public static <T> void copy(
    List<? extends T> dest,    // Can't write!
    List<? super T> src)       // Can't read specific type!
```

**2. Don't use wildcards in return types:**

```java
// ❌ BAD: Wildcard in return
public List<? extends Number> getNumbers()

// ✅ GOOD: Concrete type
public List<Number> getNumbers()
```

**3. Prefer wildcards for flexibility:**

```java
// ✅ GOOD: Accepts any Number list
public double sum(List<? extends Number> numbers)

// ❌ BAD: Only accepts List<Number>
public double sum(List<Number> numbers)
```

**4. Use type parameters when naming needed:**

```java
// ✅ GOOD: T named for return type
public <T extends Comparable<T>> T max(List<T> list)

// ❌ BAD: Can't return specific type
public Comparable<?> max(List<? extends Comparable<?>> list)
```

**5. Multiple bounds: class first:**

```java
// ✅ GOOD: Class first
<T extends Animal & Comparable<T>>

// ❌ BAD: Interface first
<T extends Comparable<T> & Animal>  // Compile error!
```

---
