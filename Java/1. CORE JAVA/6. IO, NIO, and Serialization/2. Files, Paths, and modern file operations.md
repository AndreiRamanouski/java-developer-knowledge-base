# Files, Paths, and Modern File Operations

## Overview

Java 7 introduced the NIO.2 file API with the Path interface and Files utility class, replacing the legacy File class with a more powerful, flexible, and efficient API. This guide covers modern file operations including path manipulation, file walking, attributes, directory watching, symbolic links, and efficient copying strategies.



---

## 1. Path vs File

### Understanding the New Path API

```java
/**
 * PATH VS FILE
 * 
 * Comparing legacy File with modern Path
 */

import java.io.*;
import java.nio.file.*;
import java.nio.file.attribute.*;
import java.util.*;

public class PathVsFile {
    
    /**
     * File API (legacy - Java 1.0)
     */
    public static void legacyFileAPI() {
        /**
         * FILE CLASS PROBLEMS:
         * 
         * 1. ERROR HANDLING:
         *    Methods return boolean
         *    No exception details
         *    Hard to diagnose failures
         * 
         * 2. PERFORMANCE:
         *    Poor performance
         *    Many system calls
         *    Inefficient operations
         * 
         * 3. PLATFORM ISSUES:
         *    Inconsistent behavior
         *    Windows vs Unix differences
         *    Edge cases not handled
         * 
         * 4. MISSING FEATURES:
         *    No symbolic link support
         *    Limited attributes
         *    No file tree walking
         *    Can't copy/move efficiently
         * 
         * 5. NAMING:
         *    File represents both files and directories
         *    Confusing naming
         */
        
        File file = new File("test.txt");
        
        // Create file - returns boolean only
        boolean created = file.createNewFile();  // No details on failure
        
        // Delete - returns boolean
        boolean deleted = file.delete();  // Why did it fail?
        
        // List files - returns null on error
        File[] files = file.listFiles();  // null if not directory or error
        
        // Exists check
        boolean exists = file.exists();
        
        // Many issues:
        // - exists() can return false if no permission
        // - delete() fails silently
        // - createNewFile() doesn't tell you why it failed
    }
    
    /**
     * Path API (modern - Java 7+)
     */
    public static void modernPathAPI() throws IOException {
        /**
         * PATH INTERFACE BENEFITS:
         * 
         * 1. EXCEPTIONS:
         *    Detailed exception information
         *    Know exactly what went wrong
         *    Proper error handling
         * 
         * 2. PERFORMANCE:
         *    Better performance
         *    Fewer system calls
         *    Optimized operations
         * 
         * 3. PLATFORM AGNOSTIC:
         *    Consistent behavior
         *    Handles edge cases
         *    Provider architecture
         * 
         * 4. RICH FEATURES:
         *    Symbolic link support
         *    Comprehensive attributes
         *    File tree walking
         *    Efficient copy/move
         * 
         * 5. SEPARATION:
         *    Path = location
         *    Files = operations
         *    Clear distinction
         */
        
        Path path = Paths.get("test.txt");
        
        // Create file - throws exception with details
        Files.createFile(path);  // AccessDeniedException, FileAlreadyExistsException
        
        // Delete - throws exception
        Files.delete(path);  // NoSuchFileException, AccessDeniedException
        
        // List files - Stream with exception handling
        try (var stream = Files.list(Paths.get("."))) {
            stream.forEach(System.out::println);
        }
        
        // Exists check with LinkOption
        boolean exists = Files.exists(path, LinkOption.NOFOLLOW_LINKS);
        
        // Much better:
        // - Exceptions provide details
        // - LinkOptions for symbolic links
        // - Stream API integration
        // - Type-safe operations
    }
    
    /**
     * Creating paths
     */
    public static void creatingPaths() {
        /**
         * CREATING PATHS:
         */
        
        // From string
        Path path1 = Paths.get("data.txt");
        Path path2 = Paths.get("/tmp/data.txt");
        
        // Multiple string segments
        Path path3 = Paths.get("dir", "subdir", "file.txt");
        // Same as: dir/subdir/file.txt (or dir\subdir\file.txt on Windows)
        
        // From URI
        Path path4 = Paths.get(URI.create("file:///tmp/data.txt"));
        
        // File system
        Path path5 = FileSystems.getDefault().getPath("data.txt");
        
        // From File (conversion)
        File file = new File("data.txt");
        Path path6 = file.toPath();
        
        // To File (conversion)
        File file2 = path1.toFile();
        
        /**
         * MODERN WAY (Java 11+):
         * 
         * Path.of() - cleaner than Paths.get()
         */
        Path path7 = Path.of("data.txt");
        Path path8 = Path.of("dir", "subdir", "file.txt");
    }
    
    /**
     * Path manipulation
     */
    public static void pathManipulation() {
        Path path = Paths.get("/home/user/documents/report.pdf");
        
        System.out.println("=== Path Components ===");
        System.out.println("toString: " + path);
        System.out.println("getFileName: " + path.getFileName());
        System.out.println("getParent: " + path.getParent());
        System.out.println("getRoot: " + path.getRoot());
        System.out.println("getNameCount: " + path.getNameCount());
        System.out.println("getName(0): " + path.getName(0));
        System.out.println("getName(1): " + path.getName(1));
        System.out.println("subpath(1, 3): " + path.subpath(1, 3));
        
        /**
         * OUTPUT:
         * toString: /home/user/documents/report.pdf
         * getFileName: report.pdf
         * getParent: /home/user/documents
         * getRoot: /
         * getNameCount: 4
         * getName(0): home
         * getName(1): user
         * subpath(1, 3): user/documents
         */
        
        // Absolute vs relative
        System.out.println("\n=== Absolute vs Relative ===");
        System.out.println("isAbsolute: " + path.isAbsolute());
        System.out.println("toAbsolutePath: " + Paths.get("data.txt").toAbsolutePath());
        
        // Normalization
        System.out.println("\n=== Normalization ===");
        Path messyPath = Paths.get("/home/user/../user/./documents/report.pdf");
        System.out.println("Original: " + messyPath);
        System.out.println("Normalized: " + messyPath.normalize());
        
        // Relativize
        System.out.println("\n=== Relativize ===");
        Path base = Paths.get("/home/user");
        Path target = Paths.get("/home/user/documents/report.pdf");
        System.out.println("Relative: " + base.relativize(target));
        
        // Resolve
        System.out.println("\n=== Resolve ===");
        Path dir = Paths.get("/home/user");
        Path file = Paths.get("documents/report.pdf");
        System.out.println("Resolved: " + dir.resolve(file));
    }
    
    /**
     * Path comparison
     */
    public static void pathComparison() throws IOException {
        Path path1 = Paths.get("data.txt");
        Path path2 = Paths.get("./data.txt");
        Path path3 = Paths.get("DATA.TXT");
        
        System.out.println("=== Path Equality ===");
        
        // equals() - lexical comparison
        System.out.println("path1.equals(path2): " + path1.equals(path2));  // false
        
        // compareTo() - lexicographic comparison
        System.out.println("path1.compareTo(path2): " + path1.compareTo(path2));
        
        // isSameFile() - checks if same file
        Files.createFile(path1);
        System.out.println("Files.isSameFile(path1, path2): " + 
            Files.isSameFile(path1, path2));  // true (same file)
        
        Files.delete(path1);
        
        /**
         * COMPARISON METHODS:
         * 
         * equals():
         * - Lexical comparison
         * - path1.equals(path2) → false if different strings
         * 
         * compareTo():
         * - Lexicographic order
         * - For sorting paths
         * 
         * isSameFile():
         * - Checks if same file on filesystem
         * - Follows symbolic links
         * - Most accurate comparison
         */
    }
    
    /**
     * File vs Path migration
     */
    public static void fileVsPathMigration() throws IOException {
        /**
         * MIGRATION GUIDE:
         * 
         * File → Path:
         */
        
        // File operations → Path operations
        File file = new File("data.txt");
        Path path = Paths.get("data.txt");
        
        // Creating
        file.createNewFile();          // → Files.createFile(path);
        
        // Deleting
        file.delete();                 // → Files.delete(path);
        
        // Checking existence
        file.exists();                 // → Files.exists(path);
        
        // Checking if directory
        file.isDirectory();            // → Files.isDirectory(path);
        
        // Checking if file
        file.isFile();                 // → Files.isRegularFile(path);
        
        // Getting size
        file.length();                 // → Files.size(path);
        
        // Last modified
        file.lastModified();           // → Files.getLastModifiedTime(path);
        
        // Reading
        new FileInputStream(file);     // → Files.newInputStream(path);
        new FileReader(file);          // → Files.newBufferedReader(path);
        
        // Writing
        new FileOutputStream(file);    // → Files.newOutputStream(path);
        new FileWriter(file);          // → Files.newBufferedWriter(path);
        
        // Listing
        file.listFiles();              // → Files.list(path);
        
        // Walking tree
        // No direct equivalent in File  // → Files.walk(path);
    }
    
    /**
     * When to use File vs Path
     */
    public static void whenToUseEach() {
        /**
         * USE PATH WHEN:
         * 
         * ✓ New code (always prefer)
         * ✓ Need modern features
         * ✓ Better error handling needed
         * ✓ Symbolic link support required
         * ✓ File attributes needed
         * ✓ Performance matters
         * 
         * 
         * USE FILE WHEN:
         * 
         * ✓ Maintaining legacy code
         * ✓ Third-party APIs require it
         * ✓ Java 6 or earlier compatibility
         * 
         * 
         * RECOMMENDATION:
         * 
         * Always use Path in new code
         * Convert File to Path when possible: file.toPath()
         * Gradually migrate to Path API
         */
    }
    
    public static void main(String[] args) throws IOException {
        System.out.println("=== Creating Paths ===");
        creatingPaths();
        
        System.out.println("\n=== Path Manipulation ===");
        pathManipulation();
        
        System.out.println("\n=== Path Comparison ===");
        pathComparison();
    }
}
```

---

## 2. Files Utility Class

### Comprehensive File Operations

```java
/**
 * FILES UTILITY CLASS
 * 
 * Modern file operations with Files class
 */

import java.nio.file.*;
import java.nio.charset.*;
import java.io.*;
import java.util.*;
import java.util.stream.*;

public class FilesUtilityClass {
    
    /**
     * Creating files and directories
     */
    public static void creatingFilesAndDirectories() throws IOException {
        Path file = Paths.get("test.txt");
        Path dir = Paths.get("testdir");
        Path nestedDir = Paths.get("parent/child/grandchild");
        
        // Create file
        Files.createFile(file);
        System.out.println("Created file: " + file);
        
        // Create directory
        Files.createDirectory(dir);
        System.out.println("Created directory: " + dir);
        
        // Create directories (with parents)
        Files.createDirectories(nestedDir);
        System.out.println("Created nested directories: " + nestedDir);
        
        // Create temporary file
        Path tempFile = Files.createTempFile("prefix", ".txt");
        System.out.println("Temp file: " + tempFile);
        
        // Create temporary directory
        Path tempDir = Files.createTempDirectory("tempdir");
        System.out.println("Temp directory: " + tempDir);
        
        // Cleanup
        Files.delete(file);
        Files.delete(dir);
        Files.delete(nestedDir);
        Files.delete(nestedDir.getParent());
        Files.delete(nestedDir.getParent().getParent());
        Files.delete(tempFile);
        Files.delete(tempDir);
        
        /**
         * CREATE METHODS:
         * 
         * createFile(path):
         * - Fails if exists
         * - Atomic operation
         * 
         * createDirectory(path):
         * - Creates single directory
         * - Fails if parent doesn't exist
         * 
         * createDirectories(path):
         * - Creates all parents
         * - No error if already exists
         * 
         * createTempFile(prefix, suffix):
         * - Unique file name
         * - In system temp directory
         * - Or createTempFile(dir, prefix, suffix)
         * 
         * createTempDirectory(prefix):
         * - Unique directory name
         * - In system temp directory
         */
    }
    
    /**
     * Reading and writing
     */
    public static void readingAndWriting() throws IOException {
        Path path = Paths.get("data.txt");
        
        // Write bytes
        byte[] bytes = "Hello, World!".getBytes();
        Files.write(path, bytes);
        
        // Write lines
        List<String> lines = Arrays.asList("Line 1", "Line 2", "Line 3");
        Files.write(path, lines, StandardCharsets.UTF_8);
        
        // Append
        Files.write(path, "Line 4\n".getBytes(), StandardOpenOption.APPEND);
        
        // Read all bytes
        byte[] readBytes = Files.readAllBytes(path);
        System.out.println("Read bytes: " + readBytes.length);
        
        // Read all lines
        List<String> readLines = Files.readAllLines(path, StandardCharsets.UTF_8);
        System.out.println("Read lines: " + readLines);
        
        // Read as string (Java 11+)
        String content = Files.readString(path, StandardCharsets.UTF_8);
        System.out.println("Read string: " + content);
        
        // Write string (Java 11+)
        Files.writeString(path, "New content", StandardCharsets.UTF_8);
        
        // Stream lines
        try (Stream<String> stream = Files.lines(path)) {
            stream.forEach(System.out::println);
        }
        
        Files.delete(path);
        
        /**
         * READ/WRITE METHODS:
         * 
         * Small files:
         * - readAllBytes() / writeBytes()
         * - readAllLines() / write(lines)
         * - readString() / writeString() (Java 11+)
         * 
         * Large files:
         * - lines() → Stream
         * - newBufferedReader() / newBufferedWriter()
         * - newInputStream() / newOutputStream()
         * 
         * WARNING:
         * readAllBytes() loads entire file into memory
         * Use streaming for large files
         */
    }
    
    /**
     * Checking file properties
     */
    public static void checkingFileProperties() throws IOException {
        Path file = Paths.get("test.txt");
        Path dir = Paths.get("testdir");
        
        Files.createFile(file);
        Files.createDirectory(dir);
        
        System.out.println("=== File Properties ===");
        
        // Existence
        System.out.println("exists: " + Files.exists(file));
        System.out.println("notExists: " + Files.notExists(Paths.get("missing.txt")));
        
        // Type
        System.out.println("isRegularFile: " + Files.isRegularFile(file));
        System.out.println("isDirectory: " + Files.isDirectory(dir));
        System.out.println("isSymbolicLink: " + Files.isSymbolicLink(file));
        
        // Permissions
        System.out.println("isReadable: " + Files.isReadable(file));
        System.out.println("isWritable: " + Files.isWritable(file));
        System.out.println("isExecutable: " + Files.isExecutable(file));
        
        // Hidden
        System.out.println("isHidden: " + Files.isHidden(file));
        
        // Size
        System.out.println("size: " + Files.size(file) + " bytes");
        
        // Same file
        Path same = Paths.get("./test.txt");
        System.out.println("isSameFile: " + Files.isSameFile(file, same));
        
        Files.delete(file);
        Files.delete(dir);
        
        /**
         * PROPERTY METHODS:
         * 
         * Existence:
         * - exists(path, options)
         * - notExists(path, options)
         * 
         * Type:
         * - isRegularFile(path, options)
         * - isDirectory(path, options)
         * - isSymbolicLink(path)
         * 
         * Permissions:
         * - isReadable(path)
         * - isWritable(path)
         * - isExecutable(path)
         * 
         * LinkOption.NOFOLLOW_LINKS:
         * - Check link itself, not target
         */
    }
    
    /**
     * Copying and moving
     */
    public static void copyingAndMoving() throws IOException {
        Path source = Paths.get("source.txt");
        Path target = Paths.get("target.txt");
        Path moved = Paths.get("moved.txt");
        
        Files.write(source, "Source content".getBytes());
        
        // Copy
        Files.copy(source, target);
        System.out.println("Copied to: " + target);
        
        // Copy with options
        Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);
        
        // Move
        Files.move(target, moved);
        System.out.println("Moved to: " + moved);
        
        // Move with options
        Files.move(source, target, 
            StandardCopyOption.REPLACE_EXISTING,
            StandardCopyOption.ATOMIC_MOVE);
        
        // Copy from/to streams
        try (InputStream in = Files.newInputStream(target);
             OutputStream out = Files.newOutputStream(moved)) {
            in.transferTo(out);
        }
        
        Files.delete(target);
        Files.delete(moved);
        
        /**
         * COPY OPTIONS:
         * 
         * REPLACE_EXISTING:
         * - Overwrite if exists
         * 
         * COPY_ATTRIBUTES:
         * - Copy file attributes
         * - Timestamps, permissions
         * 
         * NOFOLLOW_LINKS:
         * - Copy symlink itself
         * - Not target
         * 
         * 
         * MOVE OPTIONS:
         * 
         * REPLACE_EXISTING:
         * - Overwrite target
         * 
         * ATOMIC_MOVE:
         * - Move atomically
         * - Or fail
         * - Platform dependent
         */
    }
    
    /**
     * Deleting
     */
    public static void deleting() throws IOException {
        Path file = Paths.get("deleteme.txt");
        Path dir = Paths.get("deletedir");
        
        Files.createFile(file);
        Files.createDirectory(dir);
        
        // Delete
        Files.delete(file);
        System.out.println("Deleted: " + file);
        
        // Delete if exists
        boolean deleted = Files.deleteIfExists(dir);
        System.out.println("Deleted dir: " + deleted);
        
        // Try to delete non-existent
        try {
            Files.delete(file);
        } catch (NoSuchFileException e) {
            System.out.println("File doesn't exist: " + e.getMessage());
        }
        
        // deleteIfExists doesn't throw
        deleted = Files.deleteIfExists(file);
        System.out.println("Deleted non-existent: " + deleted);
        
        /**
         * DELETE METHODS:
         * 
         * delete(path):
         * - Throws NoSuchFileException if missing
         * - Throws DirectoryNotEmptyException if directory not empty
         * 
         * deleteIfExists(path):
         * - Returns false if missing
         * - Still throws DirectoryNotEmptyException
         * - More convenient for optional files
         */
    }
    
    /**
     * Directory operations
     */
    public static void directoryOperations() throws IOException {
        Path dir = Paths.get("mydir");
        Files.createDirectory(dir);
        
        // Create files in directory
        Files.createFile(dir.resolve("file1.txt"));
        Files.createFile(dir.resolve("file2.txt"));
        Files.createDirectory(dir.resolve("subdir"));
        
        // List directory
        System.out.println("=== List Directory ===");
        try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir)) {
            for (Path entry : stream) {
                System.out.println(entry.getFileName());
            }
        }
        
        // List with glob pattern
        System.out.println("\n=== List with Pattern ===");
        try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir, "*.txt")) {
            for (Path entry : stream) {
                System.out.println(entry.getFileName());
            }
        }
        
        // List as Stream
        System.out.println("\n=== List as Stream ===");
        try (Stream<Path> stream = Files.list(dir)) {
            stream.map(Path::getFileName)
                  .forEach(System.out::println);
        }
        
        // Cleanup
        Files.delete(dir.resolve("file1.txt"));
        Files.delete(dir.resolve("file2.txt"));
        Files.delete(dir.resolve("subdir"));
        Files.delete(dir);
        
        /**
         * DIRECTORY LISTING:
         * 
         * newDirectoryStream(path):
         * - Returns DirectoryStream
         * - Iterable interface
         * - Can filter with glob
         * - Single level only
         * 
         * list(path):
         * - Returns Stream<Path>
         * - Functional operations
         * - Single level only
         * 
         * walk(path):
         * - Recursive traversal
         * - Returns Stream<Path>
         * - Depth control
         */
    }
    
    /**
     * Probing content type
     */
    public static void probingContentType() throws IOException {
        Path textFile = Paths.get("test.txt");
        Path htmlFile = Paths.get("test.html");
        Path imageFile = Paths.get("test.jpg");
        
        Files.createFile(textFile);
        Files.createFile(htmlFile);
        Files.createFile(imageFile);
        
        // Probe content type
        String textType = Files.probeContentType(textFile);
        String htmlType = Files.probeContentType(htmlFile);
        String imageType = Files.probeContentType(imageFile);
        
        System.out.println("text.txt type: " + textType);
        System.out.println("test.html type: " + htmlType);
        System.out.println("test.jpg type: " + imageType);
        
        Files.delete(textFile);
        Files.delete(htmlFile);
        Files.delete(imageFile);
        
        /**
         * CONTENT TYPE:
         * 
         * probeContentType(path):
         * - Returns MIME type
         * - Based on file extension
         * - Platform dependent
         * - May return null
         * 
         * Examples:
         * - text/plain
         * - text/html
         * - image/jpeg
         * - application/pdf
         */
    }
    
    public static void main(String[] args) throws IOException {
        System.out.println("=== Creating Files and Directories ===");
        creatingFilesAndDirectories();
        
        System.out.println("\n=== Reading and Writing ===");
        readingAndWriting();
        
        System.out.println("\n=== Checking Properties ===");
        checkingFileProperties();
        
        System.out.println("\n=== Directory Operations ===");
        directoryOperations();
    }
}
```

---

## 3. Walking File Trees

### Recursive Directory Traversal

```java
/**
 * WALKING FILE TREES
 * 
 * Recursive directory traversal techniques
 */

import java.nio.file.*;
import java.nio.file.attribute.*;
import java.io.IOException;
import java.util.*;
import java.util.stream.*;

public class WalkingFileTrees {
    
    /**
     * Basic file walking with Stream
     */
    public static void basicFileWalking() throws IOException {
        Path start = Paths.get(".");
        
        System.out.println("=== All Files (depth 2) ===");
        try (Stream<Path> stream = Files.walk(start, 2)) {
            stream.filter(Files::isRegularFile)
                  .limit(10)
                  .forEach(System.out::println);
        }
        
        /**
         * FILES.WALK():
         * 
         * walk(start):
         * - Walks entire tree
         * - Depth first
         * - Returns Stream<Path>
         * 
         * walk(start, maxDepth):
         * - Limits depth
         * - 0 = just start
         * - 1 = start + direct children
         * 
         * walk(start, maxDepth, options):
         * - FileVisitOption.FOLLOW_LINKS
         * - Follow symbolic links
         * - Watch for cycles!
         */
    }
    
    /**
     * Finding files
     */
    public static void findingFiles() throws IOException {
        Path start = Paths.get(".");
        
        // Find all .java files
        System.out.println("=== Java Files ===");
        try (Stream<Path> stream = Files.find(start, 5,
                (path, attrs) -> path.toString().endsWith(".java"))) {
            stream.limit(5)
                  .forEach(System.out::println);
        }
        
        // Find large files
        System.out.println("\n=== Large Files (>1 KB) ===");
        try (Stream<Path> stream = Files.find(start, 3,
                (path, attrs) -> attrs.isRegularFile() && 
                                 attrs.size() > 1024)) {
            stream.limit(5)
                  .forEach(p -> System.out.println(p + " - " + 
                      getFileSize(p) + " bytes"));
        }
        
        // Find recently modified
        System.out.println("\n=== Recently Modified ===");
        long yesterday = System.currentTimeMillis() - 24 * 60 * 60 * 1000;
        try (Stream<Path> stream = Files.find(start, 2,
                (path, attrs) -> attrs.lastModifiedTime().toMillis() > yesterday)) {
            stream.limit(5)
                  .forEach(System.out::println);
        }
        
        /**
         * FILES.FIND():
         * 
         * find(start, maxDepth, matcher):
         * - Like walk() but with predicate
         * - BiPredicate<Path, BasicFileAttributes>
         * - More efficient than walk().filter()
         * - Attributes already read
         */
    }
    
    private static long getFileSize(Path path) {
        try {
            return Files.size(path);
        } catch (IOException e) {
            return 0;
        }
    }
    
    /**
     * FileVisitor pattern
     */
    public static void fileVisitorPattern() throws IOException {
        Path start = Paths.get("testdir");
        
        // Create test directory structure
        Files.createDirectories(start.resolve("subdir1"));
        Files.createDirectories(start.resolve("subdir2"));
        Files.createFile(start.resolve("file1.txt"));
        Files.createFile(start.resolve("subdir1/file2.txt"));
        
        // Custom visitor
        FileVisitor<Path> visitor = new SimpleFileVisitor<Path>() {
            private int fileCount = 0;
            private int dirCount = 0;
            
            @Override
            public FileVisitResult preVisitDirectory(Path dir, 
                    BasicFileAttributes attrs) {
                dirCount++;
                System.out.println("Entering directory: " + dir);
                return FileVisitResult.CONTINUE;
            }
            
            @Override
            public FileVisitResult visitFile(Path file, 
                    BasicFileAttributes attrs) {
                fileCount++;
                System.out.println("  File: " + file.getFileName() + 
                                 " (" + attrs.size() + " bytes)");
                return FileVisitResult.CONTINUE;
            }
            
            @Override
            public FileVisitResult visitFileFailed(Path file, IOException exc) {
                System.err.println("Failed to visit: " + file + " - " + exc);
                return FileVisitResult.CONTINUE;
            }
            
            @Override
            public FileVisitResult postVisitDirectory(Path dir, IOException exc) {
                System.out.println("Leaving directory: " + dir);
                return FileVisitResult.CONTINUE;
            }
        };
        
        Files.walkFileTree(start, visitor);
        
        // Cleanup
        Files.walk(start)
             .sorted(Comparator.reverseOrder())
             .forEach(path -> {
                 try { Files.delete(path); } catch (IOException e) {}
             });
        
        /**
         * FILEVISITOR:
         * 
         * preVisitDirectory():
         * - Before visiting directory contents
         * - Can skip directory (SKIP_SUBTREE)
         * 
         * visitFile():
         * - For each file
         * - Regular files only
         * 
         * visitFileFailed():
         * - When file can't be visited
         * - Permission errors, etc.
         * 
         * postVisitDirectory():
         * - After visiting directory contents
         * - Can check IOException
         * 
         * 
         * RETURN VALUES:
         * 
         * CONTINUE - continue normally
         * SKIP_SUBTREE - skip directory contents
         * SKIP_SIBLINGS - skip remaining siblings
         * TERMINATE - stop walking
         */
    }
    
    /**
     * Copying directory tree
     */
    public static void copyingDirectoryTree() throws IOException {
        Path source = Paths.get("source-dir");
        Path target = Paths.get("target-dir");
        
        // Create source
        Files.createDirectories(source.resolve("subdir"));
        Files.write(source.resolve("file1.txt"), "Content 1".getBytes());
        Files.write(source.resolve("subdir/file2.txt"), "Content 2".getBytes());
        
        // Copy tree
        Files.walkFileTree(source, new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult preVisitDirectory(Path dir, 
                    BasicFileAttributes attrs) throws IOException {
                Path targetDir = target.resolve(source.relativize(dir));
                Files.createDirectories(targetDir);
                return FileVisitResult.CONTINUE;
            }
            
            @Override
            public FileVisitResult visitFile(Path file, 
                    BasicFileAttributes attrs) throws IOException {
                Path targetFile = target.resolve(source.relativize(file));
                Files.copy(file, targetFile, StandardCopyOption.REPLACE_EXISTING);
                return FileVisitResult.CONTINUE;
            }
        });
        
        System.out.println("Copied directory tree from " + source + " to " + target);
        
        // Cleanup
        Files.walk(source).sorted(Comparator.reverseOrder())
             .forEach(path -> { try { Files.delete(path); } catch (IOException e) {} });
        Files.walk(target).sorted(Comparator.reverseOrder())
             .forEach(path -> { try { Files.delete(path); } catch (IOException e) {} });
        
        /**
         * DIRECTORY COPY PATTERN:
         * 
         * 1. preVisitDirectory:
         *    Create corresponding target directory
         * 
         * 2. visitFile:
         *    Copy file to target
         * 
         * 3. relativize():
         *    Get relative path from source
         *    Resolve to target
         */
    }
    
    /**
     * Deleting directory tree
     */
    public static void deletingDirectoryTree() throws IOException {
        Path dir = Paths.get("delete-me");
        
        // Create directory with contents
        Files.createDirectories(dir.resolve("subdir"));
        Files.createFile(dir.resolve("file.txt"));
        Files.createFile(dir.resolve("subdir/file2.txt"));
        
        // Delete tree - must delete in reverse order
        Files.walk(dir)
             .sorted(Comparator.reverseOrder())  // Deepest first
             .forEach(path -> {
                 try {
                     Files.delete(path);
                     System.out.println("Deleted: " + path);
                 } catch (IOException e) {
                     System.err.println("Failed to delete: " + path);
                 }
             });
        
        /**
         * DELETE TREE PATTERN:
         * 
         * 1. walk(dir) - get all paths
         * 2. sorted(reverseOrder()) - deepest first
         * 3. delete each
         * 
         * Must delete children before parents
         * Reverse order ensures this
         */
    }
    
    /**
     * Searching files
     */
    public static void searchingFiles() throws IOException {
        Path start = Paths.get(".");
        
        // Search for pattern
        String pattern = ".*\\.java$";
        PathMatcher matcher = FileSystems.getDefault()
            .getPathMatcher("regex:" + pattern);
        
        System.out.println("=== Files matching " + pattern + " ===");
        try (Stream<Path> stream = Files.walk(start, 3)) {
            stream.filter(path -> matcher.matches(path.getFileName()))
                  .limit(5)
                  .forEach(System.out::println);
        }
        
        // Glob pattern
        PathMatcher globMatcher = FileSystems.getDefault()
            .getPathMatcher("glob:**.md");
        
        System.out.println("\n=== Markdown files ===");
        try (Stream<Path> stream = Files.walk(start, 2)) {
            stream.filter(path -> globMatcher.matches(path))
                  .limit(5)
                  .forEach(System.out::println);
        }
        
        /**
         * PATH MATCHER:
         * 
         * getPathMatcher("glob:*.txt"):
         * - Glob pattern
         * - * = any characters
         * - ** = any directories
         * - ? = single character
         * - {a,b} = alternatives
         * 
         * getPathMatcher("regex:.*\\.txt"):
         * - Regex pattern
         * - Full regex support
         * - More powerful
         */
    }
    
    /**
     * Performance considerations
     */
    public static void performanceConsiderations() {
        /**
         * PERFORMANCE TIPS:
         * 
         * 1. LIMIT DEPTH:
         *    walk(start, 3) vs walk(start)
         *    Avoid deep traversals
         * 
         * 2. USE FIND() OVER WALK().FILTER():
         *    find() - attributes already read
         *    walk().filter() - may need to read attributes
         * 
         * 3. CLOSE STREAMS:
         *    Always use try-with-resources
         *    Releases file handles
         * 
         * 4. PARALLEL PROCESSING:
         *    stream.parallel() for large trees
         *    Watch for resource contention
         * 
         * 5. AVOID FOLLOWING LINKS:
         *    Can create cycles
         *    Infinite loops
         *    Use NOFOLLOW_LINKS
         */
    }
    
    public static void main(String[] args) throws IOException {
        System.out.println("=== Basic File Walking ===");
        basicFileWalking();
        
        System.out.println("\n=== Finding Files ===");
        findingFiles();
        
        System.out.println("\n=== FileVisitor Pattern ===");
        fileVisitorPattern();
    }
}
```

---

## 4. File Attributes and Permissions

### Reading and Setting File Metadata

```java
/**
 * FILE ATTRIBUTES AND PERMISSIONS
 * 
 * Working with file metadata
 */

import java.nio.file.*;
import java.nio.file.attribute.*;
import java.io.IOException;
import java.time.*;
import java.util.*;

public class FileAttributesAndPermissions {
    
    /**
     * Basic file attributes
     */
    public static void basicFileAttributes() throws IOException {
        Path file = Paths.get("test.txt");
        Files.write(file, "Test content".getBytes());
        
        // Read basic attributes
        BasicFileAttributes attrs = Files.readAttributes(
            file, BasicFileAttributes.class);
        
        System.out.println("=== Basic Attributes ===");
        System.out.println("creationTime: " + attrs.creationTime());
        System.out.println("lastModifiedTime: " + attrs.lastModifiedTime());
        System.out.println("lastAccessTime: " + attrs.lastAccessTime());
        System.out.println("size: " + attrs.size() + " bytes");
        System.out.println("isDirectory: " + attrs.isDirectory());
        System.out.println("isRegularFile: " + attrs.isRegularFile());
        System.out.println("isSymbolicLink: " + attrs.isSymbolicLink());
        System.out.println("isOther: " + attrs.isOther());
        System.out.println("fileKey: " + attrs.fileKey());
        
        Files.delete(file);
        
        /**
         * BASIC FILE ATTRIBUTES:
         * 
         * Times:
         * - creationTime()
         * - lastModifiedTime()
         * - lastAccessTime()
         * 
         * Type:
         * - isDirectory()
         * - isRegularFile()
         * - isSymbolicLink()
         * - isOther() (device, pipe, etc.)
         * 
         * Other:
         * - size()
         * - fileKey() (unique identifier)
         */
    }
    
    /**
     * Modifying timestamps
     */
    public static void modifyingTimestamps() throws IOException {
        Path file = Paths.get("test.txt");
        Files.createFile(file);
        
        // Get current time
        FileTime now = FileTime.from(Instant.now());
        FileTime yesterday = FileTime.from(
            Instant.now().minus(Duration.ofDays(1)));
        
        // Set last modified time
        Files.setLastModifiedTime(file, yesterday);
        
        System.out.println("=== Modified Timestamps ===");
        System.out.println("Last modified: " + 
            Files.getLastModifiedTime(file));
        
        // Set via attribute view
        BasicFileAttributeView view = Files.getFileAttributeView(
            file, BasicFileAttributeView.class);
        
        view.setTimes(
            now,        // lastModifiedTime
            now,        // lastAccessTime
            null        // creationTime (null = don't change)
        );
        
        BasicFileAttributes attrs = view.readAttributes();
        System.out.println("Updated modified: " + attrs.lastModifiedTime());
        System.out.println("Updated access: " + attrs.lastAccessTime());
        
        Files.delete(file);
        
        /**
         * TIMESTAMP MODIFICATION:
         * 
         * setLastModifiedTime(path, time):
         * - Quick method
         * - Only modified time
         * 
         * BasicFileAttributeView.setTimes():
         * - Set all three times
         * - null = don't change
         * - More control
         */
    }
    
    /**
     * POSIX file permissions (Unix/Linux)
     */
    public static void posixPermissions() throws IOException {
        // Only works on POSIX systems
        if (!FileSystems.getDefault().supportedFileAttributeViews()
                .contains("posix")) {
            System.out.println("POSIX not supported on this system");
            return;
        }
        
        Path file = Paths.get("test.txt");
        Files.createFile(file);
        
        // Read POSIX attributes
        PosixFileAttributes attrs = Files.readAttributes(
            file, PosixFileAttributes.class);
        
        System.out.println("=== POSIX Attributes ===");
        System.out.println("Owner: " + attrs.owner());
        System.out.println("Group: " + attrs.group());
        System.out.println("Permissions: " + PosixFilePermissions
            .toString(attrs.permissions()));
        
        // Set permissions: rwxr-xr-x
        Set<PosixFilePermission> perms = PosixFilePermissions.fromString("rwxr-xr-x");
        Files.setPosixFilePermissions(file, perms);
        
        System.out.println("Updated permissions: " + 
            PosixFilePermissions.toString(
                Files.getPosixFilePermissions(file)));
        
        // Create with permissions
        Path file2 = Paths.get("test2.txt");
        Files.createFile(file2, 
            PosixFilePermissions.asFileAttribute(
                PosixFilePermissions.fromString("rw-r--r--")));
        
        Files.delete(file);
        Files.delete(file2);
        
        /**
         * POSIX PERMISSIONS:
         * 
         * Format: rwxrwxrwx
         * - r = read (4)
         * - w = write (2)
         * - x = execute (1)
         * 
         * Three groups:
         * - Owner (user)
         * - Group
         * - Others
         * 
         * Examples:
         * - rwxr-xr-x = 755
         * - rw-r--r-- = 644
         * - rwx------ = 700
         */
    }
    
    /**
     * Windows file attributes
     */
    public static void windowsAttributes() throws IOException {
        // Only works on Windows
        if (!System.getProperty("os.name").toLowerCase().contains("win")) {
            System.out.println("Not running on Windows");
            return;
        }
        
        Path file = Paths.get("test.txt");
        Files.createFile(file);
        
        // Read DOS attributes
        DosFileAttributes attrs = Files.readAttributes(
            file, DosFileAttributes.class);
        
        System.out.println("=== DOS Attributes ===");
        System.out.println("isReadOnly: " + attrs.isReadOnly());
        System.out.println("isHidden: " + attrs.isHidden());
        System.out.println("isArchive: " + attrs.isArchive());
        System.out.println("isSystem: " + attrs.isSystem());
        
        // Set attributes
        Files.setAttribute(file, "dos:hidden", true);
        Files.setAttribute(file, "dos:readonly", true);
        
        // Read again
        attrs = Files.readAttributes(file, DosFileAttributes.class);
        System.out.println("\nUpdated:");
        System.out.println("isReadOnly: " + attrs.isReadOnly());
        System.out.println("isHidden: " + attrs.isHidden());
        
        // Reset
        Files.setAttribute(file, "dos:readonly", false);
        Files.delete(file);
        
        /**
         * DOS ATTRIBUTES:
         * 
         * readonly - can't modify
         * hidden - hidden in explorer
         * archive - backup flag
         * system - system file
         */
    }
    
    /**
     * User-defined attributes
     */
    public static void userDefinedAttributes() throws IOException {
        Path file = Paths.get("test.txt");
        Files.createFile(file);
        
        // Check if supported
        if (!FileSystems.getDefault().supportedFileAttributeViews()
                .contains("user")) {
            System.out.println("User-defined attributes not supported");
            Files.delete(file);
            return;
        }
        
        // Get user attribute view
        UserDefinedFileAttributeView view = Files.getFileAttributeView(
            file, UserDefinedFileAttributeView.class);
        
        // Write custom attributes
        view.write("author", Charset.defaultCharset()
            .encode("John Doe"));
        view.write("version", Charset.defaultCharset()
            .encode("1.0"));
        
        // List attributes
        System.out.println("=== User Attributes ===");
        for (String name : view.list()) {
            System.out.println(name + ": " + readUserAttribute(view, name));
        }
        
        Files.delete(file);
        
        /**
         * USER-DEFINED ATTRIBUTES:
         * 
         * Extended attributes
         * Platform dependent
         * Store custom metadata
         * 
         * Not widely supported
         * Use with caution
         */
    }
    
    private static String readUserAttribute(
            UserDefinedFileAttributeView view, String name) throws IOException {
        ByteBuffer buffer = ByteBuffer.allocate(view.size(name));
        view.read(name, buffer);
        buffer.flip();
        return Charset.defaultCharset().decode(buffer).toString();
    }
    
    /**
     * Reading single attributes
     */
    public static void readingSingleAttributes() throws IOException {
        Path file = Paths.get("test.txt");
        Files.write(file, "Content".getBytes());
        
        System.out.println("=== Single Attributes ===");
        
        // Read single attributes
        System.out.println("size: " + Files.getAttribute(file, "basic:size"));
        System.out.println("lastModifiedTime: " + 
            Files.getAttribute(file, "basic:lastModifiedTime"));
        System.out.println("isDirectory: " + 
            Files.getAttribute(file, "basic:isDirectory"));
        
        // Set single attribute
        FileTime time = FileTime.from(Instant.now());
        Files.setAttribute(file, "basic:lastModifiedTime", time);
        
        Files.delete(file);
        
        /**
         * ATTRIBUTE NAMES:
         * 
         * Format: view:attribute
         * 
         * Basic view:
         * - basic:size
         * - basic:lastModifiedTime
         * - basic:lastAccessTime
         * - basic:creationTime
         * - basic:isDirectory
         * - basic:isRegularFile
         * - basic:isSymbolicLink
         * 
         * POSIX view:
         * - posix:permissions
         * - posix:owner
         * - posix:group
         * 
         * DOS view:
         * - dos:readonly
         * - dos:hidden
         * - dos:archive
         * - dos:system
         */
    }
    
    /**
     * Bulk attribute reading
     */
    public static void bulkAttributeReading() throws IOException {
        Path file = Paths.get("test.txt");
        Files.createFile(file);
        
        // Read multiple attributes at once
        Map<String, Object> attrs = Files.readAttributes(
            file, "basic:size,lastModifiedTime,isDirectory");
        
        System.out.println("=== Bulk Attributes ===");
        attrs.forEach((key, value) -> 
            System.out.println(key + ": " + value));
        
        // Read all basic attributes
        Map<String, Object> allAttrs = Files.readAttributes(file, "basic:*");
        
        System.out.println("\n=== All Basic Attributes ===");
        allAttrs.forEach((key, value) -> 
            System.out.println(key + ": " + value));
        
        Files.delete(file);
        
        /**
         * BULK READING:
         * 
         * readAttributes(path, "view:attr1,attr2,attr3"):
         * - Specific attributes
         * - More efficient than individual reads
         * 
         * readAttributes(path, "view:*"):
         * - All attributes in view
         * - Single system call
         */
    }
    
    public static void main(String[] args) throws IOException {
        System.out.println("=== Basic File Attributes ===");
        basicFileAttributes();
        
        System.out.println("\n=== Modifying Timestamps ===");
        modifyingTimestamps();
        
        System.out.println("\n=== POSIX Permissions ===");
        posixPermissions();
        
        System.out.println("\n=== Single Attributes ===");
        readingSingleAttributes();
    }
}
```

---

## 5. Watching Directory Changes (WatchService)

### Monitoring Filesystem Events

```java
/**
 * WATCHING DIRECTORY CHANGES
 * 
 * Monitoring filesystem events with WatchService
 */

import java.nio.file.*;
import static java.nio.file.StandardWatchEventKinds.*;
import java.io.IOException;
import java.util.concurrent.*;

public class WatchingDirectoryChanges {
    
    /**
     * Basic directory watching
     */
    public static void basicDirectoryWatching() throws IOException, InterruptedException {
        Path dir = Paths.get("watchdir");
        Files.createDirectories(dir);
        
        // Create watch service
        WatchService watchService = FileSystems.getDefault().newWatchService();
        
        // Register directory
        WatchKey key = dir.register(watchService,
            ENTRY_CREATE,
            ENTRY_MODIFY,
            ENTRY_DELETE);
        
        System.out.println("Watching: " + dir);
        System.out.println("Make some changes...");
        
        // Watch in separate thread
        ExecutorService executor = Executors.newSingleThreadExecutor();
        executor.submit(() -> {
            try {
                while (true) {
                    // Wait for event
                    WatchKey eventKey = watchService.take();
                    
                    // Process events
                    for (WatchEvent<?> event : eventKey.pollEvents()) {
                        WatchEvent.Kind<?> kind = event.kind();
                        
                        if (kind == OVERFLOW) {
                            System.out.println("OVERFLOW - events may have been lost");
                            continue;
                        }
                        
                        WatchEvent<Path> pathEvent = (WatchEvent<Path>) event;
                        Path filename = pathEvent.context();
                        
                        System.out.println(kind.name() + ": " + filename);
                    }
                    
                    // Reset key
                    boolean valid = eventKey.reset();
                    if (!valid) {
                        System.out.println("Key no longer valid");
                        break;
                    }
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        
        // Create some test files
        Thread.sleep(1000);
        Files.createFile(dir.resolve("test1.txt"));
        Thread.sleep(100);
        Files.write(dir.resolve("test1.txt"), "content".getBytes());
        Thread.sleep(100);
        Files.delete(dir.resolve("test1.txt"));
        
        Thread.sleep(1000);
        
        // Cleanup
        executor.shutdownNow();
        watchService.close();
        Files.deleteIfExists(dir);
        
        /**
         * WATCH SERVICE BASICS:
         * 
         * 1. Create WatchService
         * 2. Register directories
         * 3. Wait for events (take() or poll())
         * 4. Process events
         * 5. Reset key
         * 6. Repeat
         * 
         * 
         * EVENT TYPES:
         * 
         * ENTRY_CREATE - file/directory created
         * ENTRY_MODIFY - file/directory modified
         * ENTRY_DELETE - file/directory deleted
         * OVERFLOW - too many events
         */
    }
    
    /**
     * Recursive directory watching
     */
    public static void recursiveDirectoryWatching() throws IOException, InterruptedException {
        Path root = Paths.get("watchroot");
        Files.createDirectories(root);
        
        WatchService watchService = FileSystems.getDefault().newWatchService();
        Map<WatchKey, Path> keys = new ConcurrentHashMap<>();
        
        // Register directory and all subdirectories
        registerAll(root, watchService, keys);
        
        System.out.println("Watching tree: " + root);
        
        // Watch loop
        ExecutorService executor = Executors.newSingleThreadExecutor();
        executor.submit(() -> {
            try {
                while (true) {
                    WatchKey key = watchService.take();
                    Path dir = keys.get(key);
                    
                    if (dir == null) {
                        continue;
                    }
                    
                    for (WatchEvent<?> event : key.pollEvents()) {
                        WatchEvent.Kind<?> kind = event.kind();
                        
                        if (kind == OVERFLOW) {
                            continue;
                        }
                        
                        WatchEvent<Path> pathEvent = (WatchEvent<Path>) event;
                        Path filename = pathEvent.context();
                        Path child = dir.resolve(filename);
                        
                        System.out.println(kind.name() + ": " + child);
                        
                        // If new directory created, register it
                        if (kind == ENTRY_CREATE && Files.isDirectory(child)) {
                            registerAll(child, watchService, keys);
                        }
                    }
                    
                    if (!key.reset()) {
                        keys.remove(key);
                        if (keys.isEmpty()) {
                            break;
                        }
                    }
                }
            } catch (InterruptedException | IOException e) {
                Thread.currentThread().interrupt();
            }
        });
        
        // Test
        Thread.sleep(1000);
        Files.createDirectory(root.resolve("subdir"));
        Thread.sleep(100);
        Files.createFile(root.resolve("subdir/file.txt"));
        Thread.sleep(1000);
        
        // Cleanup
        executor.shutdownNow();
        watchService.close();
        Files.walk(root).sorted(Comparator.reverseOrder())
             .forEach(p -> { try { Files.delete(p); } catch (IOException e) {} });
        
        /**
         * RECURSIVE WATCHING:
         * 
         * WatchService doesn't watch recursively
         * Must register each directory manually
         * 
         * Pattern:
         * 1. Walk tree, register all directories
         * 2. On ENTRY_CREATE, check if directory
         * 3. If directory, register it
         * 4. Track keys to directories map
         */
    }
    
    private static void registerAll(Path start, WatchService watchService,
            Map<WatchKey, Path> keys) throws IOException {
        Files.walk(start)
             .filter(Files::isDirectory)
             .forEach(dir -> {
                 try {
                     WatchKey key = dir.register(watchService,
                         ENTRY_CREATE, ENTRY_MODIFY, ENTRY_DELETE);
                     keys.put(key, dir);
                 } catch (IOException e) {
                     e.printStackTrace();
                 }
             });
    }
    
    /**
     * Polling vs blocking
     */
    public static void pollingVsBlocking() throws IOException, InterruptedException {
        Path dir = Paths.get("polldir");
        Files.createDirectories(dir);
        
        WatchService watchService = FileSystems.getDefault().newWatchService();
        dir.register(watchService, ENTRY_CREATE);
        
        System.out.println("=== Blocking (take) ===");
        ExecutorService executor = Executors.newSingleThreadExecutor();
        executor.submit(() -> {
            try {
                // Blocks until event available
                WatchKey key = watchService.take();
                System.out.println("Got event via take()");
                key.pollEvents();
                key.reset();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        
        Thread.sleep(500);
        Files.createFile(dir.resolve("test1.txt"));
        Thread.sleep(500);
        
        System.out.println("\n=== Polling ===");
        
        // Non-blocking poll
        WatchKey key1 = watchService.poll();
        System.out.println("poll() immediate: " + (key1 != null ? "event" : "no event"));
        
        // Poll with timeout
        Files.createFile(dir.resolve("test2.txt"));
        WatchKey key2 = watchService.poll(2, TimeUnit.SECONDS);
        System.out.println("poll(2s): " + (key2 != null ? "event" : "no event"));
        if (key2 != null) key2.reset();
        
        // Cleanup
        executor.shutdownNow();
        watchService.close();
        Files.walk(dir).sorted(Comparator.reverseOrder())
             .forEach(p -> { try { Files.delete(p); } catch (IOException e) {} });
        
        /**
         * WATCH SERVICE METHODS:
         * 
         * take():
         * - Blocks until event
         * - Returns WatchKey
         * - Can be interrupted
         * 
         * poll():
         * - Returns immediately
         * - null if no events
         * - Non-blocking
         * 
         * poll(timeout, unit):
         * - Waits up to timeout
         * - null if timeout
         * - Can be interrupted
         */
    }
    
    /**
     * File auto-reload pattern
     */
    public static void fileAutoReloadPattern() throws IOException, InterruptedException {
        Path configFile = Paths.get("config.txt");
        Path dir = configFile.getParent();
        if (dir == null) dir = Paths.get(".");
        
        Files.write(configFile, "version=1".getBytes());
        
        WatchService watchService = FileSystems.getDefault().newWatchService();
        dir.register(watchService, ENTRY_MODIFY);
        
        System.out.println("Watching config file: " + configFile);
        
        AtomicReference<String> config = new AtomicReference<>(
            new String(Files.readAllBytes(configFile)));
        
        ExecutorService executor = Executors.newSingleThreadExecutor();
        executor.submit(() -> {
            try {
                while (true) {
                    WatchKey key = watchService.poll(1, TimeUnit.SECONDS);
                    if (key == null) continue;
                    
                    for (WatchEvent<?> event : key.pollEvents()) {
                        WatchEvent<Path> pathEvent = (WatchEvent<Path>) event;
                        Path filename = pathEvent.context();
                        
                        if (filename.equals(configFile.getFileName())) {
                            // Reload config
                            String newConfig = new String(
                                Files.readAllBytes(configFile));
                            config.set(newConfig);
                            System.out.println("Config reloaded: " + newConfig);
                        }
                    }
                    
                    key.reset();
                }
            } catch (InterruptedException | IOException e) {
                Thread.currentThread().interrupt();
            }
        });
        
        // Modify config
        Thread.sleep(1000);
        Files.write(configFile, "version=2".getBytes());
        Thread.sleep(1000);
        Files.write(configFile, "version=3".getBytes());
        Thread.sleep(1000);
        
        // Cleanup
        executor.shutdownNow();
        watchService.close();
        Files.delete(configFile);
        
        /**
         * AUTO-RELOAD PATTERN:
         * 
         * 1. Watch directory containing file
         * 2. Filter events for specific file
         * 3. Reload when modified
         * 4. Update application state
         * 
         * Common uses:
         * - Configuration files
         * - Resource files
         * - Templates
         */
    }
    
    /**
     * Platform differences
     */
    public static void platformDifferences() {
        /**
         * PLATFORM BEHAVIOR:
         * 
         * WINDOWS:
         * - Uses ReadDirectoryChangesW
         * - Efficient native implementation
         * - May have delays
         * 
         * LINUX:
         * - Uses inotify
         * - Very efficient
         * - Immediate notifications
         * - Limited number of watches
         * 
         * MAC OS:
         * - Uses FSEvents or polling
         * - May use polling fallback
         * - Less efficient
         * 
         * 
         * LIMITATIONS:
         * 
         * - Not all filesystems support watching
         * - Network drives may not work
         * - Number of watches limited (Linux)
         * - Events may be coalesced
         * - Timing not guaranteed
         */
    }
    
    /**
     * Best practices
     */
    public static void bestPractices() {
        /**
         * WATCH SERVICE BEST PRACTICES:
         * 
         * 1. ALWAYS RESET KEY:
         *    if (!key.reset()) { remove key; }
         *    Otherwise no more events
         * 
         * 2. HANDLE OVERFLOW:
         *    if (kind == OVERFLOW) { rescan; }
         *    Events may have been lost
         * 
         * 3. CHECK VALIDITY:
         *    if (!key.isValid()) { stop watching; }
         *    Directory may have been deleted
         * 
         * 4. DEBOUNCE EVENTS:
         *    Multiple modify events common
         *    Wait before processing
         * 
         * 5. DEDICATED THREAD:
         *    Watch service blocks
         *    Use separate thread
         * 
         * 6. CLEANUP:
         *    watchService.close()
         *    Release resources
         * 
         * 7. ERROR HANDLING:
         *    File may not exist when processing event
         *    Check before accessing
         */
    }
    
    public static void main(String[] args) throws Exception {
        System.out.println("=== Basic Directory Watching ===");
        basicDirectoryWatching();
        
        System.out.println("\n=== Polling vs Blocking ===");
        pollingVsBlocking();
    }
}
```

---

## 6. Symbolic Links Handling

### Working with Symlinks

```java
/**
 * SYMBOLIC LINKS HANDLING
 * 
 * Creating, detecting, and reading symbolic links
 */

import java.nio.file.*;
import java.io.IOException;

public class SymbolicLinksHandling {
    
    /**
     * Creating symbolic links
     */
    public static void creatingSymbolicLinks() throws IOException {
        Path target = Paths.get("target-file.txt");
        Path link = Paths.get("link-to-target.txt");
        
        // Create target file
        Files.write(target, "Target content".getBytes());
        
        // Create symbolic link
        try {
            Files.createSymbolicLink(link, target);
            System.out.println("Created symlink: " + link + " -> " + target);
        } catch (UnsupportedOperationException e) {
            System.out.println("Symbolic links not supported");
        } catch (FileSystemException e) {
            System.out.println("Need permissions: " + e.getMessage());
        }
        
        // Cleanup
        Files.deleteIfExists(link);
        Files.delete(target);
        
        /**
         * CREATING SYMLINKS:
         * 
         * createSymbolicLink(link, target):
         * - link = path of the symlink
         * - target = path it points to (can be relative)
         * - Target doesn't need to exist
         * 
         * createLink(link, existing):
         * - Hard link (not symlink)
         * - Target must exist
         * - Not available on all systems
         * 
         * 
         * REQUIREMENTS:
         * 
         * Windows: Administrator or Developer Mode
         * Unix/Linux: Normal permissions
         * 
         * May throw:
         * - UnsupportedOperationException
         * - FileSystemException (permissions)
         */
    }
    
    /**
     * Detecting symbolic links
     */
    public static void detectingSymbolicLinks() throws IOException {
        Path target = Paths.get("target.txt");
        Path link = Paths.get("link.txt");
        
        Files.write(target, "Content".getBytes());
        
        try {
            Files.createSymbolicLink(link, target);
            
            System.out.println("=== Link Detection ===");
            
            // Check if symbolic link
            System.out.println("isSymbolicLink(target): " + 
                Files.isSymbolicLink(target));
            System.out.println("isSymbolicLink(link): " + 
                Files.isSymbolicLink(link));
            
            // Exists with different options
            System.out.println("\nexists(link, NOFOLLOW_LINKS): " + 
                Files.exists(link, LinkOption.NOFOLLOW_LINKS));
            System.out.println("exists(link): " + 
                Files.exists(link));
            
            // isRegularFile with different options
            System.out.println("\nisRegularFile(link, NOFOLLOW_LINKS): " + 
                Files.isRegularFile(link, LinkOption.NOFOLLOW_LINKS));
            System.out.println("isRegularFile(link): " + 
                Files.isRegularFile(link));
            
            Files.delete(link);
            
        } catch (UnsupportedOperationException e) {
            System.out.println("Symlinks not supported");
        }
        
        Files.delete(target);
        
        /**
         * LINK DETECTION:
         * 
         * isSymbolicLink(path):
         * - true if symlink
         * - Always checks link itself
         * 
         * With LinkOption.NOFOLLOW_LINKS:
         * - Check link itself
         * - Don't follow to target
         * 
         * Without LinkOption:
         * - Follow link to target
         * - Check target properties
         */
    }
    
    /**
     * Reading symbolic links
     */
    public static void readingSymbolicLinks() throws IOException {
        Path target = Paths.get("real-file.txt");
        Path link = Paths.get("link-file.txt");
        
        Files.write(target, "Target content".getBytes());
        
        try {
            Files.createSymbolicLink(link, target);
            
            System.out.println("=== Reading Symlink ===");
            
            // Read link target
            Path linkTarget = Files.readSymbolicLink(link);
            System.out.println("Link points to: " + linkTarget);
            
            // Resolve to real path
            Path realPath = link.toRealPath();
            System.out.println("Real path: " + realPath);
            
            // Read content through link
            String content = new String(Files.readAllBytes(link));
            System.out.println("Content via link: " + content);
            
            Files.delete(link);
            
        } catch (UnsupportedOperationException e) {
            System.out.println("Symlinks not supported");
        }
        
        Files.delete(target);
        
        /**
         * READING LINKS:
         * 
         * readSymbolicLink(path):
         * - Returns target path
         * - Throws if not a symlink
         * - Target may be relative
         * 
         * toRealPath():
         * - Resolves all symlinks
         * - Returns absolute path
         * - Throws if doesn't exist
         * 
         * toRealPath(NOFOLLOW_LINKS):
         * - Resolves parent symlinks
         * - Doesn't resolve final link
         */
    }
    
    /**
     * Broken links
     */
    public static void brokenLinks() throws IOException {
        Path link = Paths.get("broken-link.txt");
        Path missingTarget = Paths.get("missing-target.txt");
        
        try {
            // Create link to non-existent target
            Files.createSymbolicLink(link, missingTarget);
            
            System.out.println("=== Broken Link ===");
            
            // Link exists but target doesn't
            System.out.println("isSymbolicLink: " + Files.isSymbolicLink(link));
            System.out.println("exists(NOFOLLOW_LINKS): " + 
                Files.exists(link, LinkOption.NOFOLLOW_LINKS));
            System.out.println("exists: " + Files.exists(link));
            
            // Reading target works
            Path target = Files.readSymbolicLink(link);
            System.out.println("Target: " + target);
            
            // But accessing content fails
            try {
                Files.readAllBytes(link);
            } catch (NoSuchFileException e) {
                System.out.println("Cannot read through broken link");
            }
            
            Files.delete(link);
            
        } catch (UnsupportedOperationException e) {
            System.out.println("Symlinks not supported");
        }
        
        /**
         * BROKEN LINKS:
         * 
         * exists(link, NOFOLLOW_LINKS) → true
         * exists(link) → false
         * 
         * Link exists but target doesn't
         * Can read link target
         * Can't access through link
         */
    }
    
    /**
     * Link cycles
     */
    public static void linkCycles() throws IOException {
        Path link1 = Paths.get("link1.txt");
        Path link2 = Paths.get("link2.txt");
        
        try {
            // Create cycle: link1 → link2 → link1
            Files.createSymbolicLink(link1, link2);
            Files.createSymbolicLink(link2, link1);
            
            System.out.println("=== Link Cycle ===");
            
            // Cycle detected
            try {
                Path real = link1.toRealPath();
            } catch (IOException e) {
                System.out.println("Cycle detected: " + e.getClass().getSimpleName());
            }
            
            Files.delete(link1);
            Files.delete(link2);
            
        } catch (UnsupportedOperationException e) {
            System.out.println("Symlinks not supported");
        }
        
        /**
         * LINK CYCLES:
         * 
         * toRealPath() detects cycles
         * Throws IOException
         * 
         * Walking with FOLLOW_LINKS can loop
         * FileVisitor detects and handles
         */
    }
    
    /**
     * Copying and moving links
     */
    public static void copyingAndMovingLinks() throws IOException {
        Path target = Paths.get("original.txt");
        Path link = Paths.get("link.txt");
        Path linkCopy = Paths.get("link-copy.txt");
        
        Files.write(target, "Content".getBytes());
        
        try {
            Files.createSymbolicLink(link, target);
            
            System.out.println("=== Copying Links ===");
            
            // Copy following link (default)
            Files.copy(link, linkCopy);
            System.out.println("isSymbolicLink(copy): " + 
                Files.isSymbolicLink(linkCopy));  // false - copied content
            
            Files.delete(linkCopy);
            
            // Copy link itself
            Files.copy(link, linkCopy, LinkOption.NOFOLLOW_LINKS);
            System.out.println("isSymbolicLink(copy with NOFOLLOW): " + 
                Files.isSymbolicLink(linkCopy));  // true - copied link
            
            // Both links point to same target
            System.out.println("Original target: " + Files.readSymbolicLink(link));
            System.out.println("Copy target: " + Files.readSymbolicLink(linkCopy));
            
            Files.delete(link);
            Files.delete(linkCopy);
            
        } catch (UnsupportedOperationException e) {
            System.out.println("Symlinks not supported");
        }
        
        Files.delete(target);
        
        /**
         * COPYING LINKS:
         * 
         * Default: Follows link, copies target
         * NOFOLLOW_LINKS: Copies link itself
         * 
         * Moving: Always moves link itself
         */
    }
    
    /**
     * Best practices
     */
    public static void bestPractices() {
        /**
         * SYMLINK BEST PRACTICES:
         * 
         * 1. ALWAYS CHECK SUPPORT:
         *    try { createSymbolicLink() }
         *    catch (UnsupportedOperationException)
         * 
         * 2. USE NOFOLLOW_LINKS:
         *    When you want link properties
         *    Not target properties
         * 
         * 3. HANDLE BROKEN LINKS:
         *    Check exists(NOFOLLOW_LINKS)
         *    vs exists()
         * 
         * 4. DETECT CYCLES:
         *    Use FileVisitor
         *    Or catch IOException from toRealPath()
         * 
         * 5. CROSS-PLATFORM:
         *    Not all systems support symlinks
         *    Provide fallback behavior
         * 
         * 6. PERMISSIONS:
         *    Windows needs admin or Developer Mode
         *    Check and handle accordingly
         */
    }
    
    public static void main(String[] args) throws IOException {
        System.out.println("=== Creating Symbolic Links ===");
        creatingSymbolicLinks();
        
        System.out.println("\n=== Detecting Symbolic Links ===");
        detectingSymbolicLinks();
        
        System.out.println("\n=== Reading Symbolic Links ===");
        readingSymbolicLinks();
    }
}
```

---

## 7. Efficient File Copying

### High-Performance File Operations

```java
/**
 * EFFICIENT FILE COPYING
 * 
 * Optimal strategies for file copying
 */

import java.nio.file.*;
import java.nio.channels.*;
import java.io.*;

public class EfficientFileCopying {
    
    /**
     * Files.copy() - simple and efficient
     */
    public static void filesCopyMethod() throws IOException {
        Path source = Paths.get("source.txt");
        Path target = Paths.get("target.txt");
        
        // Create source
        Files.write(source, "Content".getBytes());
        
        // Simple copy
        Files.copy(source, target);
        System.out.println("Copied with Files.copy()");
        
        // Copy with options
        Files.copy(source, target, 
            StandardCopyOption.REPLACE_EXISTING,
            StandardCopyOption.COPY_ATTRIBUTES);
        
        Files.delete(source);
        Files.delete(target);
        
        /**
         * FILES.COPY():
         * 
         * Efficient implementation
         * Uses OS-specific optimizations
         * 
         * Options:
         * - REPLACE_EXISTING
         * - COPY_ATTRIBUTES
         * - NOFOLLOW_LINKS
         * 
         * Platform optimized
         * Often zero-copy
         */
    }
    
    /**
     * Channel transferTo() - zero-copy
     */
    public static void channelTransferTo() throws IOException {
        Path source = Paths.get("source-large.dat");
        Path target = Paths.get("target-large.dat");
        
        // Create large source file
        try (FileChannel channel = FileChannel.open(source,
                StandardOpenOption.CREATE, StandardOpenOption.WRITE)) {
            channel.write(ByteBuffer.allocate(10 * 1024 * 1024));  // 10 MB
        }
        
        long start = System.nanoTime();
        
        // Zero-copy transfer
        try (FileChannel sourceChannel = FileChannel.open(source, StandardOpenOption.READ);
             FileChannel targetChannel = FileChannel.open(target,
                StandardOpenOption.CREATE, StandardOpenOption.WRITE)) {
            
            long position = 0;
            long size = sourceChannel.size();
            
            while (position < size) {
                position += sourceChannel.transferTo(position, size - position, targetChannel);
            }
        }
        
        long time = System.nanoTime() - start;
        System.out.println("transferTo() took: " + time / 1_000_000 + " ms");
        
        Files.delete(source);
        Files.delete(target);
        
        /**
         * TRANSFERTO():
         * 
         * Zero-copy operation
         * Direct kernel-to-kernel transfer
         * No user-space buffer
         * 
         * Fastest for large files
         * OS-level optimization
         * 
         * Platform: sendfile() on Linux
         */
    }
    
    /**
     * Stream copying
     */
    public static void streamCopying() throws IOException {
        Path source = Paths.get("source-stream.dat");
        Path target = Paths.get("target-stream.dat");
        
        Files.write(source, new byte[1024 * 1024]);  // 1 MB
        
        long start = System.nanoTime();
        
        // Stream copy
        try (InputStream in = Files.newInputStream(source);
             OutputStream out = Files.newOutputStream(target)) {
            in.transferTo(out);
        }
        
        long time = System.nanoTime() - start;
        System.out.println("Stream transferTo() took: " + time / 1_000_000 + " ms");
        
        Files.delete(source);
        Files.delete(target);
        
        /**
         * STREAM TRANSFERTO() (Java 9+):
         * 
         * InputStream.transferTo(OutputStream)
         * 
         * Convenient
         * Buffered internally
         * Not as fast as channel transfer
         * 
         * Good for moderate files
         */
    }
    
    /**
     * Performance comparison
     */
    public static void performanceComparison() throws IOException {
        Path source = Paths.get("perf-source.dat");
        Path target = Paths.get("perf-target.dat");
        
        // Create 50 MB file
        long size = 50 * 1024 * 1024;
        try (FileChannel channel = FileChannel.open(source,
                StandardOpenOption.CREATE, StandardOpenOption.WRITE)) {
            channel.write(ByteBuffer.allocate((int) size));
        }
        
        // Method 1: Files.copy()
        long start = System.nanoTime();
        Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);
        long filesCopyTime = System.nanoTime() - start;
        Files.delete(target);
        
        // Method 2: Channel transferTo()
        start = System.nanoTime();
        try (FileChannel src = FileChannel.open(source, StandardOpenOption.READ);
             FileChannel dst = FileChannel.open(target,
                StandardOpenOption.CREATE, StandardOpenOption.WRITE)) {
            src.transferTo(0, src.size(), dst);
        }
        long transferToTime = System.nanoTime() - start;
        Files.delete(target);
        
        // Method 3: Stream copy
        start = System.nanoTime();
        try (InputStream in = new BufferedInputStream(Files.newInputStream(source));
             OutputStream out = new BufferedOutputStream(Files.newOutputStream(target))) {
            byte[] buffer = new byte[8192];
            int bytesRead;
            while ((bytesRead = in.read(buffer)) != -1) {
                out.write(buffer, 0, bytesRead);
            }
        }
        long streamCopyTime = System.nanoTime() - start;
        Files.delete(target);
        
        // Method 4: Memory-mapped
        start = System.nanoTime();
        try (FileChannel src = FileChannel.open(source, StandardOpenOption.READ);
             FileChannel dst = FileChannel.open(target,
                StandardOpenOption.CREATE, StandardOpenOption.WRITE)) {
            MappedByteBuffer buffer = src.map(FileChannel.MapMode.READ_ONLY, 0, src.size());
            dst.write(buffer);
        }
        long mappedTime = System.nanoTime() - start;
        
        System.out.println("=== Performance (50 MB) ===");
        System.out.println("Files.copy():       " + filesCopyTime / 1_000_000 + " ms");
        System.out.println("transferTo():       " + transferToTime / 1_000_000 + " ms");
        System.out.println("Stream copy:        " + streamCopyTime / 1_000_000 + " ms");
        System.out.println("Memory-mapped:      " + mappedTime / 1_000_000 + " ms");
        
        Files.delete(source);
        Files.delete(target);
        
        /**
         * TYPICAL RESULTS:
         * 
         * transferTo() - fastest (zero-copy)
         * Memory-mapped - very fast
         * Files.copy() - fast (optimized)
         * Stream copy - slowest (buffering overhead)
         * 
         * 
         * RECOMMENDATIONS:
         * 
         * Large files: transferTo() or Files.copy()
         * Small files: Files.copy() (simpler)
         * Network: Stream copy (compatibility)
         */
    }
    
    /**
     * Copying directories
     */
    public static void copyingDirectories() throws IOException {
        Path source = Paths.get("source-dir");
        Path target = Paths.get("target-dir");
        
        // Create source directory
        Files.createDirectories(source.resolve("subdir"));
        Files.write(source.resolve("file1.txt"), "Content 1".getBytes());
        Files.write(source.resolve("subdir/file2.txt"), "Content 2".getBytes());
        
        // Copy directory tree
        Files.walkFileTree(source, new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs)
                    throws IOException {
                Path targetDir = target.resolve(source.relativize(dir));
                Files.createDirectories(targetDir);
                return FileVisitResult.CONTINUE;
            }
            
            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)
                    throws IOException {
                Files.copy(file, target.resolve(source.relativize(file)),
                    StandardCopyOption.REPLACE_EXISTING);
                return FileVisitResult.CONTINUE;
            }
        });
        
        System.out.println("Copied directory tree");
        
        // Cleanup
        Files.walk(source).sorted(Comparator.reverseOrder())
             .forEach(p -> { try { Files.delete(p); } catch (IOException e) {} });
        Files.walk(target).sorted(Comparator.reverseOrder())
             .forEach(p -> { try { Files.delete(p); } catch (IOException e) {} });
        
        /**
         * DIRECTORY COPY PATTERN:
         * 
         * No built-in recursive copy
         * Use FileVisitor pattern
         * 
         * preVisitDirectory: Create dirs
         * visitFile: Copy files
         * 
         * Preserves structure
         */
    }
    
    /**
     * Best practices
     */
    public static void bestPractices() {
        /**
         * FILE COPYING BEST PRACTICES:
         * 
         * 1. CHOOSE RIGHT METHOD:
         *    Small files: Files.copy()
         *    Large files: transferTo() or Files.copy()
         *    Directories: FileVisitor
         * 
         * 2. USE APPROPRIATE OPTIONS:
         *    REPLACE_EXISTING - overwrite
         *    COPY_ATTRIBUTES - preserve metadata
         *    NOFOLLOW_LINKS - handle symlinks
         * 
         * 3. ERROR HANDLING:
         *    Handle FileAlreadyExistsException
         *    Check disk space
         *    Verify after copy
         * 
         * 4. ATOMIC OPERATIONS:
         *    Copy to temp, then move
         *    ATOMIC_MOVE for consistency
         * 
         * 5. PROGRESS MONITORING:
         *    For large files
         *    Update UI
         *    Allow cancellation
         * 
         * 6. CLEANUP:
         *    Delete temp files
         *    Handle partial copies
         */
    }
    
    public static void main(String[] args) throws IOException {
        System.out.println("=== Files.copy() ===");
        filesCopyMethod();
        
        System.out.println("\n=== Channel transferTo() ===");
        channelTransferTo();
        
        System.out.println("\n=== Performance Comparison ===");
        performanceComparison();
    }
}
```

---

## Summary

### Quick Reference

**Path vs File:**

```java
// Old way (File)
File file = new File("data.txt");
boolean created = file.createNewFile();  // Returns boolean

// New way (Path)
Path path = Paths.get("data.txt");
Files.createFile(path);  // Throws exception with details

// Conversion
Path path = file.toPath();
File file = path.toFile();
```

**Common Operations:**

```java
// Creating
Files.createFile(path);
Files.createDirectory(path);
Files.createDirectories(path);  // With parents

// Reading/Writing
Files.readAllBytes(path);
Files.readAllLines(path);
Files.readString(path);  // Java 11+
Files.write(path, bytes);
Files.write(path, lines);
Files.writeString(path, content);  // Java 11+

// Checking
Files.exists(path);
Files.isRegularFile(path);
Files.isDirectory(path);
Files.isReadable(path);
Files.size(path);

// Copying/Moving
Files.copy(source, target, REPLACE_EXISTING);
Files.move(source, target, ATOMIC_MOVE);

// Deleting
Files.delete(path);
Files.deleteIfExists(path);
```

**Walking Trees:**

```java
// Stream API
Files.walk(start, maxDepth)
     .filter(Files::isRegularFile)
     .forEach(System.out::println);

// With filter
Files.find(start, maxDepth, (path, attrs) -> 
    attrs.size() > 1024)
     .forEach(System.out::println);

// Visitor pattern
Files.walkFileTree(start, new SimpleFileVisitor<Path>() {
    @Override
    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
        // Process file
        return FileVisitResult.CONTINUE;
    }
});
```

**Attributes:**

```java
// Basic attributes
BasicFileAttributes attrs = Files.readAttributes(path, BasicFileAttributes.class);
attrs.size();
attrs.lastModifiedTime();
attrs.isDirectory();

// Single attribute
Files.getAttribute(path, "basic:size");
Files.setAttribute(path, "basic:lastModifiedTime", time);

// POSIX permissions
Set<PosixFilePermission> perms = PosixFilePermissions.fromString("rwxr-xr-x");
Files.setPosixFilePermissions(path, perms);
```

**WatchService:**

```java
WatchService watchService = FileSystems.getDefault().newWatchService();
path.register(watchService, ENTRY_CREATE, ENTRY_MODIFY, ENTRY_DELETE);

while (true) {
    WatchKey key = watchService.take();
    for (WatchEvent<?> event : key.pollEvents()) {
        System.out.println(event.kind() + ": " + event.context());
    }
    key.reset();
}
```

**Symbolic Links:**

```java
// Create
Files.createSymbolicLink(link, target);

// Detect
Files.isSymbolicLink(path);

// Read target
Path target = Files.readSymbolicLink(link);

// Real path
Path real = path.toRealPath();

// Copy link itself
Files.copy(link, copy, LinkOption.NOFOLLOW_LINKS);
```

### Comparison Tables

**Path vs File:**

```
┌──────────────────┬─────────────────┬─────────────────────┐
│ Operation        │ File (legacy)   │ Path (modern)       │
├──────────────────┼─────────────────┼─────────────────────┤
│ Create file      │ createNewFile() │ Files.createFile()  │
│ Delete           │ delete()        │ Files.delete()      │
│ Exists           │ exists()        │ Files.exists()      │
│ List directory   │ listFiles()     │ Files.list()        │
│ Error handling   │ boolean         │ Exception           │
│ Symlink support  │ No              │ Yes                 │
│ Attributes       │ Limited         │ Comprehensive       │
└──────────────────┴─────────────────┴─────────────────────┘
```

**Performance:**

```
File Operation          Small Files    Large Files
────────────────────────────────────────────────────
Files.copy()            Fast           Fast
Channel transferTo()    Overhead       Fastest
Stream copy             OK             Slow
Memory-mapped           Overhead       Very Fast
```

### Best Practices

**✅ DO:**

- Use Path API in all new code
- Always use try-with-resources for streams
- Check Files.exists() before operations
- Use Files.walk() for recursive operations
- Handle symbolic links explicitly
- Use LinkOption when appropriate
- Close WatchService when done
- Use Files.copy() for simple cases
- Use transferTo() for large files

**❌ DON'T:**

- Use File class in new code
- Forget to close directory streams
- Assume symlink behavior
- Follow links in recursive walks (cycles!)
- Forget to reset() WatchKey
- Read entire large files into memory
- Ignore platform differences
- Mix File and Path APIs unnecessarily

---
