# Network Programming Fundamentals

## Overview

Network programming in Java has evolved significantly from basic Socket/ServerSocket to non-blocking NIO, and now to the modern HTTP Client API (Java 11+). This guide covers traditional blocking sockets, scalable NIO selectors, HTTP clients, SSL/TLS configuration, connection pooling strategies, and timeout handling patterns essential for production systems.

---

## 1. Socket and ServerSocket

### Basic TCP Networking

```java
/**
 * SOCKET AND SERVERSOCKET
 * 
 * Traditional blocking TCP networking
 */

import java.net.*;
import java.io.*;
import java.util.concurrent.*;

public class SocketAndServerSocket {
    
    /**
     * Basic TCP server
     */
    public static void basicTcpServer() throws IOException {
        int port = 8080;
        
        try (ServerSocket serverSocket = new ServerSocket(port)) {
            System.out.println("Server listening on port " + port);
            
            // Accept client connection (blocks)
            Socket clientSocket = serverSocket.accept();
            System.out.println("Client connected: " + clientSocket.getRemoteSocketAddress());
            
            // Get input/output streams
            try (BufferedReader in = new BufferedReader(
                    new InputStreamReader(clientSocket.getInputStream()));
                 PrintWriter out = new PrintWriter(
                    clientSocket.getOutputStream(), true)) {
                
                // Read from client
                String message = in.readLine();
                System.out.println("Received: " + message);
                
                // Send response
                out.println("Echo: " + message);
            }
            
            clientSocket.close();
        }
        
        /**
         * BASIC SERVER FLOW:
         * 
         * 1. Create ServerSocket(port)
         * 2. accept() - blocks until client connects
         * 3. Get input/output streams
         * 4. Read/write data
         * 5. Close connection
         * 
         * BLOCKING OPERATIONS:
         * - accept() blocks until connection
         * - read() blocks until data available
         * - Thread dedicated to each client
         */
    }
    
    /**
     * Basic TCP client
     */
    public static void basicTcpClient() throws IOException {
        String host = "localhost";
        int port = 8080;
        
        try (Socket socket = new Socket(host, port)) {
            System.out.println("Connected to " + socket.getRemoteSocketAddress());
            
            try (PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
                 BufferedReader in = new BufferedReader(
                    new InputStreamReader(socket.getInputStream()))) {
                
                // Send message
                out.println("Hello, Server!");
                
                // Read response
                String response = in.readLine();
                System.out.println("Response: " + response);
            }
        }
        
        /**
         * BASIC CLIENT FLOW:
         * 
         * 1. Create Socket(host, port)
         * 2. Connect (automatic in constructor)
         * 3. Get input/output streams
         * 4. Write/read data
         * 5. Close connection
         */
    }
    
    /**
     * Multi-threaded server
     */
    public static void multiThreadedServer() throws IOException {
        int port = 8081;
        ExecutorService threadPool = Executors.newFixedThreadPool(10);
        
        try (ServerSocket serverSocket = new ServerSocket(port)) {
            System.out.println("Multi-threaded server on port " + port);
            
            while (true) {
                // Accept client
                Socket clientSocket = serverSocket.accept();
                
                // Handle in thread pool
                threadPool.submit(() -> handleClient(clientSocket));
            }
        } finally {
            threadPool.shutdown();
        }
        
        /**
         * MULTI-THREADED PATTERN:
         * 
         * 1. Accept connection on main thread
         * 2. Submit to thread pool
         * 3. Handle client in worker thread
         * 4. Thread returns to pool
         * 
         * BENEFITS:
         * - Handle multiple clients
         * - Thread pool limits resources
         * - Better than thread-per-client
         * 
         * LIMITATIONS:
         * - Still one thread per connection
         * - Doesn't scale to thousands
         */
    }
    
    private static void handleClient(Socket socket) {
        try (BufferedReader in = new BufferedReader(
                new InputStreamReader(socket.getInputStream()));
             PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {
            
            String line;
            while ((line = in.readLine()) != null) {
                System.out.println("Received: " + line);
                out.println("Echo: " + line);
                
                if ("quit".equalsIgnoreCase(line.trim())) {
                    break;
                }
            }
            
        } catch (IOException e) {
            System.err.println("Error handling client: " + e.getMessage());
        } finally {
            try {
                socket.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    
    /**
     * Socket options
     */
    public static void socketOptions() throws IOException {
        Socket socket = new Socket();
        
        // Connection timeout
        socket.connect(new InetSocketAddress("example.com", 80), 5000);
        
        // Read timeout
        socket.setSoTimeout(10000);  // 10 seconds
        
        // TCP_NODELAY (disable Nagle's algorithm)
        socket.setTcpNoDelay(true);
        
        // Keep-alive
        socket.setKeepAlive(true);
        
        // Reuse address
        socket.setReuseAddress(true);
        
        // Send/receive buffer sizes
        socket.setSendBufferSize(64 * 1024);
        socket.setReceiveBufferSize(64 * 1024);
        
        // Linger on close
        socket.setSoLinger(true, 30);
        
        socket.close();
        
        /**
         * SOCKET OPTIONS:
         * 
         * setSoTimeout():
         * - Read timeout
         * - Throws SocketTimeoutException
         * - 0 = infinite wait
         * 
         * setTcpNoDelay():
         * - true = disable Nagle's algorithm
         * - Send small packets immediately
         * - Better for interactive apps
         * 
         * setKeepAlive():
         * - Send keepalive probes
         * - Detect dead connections
         * - OS-dependent behavior
         * 
         * setReuseAddress():
         * - Reuse local address
         * - Useful for server restart
         * 
         * setSoLinger():
         * - Behavior on close()
         * - Wait for data to be sent
         */
    }
    
    /**
     * Binary protocol example
     */
    public static void binaryProtocol() throws IOException {
        // Server side
        Thread serverThread = new Thread(() -> {
            try (ServerSocket server = new ServerSocket(8082)) {
                Socket client = server.accept();
                
                DataInputStream in = new DataInputStream(client.getInputStream());
                DataOutputStream out = new DataOutputStream(client.getOutputStream());
                
                // Read binary data
                int value = in.readInt();
                String text = in.readUTF();
                
                System.out.println("Received: " + value + ", " + text);
                
                // Send binary response
                out.writeInt(value * 2);
                out.writeUTF("Processed: " + text);
                out.flush();
                
                client.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        });
        
        serverThread.start();
        Thread.sleep(100);
        
        // Client side
        try (Socket socket = new Socket("localhost", 8082)) {
            DataOutputStream out = new DataOutputStream(socket.getOutputStream());
            DataInputStream in = new DataInputStream(socket.getInputStream());
            
            // Send binary data
            out.writeInt(42);
            out.writeUTF("Hello");
            out.flush();
            
            // Read binary response
            int result = in.readInt();
            String response = in.readUTF();
            
            System.out.println("Response: " + result + ", " + response);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        /**
         * BINARY PROTOCOLS:
         * 
         * Use DataInputStream/DataOutputStream
         * 
         * Methods:
         * - writeInt/readInt
         * - writeLong/readLong
         * - writeUTF/readUTF
         * - writeBoolean/readBoolean
         * 
         * Benefits:
         * - Compact
         * - Type-safe
         * - Fast
         * 
         * Considerations:
         * - Byte order (big-endian)
         * - Protocol versioning
         * - Error handling
         */
    }
    
    /**
     * Socket limitations
     */
    public static void socketLimitations() {
        /**
         * TRADITIONAL SOCKET LIMITATIONS:
         * 
         * 1. BLOCKING I/O:
         *    - accept() blocks
         *    - read() blocks
         *    - write() can block
         *    - Thread waits
         * 
         * 2. SCALABILITY:
         *    - One thread per connection
         *    - 1000 clients = 1000 threads
         *    - High memory usage
         *    - Context switching overhead
         * 
         * 3. RESOURCE USAGE:
         *    - Each thread: ~1 MB stack
         *    - File descriptors limited
         *    - OS limits
         * 
         * 4. NO MULTIPLEXING:
         *    - Can't monitor multiple sockets
         *    - One thread = one socket
         * 
         * 
         * SOLUTIONS:
         * 
         * - NIO with Selector (next section)
         * - Event-driven architecture
         * - Async I/O
         */
    }
    
    public static void main(String[] args) throws Exception {
        System.out.println("Socket and ServerSocket examples");
        System.out.println("Run server and client in separate JVMs");
    }
}
```

---

## 2. NIO Sockets with Selector

### Scalable Non-Blocking I/O

```java
/**
 * NIO SOCKETS WITH SELECTOR
 * 
 * Non-blocking I/O for scalable servers
 */

import java.nio.*;
import java.nio.channels.*;
import java.net.*;
import java.io.IOException;
import java.util.*;

public class NIOSocketsWithSelector {
    
    /**
     * Non-blocking server with Selector
     */
    static class NonBlockingServer {
        private Selector selector;
        private ServerSocketChannel serverChannel;
        private Map<SocketChannel, ByteBuffer> clientBuffers = new HashMap<>();
        
        public void start(int port) throws IOException {
            // Create selector
            selector = Selector.open();
            
            // Create server channel
            serverChannel = ServerSocketChannel.open();
            serverChannel.bind(new InetSocketAddress(port));
            serverChannel.configureBlocking(false);
            
            // Register for accept events
            serverChannel.register(selector, SelectionKey.OP_ACCEPT);
            
            System.out.println("Non-blocking server on port " + port);
            
            // Event loop
            while (true) {
                // Wait for events
                int readyChannels = selector.select();
                
                if (readyChannels == 0) {
                    continue;
                }
                
                // Process ready keys
                Set<SelectionKey> selectedKeys = selector.selectedKeys();
                Iterator<SelectionKey> keyIterator = selectedKeys.iterator();
                
                while (keyIterator.hasNext()) {
                    SelectionKey key = keyIterator.next();
                    
                    if (key.isAcceptable()) {
                        handleAccept(key);
                    } else if (key.isReadable()) {
                        handleRead(key);
                    } else if (key.isWritable()) {
                        handleWrite(key);
                    }
                    
                    keyIterator.remove();
                }
            }
        }
        
        private void handleAccept(SelectionKey key) throws IOException {
            ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();
            SocketChannel clientChannel = serverChannel.accept();
            
            if (clientChannel != null) {
                clientChannel.configureBlocking(false);
                clientChannel.register(selector, SelectionKey.OP_READ);
                
                clientBuffers.put(clientChannel, ByteBuffer.allocate(1024));
                
                System.out.println("Accepted: " + clientChannel.getRemoteAddress());
            }
        }
        
        private void handleRead(SelectionKey key) throws IOException {
            SocketChannel channel = (SocketChannel) key.channel();
            ByteBuffer buffer = clientBuffers.get(channel);
            
            int bytesRead = channel.read(buffer);
            
            if (bytesRead == -1) {
                // Connection closed
                clientBuffers.remove(channel);
                channel.close();
                System.out.println("Client disconnected");
                return;
            }
            
            if (bytesRead > 0) {
                buffer.flip();
                
                // Echo back
                key.interestOps(SelectionKey.OP_WRITE);
            }
        }
        
        private void handleWrite(SelectionKey key) throws IOException {
            SocketChannel channel = (SocketChannel) key.channel();
            ByteBuffer buffer = clientBuffers.get(channel);
            
            channel.write(buffer);
            
            if (!buffer.hasRemaining()) {
                buffer.clear();
                key.interestOps(SelectionKey.OP_READ);
            }
        }
        
        /**
         * NIO SELECTOR PATTERN:
         * 
         * 1. Create Selector
         * 2. Create ServerSocketChannel
         * 3. Set non-blocking
         * 4. Register with Selector
         * 5. Event loop:
         *    a. select() - blocks until events
         *    b. Get selected keys
         *    c. Process each key
         *    d. Remove processed keys
         * 
         * 
         * OPERATIONS:
         * 
         * OP_ACCEPT - new connection
         * OP_CONNECT - connection complete
         * OP_READ - data to read
         * OP_WRITE - ready to write
         * 
         * 
         * BENEFITS:
         * 
         * - One thread, many connections
         * - 10,000+ connections possible
         * - Efficient CPU usage
         * - No thread overhead
         */
    }
    
    /**
     * Non-blocking client
     */
    static class NonBlockingClient {
        public void connect(String host, int port) throws IOException {
            SocketChannel channel = SocketChannel.open();
            channel.configureBlocking(false);
            
            // Start connection
            channel.connect(new InetSocketAddress(host, port));
            
            Selector selector = Selector.open();
            channel.register(selector, SelectionKey.OP_CONNECT);
            
            while (true) {
                selector.select();
                
                Set<SelectionKey> keys = selector.selectedKeys();
                Iterator<SelectionKey> iterator = keys.iterator();
                
                while (iterator.hasNext()) {
                    SelectionKey key = iterator.next();
                    iterator.remove();
                    
                    if (key.isConnectable()) {
                        handleConnect(key);
                    } else if (key.isReadable()) {
                        handleRead(key);
                        return;  // Done for this example
                    } else if (key.isWritable()) {
                        handleWrite(key);
                    }
                }
            }
        }
        
        private void handleConnect(SelectionKey key) throws IOException {
            SocketChannel channel = (SocketChannel) key.channel();
            
            if (channel.finishConnect()) {
                System.out.println("Connected to server");
                key.interestOps(SelectionKey.OP_WRITE);
            }
        }
        
        private void handleWrite(SelectionKey key) throws IOException {
            SocketChannel channel = (SocketChannel) key.channel();
            
            ByteBuffer buffer = ByteBuffer.wrap("Hello, NIO Server!".getBytes());
            channel.write(buffer);
            
            key.interestOps(SelectionKey.OP_READ);
        }
        
        private void handleRead(SelectionKey key) throws IOException {
            SocketChannel channel = (SocketChannel) key.channel();
            
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            int bytesRead = channel.read(buffer);
            
            if (bytesRead > 0) {
                buffer.flip();
                byte[] data = new byte[buffer.remaining()];
                buffer.get(data);
                
                System.out.println("Received: " + new String(data));
            }
            
            channel.close();
        }
    }
    
    /**
     * Reactor pattern implementation
     */
    static class ReactorServer {
        private Selector selector;
        private ServerSocketChannel serverChannel;
        
        public void start(int port) throws IOException {
            selector = Selector.open();
            serverChannel = ServerSocketChannel.open();
            serverChannel.bind(new InetSocketAddress(port));
            serverChannel.configureBlocking(false);
            serverChannel.register(selector, SelectionKey.OP_ACCEPT);
            
            System.out.println("Reactor server on port " + port);
            
            // Reactor event loop
            while (true) {
                selector.select();
                
                for (SelectionKey key : selector.selectedKeys()) {
                    dispatch(key);
                }
                
                selector.selectedKeys().clear();
            }
        }
        
        private void dispatch(SelectionKey key) {
            try {
                if (key.isAcceptable()) {
                    accept(key);
                } else if (key.isReadable()) {
                    read(key);
                } else if (key.isWritable()) {
                    write(key);
                }
            } catch (IOException e) {
                try {
                    key.channel().close();
                } catch (IOException ex) {
                    ex.printStackTrace();
                }
            }
        }
        
        private void accept(SelectionKey key) throws IOException {
            ServerSocketChannel server = (ServerSocketChannel) key.channel();
            SocketChannel client = server.accept();
            
            if (client != null) {
                client.configureBlocking(false);
                client.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(1024));
            }
        }
        
        private void read(SelectionKey key) throws IOException {
            SocketChannel channel = (SocketChannel) key.channel();
            ByteBuffer buffer = (ByteBuffer) key.attachment();
            
            int bytesRead = channel.read(buffer);
            
            if (bytesRead == -1) {
                channel.close();
                return;
            }
            
            if (bytesRead > 0) {
                buffer.flip();
                key.interestOps(SelectionKey.OP_WRITE);
            }
        }
        
        private void write(SelectionKey key) throws IOException {
            SocketChannel channel = (SocketChannel) key.channel();
            ByteBuffer buffer = (ByteBuffer) key.attachment();
            
            channel.write(buffer);
            
            if (!buffer.hasRemaining()) {
                buffer.clear();
                key.interestOps(SelectionKey.OP_READ);
            }
        }
        
        /**
         * REACTOR PATTERN:
         * 
         * Single thread, event-driven
         * 
         * Components:
         * 1. Reactor - event loop (selector.select())
         * 2. Handlers - process events (accept/read/write)
         * 3. Dispatcher - routes to handlers
         * 
         * Benefits:
         * - Scalable
         * - Low latency
         * - Efficient
         * 
         * Limitations:
         * - Single thread
         * - Can't use multiple cores
         * - Blocking operations problematic
         */
    }
    
    /**
     * Multi-reactor pattern (multiple threads)
     */
    public static void multiReactorPattern() {
        /**
         * MULTI-REACTOR PATTERN:
         * 
         * Main reactor: Accept connections
         * Sub reactors: Handle I/O
         * 
         * Architecture:
         * 
         * Main Reactor (Thread 1)
         * ├─ Accept connections
         * └─ Distribute to sub-reactors
         * 
         * Sub Reactor 1 (Thread 2)
         * ├─ Handle client 1
         * ├─ Handle client 2
         * └─ ...
         * 
         * Sub Reactor 2 (Thread 3)
         * ├─ Handle client N
         * └─ ...
         * 
         * 
         * Implementation:
         * 
         * 1. Main thread runs selector for accept
         * 2. On accept, round-robin to sub-reactor
         * 3. Sub-reactors handle read/write
         * 4. Uses multiple CPU cores
         * 
         * 
         * Benefits:
         * - Scales with CPU cores
         * - Better throughput
         * - Load balancing
         */
    }
    
    /**
     * Best practices
     */
    public static void bestPractices() {
        /**
         * NIO SELECTOR BEST PRACTICES:
         * 
         * 1. ALWAYS REMOVE SELECTED KEYS:
         *    selectedKeys().clear()
         *    Or remove in loop
         *    Otherwise infinite loop
         * 
         * 2. HANDLE ALL KEY STATES:
         *    Check isAcceptable/isReadable/isWritable
         *    Don't assume
         * 
         * 3. CHECK CHANNEL VALIDITY:
         *    if (!key.isValid()) continue;
         *    Channel may be closed
         * 
         * 4. BUFFER MANAGEMENT:
         *    Attach buffers to keys
         *    Or use map
         *    Reuse buffers
         * 
         * 5. ERROR HANDLING:
         *    Close channel on error
         *    Cancel key
         *    Remove from structures
         * 
         * 6. AVOID BLOCKING:
         *    Don't block in event loop
         *    Offload to thread pool if needed
         * 
         * 7. WAKE UP SELECTOR:
         *    selector.wakeup() to interrupt select()
         *    For shutdown
         */
    }
    
    public static void main(String[] args) throws Exception {
        System.out.println("NIO Selector examples");
        System.out.println("Use NonBlockingServer and NonBlockingClient classes");
    }
}
```

---

## 3. URL and URLConnection

### Legacy HTTP Client

```java
/**
 * URL AND URLCONNECTION
 * 
 * Legacy HTTP client (pre-Java 11)
 */

import java.net.*;
import java.io.*;
import java.util.*;

public class URLAndURLConnection {
    
    /**
     * Basic URL usage
     */
    public static void basicUrlUsage() throws Exception {
        URL url = new URL("https://api.github.com/users/octocat");
        
        // URL components
        System.out.println("Protocol: " + url.getProtocol());
        System.out.println("Host: " + url.getHost());
        System.out.println("Port: " + url.getPort());
        System.out.println("Path: " + url.getPath());
        System.out.println("Query: " + url.getQuery());
        System.out.println("Ref: " + url.getRef());
        
        /**
         * URL STRUCTURE:
         * 
         * https://example.com:8080/path?query=value#fragment
         * ├─ protocol: https
         * ├─ host: example.com
         * ├─ port: 8080 (-1 if default)
         * ├─ path: /path
         * ├─ query: query=value
         * └─ ref: fragment
         */
    }
    
    /**
     * Simple HTTP GET
     */
    public static void simpleHttpGet() throws Exception {
        URL url = new URL("https://api.github.com/");
        
        try (InputStream in = url.openStream();
             BufferedReader reader = new BufferedReader(
                new InputStreamReader(in))) {
            
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
        }
        
        /**
         * SIMPLE GET:
         * 
         * url.openStream() - opens connection
         * Returns InputStream
         * Read like any stream
         * 
         * Limitations:
         * - No headers
         * - No HTTP details
         * - Always GET
         */
    }
    
    /**
     * URLConnection for more control
     */
    public static void urlConnectionExample() throws Exception {
        URL url = new URL("https://api.github.com/users/octocat");
        URLConnection connection = url.openConnection();
        
        // Set request headers
        connection.setRequestProperty("User-Agent", "Java URLConnection");
        connection.setRequestProperty("Accept", "application/json");
        
        // Set timeout
        connection.setConnectTimeout(5000);
        connection.setReadTimeout(10000);
        
        // Connect
        connection.connect();
        
        // Get response headers
        System.out.println("Content-Type: " + connection.getContentType());
        System.out.println("Content-Length: " + connection.getContentLength());
        System.out.println("Last-Modified: " + new Date(connection.getLastModified()));
        
        // Read response
        try (BufferedReader reader = new BufferedReader(
                new InputStreamReader(connection.getInputStream()))) {
            
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
        }
        
        /**
         * URLCONNECTION:
         * 
         * More control than URL.openStream()
         * 
         * Methods:
         * - setRequestProperty() - set headers
         * - setConnectTimeout() - connection timeout
         * - setReadTimeout() - read timeout
         * - connect() - explicit connect
         * - getContentType() - response header
         * - getInputStream() - response body
         */
    }
    
    /**
     * HTTP POST request
     */
    public static void httpPostRequest() throws Exception {
        URL url = new URL("https://httpbin.org/post");
        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
        
        // Configure for POST
        connection.setRequestMethod("POST");
        connection.setDoOutput(true);
        connection.setRequestProperty("Content-Type", "application/json");
        
        // Write request body
        String json = "{\"name\":\"Alice\",\"age\":30}";
        try (OutputStream out = connection.getOutputStream()) {
            out.write(json.getBytes());
            out.flush();
        }
        
        // Get response code
        int responseCode = connection.getResponseCode();
        System.out.println("Response Code: " + responseCode);
        
        // Read response
        try (BufferedReader reader = new BufferedReader(
                new InputStreamReader(connection.getInputStream()))) {
            
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
        }
        
        connection.disconnect();
        
        /**
         * HTTP POST:
         * 
         * 1. Cast to HttpURLConnection
         * 2. setRequestMethod("POST")
         * 3. setDoOutput(true)
         * 4. Set Content-Type
         * 5. Write to OutputStream
         * 6. Read response
         * 
         * Methods:
         * - POST, GET, PUT, DELETE, etc.
         */
    }
    
    /**
     * Handle error responses
     */
    public static void handleErrorResponses() throws Exception {
        URL url = new URL("https://httpbin.org/status/404");
        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
        
        int responseCode = connection.getResponseCode();
        System.out.println("Response Code: " + responseCode);
        
        if (responseCode >= 200 && responseCode < 300) {
            // Success - read from getInputStream()
            try (BufferedReader reader = new BufferedReader(
                    new InputStreamReader(connection.getInputStream()))) {
                // Read response...
            }
        } else {
            // Error - read from getErrorStream()
            try (BufferedReader reader = new BufferedReader(
                    new InputStreamReader(connection.getErrorStream()))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    System.err.println(line);
                }
            }
        }
        
        connection.disconnect();
        
        /**
         * ERROR HANDLING:
         * 
         * Response codes:
         * - 2xx: Success → getInputStream()
         * - 4xx/5xx: Error → getErrorStream()
         * 
         * Check responseCode first
         * Read from appropriate stream
         */
    }
    
    /**
     * Following redirects
     */
    public static void followingRedirects() throws Exception {
        URL url = new URL("https://httpbin.org/redirect/2");
        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
        
        // Follow redirects (default is true)
        connection.setInstanceFollowRedirects(true);
        
        // Or set globally
        HttpURLConnection.setFollowRedirects(true);
        
        connection.connect();
        
        System.out.println("Final URL: " + connection.getURL());
        System.out.println("Response Code: " + connection.getResponseCode());
        
        /**
         * REDIRECTS:
         * 
         * setInstanceFollowRedirects() - per connection
         * setFollowRedirects() - global
         * 
         * Default: true
         * Automatically follows 3xx redirects
         * 
         * Max redirects: 20 (hardcoded)
         */
    }
    
    /**
     * URLConnection limitations
     */
    public static void urlConnectionLimitations() {
        /**
         * URLCONNECTION LIMITATIONS:
         * 
         * 1. VERBOSE:
         *    Lots of boilerplate
         *    Manual stream management
         *    Complex for simple tasks
         * 
         * 2. NO HTTP/2:
         *    Only HTTP/1.1
         *    No server push
         *    No multiplexing
         * 
         * 3. NO ASYNC:
         *    Always blocking
         *    No CompletableFuture
         *    Must use threads
         * 
         * 4. POOR API:
         *    Mutable state
         *    Error-prone
         *    Hard to use correctly
         * 
         * 5. NO AUTHENTICATION:
         *    Manual header management
         *    No built-in auth
         * 
         * 6. NO CONNECTION POOLING:
         *    Manual pooling needed
         *    No built-in support
         * 
         * 
         * RECOMMENDATION:
         * 
         * Use Java 11+ HttpClient instead
         * Much better API
         * Modern features
         */
    }
    
    public static void main(String[] args) throws Exception {
        System.out.println("=== Basic URL Usage ===");
        basicUrlUsage();
        
        System.out.println("\n=== Simple HTTP GET ===");
        simpleHttpGet();
    }
}
```

---

## 4. HTTP Client (Java 11+)

### Modern HTTP Client API

```java
/**
 * HTTP CLIENT (JAVA 11+)
 * 
 * Modern, asynchronous HTTP client
 */

import java.net.http.*;
import java.net.*;
import java.time.Duration;
import java.util.concurrent.*;
import java.io.IOException;

public class ModernHTTPClient {
    
    /**
     * Basic HTTP GET
     */
    public static void basicHttpGet() throws Exception {
        HttpClient client = HttpClient.newHttpClient();
        
        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create("https://api.github.com/"))
            .GET()
            .build();
        
        HttpResponse<String> response = client.send(request,
            HttpResponse.BodyHandlers.ofString());
        
        System.out.println("Status: " + response.statusCode());
        System.out.println("Body: " + response.body());
        
        /**
         * MODERN HTTP CLIENT:
         * 
         * 1. Create HttpClient (reusable)
         * 2. Build HttpRequest
         * 3. Send request with BodyHandler
         * 4. Get HttpResponse
         * 
         * Much cleaner than URLConnection!
         */
    }
    
    /**
     * HTTP POST with JSON
     */
    public static void httpPostJson() throws Exception {
        HttpClient client = HttpClient.newHttpClient();
        
        String json = "{\"name\":\"Alice\",\"age\":30}";
        
        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create("https://httpbin.org/post"))
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(json))
            .build();
        
        HttpResponse<String> response = client.send(request,
            HttpResponse.BodyHandlers.ofString());
        
        System.out.println("Response: " + response.body());
        
        /**
         * HTTP POST:
         * 
         * POST(BodyPublisher)
         * 
         * BodyPublishers:
         * - ofString(String)
         * - ofByteArray(byte[])
         * - ofFile(Path)
         * - ofInputStream(Supplier<InputStream>)
         */
    }
    
    /**
     * Async HTTP request
     */
    public static void asyncHttpRequest() throws Exception {
        HttpClient client = HttpClient.newHttpClient();
        
        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create("https://api.github.com/"))
            .build();
        
        // Send async
        CompletableFuture<HttpResponse<String>> futureResponse = 
            client.sendAsync(request, HttpResponse.BodyHandlers.ofString());
        
        // Do other work...
        System.out.println("Request sent, doing other work...");
        
        // Wait for response
        HttpResponse<String> response = futureResponse.get();
        System.out.println("Status: " + response.statusCode());
        
        /**
         * ASYNC REQUESTS:
         * 
         * sendAsync() returns CompletableFuture
         * Non-blocking
         * Can chain with thenApply/thenAccept
         * 
         * Example:
         * client.sendAsync(request, BodyHandlers.ofString())
         *       .thenApply(HttpResponse::body)
         *       .thenAccept(System.out::println);
         */
    }
    
    /**
     * Multiple async requests
     */
    public static void multipleAsyncRequests() throws Exception {
        HttpClient client = HttpClient.newHttpClient();
        
        List<String> urls = List.of(
            "https://api.github.com/",
            "https://httpbin.org/get",
            "https://httpbin.org/user-agent"
        );
        
        // Send all requests concurrently
        List<CompletableFuture<HttpResponse<String>>> futures = urls.stream()
            .map(url -> HttpRequest.newBuilder(URI.create(url)).build())
            .map(request -> client.sendAsync(request, 
                HttpResponse.BodyHandlers.ofString()))
            .toList();
        
        // Wait for all
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .join();
        
        // Get results
        for (CompletableFuture<HttpResponse<String>> future : futures) {
            HttpResponse<String> response = future.get();
            System.out.println("URL: " + response.uri());
            System.out.println("Status: " + response.statusCode());
        }
        
        /**
         * CONCURRENT REQUESTS:
         * 
         * Send multiple requests in parallel
         * Wait with CompletableFuture.allOf()
         * Much faster than sequential
         */
    }
    
    /**
     * Custom HttpClient configuration
     */
    public static void customHttpClient() {
        HttpClient client = HttpClient.newBuilder()
            .version(HttpClient.Version.HTTP_2)
            .followRedirects(HttpClient.Redirect.NORMAL)
            .connectTimeout(Duration.ofSeconds(10))
            .executor(Executors.newFixedThreadPool(4))
            .build();
        
        /**
         * HTTP CLIENT CONFIGURATION:
         * 
         * version():
         * - HTTP_1_1
         * - HTTP_2 (default)
         * 
         * followRedirects():
         * - NEVER
         * - NORMAL (same protocol)
         * - ALWAYS
         * 
         * connectTimeout():
         * - Connection timeout
         * - Duration.ofSeconds(n)
         * 
         * executor():
         * - Thread pool for async
         * - Default: internal pool
         * 
         * proxy():
         * - HTTP proxy
         * 
         * authenticator():
         * - HTTP authentication
         * 
         * cookieHandler():
         * - Cookie management
         */
    }
    
    /**
     * Request configuration
     */
    public static void requestConfiguration() {
        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create("https://api.github.com/"))
            .timeout(Duration.ofSeconds(5))
            .header("User-Agent", "Java HttpClient")
            .header("Accept", "application/json")
            .GET()
            .build();
        
        /**
         * REQUEST CONFIGURATION:
         * 
         * timeout():
         * - Request timeout
         * - Overrides client timeout
         * 
         * header():
         * - Add header
         * - Can call multiple times
         * 
         * headers():
         * - Multiple headers at once
         * - Varargs: "key1", "value1", "key2", "value2"
         * 
         * Method:
         * - GET(), POST(), PUT(), DELETE()
         * - method(String, BodyPublisher)
         * 
         * version():
         * - Override client version
         */
    }
    
    /**
     * Response body handlers
     */
    public static void responseBodyHandlers() {
        /**
         * BODY HANDLERS:
         * 
         * ofString():
         * - Response as String
         * - UTF-8 by default
         * 
         * ofByteArray():
         * - Response as byte[]
         * 
         * ofFile(Path):
         * - Save to file
         * 
         * ofInputStream():
         * - Response as InputStream
         * 
         * ofLines():
         * - Response as Stream<String>
         * 
         * discarding():
         * - Ignore response body
         * 
         * Custom:
         * - Implement BodyHandler
         * - Full control
         */
    }
    
    /**
     * WebSocket support
     */
    public static void webSocketSupport() throws Exception {
        HttpClient client = HttpClient.newHttpClient();
        
        WebSocket.Listener listener = new WebSocket.Listener() {
            @Override
            public void onOpen(WebSocket webSocket) {
                System.out.println("WebSocket opened");
                webSocket.sendText("Hello, Server!", true);
                WebSocket.Listener.super.onOpen(webSocket);
            }
            
            @Override
            public CompletionStage<?> onText(WebSocket webSocket, 
                    CharSequence data, boolean last) {
                System.out.println("Received: " + data);
                return WebSocket.Listener.super.onText(webSocket, data, last);
            }
            
            @Override
            public CompletionStage<?> onClose(WebSocket webSocket, 
                    int statusCode, String reason) {
                System.out.println("WebSocket closed: " + reason);
                return WebSocket.Listener.super.onClose(webSocket, statusCode, reason);
            }
        };
        
        CompletableFuture<WebSocket> wsFuture = client.newWebSocketBuilder()
            .buildAsync(URI.create("wss://echo.websocket.org/"), listener);
        
        WebSocket ws = wsFuture.get();
        
        // Send message
        ws.sendText("Hello!", true);
        
        Thread.sleep(1000);
        ws.sendClose(WebSocket.NORMAL_CLOSURE, "Done");
        
        /**
         * WEBSOCKET:
         * 
         * Built-in support
         * Async by default
         * Listener pattern
         * 
         * Methods:
         * - onOpen()
         * - onText()
         * - onBinary()
         * - onPing/onPong()
         * - onClose()
         * - onError()
         */
    }
    
    /**
     * Advantages of modern HTTP client
     */
    public static void advantagesOfModernClient() {
        /**
         * ADVANTAGES:
         * 
         * 1. HTTP/2 SUPPORT:
         *    Multiplexing
         *    Server push
         *    Header compression
         * 
         * 2. ASYNC:
         *    CompletableFuture
         *    Non-blocking
         *    Reactive streams
         * 
         * 3. CLEAN API:
         *    Builder pattern
         *    Immutable
         *    Type-safe
         * 
         * 4. WEBSOCKET:
         *    Built-in support
         *    No extra library
         * 
         * 5. MODERN:
         *    Maintained
         *    Active development
         *    Best practices
         * 
         * 6. PERFORMANCE:
         *    Connection pooling
         *    Keep-alive
         *    Efficient
         */
    }
    
    public static void main(String[] args) throws Exception {
        System.out.println("=== Basic HTTP GET ===");
        basicHttpGet();
        
        System.out.println("\n=== Async HTTP Request ===");
        asyncHttpRequest();
    }
}
```

---

## 5. SSL/TLS Configuration

### Secure Network Communication

```java
/**
 * SSL/TLS CONFIGURATION
 * 
 * Configuring secure connections
 */

import javax.net.ssl.*;
import java.security.*;
import java.security.cert.*;
import java.io.*;
import java.net.*;

public class SSLTLSConfiguration {
    
    /**
     * Basic HTTPS connection
     */
    public static void basicHttpsConnection() throws Exception {
        URL url = new URL("https://www.google.com");
        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
        
        try (BufferedReader reader = new BufferedReader(
                new InputStreamReader(connection.getInputStream()))) {
            
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
        }
        
        /**
         * HTTPS:
         * 
         * Default SSL/TLS configuration works
         * Uses system trust store
         * Validates certificates
         * 
         * Java handles:
         * - Certificate validation
         * - Cipher negotiation
         * - Protocol selection
         */
    }
    
    /**
     * Custom SSLContext
     */
    public static void customSSLContext() throws Exception {
        // Create SSL context
        SSLContext sslContext = SSLContext.getInstance("TLS");
        
        // Initialize with default
        sslContext.init(null, null, null);
        
        // Set as default
        SSLContext.setDefault(sslContext);
        
        /**
         * SSL PROTOCOLS:
         * 
         * TLS (recommended) - uses latest
         * TLSv1.3 - TLS 1.3 only
         * TLSv1.2 - TLS 1.2 only
         * SSL (deprecated) - old SSL
         * 
         * Use "TLS" for best compatibility
         */
    }
    
    /**
     * Custom trust manager (trust all - DANGEROUS!)
     */
    public static void trustAllCertificates() throws Exception {
        // Create trust manager that trusts all
        TrustManager[] trustAllCerts = new TrustManager[] {
            new X509TrustManager() {
                public X509Certificate[] getAcceptedIssuers() {
                    return null;
                }
                
                public void checkClientTrusted(X509Certificate[] certs, 
                        String authType) {
                }
                
                public void checkServerTrusted(X509Certificate[] certs, 
                        String authType) {
                }
            }
        };
        
        // Install trust manager
        SSLContext sc = SSLContext.getInstance("TLS");
        sc.init(null, trustAllCerts, new SecureRandom());
        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
        
        // Also disable hostname verification (DANGEROUS!)
        HostnameVerifier allHostsValid = (hostname, session) -> true;
        HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);
        
        /**
         * WARNING: NEVER DO THIS IN PRODUCTION!
         * 
         * This disables certificate validation
         * Vulnerable to man-in-the-middle attacks
         * 
         * Only for testing/development
         * With known safe environment
         */
    }
    
    /**
     * Load custom truststore
     */
    public static void loadCustomTruststore() throws Exception {
        // Load truststore
        KeyStore trustStore = KeyStore.getInstance("JKS");
        try (FileInputStream fis = new FileInputStream("truststore.jks")) {
            trustStore.load(fis, "password".toCharArray());
        }
        
        // Create trust manager factory
        TrustManagerFactory tmf = TrustManagerFactory.getInstance(
            TrustManagerFactory.getDefaultAlgorithm());
        tmf.init(trustStore);
        
        // Create SSL context
        SSLContext sslContext = SSLContext.getInstance("TLS");
        sslContext.init(null, tmf.getTrustManagers(), null);
        
        // Use for connections
        HttpsURLConnection.setDefaultSSLSocketFactory(
            sslContext.getSocketFactory());
        
        /**
         * CUSTOM TRUSTSTORE:
         * 
         * Use when:
         * - Self-signed certificates
         * - Internal CA
         * - Custom certificate chain
         * 
         * Create truststore:
         * keytool -import -file cert.pem -keystore truststore.jks
         */
    }
    
    /**
     * Client certificate authentication
     */
    public static void clientCertificateAuth() throws Exception {
        // Load keystore with client certificate
        KeyStore keyStore = KeyStore.getInstance("PKCS12");
        try (FileInputStream fis = new FileInputStream("client.p12")) {
            keyStore.load(fis, "password".toCharArray());
        }
        
        // Create key manager factory
        KeyManagerFactory kmf = KeyManagerFactory.getInstance(
            KeyManagerFactory.getDefaultAlgorithm());
        kmf.init(keyStore, "password".toCharArray());
        
        // Create SSL context
        SSLContext sslContext = SSLContext.getInstance("TLS");
        sslContext.init(kmf.getKeyManagers(), null, null);
        
        // Use for connections
        HttpsURLConnection.setDefaultSSLSocketFactory(
            sslContext.getSocketFactory());
        
        /**
         * CLIENT CERTIFICATES:
         * 
         * Mutual TLS (mTLS)
         * Server authenticates client
         * 
         * Used for:
         * - API authentication
         * - Service-to-service
         * - High security
         */
    }
    
    /**
     * SSL socket factory
     */
    public static void sslSocketFactory() throws Exception {
        SSLContext sslContext = SSLContext.getInstance("TLS");
        sslContext.init(null, null, null);
        
        SSLSocketFactory factory = sslContext.getSocketFactory();
        
        // Create SSL socket
        try (SSLSocket socket = (SSLSocket) factory.createSocket(
                "www.google.com", 443)) {
            
            // Configure protocols
            socket.setEnabledProtocols(new String[] {"TLSv1.2", "TLSv1.3"});
            
            // Configure cipher suites
            String[] ciphers = socket.getSupportedCipherSuites();
            socket.setEnabledCipherSuites(ciphers);
            
            // Start handshake
            socket.startHandshake();
            
            // Get session info
            SSLSession session = socket.getSession();
            System.out.println("Protocol: " + session.getProtocol());
            System.out.println("Cipher: " + session.getCipherSuite());
            
            // Use socket...
        }
        
        /**
         * SSL SOCKET:
         * 
         * Low-level SSL/TLS
         * Full control
         * 
         * Configuration:
         * - Enabled protocols
         * - Cipher suites
         * - Session management
         */
    }
    
    /**
     * Modern HttpClient SSL
     */
    public static void modernHttpClientSSL() throws Exception {
        SSLContext sslContext = SSLContext.getInstance("TLS");
        sslContext.init(null, null, null);
        
        HttpClient client = HttpClient.newBuilder()
            .sslContext(sslContext)
            .build();
        
        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create("https://www.google.com"))
            .build();
        
        HttpResponse<String> response = client.send(request,
            HttpResponse.BodyHandlers.ofString());
        
        System.out.println("Status: " + response.statusCode());
        
        /**
         * MODERN HTTP CLIENT SSL:
         * 
         * Set SSLContext on client
         * Used for all requests
         * Cleaner than URLConnection
         */
    }
    
    /**
     * Best practices
     */
    public static void bestPractices() {
        /**
         * SSL/TLS BEST PRACTICES:
         * 
         * 1. USE TLS 1.2+:
         *    Disable old protocols
         *    TLS 1.3 preferred
         * 
         * 2. VALIDATE CERTIFICATES:
         *    Never disable in production
         *    Use proper trust store
         * 
         * 3. STRONG CIPHERS:
         *    Disable weak ciphers
         *    Use forward secrecy
         * 
         * 4. HOSTNAME VERIFICATION:
         *    Always verify hostname
         *    Prevents MITM attacks
         * 
         * 5. CERTIFICATE PINNING:
         *    For high security
         *    Pin specific certificates
         * 
         * 6. MTLS FOR SERVICES:
         *    Service-to-service auth
         *    Better than passwords
         * 
         * 7. MONITOR EXPIRATION:
         *    Certificates expire
         *    Automated renewal
         * 
         * 8. USE MODERN APIs:
         *    Java 11+ HttpClient
         *    Better defaults
         */
    }
    
    public static void main(String[] args) throws Exception {
        System.out.println("=== Basic HTTPS Connection ===");
        basicHttpsConnection();
    }
}
```

---

## 6. Connection Pooling

### Efficient Resource Management

```java
/**
 * CONNECTION POOLING
 * 
 * Reusing connections for performance
 */

import java.net.http.*;
import java.net.*;
import java.util.concurrent.*;
import java.time.Duration;

public class ConnectionPooling {
    
    /**
     * Why connection pooling
     */
    public static void whyConnectionPooling() {
        /**
         * CONNECTION OVERHEAD:
         * 
         * Creating new connection:
         * 1. DNS lookup (50-200ms)
         * 2. TCP handshake (1 RTT)
         * 3. TLS handshake (2 RTTs)
         * 4. HTTP request
         * 
         * Total: 100-500ms overhead!
         * 
         * 
         * WITH CONNECTION POOLING:
         * 
         * 1. Reuse existing connection
         * 2. Skip DNS/TCP/TLS
         * 3. Send HTTP request immediately
         * 
         * Total: <10ms overhead
         * 
         * 
         * BENEFITS:
         * 
         * - 10-50x faster
         * - Lower latency
         * - Reduced server load
         * - Better throughput
         */
    }
    
    /**
     * Java 11+ HttpClient pooling
     */
    public static void httpClientPooling() {
        HttpClient client = HttpClient.newBuilder()
            .connectTimeout(Duration.ofSeconds(10))
            .build();
        
        /**
         * AUTOMATIC POOLING:
         * 
         * Java 11+ HttpClient has built-in pooling!
         * 
         * - Reuses connections automatically
         * - HTTP/1.1: Keep-alive
         * - HTTP/2: Multiplexing
         * - Per-client pool
         * 
         * Best practice:
         * - Reuse HttpClient instance
         * - Don't create per-request
         * - Share across application
         */
    }
    
    /**
     * Shared HttpClient pattern
     */
    static class HttpClientManager {
        private static final HttpClient SHARED_CLIENT = HttpClient.newBuilder()
            .version(HttpClient.Version.HTTP_2)
            .followRedirects(HttpClient.Redirect.NORMAL)
            .connectTimeout(Duration.ofSeconds(10))
            .executor(Executors.newFixedThreadPool(10))
            .build();
        
        public static HttpClient getClient() {
            return SHARED_CLIENT;
        }
        
        /**
         * SINGLETON PATTERN:
         * 
         * Single HttpClient for application
         * Shared connection pool
         * Thread-safe
         * 
         * Usage:
         * HttpClient client = HttpClientManager.getClient();
         */
    }
    
    /**
     * Custom connection pool (URLConnection)
     */
    static class SimpleConnectionPool {
        private final BlockingQueue<HttpURLConnection> pool;
        private final String baseUrl;
        private final int maxSize;
        
        public SimpleConnectionPool(String baseUrl, int maxSize) {
            this.baseUrl = baseUrl;
            this.maxSize = maxSize;
            this.pool = new LinkedBlockingQueue<>(maxSize);
        }
        
        public HttpURLConnection acquire() throws Exception {
            HttpURLConnection conn = pool.poll();
            
            if (conn == null) {
                // Create new connection
                URL url = new URL(baseUrl);
                conn = (HttpURLConnection) url.openConnection();
                conn.setRequestProperty("Connection", "Keep-Alive");
            }
            
            return conn;
        }
        
        public void release(HttpURLConnection conn) {
            if (pool.size() < maxSize) {
                pool.offer(conn);
            } else {
                conn.disconnect();
            }
        }
        
        /**
         * MANUAL POOL:
         * 
         * For URLConnection (no built-in pooling)
         * 
         * Pattern:
         * 1. acquire() - get connection
         * 2. Use connection
         * 3. release() - return to pool
         * 
         * Limitations:
         * - Simple implementation
         * - No idle timeout
         * - No health checks
         * - Better use HttpClient!
         */
    }
    
    /**
     * Connection pool sizing
     */
    public static void connectionPoolSizing() {
        /**
         * POOL SIZE GUIDELINES:
         * 
         * Formula:
         * pool_size = connections_per_host * number_of_hosts
         * 
         * 
         * FACTORS:
         * 
         * 1. CONCURRENT REQUESTS:
         *    How many simultaneous?
         *    Pool >= concurrent requests
         * 
         * 2. SERVER LIMITS:
         *    Server max connections
         *    Don't exceed
         * 
         * 3. LATENCY:
         *    High latency = more connections
         *    Requests take longer
         * 
         * 4. RESOURCES:
         *    Memory per connection
         *    File descriptors
         * 
         * 
         * TYPICAL SIZES:
         * 
         * Small app: 5-10 per host
         * Medium app: 20-50 per host
         * Large app: 100+ per host
         * 
         * 
         * HTTP/2 DIFFERENCE:
         * 
         * HTTP/1.1: Need many connections
         * HTTP/2: 1 connection, many streams
         * HTTP/2 pool can be smaller
         */
    }
    
    /**
     * Connection lifecycle
     */
    public static void connectionLifecycle() {
        /**
         * CONNECTION STATES:
         * 
         * 1. IDLE:
         *    In pool, not in use
         *    Available for requests
         * 
         * 2. ACTIVE:
         *    Processing request
         *    Not available
         * 
         * 3. KEEP-ALIVE:
         *    Request done
         *    Waiting for reuse
         *    Timeout period
         * 
         * 4. CLOSED:
         *    Connection closed
         *    Removed from pool
         * 
         * 
         * TIMEOUTS:
         * 
         * Idle timeout:
         * - Close unused connections
         * - Free resources
         * - Typically 30-60s
         * 
         * Max lifetime:
         * - Close after time
         * - Even if active
         * - Prevent stale connections
         */
    }
    
    /**
     * Monitoring connection pool
     */
    static class MonitoredHttpClient {
        private final HttpClient client;
        private final ExecutorService executor;
        
        public MonitoredHttpClient() {
            this.executor = Executors.newFixedThreadPool(10);
            
            this.client = HttpClient.newBuilder()
                .executor(executor)
                .build();
        }
        
        public ThreadPoolExecutor getExecutor() {
            return (ThreadPoolExecutor) executor;
        }
        
        public void printStats() {
            ThreadPoolExecutor tpe = getExecutor();
            
            System.out.println("Active threads: " + tpe.getActiveCount());
            System.out.println("Pool size: " + tpe.getPoolSize());
            System.out.println("Queue size: " + tpe.getQueue().size());
            System.out.println("Completed tasks: " + tpe.getCompletedTaskCount());
        }
        
        /**
         * MONITORING:
         * 
         * Track:
         * - Active connections
         * - Pool size
         * - Queue depth
         * - Wait times
         * - Errors
         * 
         * Alerts:
         * - Pool exhaustion
         * - High latency
         * - Connection failures
         */
    }
    
    /**
     * Best practices
     */
    public static void bestPractices() {
        /**
         * CONNECTION POOLING BEST PRACTICES:
         * 
         * 1. REUSE CLIENT:
         *    Single HttpClient instance
         *    Don't create per-request
         *    Share across threads
         * 
         * 2. SIZE APPROPRIATELY:
         *    Match concurrent requests
         *    Consider server limits
         *    Monitor and adjust
         * 
         * 3. SET TIMEOUTS:
         *    Connection timeout
         *    Read timeout
         *    Idle timeout
         * 
         * 4. HANDLE ERRORS:
         *    Retry logic
         *    Circuit breaker
         *    Failover
         * 
         * 5. MONITOR:
         *    Pool utilization
         *    Wait times
         *    Error rates
         * 
         * 6. USE HTTP/2:
         *    Better multiplexing
         *    Fewer connections needed
         * 
         * 7. CLEANUP:
         *    Close connections on shutdown
         *    Release resources
         */
    }
    
    public static void main(String[] args) {
        System.out.println("Connection pooling examples");
    }
}
```

---

## 7. Timeout Handling

### Preventing Hangs and Deadlocks

```java
/**
 * TIMEOUT HANDLING
 * 
 * Preventing network operations from hanging
 */

import java.net.*;
import java.net.http.*;
import java.time.Duration;
import java.util.concurrent.*;
import java.io.*;

public class TimeoutHandling {
    
    /**
     * Types of timeouts
     */
    public static void typesOfTimeouts() {
        /**
         * NETWORK TIMEOUTS:
         * 
         * 1. CONNECTION TIMEOUT:
         *    Time to establish connection
         *    Covers: DNS, TCP, TLS handshake
         *    Typical: 5-10 seconds
         * 
         * 2. READ TIMEOUT:
         *    Time waiting for data
         *    After connection established
         *    Typical: 30-60 seconds
         * 
         * 3. WRITE TIMEOUT:
         *    Time waiting to send data
         *    Less common
         * 
         * 4. REQUEST TIMEOUT:
         *    Total time for entire request
         *    Connection + read + write
         *    Typical: 60-120 seconds
         * 
         * 
         * WHY TIMEOUTS MATTER:
         * 
         * Without timeouts:
         * - Threads hang forever
         * - Resources leak
         * - Application freezes
         * - Poor user experience
         * 
         * With timeouts:
         * - Fail fast
         * - Release resources
         * - Retry possible
         * - Better reliability
         */
    }
    
    /**
     * Socket timeouts
     */
    public static void socketTimeouts() throws IOException {
        Socket socket = new Socket();
        
        // Connection timeout
        socket.connect(new InetSocketAddress("example.com", 80), 5000);
        
        // Read timeout
        socket.setSoTimeout(10000);
        
        try (BufferedReader reader = new BufferedReader(
                new InputStreamReader(socket.getInputStream()));
             PrintWriter writer = new PrintWriter(socket.getOutputStream())) {
            
            writer.println("GET / HTTP/1.1");
            writer.println("Host: example.com");
            writer.println();
            writer.flush();
            
            // This will timeout after 10 seconds if no data
            String line = reader.readLine();
            System.out.println(line);
            
        } catch (SocketTimeoutException e) {
            System.err.println("Timeout! " + e.getMessage());
        } finally {
            socket.close();
        }
        
        /**
         * SOCKET TIMEOUTS:
         * 
         * connect(address, timeout):
         * - Connection timeout in ms
         * - Throws SocketTimeoutException
         * 
         * setSoTimeout(timeout):
         * - Read timeout in ms
         * - Applies to all read operations
         * - 0 = infinite wait (default)
         */
    }
    
    /**
     * URLConnection timeouts
     */
    public static void urlConnectionTimeouts() throws IOException {
        URL url = new URL("https://httpbin.org/delay/5");
        URLConnection connection = url.openConnection();
        
        // Connection timeout
        connection.setConnectTimeout(5000);
        
        // Read timeout
        connection.setReadTimeout(3000);
        
        try (BufferedReader reader = new BufferedReader(
                new InputStreamReader(connection.getInputStream()))) {
            
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
            
        } catch (SocketTimeoutException e) {
            System.err.println("Request timed out: " + e.getMessage());
        }
        
        /**
         * URLCONNECTION TIMEOUTS:
         * 
         * setConnectTimeout(ms)
         * setReadTimeout(ms)
         * 
         * Both required for complete timeout handling
         */
    }
    
    /**
     * HttpClient timeouts
     */
    public static void httpClientTimeouts() throws Exception {
        // Client-level timeout
        HttpClient client = HttpClient.newBuilder()
            .connectTimeout(Duration.ofSeconds(5))
            .build();
        
        // Request-level timeout (overrides client)
        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create("https://httpbin.org/delay/10"))
            .timeout(Duration.ofSeconds(3))
            .GET()
            .build();
        
        try {
            HttpResponse<String> response = client.send(request,
                HttpResponse.BodyHandlers.ofString());
            
            System.out.println(response.body());
            
        } catch (HttpTimeoutException e) {
            System.err.println("Request timed out: " + e.getMessage());
        }
        
        /**
         * HTTPCLIENT TIMEOUTS:
         * 
         * Client level:
         * - connectTimeout() - connection only
         * 
         * Request level:
         * - timeout() - entire request
         * - Includes connection + read
         * 
         * Request timeout overrides client
         */
    }
    
    /**
     * Async timeout with CompletableFuture
     */
    public static void asyncTimeout() {
        HttpClient client = HttpClient.newHttpClient();
        
        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create("https://httpbin.org/delay/10"))
            .build();
        
        CompletableFuture<HttpResponse<String>> responseFuture = 
            client.sendAsync(request, HttpResponse.BodyHandlers.ofString());
        
        try {
            // Timeout with CompletableFuture
            HttpResponse<String> response = responseFuture
                .orTimeout(5, TimeUnit.SECONDS)
                .get();
            
            System.out.println(response.body());
            
        } catch (TimeoutException e) {
            System.err.println("Request timed out");
            responseFuture.cancel(true);
        } catch (Exception e) {
            e.printStackTrace();
        }
        
        /**
         * ASYNC TIMEOUTS:
         * 
         * orTimeout(timeout, unit):
         * - Java 9+ feature
         * - Completes exceptionally on timeout
         * - Works with any CompletableFuture
         * 
         * Alternative:
         * completeOnTimeout(value, timeout, unit)
         * - Completes with default value
         */
    }
    
    /**
     * Retry with timeout
     */
    public static void retryWithTimeout() {
        HttpClient client = HttpClient.newHttpClient();
        
        int maxRetries = 3;
        int retryDelay = 1000;
        
        for (int attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                HttpRequest request = HttpRequest.newBuilder()
                    .uri(URI.create("https://httpbin.org/status/500"))
                    .timeout(Duration.ofSeconds(5))
                    .build();
                
                HttpResponse<String> response = client.send(request,
                    HttpResponse.BodyHandlers.ofString());
                
                if (response.statusCode() == 200) {
                    System.out.println("Success!");
                    break;
                }
                
                System.out.println("Attempt " + attempt + " failed with status: " 
                    + response.statusCode());
                
            } catch (HttpTimeoutException e) {
                System.err.println("Attempt " + attempt + " timed out");
                
            } catch (Exception e) {
                System.err.println("Attempt " + attempt + " failed: " + e.getMessage());
            }
            
            if (attempt < maxRetries) {
                try {
                    Thread.sleep(retryDelay * attempt);  // Exponential backoff
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }
        
        /**
         * RETRY PATTERN:
         * 
         * 1. Try request with timeout
         * 2. On failure, wait
         * 3. Retry with backoff
         * 4. Give up after max attempts
         * 
         * Exponential backoff:
         * - Attempt 1: wait 1s
         * - Attempt 2: wait 2s
         * - Attempt 3: wait 4s
         */
    }
    
    /**
     * Circuit breaker pattern
     */
    static class SimpleCircuitBreaker {
        enum State { CLOSED, OPEN, HALF_OPEN }
        
        private State state = State.CLOSED;
        private int failureCount = 0;
        private final int failureThreshold;
        private final long timeout;
        private long lastFailureTime;
        
        public SimpleCircuitBreaker(int failureThreshold, long timeout) {
            this.failureThreshold = failureThreshold;
            this.timeout = timeout;
        }
        
        public synchronized boolean allowRequest() {
            if (state == State.OPEN) {
                if (System.currentTimeMillis() - lastFailureTime > timeout) {
                    state = State.HALF_OPEN;
                    return true;
                }
                return false;
            }
            return true;
        }
        
        public synchronized void recordSuccess() {
            failureCount = 0;
            state = State.CLOSED;
        }
        
        public synchronized void recordFailure() {
            failureCount++;
            lastFailureTime = System.currentTimeMillis();
            
            if (failureCount >= failureThreshold) {
                state = State.OPEN;
            }
        }
        
        /**
         * CIRCUIT BREAKER:
         * 
         * States:
         * - CLOSED: Normal operation
         * - OPEN: Failing, reject requests
         * - HALF_OPEN: Testing recovery
         * 
         * Prevents:
         * - Cascading failures
         * - Resource exhaustion
         * - Wasted retries
         */
    }
    
    /**
     * Best practices
     */
    public static void bestPractices() {
        /**
         * TIMEOUT BEST PRACTICES:
         * 
         * 1. ALWAYS SET TIMEOUTS:
         *    Never infinite wait
         *    Both connection and read
         *    Request timeout for total
         * 
         * 2. APPROPRIATE VALUES:
         *    Connection: 5-10s
         *    Read: 30-60s
         *    Request: 60-120s
         *    Adjust based on use case
         * 
         * 3. HANDLE TIMEOUT EXCEPTIONS:
         *    Catch SocketTimeoutException
         *    HttpTimeoutException
         *    TimeoutException
         *    Clean up resources
         * 
         * 4. RETRY INTELLIGENTLY:
         *    Exponential backoff
         *    Jitter to prevent thundering herd
         *    Max retry limit
         * 
         * 5. CIRCUIT BREAKER:
         *    Protect failing services
         *    Fast fail when open
         *    Automatic recovery
         * 
         * 6. MONITOR:
         *    Timeout frequency
         *    Which endpoints timeout
         *    Adjust timeouts based on data
         * 
         * 7. TEST:
         *    Test timeout scenarios
         *    Chaos engineering
         *    Verify cleanup
         */
    }
    
    public static void main(String[] args) throws Exception {
        System.out.println("=== Socket Timeouts ===");
        socketTimeouts();
        
        System.out.println("\n=== HttpClient Timeouts ===");
        httpClientTimeouts();
    }
}
```

---

## Summary

### Quick Reference

**Socket vs NIO vs HttpClient:**

```
┌─────────────┬────────────┬──────────────┬────────────────┐
│ Feature     │ Socket     │ NIO Selector │ HttpClient 11+ │
├─────────────┼────────────┼──────────────┼────────────────┤
│ Blocking    │ Yes        │ No           │ Optional       │
│ Scalability │ Poor       │ Excellent    │ Excellent      │
│ Threads     │ Many       │ Few          │ Pool           │
│ Complexity  │ Low        │ High         │ Low            │
│ HTTP/2      │ No         │ Manual       │ Yes            │
│ Async       │ No         │ Manual       │ Built-in       │
│ Use case    │ Simple     │ High-scale   │ Modern HTTP    │
└─────────────┴────────────┴──────────────┴────────────────┘
```

**Timeout Recommendations:**

```
Operation          Typical Timeout
─────────────────  ───────────────
DNS Lookup         2-5 seconds
TCP Connect        5-10 seconds
TLS Handshake      5-10 seconds
HTTP Read          30-60 seconds
Total Request      60-120 seconds
WebSocket Ping     30 seconds
```

**Code Examples:**

```java
// Modern HTTP Client (recommended)
HttpClient client = HttpClient.newBuilder()
    .version(HttpClient.Version.HTTP_2)
    .connectTimeout(Duration.ofSeconds(10))
    .build();

HttpRequest request = HttpRequest.newBuilder()
    .uri(URI.create("https://api.example.com/data"))
    .timeout(Duration.ofSeconds(30))
    .header("Content-Type", "application/json")
    .POST(HttpRequest.BodyPublishers.ofString(json))
    .build();

HttpResponse<String> response = client.send(request,
    HttpResponse.BodyHandlers.ofString());

// Async
client.sendAsync(request, HttpResponse.BodyHandlers.ofString())
      .thenApply(HttpResponse::body)
      .thenAccept(System.out::println);

// NIO Selector (for high concurrency)
Selector selector = Selector.open();
ServerSocketChannel channel = ServerSocketChannel.open();
channel.configureBlocking(false);
channel.register(selector, SelectionKey.OP_ACCEPT);

while (true) {
    selector.select();
    for (SelectionKey key : selector.selectedKeys()) {
        // Handle events
    }
    selector.selectedKeys().clear();
}
```

### Decision Tree

```
Need to make HTTP requests?
├─ Yes → Use Java 11+ HttpClient
│  ├─ Async? → sendAsync()
│  └─ Sync? → send()
│
└─ Raw TCP needed?
   ├─ <1000 connections → Socket + thread pool
   └─ >1000 connections → NIO with Selector
```

### Best Practices Summary

**✅ DO:**

- Use Java 11+ HttpClient for HTTP
- Always set timeouts (connection, read, request)
- Reuse HttpClient instances (connection pooling)
- Use async for concurrent requests
- Handle timeout exceptions
- Implement retry with exponential backoff
- Use circuit breaker for failing services
- Configure SSL/TLS properly
- Monitor connection pool metrics

**❌ DON'T:**

- Create new client per request
- Use infinite timeouts
- Ignore timeout exceptions
- Disable SSL validation in production
- Trust all certificates
- Block in NIO event loop
- Forget to close connections
- Use URLConnection for new code

---
