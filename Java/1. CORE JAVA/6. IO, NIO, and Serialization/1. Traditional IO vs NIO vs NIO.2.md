# Traditional I/O vs NIO vs NIO.2

## Overview

Java provides three distinct I/O approaches: Traditional I/O (Java 1.0), NIO (Java 1.4), and NIO.2 (Java 7). Each has different characteristics, performance profiles, and use cases. This guide provides a comprehensive comparison, covering blocking vs non-blocking vs asynchronous I/O, buffer management, direct vs heap buffers, memory-mapped files, and when to use each approach.

---

## 1. Blocking I/O (Traditional Streams)

### Java I/O Foundation

```java
/**
 * TRADITIONAL I/O (BLOCKING STREAMS)
 * 
 * Java 1.0 - Stream-based, blocking I/O
 */

import java.io.*;
import java.net.*;

public class TraditionalBlockingIO {
    
    /**
     * Basic stream I/O characteristics
     */
    public static void streamCharacteristics() {
        /**
         * TRADITIONAL I/O CHARACTERISTICS:
         * 
         * 1. STREAM-BASED:
         *    Data flows through streams
         *    InputStream/OutputStream (bytes)
         *    Reader/Writer (characters)
         * 
         * 2. BLOCKING:
         *    read() blocks until data available
         *    write() blocks until space available
         *    Thread waits during I/O
         * 
         * 3. SYNCHRONOUS:
         *    I/O completes before returning
         *    Sequential processing
         * 
         * 4. ONE-WAY:
         *    Input stream for reading
         *    Output stream for writing
         *    Separate streams for each direction
         */
    }
    
    /**
     * File I/O example
     */
    public static void fileIOExample() throws IOException {
        // Writing
        try (FileOutputStream fos = new FileOutputStream("data.txt");
             BufferedOutputStream bos = new BufferedOutputStream(fos)) {
            
            String data = "Hello, World!";
            bos.write(data.getBytes());
            bos.flush();
            
            /**
             * WRITE OPERATION:
             * 
             * 1. Opens file (creates if needed)
             * 2. write() transfers bytes
             * 3. Blocks until written
             * 4. flush() ensures data written
             * 5. close() releases file handle
             */
        }
        
        // Reading
        try (FileInputStream fis = new FileInputStream("data.txt");
             BufferedInputStream bis = new BufferedInputStream(fis)) {
            
            int byteRead;
            while ((byteRead = bis.read()) != -1) {
                System.out.print((char) byteRead);
            }
            
            /**
             * READ OPERATION:
             * 
             * 1. Opens file
             * 2. read() blocks until byte available
             * 3. Returns -1 at end
             * 4. close() releases file handle
             */
        }
    }
    
    /**
     * Network I/O example
     */
    public static void networkIOExample() throws IOException {
        // Server
        Thread serverThread = new Thread(() -> {
            try (ServerSocket serverSocket = new ServerSocket(8080)) {
                System.out.println("Server listening on port 8080");
                
                Socket clientSocket = serverSocket.accept();  // Blocks waiting
                System.out.println("Client connected");
                
                try (BufferedReader in = new BufferedReader(
                        new InputStreamReader(clientSocket.getInputStream()));
                     PrintWriter out = new PrintWriter(
                        clientSocket.getOutputStream(), true)) {
                    
                    String line = in.readLine();  // Blocks waiting for data
                    System.out.println("Received: " + line);
                    out.println("Echo: " + line);
                }
                
            } catch (IOException e) {
                e.printStackTrace();
            }
        });
        
        serverThread.start();
        
        // Give server time to start
        try { Thread.sleep(100); } catch (InterruptedException e) {}
        
        // Client
        try (Socket socket = new Socket("localhost", 8080);
             PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
             BufferedReader in = new BufferedReader(
                new InputStreamReader(socket.getInputStream()))) {
            
            out.println("Hello, Server!");
            String response = in.readLine();  // Blocks waiting
            System.out.println("Client received: " + response);
        }
        
        /**
         * NETWORK I/O BLOCKING:
         * 
         * Server:
         * - accept() blocks waiting for connection
         * - readLine() blocks waiting for data
         * - Thread dedicated to each client
         * 
         * Client:
         * - connect() blocks until connected
         * - readLine() blocks waiting for response
         */
    }
    
    /**
     * Multi-threaded server (one thread per client)
     */
    public static void multiThreadedServer() throws IOException {
        ExecutorService executor = Executors.newFixedThreadPool(10);
        
        try (ServerSocket serverSocket = new ServerSocket(8081)) {
            System.out.println("Multi-threaded server on port 8081");
            
            while (true) {
                Socket clientSocket = serverSocket.accept();  // Blocks
                
                // Handle each client in separate thread
                executor.submit(() -> {
                    try (BufferedReader in = new BufferedReader(
                            new InputStreamReader(clientSocket.getInputStream()));
                         PrintWriter out = new PrintWriter(
                            clientSocket.getOutputStream(), true)) {
                        
                        String line;
                        while ((line = in.readLine()) != null) {
                            System.out.println("Thread " + 
                                Thread.currentThread().getId() + ": " + line);
                            out.println("Echo: " + line);
                        }
                        
                    } catch (IOException e) {
                        e.printStackTrace();
                    } finally {
                        try {
                            clientSocket.close();
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    }
                });
            }
        } finally {
            executor.shutdown();
        }
        
        /**
         * ONE THREAD PER CLIENT:
         * 
         * - Each client gets dedicated thread
         * - Thread blocks on read()
         * - Scales poorly (threads expensive)
         * - Context switching overhead
         * 
         * SCALABILITY LIMIT:
         * 
         * 10,000 clients = 10,000 threads
         * Each thread: 1 MB stack
         * Total: 10 GB memory
         * Plus context switching
         */
    }
    
    /**
     * Advantages of traditional I/O
     */
    public static void advantagesOfTraditionalIO() {
        /**
         * ADVANTAGES:
         * 
         * 1. SIMPLE:
         *    Easy to understand
         *    Straightforward code
         *    Sequential logic
         * 
         * 2. FAMILIAR:
         *    Well-known APIs
         *    Extensive documentation
         *    Many examples
         * 
         * 3. GOOD FOR:
         *    - Small number of connections
         *    - File I/O
         *    - Simple applications
         *    - Blocking operations acceptable
         * 
         * 4. BUFFERING:
         *    BufferedInputStream/BufferedOutputStream
         *    Reduces system calls
         *    Better performance
         */
    }
    
    /**
     * Disadvantages of traditional I/O
     */
    public static void disadvantagesOfTraditionalIO() {
        /**
         * DISADVANTAGES:
         * 
         * 1. BLOCKING:
         *    Thread waits during I/O
         *    Can't do other work
         *    Wasted CPU cycles
         * 
         * 2. ONE THREAD PER CONNECTION:
         *    Doesn't scale
         *    High memory usage
         *    Context switching overhead
         * 
         * 3. NO MULTIPLEXING:
         *    Can't monitor multiple connections
         *    One thread = one connection
         * 
         * 4. INEFFICIENT FOR:
         *    - High concurrency
         *    - Many idle connections
         *    - Network servers
         *    - Real-time systems
         * 
         * 5. NO TIMEOUT CONTROL:
         *    Can't set read/write timeouts easily
         *    Socket.setSoTimeout() limited
         */
    }
    
    /**
     * Performance characteristics
     */
    public static void performanceCharacteristics() {
        /**
         * PERFORMANCE:
         * 
         * THROUGHPUT:
         * - Good for sequential I/O
         * - Buffering improves performance
         * - Limited by single thread
         * 
         * LATENCY:
         * - Blocking adds latency
         * - Thread context switching
         * - Waiting for I/O
         * 
         * SCALABILITY:
         * - Poor for many connections
         * - Thread-per-connection limit
         * - Memory usage grows linearly
         * 
         * CPU USAGE:
         * - Low when blocked
         * - High during context switching
         * - Inefficient use of CPU
         * 
         * 
         * BENCHMARKS (approximate):
         * 
         * File read: 100 MB/s (buffered)
         * Network: 1000 connections max
         * Memory: 1 MB per thread
         * Context switch: 1-10 microseconds
         */
    }
    
    public static void main(String[] args) throws IOException {
        System.out.println("=== File I/O ===");
        fileIOExample();
        
        System.out.println("\n=== Network I/O ===");
        networkIOExample();
    }
}
```

---

## 2. Non-Blocking I/O (NIO - Channels and Selectors)

### Java NIO Foundation

```java
/**
 * NON-BLOCKING I/O (NIO)
 * 
 * Java 1.4 - Channel-based, non-blocking I/O
 */

import java.nio.*;
import java.nio.channels.*;
import java.io.*;
import java.net.*;
import java.util.*;

public class NonBlockingNIO {
    
    /**
     * NIO characteristics
     */
    public static void nioCharacteristics() {
        /**
         * NIO CHARACTERISTICS:
         * 
         * 1. CHANNEL-BASED:
         *    Channels replace streams
         *    Bidirectional (read/write)
         *    Work with buffers
         * 
         * 2. NON-BLOCKING:
         *    read() returns immediately
         *    write() returns immediately
         *    Even if no data ready
         * 
         * 3. BUFFER-ORIENTED:
         *    Data read into buffers
         *    Data written from buffers
         *    Direct memory access
         * 
         * 4. SELECTORS:
         *    Multiplexing support
         *    Monitor multiple channels
         *    One thread, many connections
         * 
         * 5. SCATTER/GATHER:
         *    Read into multiple buffers
         *    Write from multiple buffers
         */
    }
    
    /**
     * Basic channel I/O
     */
    public static void basicChannelIO() throws IOException {
        // Write
        try (FileChannel channel = FileChannel.open(
                Paths.get("data.txt"),
                StandardOpenOption.CREATE,
                StandardOpenOption.WRITE)) {
            
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            buffer.put("Hello, NIO!".getBytes());
            buffer.flip();  // Prepare for reading
            
            while (buffer.hasRemaining()) {
                channel.write(buffer);
            }
            
            /**
             * CHANNEL WRITE:
             * 
             * 1. Create buffer
             * 2. Put data in buffer
             * 3. flip() switches to read mode
             * 4. write() transfers from buffer
             * 5. May not write all at once
             */
        }
        
        // Read
        try (FileChannel channel = FileChannel.open(
                Paths.get("data.txt"),
                StandardOpenOption.READ)) {
            
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            
            int bytesRead = channel.read(buffer);
            buffer.flip();  // Prepare for reading
            
            while (buffer.hasRemaining()) {
                System.out.print((char) buffer.get());
            }
            
            /**
             * CHANNEL READ:
             * 
             * 1. Allocate buffer
             * 2. read() fills buffer
             * 3. Returns bytes read (may be 0)
             * 4. flip() switches to read mode
             * 5. get() retrieves data
             */
        }
    }
    
    /**
     * Buffer management
     */
    public static void bufferManagement() {
        ByteBuffer buffer = ByteBuffer.allocate(10);
        
        System.out.println("=== Initial State ===");
        printBufferState(buffer);
        
        // Write data
        buffer.put((byte) 'H');
        buffer.put((byte) 'e');
        buffer.put((byte) 'l');
        buffer.put((byte) 'l');
        buffer.put((byte) 'o');
        
        System.out.println("\n=== After Writing ===");
        printBufferState(buffer);
        
        // Flip to read mode
        buffer.flip();
        
        System.out.println("\n=== After Flip ===");
        printBufferState(buffer);
        
        // Read data
        while (buffer.hasRemaining()) {
            System.out.print((char) buffer.get());
        }
        System.out.println();
        
        System.out.println("\n=== After Reading ===");
        printBufferState(buffer);
        
        // Compact for more writing
        buffer.compact();
        
        System.out.println("\n=== After Compact ===");
        printBufferState(buffer);
        
        /**
         * BUFFER STATES:
         * 
         * Initial:
         * - position = 0
         * - limit = capacity
         * - ready for writing
         * 
         * After Writing:
         * - position = bytes written
         * - limit = capacity
         * 
         * After flip():
         * - position = 0
         * - limit = previous position
         * - ready for reading
         * 
         * After compact():
         * - Unread data moved to start
         * - position = unread bytes
         * - ready for more writing
         */
    }
    
    private static void printBufferState(ByteBuffer buffer) {
        System.out.println("Position: " + buffer.position());
        System.out.println("Limit: " + buffer.limit());
        System.out.println("Capacity: " + buffer.capacity());
        System.out.println("Remaining: " + buffer.remaining());
    }
    
    /**
     * Non-blocking server with selector
     */
    public static void nonBlockingServer() throws IOException {
        Selector selector = Selector.open();
        ServerSocketChannel serverChannel = ServerSocketChannel.open();
        
        serverChannel.bind(new InetSocketAddress(8082));
        serverChannel.configureBlocking(false);  // Non-blocking!
        
        // Register for accept events
        serverChannel.register(selector, SelectionKey.OP_ACCEPT);
        
        System.out.println("Non-blocking server on port 8082");
        
        while (true) {
            // Wait for events (blocks, but monitors many channels)
            int readyCount = selector.select();
            
            if (readyCount == 0) {
                continue;
            }
            
            Set<SelectionKey> selectedKeys = selector.selectedKeys();
            Iterator<SelectionKey> iterator = selectedKeys.iterator();
            
            while (iterator.hasNext()) {
                SelectionKey key = iterator.next();
                iterator.remove();
                
                if (!key.isValid()) {
                    continue;
                }
                
                if (key.isAcceptable()) {
                    handleAccept(key, selector);
                } else if (key.isReadable()) {
                    handleRead(key);
                } else if (key.isWritable()) {
                    handleWrite(key);
                }
            }
        }
        
        /**
         * SELECTOR PATTERN:
         * 
         * 1. Create selector
         * 2. Register channels with selector
         * 3. Specify interested operations (accept, read, write)
         * 4. selector.select() blocks until event
         * 5. Process ready keys
         * 6. Remove processed keys
         * 
         * ONE THREAD, MANY CONNECTIONS!
         */
    }
    
    private static void handleAccept(SelectionKey key, Selector selector) 
            throws IOException {
        ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();
        SocketChannel clientChannel = serverChannel.accept();
        
        if (clientChannel != null) {
            clientChannel.configureBlocking(false);
            clientChannel.register(selector, SelectionKey.OP_READ);
            System.out.println("Accepted connection from: " + 
                clientChannel.getRemoteAddress());
        }
    }
    
    private static void handleRead(SelectionKey key) throws IOException {
        SocketChannel channel = (SocketChannel) key.channel();
        ByteBuffer buffer = ByteBuffer.allocate(1024);
        
        int bytesRead = channel.read(buffer);
        
        if (bytesRead == -1) {
            // Connection closed
            System.out.println("Connection closed by client");
            channel.close();
            key.cancel();
            return;
        }
        
        if (bytesRead > 0) {
            buffer.flip();
            byte[] data = new byte[buffer.remaining()];
            buffer.get(data);
            
            String message = new String(data);
            System.out.println("Received: " + message);
            
            // Echo back
            ByteBuffer writeBuffer = ByteBuffer.wrap(("Echo: " + message).getBytes());
            key.attach(writeBuffer);
            key.interestOps(SelectionKey.OP_WRITE);
        }
    }
    
    private static void handleWrite(SelectionKey key) throws IOException {
        SocketChannel channel = (SocketChannel) key.channel();
        ByteBuffer buffer = (ByteBuffer) key.attachment();
        
        if (buffer != null && buffer.hasRemaining()) {
            channel.write(buffer);
        }
        
        if (!buffer.hasRemaining()) {
            key.interestOps(SelectionKey.OP_READ);
        }
    }
    
    /**
     * Advantages of NIO
     */
    public static void advantagesOfNIO() {
        /**
         * ADVANTAGES:
         * 
         * 1. SCALABILITY:
         *    One thread, many connections
         *    No thread-per-connection
         *    Lower memory usage
         * 
         * 2. MULTIPLEXING:
         *    Selector monitors many channels
         *    Single thread handles all
         *    Efficient CPU usage
         * 
         * 3. BIDIRECTIONAL:
         *    Same channel for read/write
         *    Simpler code
         * 
         * 4. BUFFER CONTROL:
         *    Direct memory access
         *    Zero-copy operations
         *    Better performance
         * 
         * 5. SCATTER/GATHER:
         *    Read into multiple buffers
         *    Write from multiple buffers
         *    Efficient for protocols
         */
    }
    
    /**
     * Disadvantages of NIO
     */
    public static void disadvantagesOfNIO() {
        /**
         * DISADVANTAGES:
         * 
         * 1. COMPLEXITY:
         *    More complex API
         *    Harder to understand
         *    More code required
         * 
         * 2. BUFFER MANAGEMENT:
         *    Manual buffer handling
         *    flip(), compact(), clear()
         *    Easy to get wrong
         * 
         * 3. DEBUGGING:
         *    Harder to debug
         *    Asynchronous behavior
         *    State machines complex
         * 
         * 4. STILL BLOCKS:
         *    selector.select() blocks
         *    Not fully asynchronous
         *    One slow channel affects all
         * 
         * 5. LEARNING CURVE:
         *    Steep learning curve
         *    Different paradigm
         *    More potential bugs
         */
    }
    
    /**
     * Performance characteristics
     */
    public static void nioPerformance() {
        /**
         * NIO PERFORMANCE:
         * 
         * THROUGHPUT:
         * - Similar to traditional I/O
         * - Direct buffers faster
         * - Zero-copy operations
         * 
         * LATENCY:
         * - Lower for many connections
         * - No thread context switching
         * - selector.select() overhead
         * 
         * SCALABILITY:
         * - Excellent for many connections
         * - 10,000+ connections possible
         * - Single thread or small pool
         * 
         * MEMORY:
         * - Lower than traditional I/O
         * - No thread per connection
         * - Buffer pooling important
         * 
         * 
         * BENCHMARKS (approximate):
         * 
         * Connections: 10,000+ per thread
         * Memory: ~100 KB per connection
         * Latency: Lower than blocking I/O
         * CPU: More efficient
         */
    }
    
    public static void main(String[] args) throws IOException {
        System.out.println("=== Basic Channel I/O ===");
        basicChannelIO();
        
        System.out.println("\n=== Buffer Management ===");
        bufferManagement();
    }
}
```

---

## 3. Asynchronous I/O (NIO.2 - AsynchronousChannel)

### Java NIO.2 Foundation

```java
/**
 * ASYNCHRONOUS I/O (NIO.2)
 * 
 * Java 7 - Truly asynchronous I/O
 */

import java.nio.*;
import java.nio.channels.*;
import java.nio.file.*;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.util.concurrent.*;

public class AsynchronousNIO2 {
    
    /**
     * NIO.2 characteristics
     */
    public static void nio2Characteristics() {
        /**
         * NIO.2 CHARACTERISTICS:
         * 
         * 1. TRULY ASYNCHRONOUS:
         *    I/O initiated, callback on completion
         *    No blocking at all
         *    OS-level async support
         * 
         * 2. COMPLETION HANDLERS:
         *    completed() on success
         *    failed() on error
         *    Called when I/O finishes
         * 
         * 3. FUTURE-BASED:
         *    Returns Future<Integer>
         *    Can wait or poll
         *    Alternative to callbacks
         * 
         * 4. THREAD POOLS:
         *    Uses AsynchronousChannelGroup
         *    Configurable thread pool
         *    Efficient thread usage
         * 
         * 5. FILE OPERATIONS:
         *    Improved file I/O (Path API)
         *    Directory watching
         *    Symbolic link handling
         */
    }
    
    /**
     * Asynchronous file I/O with completion handler
     */
    public static void asyncFileWithCallback() throws IOException {
        Path path = Paths.get("async-data.txt");
        
        // Write
        AsynchronousFileChannel writeChannel = AsynchronousFileChannel.open(
            path,
            StandardOpenOption.CREATE,
            StandardOpenOption.WRITE
        );
        
        ByteBuffer buffer = ByteBuffer.wrap("Hello, Async!".getBytes());
        
        writeChannel.write(buffer, 0, null, new CompletionHandler<Integer, Object>() {
            @Override
            public void completed(Integer bytesWritten, Object attachment) {
                System.out.println("Write completed: " + bytesWritten + " bytes");
                
                try {
                    writeChannel.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            
            @Override
            public void failed(Throwable exc, Object attachment) {
                System.err.println("Write failed: " + exc.getMessage());
            }
        });
        
        // Read
        AsynchronousFileChannel readChannel = AsynchronousFileChannel.open(
            path,
            StandardOpenOption.READ
        );
        
        ByteBuffer readBuffer = ByteBuffer.allocate(1024);
        
        readChannel.read(readBuffer, 0, readBuffer, 
            new CompletionHandler<Integer, ByteBuffer>() {
            
            @Override
            public void completed(Integer bytesRead, ByteBuffer buffer) {
                System.out.println("Read completed: " + bytesRead + " bytes");
                
                buffer.flip();
                byte[] data = new byte[buffer.remaining()];
                buffer.get(data);
                System.out.println("Data: " + new String(data));
                
                try {
                    readChannel.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            
            @Override
            public void failed(Throwable exc, ByteBuffer buffer) {
                System.err.println("Read failed: " + exc.getMessage());
            }
        });
        
        /**
         * COMPLETION HANDLER:
         * 
         * completed(result, attachment):
         * - Called on success
         * - result = bytes read/written
         * - attachment = custom object
         * 
         * failed(exception, attachment):
         * - Called on failure
         * - exception = error details
         * 
         * Runs in thread pool thread
         * Non-blocking
         */
    }
    
    /**
     * Asynchronous file I/O with Future
     */
    public static void asyncFileWithFuture() throws IOException, 
            InterruptedException, ExecutionException {
        
        Path path = Paths.get("future-data.txt");
        
        // Write
        AsynchronousFileChannel channel = AsynchronousFileChannel.open(
            path,
            StandardOpenOption.CREATE,
            StandardOpenOption.WRITE
        );
        
        ByteBuffer buffer = ByteBuffer.wrap("Hello, Future!".getBytes());
        
        Future<Integer> writeFuture = channel.write(buffer, 0);
        
        // Do other work here...
        System.out.println("Writing asynchronously...");
        
        // Wait for completion
        Integer bytesWritten = writeFuture.get();  // Blocks until done
        System.out.println("Wrote " + bytesWritten + " bytes");
        
        channel.close();
        
        /**
         * FUTURE-BASED:
         * 
         * - Returns Future immediately
         * - I/O happens asynchronously
         * - get() blocks until complete
         * - get(timeout) with timeout
         * - isDone() to check status
         * 
         * More flexible than callback
         * Can choose when to wait
         */
    }
    
    /**
     * Asynchronous server
     */
    public static void asyncServer() throws IOException, InterruptedException {
        AsynchronousServerSocketChannel serverChannel = 
            AsynchronousServerSocketChannel.open();
        
        serverChannel.bind(new InetSocketAddress(8083));
        
        System.out.println("Async server on port 8083");
        
        // Accept connections
        serverChannel.accept(null, new CompletionHandler<
                AsynchronousSocketChannel, Object>() {
            
            @Override
            public void completed(AsynchronousSocketChannel clientChannel, 
                    Object attachment) {
                
                System.out.println("Client connected");
                
                // Accept next connection
                serverChannel.accept(null, this);
                
                // Handle this client
                handleClient(clientChannel);
            }
            
            @Override
            public void failed(Throwable exc, Object attachment) {
                System.err.println("Accept failed: " + exc.getMessage());
            }
        });
        
        // Keep server running
        Thread.sleep(60000);
        
        /**
         * ASYNC ACCEPT:
         * 
         * - accept() returns immediately
         * - completed() called when client connects
         * - Chain accept() calls for multiple clients
         * - No blocking
         */
    }
    
    private static void handleClient(AsynchronousSocketChannel channel) {
        ByteBuffer buffer = ByteBuffer.allocate(1024);
        
        // Read from client
        channel.read(buffer, buffer, new CompletionHandler<Integer, ByteBuffer>() {
            @Override
            public void completed(Integer bytesRead, ByteBuffer buffer) {
                if (bytesRead == -1) {
                    try {
                        channel.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    return;
                }
                
                buffer.flip();
                byte[] data = new byte[buffer.remaining()];
                buffer.get(data);
                
                String message = new String(data);
                System.out.println("Received: " + message);
                
                // Echo back
                ByteBuffer writeBuffer = ByteBuffer.wrap(
                    ("Echo: " + message).getBytes());
                
                channel.write(writeBuffer, writeBuffer, 
                    new CompletionHandler<Integer, ByteBuffer>() {
                    
                    @Override
                    public void completed(Integer bytesWritten, ByteBuffer buffer) {
                        System.out.println("Echoed " + bytesWritten + " bytes");
                        
                        // Read next message
                        buffer.clear();
                        channel.read(buffer, buffer, 
                            handleClient.this);  // Recursive
                    }
                    
                    @Override
                    public void failed(Throwable exc, ByteBuffer buffer) {
                        System.err.println("Write failed: " + exc.getMessage());
                    }
                });
            }
            
            @Override
            public void failed(Throwable exc, ByteBuffer buffer) {
                System.err.println("Read failed: " + exc.getMessage());
            }
        });
    }
    
    /**
     * Custom thread pool
     */
    public static void customThreadPool() throws IOException, InterruptedException {
        // Create custom thread pool
        ExecutorService executor = Executors.newFixedThreadPool(4);
        
        AsynchronousChannelGroup group = 
            AsynchronousChannelGroup.withThreadPool(executor);
        
        AsynchronousServerSocketChannel server = 
            AsynchronousServerSocketChannel.open(group);
        
        server.bind(new InetSocketAddress(8084));
        
        System.out.println("Server with custom thread pool on port 8084");
        
        /**
         * CUSTOM THREAD POOL:
         * 
         * - Control number of threads
         * - Share thread pool across channels
         * - Better resource management
         * - Monitor thread pool metrics
         */
        
        Thread.sleep(60000);
        
        executor.shutdown();
    }
    
    /**
     * Advantages of NIO.2
     */
    public static void advantagesOfNIO2() {
        /**
         * ADVANTAGES:
         * 
         * 1. TRULY ASYNCHRONOUS:
         *    No blocking at all
         *    OS-level async support
         *    Maximum efficiency
         * 
         * 2. CALLBACK MODEL:
         *    Clean async code
         *    Reactive programming
         *    Event-driven
         * 
         * 3. FUTURE SUPPORT:
         *    Alternative to callbacks
         *    Flexible waiting
         *    Composable
         * 
         * 4. THREAD POOL CONTROL:
         *    Custom thread pools
         *    Resource management
         *    Better scaling
         * 
         * 5. IMPROVED FILE I/O:
         *    Path API (better than File)
         *    Symbolic links
         *    Directory watching
         */
    }
    
    /**
     * Disadvantages of NIO.2
     */
    public static void disadvantagesOfNIO2() {
        /**
         * DISADVANTAGES:
         * 
         * 1. COMPLEXITY:
         *    Most complex API
         *    Callback hell potential
         *    Hard to debug
         * 
         * 2. PLATFORM SUPPORT:
         *    OS-dependent
         *    Windows: IOCP
         *    Linux: epoll
         *    May fall back to thread pool
         * 
         * 3. ERROR HANDLING:
         *    Callbacks make it harder
         *    Exception handling complex
         * 
         * 4. TESTING:
         *    Harder to test
         *    Asynchronous behavior
         *    Timing issues
         * 
         * 5. OVERKILL:
         *    May be too complex
         *    For simple use cases
         *    Traditional I/O sufficient
         */
    }
    
    /**
     * Performance characteristics
     */
    public static void nio2Performance() {
        /**
         * NIO.2 PERFORMANCE:
         * 
         * THROUGHPUT:
         * - Best for high-concurrency
         * - OS-level async support
         * - Zero context switching
         * 
         * LATENCY:
         * - Lowest latency
         * - No blocking
         * - Immediate callbacks
         * 
         * SCALABILITY:
         * - Best scalability
         * - 100,000+ connections
         * - Small thread pool
         * 
         * CPU:
         * - Most efficient
         * - No busy waiting
         * - Event-driven
         * 
         * 
         * BENCHMARKS (approximate):
         * 
         * Connections: 100,000+ per thread pool
         * Memory: ~50 KB per connection
         * Latency: Lowest
         * CPU: Most efficient
         */
    }
    
    public static void main(String[] args) throws Exception {
        System.out.println("=== Async File with Callback ===");
        asyncFileWithCallback();
        Thread.sleep(1000);  // Wait for async operations
        
        System.out.println("\n=== Async File with Future ===");
        asyncFileWithFuture();
    }
}
```

---

## 4. Buffer Management

### Deep Dive into Buffers

```java
/**
 * BUFFER MANAGEMENT
 * 
 * Understanding buffer internals and operations
 */

import java.nio.*;

public class BufferManagementDeep {
    
    /**
     * Buffer fundamentals
     */
    public static void bufferFundamentals() {
        /**
         * BUFFER PROPERTIES:
         * 
         * 1. CAPACITY:
         *    Maximum number of elements
         *    Set at creation
         *    Never changes
         * 
         * 2. LIMIT:
         *    Index of first element not to read/write
         *    limit <= capacity
         *    Changeable
         * 
         * 3. POSITION:
         *    Index of next element to read/write
         *    0 <= position <= limit
         *    Advances on get/put
         * 
         * 4. MARK:
         *    Saved position
         *    Can reset() to mark
         *    Optional
         * 
         * 
         * INVARIANT:
         * 
         * 0 <= mark <= position <= limit <= capacity
         */
    }
    
    /**
     * Buffer operations
     */
    public static void bufferOperations() {
        ByteBuffer buffer = ByteBuffer.allocate(10);
        
        System.out.println("=== allocate(10) ===");
        System.out.println("capacity=" + buffer.capacity());
        System.out.println("position=" + buffer.position());
        System.out.println("limit=" + buffer.limit());
        System.out.println("remaining=" + buffer.remaining());
        
        // Put data
        buffer.put((byte) 'H');
        buffer.put((byte) 'E');
        buffer.put((byte) 'L');
        buffer.put((byte) 'L');
        buffer.put((byte) 'O');
        
        System.out.println("\n=== After put 5 bytes ===");
        System.out.println("position=" + buffer.position());
        System.out.println("limit=" + buffer.limit());
        System.out.println("remaining=" + buffer.remaining());
        
        // flip() - switch to read mode
        buffer.flip();
        
        System.out.println("\n=== After flip() ===");
        System.out.println("position=" + buffer.position());
        System.out.println("limit=" + buffer.limit());
        System.out.println("remaining=" + buffer.remaining());
        
        // Read 2 bytes
        buffer.get();
        buffer.get();
        
        System.out.println("\n=== After get 2 bytes ===");
        System.out.println("position=" + buffer.position());
        System.out.println("limit=" + buffer.limit());
        System.out.println("remaining=" + buffer.remaining());
        
        // compact() - prepare for more writing
        buffer.compact();
        
        System.out.println("\n=== After compact() ===");
        System.out.println("position=" + buffer.position());
        System.out.println("limit=" + buffer.limit());
        System.out.println("remaining=" + buffer.remaining());
        
        /**
         * OPERATION SUMMARY:
         * 
         * flip():
         * - limit = position
         * - position = 0
         * - Switches write → read mode
         * 
         * clear():
         * - position = 0
         * - limit = capacity
         * - Discards all data
         * - Switches read → write mode
         * 
         * compact():
         * - Copies unread data to start
         * - position = number of unread bytes
         * - limit = capacity
         * - Preserves unread data
         * 
         * rewind():
         * - position = 0
         * - limit unchanged
         * - Re-read from start
         */
    }
    
    /**
     * Buffer types
     */
    public static void bufferTypes() {
        /**
         * BUFFER TYPES:
         * 
         * ByteBuffer - bytes
         * CharBuffer - chars
         * ShortBuffer - shorts
         * IntBuffer - ints
         * LongBuffer - longs
         * FloatBuffer - floats
         * DoubleBuffer - doubles
         * 
         * All extend Buffer
         * ByteBuffer most common
         */
        
        // ByteBuffer
        ByteBuffer byteBuffer = ByteBuffer.allocate(100);
        byteBuffer.put((byte) 42);
        
        // IntBuffer
        IntBuffer intBuffer = IntBuffer.allocate(10);
        intBuffer.put(42);
        intBuffer.put(100);
        
        // View buffers
        ByteBuffer bytes = ByteBuffer.allocate(16);
        IntBuffer ints = bytes.asIntBuffer();  // View as ints
        
        ints.put(0, 1000);  // Write int
        System.out.println("Byte 0: " + bytes.get(0));  // Read underlying bytes
        System.out.println("Byte 1: " + bytes.get(1));
        System.out.println("Byte 2: " + bytes.get(2));
        System.out.println("Byte 3: " + bytes.get(3));
        
        /**
         * VIEW BUFFERS:
         * 
         * asIntBuffer(), asFloatBuffer(), etc.
         * Share underlying data
         * Different view of same bytes
         */
    }
    
    /**
     * Bulk operations
     */
    public static void bulkOperations() {
        ByteBuffer buffer = ByteBuffer.allocate(100);
        
        // Bulk put
        byte[] data = "Hello, World!".getBytes();
        buffer.put(data);  // Puts entire array
        
        // Bulk get
        buffer.flip();
        byte[] result = new byte[13];
        buffer.get(result);  // Gets into array
        
        System.out.println("Bulk read: " + new String(result));
        
        /**
         * BULK OPERATIONS:
         * 
         * put(byte[]) - put entire array
         * put(byte[], offset, length) - put portion
         * get(byte[]) - get entire array
         * get(byte[], offset, length) - get portion
         * 
         * More efficient than element-by-element
         */
    }
    
    /**
     * Slice and duplicate
     */
    public static void sliceAndDuplicate() {
        ByteBuffer original = ByteBuffer.allocate(10);
        original.put("HELLO".getBytes());
        original.flip();
        
        // Advance position
        original.get();
        original.get();
        
        // Slice - share data, independent position
        ByteBuffer slice = original.slice();
        System.out.println("Slice capacity: " + slice.capacity());  // 3 (remaining)
        System.out.println("Slice position: " + slice.position());  // 0
        
        slice.put((byte) 'X');  // Modifies original!
        
        original.position(2);
        System.out.println("Original after slice modify: " + (char) original.get());
        
        // Duplicate - share data, independent position
        ByteBuffer dup = original.duplicate();
        dup.position(0);
        
        /**
         * SLICE:
         * - Share data
         * - Independent position/limit/mark
         * - Capacity = original.remaining()
         * - Changes visible in both
         * 
         * DUPLICATE:
         * - Share data
         * - Independent position/limit/mark
         * - Same capacity as original
         * - Changes visible in both
         */
    }
    
    /**
     * Read-only buffers
     */
    public static void readOnlyBuffers() {
        ByteBuffer buffer = ByteBuffer.allocate(10);
        buffer.put("HELLO".getBytes());
        buffer.flip();
        
        // Create read-only view
        ByteBuffer readOnly = buffer.asReadOnlyBuffer();
        
        System.out.println("Read: " + (char) readOnly.get());
        
        try {
            readOnly.put((byte) 'X');  // ReadOnlyBufferException
        } catch (ReadOnlyBufferException e) {
            System.out.println("Cannot write to read-only buffer");
        }
        
        /**
         * READ-ONLY BUFFERS:
         * 
         * asReadOnlyBuffer() - create read-only view
         * Share data with original
         * put() throws ReadOnlyBufferException
         * Useful for protecting data
         */
    }
    
    /**
     * Best practices
     */
    public static void bestPractices() {
        /**
         * BUFFER BEST PRACTICES:
         * 
         * 1. ALWAYS FLIP:
         *    After writing, before reading
         *    buffer.flip()
         * 
         * 2. CLEAR OR COMPACT:
         *    clear() - discard all
         *    compact() - preserve unread
         * 
         * 3. CHECK REMAINING:
         *    while (buffer.hasRemaining())
         *    Avoid BufferOverflowException
         * 
         * 4. USE BULK OPERATIONS:
         *    More efficient
         *    put(byte[]), get(byte[])
         * 
         * 5. POOL BUFFERS:
         *    Reuse buffers
         *    Avoid allocation overhead
         * 
         * 6. DIRECT BUFFERS FOR I/O:
         *    ByteBuffer.allocateDirect()
         *    Better for channel I/O
         * 
         * 7. HEAP BUFFERS FOR PROCESSING:
         *    ByteBuffer.allocate()
         *    Faster access from Java
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Buffer Operations ===");
        bufferOperations();
        
        System.out.println("\n=== Buffer Types ===");
        bufferTypes();
        
        System.out.println("\n=== Slice and Duplicate ===");
        sliceAndDuplicate();
    }
}
```

---

## 5. Direct vs Heap Buffers

### Memory Management Comparison

```java
/**
 * DIRECT VS HEAP BUFFERS
 * 
 * Understanding buffer memory allocation
 */

import java.nio.*;

public class DirectVsHeapBuffers {
    
    /**
     * Buffer allocation types
     */
    public static void bufferAllocationTypes() {
        /**
         * HEAP BUFFER:
         * 
         * ByteBuffer.allocate(capacity)
         * 
         * - Allocated in JVM heap
         * - Subject to garbage collection
         * - Faster to allocate
         * - Slower for I/O operations
         * - Array accessible (array())
         * 
         * 
         * DIRECT BUFFER:
         * 
         * ByteBuffer.allocateDirect(capacity)
         * 
         * - Allocated outside JVM heap
         * - Not subject to GC (until buffer collected)
         * - Slower to allocate
         * - Faster for I/O operations
         * - No array access
         * - Limited by -XX:MaxDirectMemorySize
         */
    }
    
    /**
     * Creating buffers
     */
    public static void creatingBuffers() {
        // Heap buffer
        ByteBuffer heapBuffer = ByteBuffer.allocate(1024);
        System.out.println("Heap buffer:");
        System.out.println("  isDirect: " + heapBuffer.isDirect());
        System.out.println("  hasArray: " + heapBuffer.hasArray());
        
        // Direct buffer
        ByteBuffer directBuffer = ByteBuffer.allocateDirect(1024);
        System.out.println("\nDirect buffer:");
        System.out.println("  isDirect: " + directBuffer.isDirect());
        System.out.println("  hasArray: " + directBuffer.hasArray());
        
        /**
         * IDENTIFICATION:
         * 
         * isDirect() - true for direct buffers
         * hasArray() - false for direct buffers
         */
    }
    
    /**
     * Performance comparison
     */
    public static void performanceComparison() {
        int size = 1024 * 1024;  // 1 MB
        int iterations = 1000;
        
        // Allocation time - heap
        long heapAllocStart = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            ByteBuffer.allocate(size);
        }
        long heapAllocTime = System.nanoTime() - heapAllocStart;
        
        // Allocation time - direct
        long directAllocStart = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            ByteBuffer.allocateDirect(size);
        }
        long directAllocTime = System.nanoTime() - directAllocStart;
        
        System.out.println("Allocation time:");
        System.out.println("  Heap: " + heapAllocTime / 1_000_000 + " ms");
        System.out.println("  Direct: " + directAllocTime / 1_000_000 + " ms");
        
        // Access time - heap
        ByteBuffer heapBuf = ByteBuffer.allocate(size);
        long heapAccessStart = System.nanoTime();
        for (int i = 0; i < size; i++) {
            heapBuf.put((byte) i);
        }
        long heapAccessTime = System.nanoTime() - heapAccessStart;
        
        // Access time - direct
        ByteBuffer directBuf = ByteBuffer.allocateDirect(size);
        long directAccessStart = System.nanoTime();
        for (int i = 0; i < size; i++) {
            directBuf.put((byte) i);
        }
        long directAccessTime = System.nanoTime() - directAccessStart;
        
        System.out.println("\nAccess time (put):");
        System.out.println("  Heap: " + heapAccessTime / 1_000_000 + " ms");
        System.out.println("  Direct: " + directAccessTime / 1_000_000 + " ms");
        
        /**
         * TYPICAL RESULTS:
         * 
         * Allocation:
         * - Heap: Faster (JVM managed)
         * - Direct: Slower (native allocation)
         * 
         * Access from Java:
         * - Heap: Faster (in JVM heap)
         * - Direct: Slower (native memory)
         * 
         * I/O operations:
         * - Heap: Slower (needs copy)
         * - Direct: Faster (zero-copy)
         */
    }
    
    /**
     * I/O performance
     */
    public static void ioPerformance() throws Exception {
        Path path = Paths.get("test-file.dat");
        int size = 1024 * 1024 * 10;  // 10 MB
        
        // Write with heap buffer
        ByteBuffer heapBuffer = ByteBuffer.allocate(size);
        for (int i = 0; i < size; i++) {
            heapBuffer.put((byte) i);
        }
        heapBuffer.flip();
        
        long heapWriteStart = System.nanoTime();
        try (FileChannel channel = FileChannel.open(path, 
                StandardOpenOption.CREATE, StandardOpenOption.WRITE)) {
            channel.write(heapBuffer);
        }
        long heapWriteTime = System.nanoTime() - heapWriteStart;
        
        Files.delete(path);
        
        // Write with direct buffer
        ByteBuffer directBuffer = ByteBuffer.allocateDirect(size);
        for (int i = 0; i < size; i++) {
            directBuffer.put((byte) i);
        }
        directBuffer.flip();
        
        long directWriteStart = System.nanoTime();
        try (FileChannel channel = FileChannel.open(path, 
                StandardOpenOption.CREATE, StandardOpenOption.WRITE)) {
            channel.write(directBuffer);
        }
        long directWriteTime = System.nanoTime() - directWriteStart;
        
        System.out.println("I/O Write time (10 MB):");
        System.out.println("  Heap: " + heapWriteTime / 1_000_000 + " ms");
        System.out.println("  Direct: " + directWriteTime / 1_000_000 + " ms");
        
        Files.delete(path);
        
        /**
         * I/O PERFORMANCE:
         * 
         * Heap buffer:
         * 1. Java creates temp direct buffer
         * 2. Copies data from heap to direct
         * 3. OS reads from direct buffer
         * 4. Extra copy step
         * 
         * Direct buffer:
         * 1. OS reads directly from buffer
         * 2. Zero-copy
         * 3. Faster I/O
         */
    }
    
    /**
     * Memory implications
     */
    public static void memoryImplications() {
        /**
         * HEAP BUFFER MEMORY:
         * 
         * - Counted in heap memory
         * - Subject to GC
         * - Visible in heap dumps
         * - Limited by -Xmx
         * - Cleaned by GC
         * 
         * 
         * DIRECT BUFFER MEMORY:
         * 
         * - Outside heap
         * - Not visible in heap dumps
         * - Limited by -XX:MaxDirectMemorySize (default: -Xmx)
         * - Cleaned when buffer becomes unreachable
         * - Cleaner thread runs
         * - Can cause OutOfMemoryError (direct memory)
         * 
         * 
         * MEMORY LEAKS:
         * 
         * Direct buffers can leak:
         * - Keep reference → never cleaned
         * - No explicit deallocation
         * - Wait for GC
         * - May need System.gc() hint
         */
    }
    
    /**
     * When to use each
     */
    public static void whenToUseEach() {
        /**
         * USE HEAP BUFFERS WHEN:
         * 
         * ✓ Temporary buffers
         * ✓ Frequent allocation/deallocation
         * ✓ Need array access (array())
         * ✓ Processing in Java
         * ✓ Small buffers
         * ✓ No I/O operations
         * 
         * Example:
         * - Parsing data
         * - String processing
         * - Temporary calculations
         * 
         * 
         * USE DIRECT BUFFERS WHEN:
         * 
         * ✓ I/O operations
         * ✓ Long-lived buffers
         * ✓ Large buffers
         * ✓ Channel I/O
         * ✓ Performance critical
         * ✓ Minimize GC impact
         * 
         * Example:
         * - Network I/O
         * - File I/O
         * - Buffer pools
         * - Zero-copy requirements
         */
    }
    
    /**
     * Best practices
     */
    public static void bestPractices() {
        /**
         * DIRECT BUFFER BEST PRACTICES:
         * 
         * 1. POOL AND REUSE:
         *    Allocation expensive
         *    Create pool of direct buffers
         *    Reuse across operations
         * 
         * 2. MONITOR USAGE:
         *    Watch direct memory usage
         *    Set -XX:MaxDirectMemorySize
         *    Can cause OOM
         * 
         * 3. EXPLICIT CLEANUP:
         *    sun.misc.Unsafe.freeMemory() (internal)
         *    Or wait for GC
         *    Consider System.gc() hint
         * 
         * 4. SIZE APPROPRIATELY:
         *    Don't over-allocate
         *    Balance memory vs performance
         * 
         * 5. USE FOR I/O ONLY:
         *    Not for general processing
         *    Heap buffers faster for Java access
         * 
         * 6. TUNE JVM:
         *    -XX:MaxDirectMemorySize=2g
         *    Monitor with JMX
         */
    }
    
    /**
     * Common pitfalls
     */
    public static void commonPitfalls() {
        /**
         * PITFALLS:
         * 
         * 1. OVERUSING DIRECT BUFFERS:
         *    Not always faster
         *    Allocation overhead
         *    Use for I/O only
         * 
         * 2. NOT POOLING:
         *    Allocating frequently
         *    Slow and wasteful
         *    Pool and reuse
         * 
         * 3. MEMORY LEAKS:
         *    Keeping references
         *    Direct memory not freed
         *    Monitor with JMX
         * 
         * 4. WRONG SIZE:
         *    Too small: many I/O calls
         *    Too large: wasted memory
         *    Benchmark optimal size
         * 
         * 5. ACCESSING ARRAY:
         *    array() throws on direct buffers
         *    Check hasArray() first
         */
    }
    
    public static void main(String[] args) throws Exception {
        System.out.println("=== Creating Buffers ===");
        creatingBuffers();
        
        System.out.println("\n=== Performance Comparison ===");
        performanceComparison();
        
        System.out.println("\n=== I/O Performance ===");
        ioPerformance();
    }
}
```

---

## 6. Memory-Mapped Files

### Zero-Copy File Access

```java
/**
 * MEMORY-MAPPED FILES
 * 
 * Direct memory mapping for file I/O
 */

import java.nio.*;
import java.nio.channels.*;
import java.nio.file.*;
import java.io.IOException;

public class MemoryMappedFiles {
    
    /**
     * Memory-mapped file characteristics
     */
    public static void memoryMappedCharacteristics() {
        /**
         * MEMORY-MAPPED FILES:
         * 
         * 1. MAP FILE TO MEMORY:
         *    File contents mapped to virtual memory
         *    OS handles paging
         *    Looks like byte array
         * 
         * 2. ZERO-COPY:
         *    No copying between kernel and user space
         *    Direct memory access
         *    OS manages I/O
         * 
         * 3. SHARED MEMORY:
         *    Multiple processes can map same file
         *    Inter-process communication
         *    Changes visible to all
         * 
         * 4. LAZY LOADING:
         *    Pages loaded on demand
         *    Only accessed pages in memory
         *    OS handles paging
         * 
         * 5. PERSISTENCE:
         *    Changes written back to file
         *    OS handles when
         *    MappedByteBuffer.force() to flush
         */
    }
    
    /**
     * Creating memory-mapped file
     */
    public static void creatingMemoryMappedFile() throws IOException {
        Path path = Paths.get("mapped-file.dat");
        
        // Create file with some data
        try (FileChannel channel = FileChannel.open(path,
                StandardOpenOption.CREATE,
                StandardOpenOption.READ,
                StandardOpenOption.WRITE)) {
            
            // Map entire file to memory
            long fileSize = 1024 * 1024;  // 1 MB
            MappedByteBuffer buffer = channel.map(
                FileChannel.MapMode.READ_WRITE,
                0,  // Position
                fileSize  // Size
            );
            
            // Write data
            for (int i = 0; i < 100; i++) {
                buffer.putInt(i);
            }
            
            // Force write to disk
            buffer.force();
            
            System.out.println("Mapped buffer created and written");
            
            /**
             * MAPPING MODES:
             * 
             * MapMode.READ_ONLY:
             * - Read-only access
             * - Changes not written to file
             * - Multiple readers can map
             * 
             * MapMode.READ_WRITE:
             * - Read and write access
             * - Changes written to file
             * - Shared across processes
             * 
             * MapMode.PRIVATE:
             * - Copy-on-write
             * - Changes not written to file
             * - Private to this mapping
             */
        }
        
        Files.delete(path);
    }
    
    /**
     * Reading memory-mapped file
     */
    public static void readingMemoryMappedFile() throws IOException {
        Path path = Paths.get("data-file.dat");
        
        // Create test file
        try (FileChannel channel = FileChannel.open(path,
                StandardOpenOption.CREATE,
                StandardOpenOption.WRITE)) {
            ByteBuffer buffer = ByteBuffer.allocate(1000);
            for (int i = 0; i < 250; i++) {
                buffer.putInt(i);
            }
            buffer.flip();
            channel.write(buffer);
        }
        
        // Read via memory mapping
        try (FileChannel channel = FileChannel.open(path,
                StandardOpenOption.READ)) {
            
            MappedByteBuffer buffer = channel.map(
                FileChannel.MapMode.READ_ONLY,
                0,
                channel.size()
            );
            
            // Read data
            System.out.println("Reading first 10 integers:");
            for (int i = 0; i < 10; i++) {
                System.out.print(buffer.getInt() + " ");
            }
            System.out.println();
            
            /**
             * RANDOM ACCESS:
             * 
             * Can seek to any position
             * buffer.position(offset)
             * No sequential requirement
             */
        }
        
        Files.delete(path);
    }
    
    /**
     * Large file processing
     */
    public static void largeFileProcessing() throws IOException {
        Path path = Paths.get("large-file.dat");
        long fileSize = 1024L * 1024 * 100;  // 100 MB
        
        // Create large file
        try (FileChannel channel = FileChannel.open(path,
                StandardOpenOption.CREATE,
                StandardOpenOption.READ,
                StandardOpenOption.WRITE)) {
            
            // Map in chunks (can't map entire file at once)
            long chunkSize = 1024 * 1024 * 10;  // 10 MB chunks
            
            long position = 0;
            while (position < fileSize) {
                long remaining = fileSize - position;
                long size = Math.min(chunkSize, remaining);
                
                MappedByteBuffer buffer = channel.map(
                    FileChannel.MapMode.READ_WRITE,
                    position,
                    size
                );
                
                // Process chunk
                while (buffer.hasRemaining()) {
                    buffer.put((byte) (position % 256));
                    position++;
                }
                
                buffer.force();
            }
            
            System.out.println("Processed " + fileSize + " bytes in chunks");
            
            /**
             * CHUNK PROCESSING:
             * 
             * Large files can't be mapped entirely
             * Map in manageable chunks
             * Process chunk by chunk
             * Memory efficient
             */
        }
        
        Files.delete(path);
    }
    
    /**
     * Performance comparison
     */
    public static void performanceComparison() throws IOException {
        Path path = Paths.get("perf-test.dat");
        int size = 1024 * 1024 * 10;  // 10 MB
        
        // Traditional I/O
        long traditionalStart = System.nanoTime();
        try (FileOutputStream fos = new FileOutputStream(path.toFile());
             BufferedOutputStream bos = new BufferedOutputStream(fos)) {
            for (int i = 0; i < size; i++) {
                bos.write((byte) i);
            }
        }
        long traditionalTime = System.nanoTime() - traditionalStart;
        
        Files.delete(path);
        
        // NIO channel
        long nioStart = System.nanoTime();
        try (FileChannel channel = FileChannel.open(path,
                StandardOpenOption.CREATE,
                StandardOpenOption.WRITE)) {
            ByteBuffer buffer = ByteBuffer.allocateDirect(8192);
            for (int i = 0; i < size; i++) {
                if (!buffer.hasRemaining()) {
                    buffer.flip();
                    channel.write(buffer);
                    buffer.clear();
                }
                buffer.put((byte) i);
            }
            buffer.flip();
            channel.write(buffer);
        }
        long nioTime = System.nanoTime() - nioStart;
        
        Files.delete(path);
        
        // Memory-mapped
        long mappedStart = System.nanoTime();
        try (FileChannel channel = FileChannel.open(path,
                StandardOpenOption.CREATE,
                StandardOpenOption.READ,
                StandardOpenOption.WRITE)) {
            MappedByteBuffer buffer = channel.map(
                FileChannel.MapMode.READ_WRITE,
                0,
                size
            );
            for (int i = 0; i < size; i++) {
                buffer.put((byte) i);
            }
            buffer.force();
        }
        long mappedTime = System.nanoTime() - mappedStart;
        
        System.out.println("Write 10 MB performance:");
        System.out.println("  Traditional I/O: " + traditionalTime / 1_000_000 + " ms");
        System.out.println("  NIO Channel: " + nioTime / 1_000_000 + " ms");
        System.out.println("  Memory-mapped: " + mappedTime / 1_000_000 + " ms");
        
        Files.delete(path);
        
        /**
         * TYPICAL RESULTS:
         * 
         * Memory-mapped fastest for:
         * - Large sequential writes
         * - Random access
         * - Frequent small updates
         * 
         * NIO channel good for:
         * - Large sequential I/O
         * - Streaming data
         * 
         * Traditional I/O acceptable for:
         * - Small files
         * - Simple use cases
         */
    }
    
    /**
     * Advantages of memory-mapped files
     */
    public static void advantages() {
        /**
         * ADVANTAGES:
         * 
         * 1. PERFORMANCE:
         *    Fastest I/O method
         *    Zero-copy operations
         *    OS handles paging
         * 
         * 2. RANDOM ACCESS:
         *    Seek to any position instantly
         *    No sequential requirement
         *    Like byte array access
         * 
         * 3. SHARED MEMORY:
         *    Inter-process communication
         *    Multiple processes read/write
         *    Synchronized updates
         * 
         * 4. LAZY LOADING:
         *    Only accessed pages loaded
         *    Memory efficient for large files
         *    OS manages memory
         * 
         * 5. SIMPLE API:
         *    Looks like ByteBuffer
         *    Familiar operations
         *    Easy to use
         */
    }
    
    /**
     * Disadvantages of memory-mapped files
     */
    public static void disadvantages() {
        /**
         * DISADVANTAGES:
         * 
         * 1. SIZE LIMIT:
         *    32-bit JVM: 2-4 GB limit
         *    Must map in chunks for large files
         *    Platform dependent
         * 
         * 2. RESOURCE USAGE:
         *    Uses address space
         *    Limited number of mappings
         *    OS-dependent limits
         * 
         * 3. NO EXPLICIT CLOSE:
         *    Unmapping is tricky
         *    Wait for GC
         *    File may stay locked
         * 
         * 4. PORTABILITY:
         *    Behavior varies by OS
         *    Windows vs Linux differences
         *    Edge cases differ
         * 
         * 5. ERROR HANDLING:
         *    I/O errors become runtime exceptions
         *    Can't catch at operation
         *    OS determines when errors occur
         * 
         * 6. NOT SUITABLE FOR:
         *    - Streaming data
         *    - Network I/O
         *    - Small files (overhead)
         *    - Frequent file changes
         */
    }
    
    /**
     * When to use memory-mapped files
     */
    public static void whenToUse() {
        /**
         * USE MEMORY-MAPPED FILES WHEN:
         * 
         * ✓ Large file random access
         * ✓ High-performance I/O needed
         * ✓ Frequent small updates
         * ✓ Inter-process communication
         * ✓ Database-like access patterns
         * 
         * Examples:
         * - Database files
         * - Memory-mapped indexes
         * - Shared memory IPC
         * - Large data processing
         * - Cache implementations
         * 
         * 
         * DON'T USE WHEN:
         * 
         * ✗ Small files (<1 MB)
         * ✗ Sequential streaming
         * ✗ Network I/O
         * ✗ Temporary files
         * ✗ Files that change frequently
         * ✗ Need precise error control
         */
    }
    
    /**
     * Best practices
     */
    public static void bestPractices() {
        /**
         * MEMORY-MAPPED FILES BEST PRACTICES:
         * 
         * 1. CHUNK LARGE FILES:
         *    Don't map entire huge files
         *    Use reasonable chunk sizes (10-100 MB)
         *    Map on demand
         * 
         * 2. FORCE() FOR DURABILITY:
         *    buffer.force() to ensure written
         *    OS may delay writes
         *    Critical for persistence
         * 
         * 3. HANDLE CLOSE CAREFULLY:
         *    No explicit unmap
         *    Set reference to null
         *    Suggest System.gc() if needed
         * 
         * 4. USE READ_ONLY WHEN POSSIBLE:
         *    MapMode.READ_ONLY for reading
         *    Safer and faster
         *    Multiple readers OK
         * 
         * 5. MONITOR MEMORY:
         *    Watch virtual memory usage
         *    OS-dependent limits
         *    Can exhaust address space
         * 
         * 6. BUFFER POOL:
         *    Reuse mappings if possible
         *    Avoid repeated map/unmap
         *    Cache mapped regions
         */
    }
    
    public static void main(String[] args) throws IOException {
        System.out.println("=== Creating Memory-Mapped File ===");
        creatingMemoryMappedFile();
        
        System.out.println("\n=== Reading Memory-Mapped File ===");
        readingMemoryMappedFile();
        
        System.out.println("\n=== Performance Comparison ===");
        performanceComparison();
    }
}
```

---

## 7. When to Use Each Approach

### Decision Framework

```java
/**
 * WHEN TO USE EACH APPROACH
 * 
 * Decision guide for choosing I/O method
 */

public class IOApproachDecisionGuide {
    
    /**
     * Decision tree
     */
    public static void decisionTree() {
        /**
         * I/O APPROACH DECISION TREE:
         * 
         * Q1: What type of I/O?
         *     ├─ File I/O → Q2
         *     └─ Network I/O → Q5
         * 
         * Q2: File I/O - What access pattern?
         *     ├─ Sequential → Q3
         *     └─ Random → Memory-mapped files
         * 
         * Q3: Sequential file I/O - How large?
         *     ├─ Small (<1 MB) → Traditional I/O
         *     └─ Large (>1 MB) → Q4
         * 
         * Q4: Large sequential file - Performance critical?
         *     ├─ Yes → NIO channels
         *     └─ No → Traditional I/O
         * 
         * Q5: Network I/O - How many connections?
         *     ├─ Few (<100) → Traditional I/O
         *     ├─ Many (100-10,000) → NIO with Selector
         *     └─ Very many (>10,000) → NIO.2 Async
         * 
         * Q6: Network I/O - Connection duration?
         *     ├─ Short-lived → Traditional I/O
         *     └─ Long-lived → NIO/NIO.2
         * 
         * Q7: Need non-blocking?
         *     ├─ Yes → NIO or NIO.2
         *     └─ No → Traditional I/O
         */
    }
    
    /**
     * Use case matrix
     */
    public static void useCaseMatrix() {
        /**
         * USE CASE MATRIX:
         * 
         * ┌──────────────────┬─────────────┬──────────────┬──────────────┐
         * │ Use Case         │ Traditional │ NIO          │ NIO.2        │
         * ├──────────────────┼─────────────┼──────────────┼──────────────┤
         * │ Read config file │ ✓ Best      │ OK           │ Overkill     │
         * │ Log file writing │ ✓ Best      │ OK           │ Overkill     │
         * │ Small file copy  │ ✓ Best      │ OK           │ Overkill     │
         * │ Large file copy  │ OK          │ ✓ Best       │ OK           │
         * │ Random access    │ Poor        │ OK           │ OK           │
         * │ Memory-mapped DB │ Poor        │ ✓ Best (MM)  │ ✓ Best (MM)  │
         * │ HTTP server      │ OK (<100)   │ ✓ Best       │ ✓ Best       │
         * │ Chat server      │ Poor        │ ✓ Good       │ ✓ Best       │
         * │ Proxy server     │ Poor        │ ✓ Good       │ ✓ Best       │
         * │ File upload      │ ✓ OK        │ ✓ Better     │ ✓ Best       │
         * │ Streaming data   │ ✓ OK        │ ✓ Better     │ ✓ Best       │
         * └──────────────────┴─────────────┴──────────────┴──────────────┘
         */
    }
    
    /**
     * Traditional I/O use cases
     */
    public static void traditionalIOUseCases() {
        /**
         * USE TRADITIONAL I/O FOR:
         * 
         * 1. SIMPLE FILE OPERATIONS:
         *    - Reading configuration
         *    - Writing logs
         *    - Small file processing
         *    
         *    Example:
         *    Properties props = new Properties();
         *    props.load(new FileInputStream("config.properties"));
         * 
         * 2. LOW CONCURRENCY:
         *    - Desktop applications
         *    - Batch processing
         *    - Single-user tools
         *    
         *    Example:
         *    BufferedReader reader = new BufferedReader(
         *        new FileReader("data.txt"));
         * 
         * 3. SIMPLE NETWORK CLIENTS:
         *    - HTTP clients
         *    - Database clients
         *    - One-off connections
         *    
         *    Example:
         *    Socket socket = new Socket("localhost", 8080);
         * 
         * 4. WHEN SIMPLICITY MATTERS:
         *    - Prototypes
         *    - Scripts
         *    - Learning projects
         *    - Quick tools
         * 
         * 
         * CHARACTERISTICS:
         * ✓ Simple API
         * ✓ Easy to understand
         * ✓ Good for small scale
         * ✓ Well documented
         * ✗ Doesn't scale
         * ✗ Blocking
         */
    }
    
    /**
     * NIO use cases
     */
    public static void nioUseCases() {
        /**
         * USE NIO FOR:
         * 
         * 1. HIGH-PERFORMANCE FILE I/O:
         *    - Large file processing
         *    - Zero-copy transfers
         *    - Direct buffers
         *    
         *    Example:
         *    FileChannel source = ...;
         *    FileChannel dest = ...;
         *    source.transferTo(0, source.size(), dest);
         * 
         * 2. SCALABLE SERVERS:
         *    - Web servers
         *    - Proxy servers
         *    - Game servers
         *    
         *    Example:
         *    Selector selector = Selector.open();
         *    serverChannel.register(selector, OP_ACCEPT);
         *    // Handle 1000+ connections with few threads
         * 
         * 3. MULTIPLEXED I/O:
         *    - Monitor multiple channels
         *    - Single thread, many connections
         *    - Efficient CPU usage
         * 
         * 4. MEMORY-MAPPED FILES:
         *    - Database implementations
         *    - Large file random access
         *    - Shared memory IPC
         *    
         *    Example:
         *    MappedByteBuffer buffer = channel.map(
         *        MapMode.READ_WRITE, 0, size);
         * 
         * 5. ZERO-COPY OPERATIONS:
         *    - File transfers
         *    - Streaming media
         *    - High throughput required
         * 
         * 
         * CHARACTERISTICS:
         * ✓ Scalable
         * ✓ Non-blocking
         * ✓ High performance
         * ✓ Flexible
         * ✗ Complex API
         * ✗ Steeper learning curve
         */
    }
    
    /**
     * NIO.2 use cases
     */
    public static void nio2UseCases() {
        /**
         * USE NIO.2 FOR:
         * 
         * 1. ASYNC NETWORK SERVERS:
         *    - Very high concurrency (10,000+ connections)
         *    - Event-driven architecture
         *    - Reactive systems
         *    
         *    Example:
         *    AsynchronousServerSocketChannel server = ...;
         *    server.accept(null, new CompletionHandler<>() {
         *        // Async callback
         *    });
         * 
         * 2. FILE WATCHING:
         *    - Monitor directory changes
         *    - File system events
         *    - Auto-reload configurations
         *    
         *    Example:
         *    WatchService watchService = ...;
         *    path.register(watchService, ENTRY_CREATE, ENTRY_MODIFY);
         * 
         * 3. IMPROVED FILE OPERATIONS:
         *    - Path API (better than File)
         *    - Symbolic links
         *    - File attributes
         *    
         *    Example:
         *    Files.copy(source, target, REPLACE_EXISTING);
         *    Files.walk(startPath).forEach(...);
         * 
         * 4. TRULY ASYNC I/O:
         *    - No blocking at all
         *    - OS-level async support
         *    - Callback-based
         * 
         * 5. MODERN APPLICATIONS:
         *    - Microservices
         *    - Cloud-native apps
         *    - High-scale systems
         * 
         * 
         * CHARACTERISTICS:
         * ✓ Truly asynchronous
         * ✓ Maximum scalability
         * ✓ Modern API
         * ✓ OS-level support
         * ✗ Most complex
         * ✗ Callback complexity
         */
    }
    
    /**
     * Performance considerations
     */
    public static void performanceConsiderations() {
        /**
         * PERFORMANCE FACTORS:
         * 
         * 1. THROUGHPUT:
         *    Traditional I/O: Good for sequential
         *    NIO: Best for large sequential
         *    NIO.2: Best overall
         *    Memory-mapped: Best for random access
         * 
         * 2. LATENCY:
         *    Traditional I/O: High (blocking)
         *    NIO: Lower (multiplexing)
         *    NIO.2: Lowest (async)
         * 
         * 3. SCALABILITY:
         *    Traditional I/O: Poor (thread per connection)
         *    NIO: Good (selector)
         *    NIO.2: Best (async)
         * 
         * 4. MEMORY:
         *    Traditional I/O: High (threads)
         *    NIO: Lower (buffers)
         *    NIO.2: Lowest
         * 
         * 5. CPU EFFICIENCY:
         *    Traditional I/O: Low (context switching)
         *    NIO: Good (multiplexing)
         *    NIO.2: Best (event-driven)
         * 
         * 
         * BENCHMARKS (approximate):
         * 
         * File read (100 MB):
         * - Traditional: 200 ms
         * - NIO: 150 ms
         * - Memory-mapped: 100 ms
         * 
         * Network (1000 connections):
         * - Traditional: 1000 threads, 1 GB RAM
         * - NIO: 10 threads, 100 MB RAM
         * - NIO.2: 5 threads, 50 MB RAM
         */
    }
    
    /**
     * Migration guide
     */
    public static void migrationGuide() {
        /**
         * MIGRATION PATH:
         * 
         * Traditional → NIO:
         * 1. Replace InputStream/OutputStream with Channels
         * 2. Use ByteBuffer instead of byte[]
         * 3. Implement Selector for multiplexing
         * 4. Pool and reuse buffers
         * 
         * NIO → NIO.2:
         * 1. Replace Selector with AsynchronousChannelGroup
         * 2. Use CompletionHandler callbacks
         * 3. Or use Future-based approach
         * 4. Leverage Path API for files
         * 
         * 
         * HYBRID APPROACH:
         * 
         * Use different I/O for different parts:
         * - Config loading: Traditional I/O
         * - Data processing: NIO memory-mapped
         * - Network server: NIO.2 async
         * - Logging: Traditional I/O
         * 
         * Choose right tool for each job
         */
    }
    
    /**
     * Summary recommendations
     */
    public static void summaryRecommendations() {
        /**
         * QUICK RECOMMENDATIONS:
         * 
         * START WITH:
         * - Traditional I/O for simplicity
         * - Upgrade to NIO when needed
         * - NIO.2 for new high-scale projects
         * 
         * 
         * CHOOSE TRADITIONAL I/O IF:
         * - Simple file operations
         * - Low concurrency (<100 connections)
         * - Simplicity over performance
         * - Prototyping or learning
         * 
         * 
         * CHOOSE NIO IF:
         * - Need scalability (100-10,000 connections)
         * - Large file processing
         * - Memory-mapped files needed
         * - Performance critical but not async
         * 
         * 
         * CHOOSE NIO.2 IF:
         * - Very high concurrency (10,000+ connections)
         * - Truly async required
         * - Modern reactive architecture
         * - Maximum performance needed
         * 
         * 
         * USE MEMORY-MAPPED IF:
         * - Large file random access
         * - Database-like access patterns
         * - Maximum file I/O performance
         * - Inter-process communication
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Decision Tree ===");
        decisionTree();
        
        System.out.println("\n=== Use Case Matrix ===");
        useCaseMatrix();
    }
}
```

---

## Summary

### Quick Reference

**I/O Approach Comparison:**

```
┌────────────────┬──────────────┬──────────────┬──────────────┐
│ Feature        │ Traditional  │ NIO          │ NIO.2        │
├────────────────┼──────────────┼──────────────┼──────────────┤
│ API            │ Streams      │ Channels     │ Async Chan.  │
│ Blocking       │ Yes          │ Optional     │ No           │
│ Buffer         │ byte[]       │ ByteBuffer   │ ByteBuffer   │
│ Multiplexing   │ No           │ Selector     │ Built-in     │
│ Complexity     │ Simple       │ Moderate     │ Complex      │
│ Scalability    │ Poor         │ Good         │ Excellent    │
│ Performance    │ OK           │ Good         │ Best         │
│ Since          │ Java 1.0     │ Java 1.4     │ Java 7       │
└────────────────┴──────────────┴──────────────┴──────────────┘
```

**Buffer Types:**

```java
// Heap buffer - JVM heap
ByteBuffer heapBuffer = ByteBuffer.allocate(1024);
// Fast allocation, slower I/O, GC managed

// Direct buffer - native memory
ByteBuffer directBuffer = ByteBuffer.allocateDirect(1024);
// Slow allocation, faster I/O, manual cleanup

// Memory-mapped - file mapped to memory
MappedByteBuffer mapped = channel.map(MapMode.READ_WRITE, 0, size);
// Fastest file I/O, OS managed
```

**Code Examples:**

```java
// Traditional I/O
try (BufferedReader reader = new BufferedReader(
        new FileReader("file.txt"))) {
    String line;
    while ((line = reader.readLine()) != null) {
        process(line);
    }
}

// NIO
try (FileChannel channel = FileChannel.open(path, READ)) {
    ByteBuffer buffer = ByteBuffer.allocate(1024);
    while (channel.read(buffer) > 0) {
        buffer.flip();
        process(buffer);
        buffer.clear();
    }
}

// NIO.2
AsynchronousFileChannel channel = AsynchronousFileChannel.open(path, READ);
ByteBuffer buffer = ByteBuffer.allocate(1024);
channel.read(buffer, 0, buffer, new CompletionHandler<>() {
    public void completed(Integer result, ByteBuffer attachment) {
        attachment.flip();
        process(attachment);
    }
    public void failed(Throwable exc, ByteBuffer attachment) {
        handleError(exc);
    }
});
```

### Performance Characteristics

**Throughput:**

```
Memory-mapped  ████████████████████████ Highest
NIO Direct     ███████████████████░░░░░ High
NIO Heap       ████████████████░░░░░░░░ Good
Traditional    ████████████░░░░░░░░░░░░ OK
```

**Scalability (connections):**

```
NIO.2          ████████████████████████ 100,000+
NIO Selector   ████████████████░░░░░░░░ 10,000+
Traditional    ████░░░░░░░░░░░░░░░░░░░░ <1,000
```

**Complexity:**

```
Traditional    ████░░░░░░░░░░░░░░░░░░░░ Simple
NIO            ████████████░░░░░░░░░░░░ Moderate
NIO.2          ████████████████████░░░░ Complex
```

### Decision Table

**Choose Traditional I/O when:**

- ✓ Simple file operations (config, logs)
- ✓ Low concurrency (<100 connections)
- ✓ Simplicity more important than performance
- ✓ Sequential access sufficient
- ✓ Prototyping or learning

**Choose NIO when:**

- ✓ Medium-high concurrency (100-10,000)
- ✓ Need multiplexing (one thread, many connections)
- ✓ Large file processing
- ✓ Zero-copy transfers needed
- ✓ Memory-mapped files required

**Choose NIO.2 when:**

- ✓ Very high concurrency (10,000+)
- ✓ Truly asynchronous required
- ✓ Event-driven architecture
- ✓ Maximum performance critical
- ✓ Modern file operations (Path API)

**Use Memory-Mapped Files when:**

- ✓ Large file random access
- ✓ High-performance file I/O
- ✓ Database-like access patterns
- ✓ Inter-process communication
- ✓ Frequent small updates

### Best Practices

**Buffer Management:**

```java
// Always flip before reading
buffer.put(data);
buffer.flip();
while (buffer.hasRemaining()) {
    channel.write(buffer);
}

// Clear or compact before reusing
buffer.clear();      // Discard all
buffer.compact();    // Preserve unread

// Use bulk operations
buffer.put(byteArray);
buffer.get(byteArray);
```

**Direct Buffers:**

```java
// Pool and reuse
private static final ByteBuffer POOL = 
    ByteBuffer.allocateDirect(8192);

// Use for I/O only
ByteBuffer direct = ByteBuffer.allocateDirect(1024);
channel.write(direct);  // Fast

// Heap for processing
ByteBuffer heap = ByteBuffer.allocate(1024);
process(heap);  // Fast access from Java
```

**NIO Selector:**

```java
Selector selector = Selector.open();
channel.configureBlocking(false);
channel.register(selector, SelectionKey.OP_READ);

while (true) {
    selector.select();  // Blocks until ready
    for (SelectionKey key : selector.selectedKeys()) {
        if (key.isReadable()) handleRead(key);
        if (key.isWritable()) handleWrite(key);
    }
    selector.selectedKeys().clear();  // Must clear!
}
```

---
