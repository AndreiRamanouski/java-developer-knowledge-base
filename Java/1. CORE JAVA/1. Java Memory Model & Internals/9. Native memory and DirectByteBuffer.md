# Java Native Memory and DirectByteBuffer

## Overview

Native memory (off-heap memory) provides an alternative to heap-based allocation, offering better performance for certain use cases and avoiding GC overhead. This guide explores native memory management, DirectByteBuffer, memory-mapped files, and modern memory access APIs.


---

## 1. Native Memory vs Heap Memory

### Memory Architecture

```java
/**
 * MEMORY LAYOUT:
 * 
 * ┌─────────────────────────────────────────────────────────┐
 * │                    PROCESS MEMORY                       │
 * ├─────────────────────────────────────────────────────────┤
 * │  JVM HEAP (Managed by GC)                               │
 * │  ┌───────────────────────────────────────────────────┐  │
 * │  │ Young Generation (Eden + Survivor)                │  │
 * │  │ Old Generation                                    │  │
 * │  │ String Pool, Intern Tables                        │  │
 * │  └───────────────────────────────────────────────────┘  │
 * │  Controlled by -Xmx/-Xms                                │
 * ├─────────────────────────────────────────────────────────┤
 * │  METASPACE (Class metadata)                             │
 * │  Controlled by -XX:MaxMetaspaceSize                     │
 * ├─────────────────────────────────────────────────────────┤
 * │  NATIVE MEMORY (Off-heap, unmanaged)                    │
 * │  ┌───────────────────────────────────────────────────┐  │
 * │  │ DirectByteBuffers                                 │  │
 * │  │ Memory-mapped files                               │  │
 * │  │ JNI allocations                                   │  │
 * │  │ Thread stacks                                     │  │
 * │  │ Code cache (JIT compiled code)                    │  │
 * │  │ GC internal structures                            │  │
 * │  │ NIO buffers                                       │  │
 * │  └───────────────────────────────────────────────────┘  │
 * │  Limited by OS and -XX:MaxDirectMemorySize              │
 * └─────────────────────────────────────────────────────────┘
 * 
 * TOTAL PROCESS MEMORY = Heap + Metaspace + Native + Overhead
 */

public class MemoryArchitectureDemo {
    
    /**
     * HEAP MEMORY CHARACTERISTICS:
     * 
     * ✓ Managed by Garbage Collector
     * ✓ Automatic memory management
     * ✓ Type-safe access
     * ✓ Bounds checking
     * ✗ GC pauses
     * ✗ Memory overhead (object headers)
     * ✗ Fragmentation
     * ✗ Limited size (-Xmx)
     */
    
    /**
     * NATIVE MEMORY CHARACTERISTICS:
     * 
     * ✓ No GC overhead
     * ✓ Larger allocations possible
     * ✓ Shared with other processes (memory-mapped files)
     * ✓ Better for I/O operations
     * ✗ Manual memory management
     * ✗ No type safety
     * ✗ No bounds checking (in Unsafe)
     * ✗ Memory leaks if not freed
     */
    
    /**
     * MEASURING MEMORY USAGE:
     */
    public static void measureMemory() {
        Runtime runtime = Runtime.getRuntime();
        
        // Heap memory
        long heapSize = runtime.totalMemory();
        long heapUsed = heapSize - runtime.freeMemory();
        long heapMax = runtime.maxMemory();
        
        System.out.println("=== HEAP MEMORY ===");
        System.out.printf("Used: %,d MB%n", heapUsed / (1024 * 1024));
        System.out.printf("Total: %,d MB%n", heapSize / (1024 * 1024));
        System.out.printf("Max: %,d MB%n", heapMax / (1024 * 1024));
        
        // Native memory (DirectByteBuffer)
        java.lang.management.BufferPoolMXBean directPool = null;
        for (java.lang.management.BufferPoolMXBean pool : 
             java.lang.management.ManagementFactory.getPlatformMXBeans(
                 java.lang.management.BufferPoolMXBean.class)) {
            if (pool.getName().equals("direct")) {
                directPool = pool;
                break;
            }
        }
        
        if (directPool != null) {
            System.out.println("\n=== DIRECT MEMORY ===");
            System.out.printf("Count: %,d buffers%n", directPool.getCount());
            System.out.printf("Used: %,d MB%n", 
                directPool.getMemoryUsed() / (1024 * 1024));
            System.out.printf("Capacity: %,d MB%n", 
                directPool.getTotalCapacity() / (1024 * 1024));
        }
        
        // Process memory (via JMX)
        java.lang.management.OperatingSystemMXBean os = 
            java.lang.management.ManagementFactory.getOperatingSystemMXBean();
        
        if (os instanceof com.sun.management.OperatingSystemMXBean) {
            com.sun.management.OperatingSystemMXBean sunOS = 
                (com.sun.management.OperatingSystemMXBean) os;
            
            System.out.println("\n=== PROCESS MEMORY ===");
            System.out.printf("Committed: %,d MB%n", 
                sunOS.getCommittedVirtualMemorySize() / (1024 * 1024));
        }
        
        /**
         * EXAMPLE OUTPUT:
         * 
         * === HEAP MEMORY ===
         * Used: 50 MB
         * Total: 256 MB
         * Max: 4096 MB
         * 
         * === DIRECT MEMORY ===
         * Count: 10 buffers
         * Used: 100 MB
         * Capacity: 100 MB
         * 
         * === PROCESS MEMORY ===
         * Committed: 500 MB
         * 
         * BREAKDOWN:
         * - Heap: 256 MB
         * - Direct: 100 MB
         * - Metaspace: ~50 MB
         * - Thread stacks: ~50 MB (50 threads × 1 MB)
         * - Other native: ~44 MB
         * Total: ~500 MB
         */
    }
    
    /**
     * WHEN TO USE NATIVE MEMORY:
     * 
     * 1. Large data sets that don't fit in heap
     * 2. I/O operations (NIO, network, files)
     * 3. Sharing memory between processes
     * 4. Avoiding GC pressure
     * 5. Caching large amounts of data
     * 6. Memory-mapped files
     * 7. Interfacing with native libraries
     * 
     * WHEN TO USE HEAP MEMORY:
     * 
     * 1. Most application objects
     * 2. When GC is acceptable
     * 3. Short-lived objects
     * 4. Type-safe data structures
     * 5. Normal Java collections
     */
}
```

### Performance Comparison

```java
/**
 * HEAP VS NATIVE MEMORY PERFORMANCE:
 */

public class HeapVsNativePerformance {
    
    /**
     * TEST: Large array allocation and access
     */
    public static void benchmarkAllocation() {
        final int SIZE = 100_000_000;  // 100M integers = 400MB
        
        // Test 1: Heap allocation
        long start = System.nanoTime();
        int[] heapArray = new int[SIZE];
        for (int i = 0; i < SIZE; i++) {
            heapArray[i] = i;
        }
        long heapTime = System.nanoTime() - start;
        
        System.gc();  // Clean up
        
        // Test 2: Native allocation
        start = System.nanoTime();
        java.nio.IntBuffer nativeBuffer = 
            java.nio.ByteBuffer.allocateDirect(SIZE * 4).asIntBuffer();
        for (int i = 0; i < SIZE; i++) {
            nativeBuffer.put(i, i);
        }
        long nativeTime = System.nanoTime() - start;
        
        System.out.printf("Heap allocation:   %,d ms%n", heapTime / 1_000_000);
        System.out.printf("Native allocation: %,d ms%n", nativeTime / 1_000_000);
        
        /**
         * TYPICAL RESULTS:
         * 
         * Heap allocation:   150 ms
         * Native allocation: 200 ms
         * 
         * ANALYSIS:
         * - Heap slightly faster for allocation
         * - Native has allocation overhead (OS call)
         * - But native doesn't impact GC
         */
        
        // Clean up native memory
        if (nativeBuffer instanceof sun.nio.ch.DirectBuffer) {
            ((sun.nio.ch.DirectBuffer) nativeBuffer).cleaner().clean();
        }
    }
    
    /**
     * TEST: Sequential access
     */
    public static void benchmarkSequentialAccess() {
        final int SIZE = 10_000_000;
        final int ITERATIONS = 10;
        
        int[] heapArray = new int[SIZE];
        java.nio.IntBuffer nativeBuffer = 
            java.nio.ByteBuffer.allocateDirect(SIZE * 4).asIntBuffer();
        
        // Warmup
        for (int i = 0; i < SIZE; i++) {
            heapArray[i] = i;
            nativeBuffer.put(i, i);
        }
        
        // Benchmark heap
        long start = System.nanoTime();
        for (int iter = 0; iter < ITERATIONS; iter++) {
            long sum = 0;
            for (int i = 0; i < SIZE; i++) {
                sum += heapArray[i];
            }
        }
        long heapTime = System.nanoTime() - start;
        
        // Benchmark native
        start = System.nanoTime();
        for (int iter = 0; iter < ITERATIONS; iter++) {
            long sum = 0;
            for (int i = 0; i < SIZE; i++) {
                sum += nativeBuffer.get(i);
            }
        }
        long nativeTime = System.nanoTime() - start;
        
        System.out.printf("Heap sequential:   %,d ms%n", heapTime / 1_000_000);
        System.out.printf("Native sequential: %,d ms%n", nativeTime / 1_000_000);
        
        /**
         * TYPICAL RESULTS:
         * 
         * Heap sequential:   100 ms
         * Native sequential: 150 ms
         * 
         * ANALYSIS:
         * - Heap faster for sequential access
         * - Native has bounds checking overhead
         * - Native not in CPU cache initially
         */
    }
    
    /**
     * TEST: Random access
     */
    public static void benchmarkRandomAccess() {
        final int SIZE = 10_000_000;
        final int ACCESSES = 100_000_000;
        
        int[] heapArray = new int[SIZE];
        java.nio.IntBuffer nativeBuffer = 
            java.nio.ByteBuffer.allocateDirect(SIZE * 4).asIntBuffer();
        
        java.util.Random random = new java.util.Random(42);
        int[] indices = new int[ACCESSES];
        for (int i = 0; i < ACCESSES; i++) {
            indices[i] = random.nextInt(SIZE);
        }
        
        // Benchmark heap
        long start = System.nanoTime();
        long sum = 0;
        for (int i = 0; i < ACCESSES; i++) {
            sum += heapArray[indices[i]];
        }
        long heapTime = System.nanoTime() - start;
        
        // Benchmark native
        start = System.nanoTime();
        sum = 0;
        for (int i = 0; i < ACCESSES; i++) {
            sum += nativeBuffer.get(indices[i]);
        }
        long nativeTime = System.nanoTime() - start;
        
        System.out.printf("Heap random:   %,d ms%n", heapTime / 1_000_000);
        System.out.printf("Native random: %,d ms%n", nativeTime / 1_000_000);
        
        /**
         * TYPICAL RESULTS:
         * 
         * Heap random:   400 ms
         * Native random: 500 ms
         * 
         * ANALYSIS:
         * - Heap slightly faster
         * - Random access kills cache benefits
         * - Native has JNI overhead
         */
    }
    
    /**
     * TEST: GC impact
     */
    public static void benchmarkGCImpact() {
        final int SIZE = 50_000_000;  // 200MB
        
        System.out.println("=== Heap allocation (causes GC) ===");
        long gcCount1 = getGCCount();
        long start = System.nanoTime();
        
        for (int i = 0; i < 10; i++) {
            byte[] array = new byte[SIZE];
            // Use array
            array[0] = 1;
        }
        
        long heapTime = System.nanoTime() - start;
        long gcCount2 = getGCCount();
        System.out.printf("Time: %,d ms%n", heapTime / 1_000_000);
        System.out.printf("GC count: %d%n", gcCount2 - gcCount1);
        
        System.out.println("\n=== Native allocation (no GC) ===");
        gcCount1 = getGCCount();
        start = System.nanoTime();
        
        for (int i = 0; i < 10; i++) {
            java.nio.ByteBuffer buffer = 
                java.nio.ByteBuffer.allocateDirect(SIZE);
            // Use buffer
            buffer.put(0, (byte) 1);
            
            // Cleanup
            if (buffer instanceof sun.nio.ch.DirectBuffer) {
                ((sun.nio.ch.DirectBuffer) buffer).cleaner().clean();
            }
        }
        
        long nativeTime = System.nanoTime() - start;
        gcCount2 = getGCCount();
        System.out.printf("Time: %,d ms%n", nativeTime / 1_000_000);
        System.out.printf("GC count: %d%n", gcCount2 - gcCount1);
        
        /**
         * TYPICAL RESULTS:
         * 
         * === Heap allocation (causes GC) ===
         * Time: 500 ms
         * GC count: 5
         * 
         * === Native allocation (no GC) ===
         * Time: 300 ms
         * GC count: 0
         * 
         * ANALYSIS:
         * - Native faster when avoiding GC
         * - No GC pauses with native
         * - Better for large, long-lived data
         */
    }
    
    private static long getGCCount() {
        long count = 0;
        for (java.lang.management.GarbageCollectorMXBean gc : 
             java.lang.management.ManagementFactory.getGarbageCollectorMXBeans()) {
            count += gc.getCollectionCount();
        }
        return count;
    }
}
```

---

## 2. DirectByteBuffer Allocation and Cleanup

### DirectByteBuffer Internals

```java
/**
 * DIRECTBYTEBUFFER STRUCTURE:
 * 
 * DirectByteBuffer is a Java wrapper around native memory
 * 
 * OBJECT LAYOUT:
 * ┌─────────────────────────────────────────┐
 * │ DirectByteBuffer (Java object)          │
 * │  - Object header (12-16 bytes)          │
 * │  - long address (8 bytes) ────────────┐ │
 * │  - int capacity (4 bytes)             │ │
 * │  - Cleaner reference                  │ │
 * └───────────────────────────────────────┼─┘
 *                                         │
 *                                         ↓
 * ┌─────────────────────────────────────────┐
 * │ NATIVE MEMORY (off-heap)                │
 * │  - Raw bytes (capacity)                 │
 * │  - No object header                     │
 * │  - No GC management                     │
 * └─────────────────────────────────────────┘
 */

public class DirectByteBufferDemo {
    
    /**
     * ALLOCATION METHODS:
     */
    public static void allocationMethods() {
        // Method 1: Direct allocation (native memory)
        java.nio.ByteBuffer direct = java.nio.ByteBuffer.allocateDirect(1024);
        System.out.println("Direct buffer created: " + direct.isDirect());
        
        // Method 2: Heap allocation (Java heap)
        java.nio.ByteBuffer heap = java.nio.ByteBuffer.allocate(1024);
        System.out.println("Heap buffer created: " + heap.isDirect());
        
        // Method 3: Wrap existing array (heap)
        byte[] array = new byte[1024];
        java.nio.ByteBuffer wrapped = java.nio.ByteBuffer.wrap(array);
        System.out.println("Wrapped buffer: " + wrapped.isDirect());
        
        /**
         * OUTPUT:
         * Direct buffer created: true
         * Heap buffer created: false
         * Wrapped buffer: false
         * 
         * MEMORY ALLOCATION:
         * 
         * Direct (1024 bytes):
         * - Java object: ~48 bytes (heap)
         * - Native memory: 1024 bytes (off-heap)
         * - Total: ~1072 bytes
         * 
         * Heap (1024 bytes):
         * - Java object: ~48 bytes (heap)
         * - Array: 1024 + 24 bytes (heap)
         * - Total: ~1096 bytes (all on heap)
         */
    }
    
    /**
     * ALLOCATION PROCESS:
     */
    public static void allocationProcess() {
        /**
         * allocateDirect() STEPS:
         * 
         * 1. Check MaxDirectMemorySize limit
         * 2. Reserve memory from counter
         * 3. Call Unsafe.allocateMemory(size)
         * 4. OS allocates native memory
         * 5. Create DirectByteBuffer wrapper
         * 6. Create Cleaner for cleanup
         * 7. Register with Cleaner thread
         * 
         * PSEUDOCODE:
         * 
         * public static ByteBuffer allocateDirect(int capacity) {
         *     // Check limit
         *     if (reserveMemory(capacity)) {
         *         long address = Unsafe.allocateMemory(capacity);
         *         return new DirectByteBuffer(address, capacity);
         *     } else {
         *         throw new OutOfMemoryError("Direct buffer memory");
         *     }
         * }
         */
        
        try {
            java.nio.ByteBuffer buffer = 
                java.nio.ByteBuffer.allocateDirect(1024);
            
            // Get native address (using reflection)
            java.lang.reflect.Field addressField = 
                java.nio.Buffer.class.getDeclaredField("address");
            addressField.setAccessible(true);
            long address = addressField.getLong(buffer);
            
            System.out.printf("Native address: 0x%X%n", address);
            System.out.printf("Capacity: %d bytes%n", buffer.capacity());
            
            /**
             * OUTPUT:
             * Native address: 0x7F8A9C000000 (example)
             * Capacity: 1024 bytes
             */
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    /**
     * MEMORY LIMITS:
     */
    public static void memoryLimits() {
        /**
         * MAX DIRECT MEMORY SIZE:
         * 
         * Default: Same as -Xmx (heap size)
         * Configure: -XX:MaxDirectMemorySize=2g
         * 
         * EXAMPLES:
         * -Xmx4g                           → Max direct: 4g
         * -Xmx4g -XX:MaxDirectMemorySize=2g → Max direct: 2g
         * -XX:MaxDirectMemorySize=8g       → Max direct: 8g
         * 
         * CHECKING LIMIT:
         */
        
        try {
            Class<?> vmClass = Class.forName("sun.misc.VM");
            java.lang.reflect.Method maxMethod = 
                vmClass.getDeclaredMethod("maxDirectMemory");
            long maxDirect = (Long) maxMethod.invoke(null);
            
            System.out.printf("Max direct memory: %,d MB%n", 
                maxDirect / (1024 * 1024));
            
        } catch (Exception e) {
            System.out.println("Cannot determine max direct memory");
        }
        
        /**
         * EXCEEDING LIMIT:
         */
        try {
            long maxDirect = 1024 * 1024 * 1024;  // 1GB
            java.nio.ByteBuffer buffer = 
                java.nio.ByteBuffer.allocateDirect((int) maxDirect + 1);
            
        } catch (OutOfMemoryError e) {
            System.out.println("Out of direct memory: " + e.getMessage());
            
            /**
             * OUTPUT:
             * Out of direct memory: Direct buffer memory
             * 
             * NOTE: Different message than heap OOM
             */
        }
    }
    
    /**
     * BASIC OPERATIONS:
     */
    public static void basicOperations() {
        java.nio.ByteBuffer buffer = 
            java.nio.ByteBuffer.allocateDirect(1024);
        
        // Write operations
        buffer.putInt(42);              // Write int at current position
        buffer.putLong(100L);           // Write long
        buffer.putDouble(3.14);         // Write double
        
        // Position and limit
        System.out.println("Position: " + buffer.position());  // 20
        System.out.println("Limit: " + buffer.limit());        // 1024
        System.out.println("Capacity: " + buffer.capacity());  // 1024
        System.out.println("Remaining: " + buffer.remaining());// 1004
        
        // Flip for reading
        buffer.flip();  // limit = position; position = 0
        
        // Read operations
        int i = buffer.getInt();        // Read int
        long l = buffer.getLong();      // Read long
        double d = buffer.getDouble();  // Read double
        
        System.out.printf("Read: %d, %d, %.2f%n", i, l, d);
        // Output: Read: 42, 100, 3.14
        
        // Clear for reuse
        buffer.clear();  // position = 0; limit = capacity
        
        /**
         * BUFFER STATES:
         * 
         * Initial:  position=0, limit=1024, capacity=1024
         * After writes: position=20, limit=1024, capacity=1024
         * After flip:   position=0, limit=20, capacity=1024
         * After reads:  position=20, limit=20, capacity=1024
         * After clear:  position=0, limit=1024, capacity=1024
         */
    }
}
```

### Cleanup Mechanisms

```java
/**
 * DIRECTBYTEBUFFER CLEANUP:
 */

public class DirectByteBufferCleanup {
    
    /**
     * AUTOMATIC CLEANUP (Cleaner):
     */
    public static void automaticCleanup() {
        /**
         * CLEANER MECHANISM:
         * 
         * 1. DirectByteBuffer has Cleaner (phantom reference)
         * 2. When DirectByteBuffer becomes unreachable:
         *    a. GC enqueues Cleaner in reference queue
         *    b. Cleaner thread processes queue
         *    c. Cleaner.clean() called
         *    d. Unsafe.freeMemory(address) called
         *    e. Native memory freed
         * 
         * PROBLEM: Cleanup is NOT immediate
         * - Depends on GC cycles
         * - May run out of native memory before GC
         * 
         * SOLUTION: Manual cleanup when possible
         */
        
        java.nio.ByteBuffer buffer = 
            java.nio.ByteBuffer.allocateDirect(1024 * 1024);  // 1MB
        
        // Use buffer
        buffer.putInt(42);
        
        // Buffer goes out of scope
        buffer = null;
        
        // GC will eventually clean up
        // But when?
        System.gc();  // Request (not guarantee) GC
        
        /**
         * TIMING:
         * 
         * Allocation: Immediate
         * Deallocation: Delayed (until GC + Cleaner)
         * 
         * If allocating many buffers quickly:
         * → Can run out of native memory
         * → Even if heap has plenty of space!
         */
    }
    
    /**
     * MANUAL CLEANUP:
     */
    public static void manualCleanup() {
        java.nio.ByteBuffer buffer = 
            java.nio.ByteBuffer.allocateDirect(1024 * 1024);
        
        try {
            // Use buffer
            buffer.putInt(42);
            
        } finally {
            // Manual cleanup
            if (buffer instanceof sun.nio.ch.DirectBuffer) {
                sun.nio.ch.DirectBuffer directBuffer = 
                    (sun.nio.ch.DirectBuffer) buffer;
                
                if (directBuffer.cleaner() != null) {
                    directBuffer.cleaner().clean();
                }
            }
        }
        
        /**
         * BENEFITS:
         * - Immediate cleanup
         * - Prevents native memory leaks
         * - More predictable memory usage
         * 
         * DRAWBACKS:
         * - Verbose
         * - sun.* packages (internal API)
         * - May change in future Java versions
         */
    }
    
    /**
     * CLEANUP HELPER METHOD:
     */
    public static void cleanDirectBuffer(java.nio.ByteBuffer buffer) {
        if (buffer == null || !buffer.isDirect()) {
            return;
        }
        
        try {
            // Java 9+ (Cleaner API)
            if (buffer instanceof sun.nio.ch.DirectBuffer) {
                sun.nio.ch.DirectBuffer directBuffer = 
                    (sun.nio.ch.DirectBuffer) buffer;
                
                jdk.internal.ref.Cleaner cleaner = directBuffer.cleaner();
                if (cleaner != null) {
                    cleaner.clean();
                }
            }
        } catch (Exception e) {
            // Fallback: Let GC handle it
            System.err.println("Failed to clean buffer: " + e.getMessage());
        }
    }
    
    /**
     * MODERN APPROACH (Java 9+):
     */
    public static void modernCleanup() {
        /**
         * Use try-with-resources with custom wrapper:
         */
        
        class DirectBufferWrapper implements AutoCloseable {
            private java.nio.ByteBuffer buffer;
            
            DirectBufferWrapper(int capacity) {
                this.buffer = java.nio.ByteBuffer.allocateDirect(capacity);
            }
            
            public java.nio.ByteBuffer buffer() {
                return buffer;
            }
            
            @Override
            public void close() {
                cleanDirectBuffer(buffer);
                buffer = null;
            }
        }
        
        // Usage
        try (DirectBufferWrapper wrapper = new DirectBufferWrapper(1024)) {
            java.nio.ByteBuffer buffer = wrapper.buffer();
            buffer.putInt(42);
            
        }  // Automatic cleanup on close
        
        /**
         * BENEFITS:
         * - Guaranteed cleanup
         * - Clean syntax
         * - Exception-safe
         */
    }
    
    /**
     * MONITORING CLEANUP:
     */
    public static void monitorCleanup() {
        java.lang.management.BufferPoolMXBean directPool = null;
        
        for (java.lang.management.BufferPoolMXBean pool : 
             java.lang.management.ManagementFactory.getPlatformMXBeans(
                 java.lang.management.BufferPoolMXBean.class)) {
            if (pool.getName().equals("direct")) {
                directPool = pool;
                break;
            }
        }
        
        if (directPool != null) {
            System.out.println("=== Direct Buffer Pool ===");
            System.out.printf("Count: %,d%n", directPool.getCount());
            System.out.printf("Used: %,d bytes%n", directPool.getMemoryUsed());
            System.out.printf("Capacity: %,d bytes%n", 
                directPool.getTotalCapacity());
        }
        
        /**
         * MONITORING STRATEGY:
         * 
         * 1. Track allocation rate
         * 2. Monitor pool size growth
         * 3. Watch for OOM errors
         * 4. Correlate with GC activity
         * 
         * WARNING SIGNS:
         * - Pool size keeps growing
         * - Many buffers not cleaned
         * - Native memory OOM
         * - GC not reclaiming buffers
         */
    }
    
    /**
     * CLEANUP BEST PRACTICES:
     */
    public static void bestPractices() {
        /**
         * 1. ALWAYS CLEAN LARGE BUFFERS MANUALLY
         * 
         * Large buffers (>1MB) should be cleaned explicitly
         * Don't wait for GC
         * 
         * 2. USE TRY-FINALLY OR TRY-WITH-RESOURCES
         * 
         * Ensure cleanup even on exceptions
         * 
         * 3. POOL BUFFERS WHEN POSSIBLE
         * 
         * Reuse buffers instead of allocate/free
         * Reduces allocation overhead
         * 
         * 4. SET -XX:MaxDirectMemorySize
         * 
         * Prevent unbounded native memory growth
         * Match to application needs
         * 
         * 5. MONITOR NATIVE MEMORY
         * 
         * Track DirectByteBuffer pool
         * Alert on unusual growth
         * 
         * 6. CONSIDER ALTERNATIVES
         * 
         * Heap buffers for small, short-lived data
         * Memory-mapped files for very large data
         */
    }
}
```

---

## 3. Memory-Mapped Files (MappedByteBuffer)

### Memory Mapping Basics

```java
/**
 * MEMORY-MAPPED FILES:
 * 
 * Map file contents directly into memory
 * OS handles paging between RAM and disk
 * 
 * ARCHITECTURE:
 * 
 * ┌──────────────────────────────────────┐
 * │  Application (Java)                  │
 * │  ┌────────────────────────────────┐  │
 * │  │  MappedByteBuffer              │  │
 * │  │  - Looks like memory array     │  │
 * │  │  - Actually backed by file     │  │
 * │  └────────────────┬───────────────┘  │
 * └───────────────────┼──────────────────┘
 *                     │
 *                     ↓
 * ┌──────────────────────────────────────┐
 * │  Operating System                    │
 * │  ┌────────────────────────────────┐  │
 * │  │  Virtual Memory (Page Cache)   │  │
 * │  │  - Some pages in RAM           │  │
 * │  │  - Some pages on disk          │  │
 * │  │  - OS swaps as needed          │  │
 * │  └────────────────┬───────────────┘  │
 * └───────────────────┼──────────────────┘
 *                     │
 *                     ↓
 * ┌──────────────────────────────────────┐
 * │  Disk File                           │
 * └──────────────────────────────────────┘
 */

import java.io.RandomAccessFile;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;

public class MemoryMappedFileDemo {
    
    /**
     * BASIC MEMORY MAPPING:
     */
    public static void basicMapping() throws Exception {
        // Create or open file
        RandomAccessFile file = new RandomAccessFile("data.bin", "rw");
        
        // Get file channel
        FileChannel channel = file.getChannel();
        
        // Map file to memory (1MB)
        MappedByteBuffer buffer = channel.map(
            FileChannel.MapMode.READ_WRITE,  // Mode
            0,                                // Position in file
            1024 * 1024                       // Size to map (1MB)
        );
        
        // Write data (goes to memory, OS writes to disk)
        buffer.putInt(0, 42);
        buffer.putLong(4, 12345L);
        
        // Read data (from memory, OS loads from disk if needed)
        int value1 = buffer.getInt(0);
        long value2 = buffer.getLong(4);
        
        System.out.printf("Read: %d, %d%n", value1, value2);
        
        // Force writes to disk
        buffer.force();
        
        // Cleanup
        channel.close();
        file.close();
        
        /**
         * MAPPING MODES:
         * 
         * READ_ONLY:
         * - Cannot modify
         * - Throws ReadOnlyBufferException on write
         * - Multiple processes can map simultaneously
         * 
         * READ_WRITE:
         * - Can read and write
         * - Changes visible to other processes (eventually)
         * - Changes written to file (eventually)
         * 
         * PRIVATE (copy-on-write):
         * - Can read and write
         * - Changes NOT written to file
         * - Changes private to this process
         */
    }
    
    /**
     * LARGE FILE PROCESSING:
     */
    public static void processLargeFile() throws Exception {
        String filename = "large_data.bin";
        long fileSize = 1024L * 1024 * 1024;  // 1GB
        
        // Create large file
        RandomAccessFile file = new RandomAccessFile(filename, "rw");
        file.setLength(fileSize);
        
        FileChannel channel = file.getChannel();
        
        // Process in chunks (map 100MB at a time)
        long chunkSize = 100 * 1024 * 1024;
        
        for (long offset = 0; offset < fileSize; offset += chunkSize) {
            long size = Math.min(chunkSize, fileSize - offset);
            
            MappedByteBuffer buffer = channel.map(
                FileChannel.MapMode.READ_WRITE,
                offset,
                size
            );
            
            // Process chunk
            processChunk(buffer, offset);
            
            // Force writes (optional, OS will do it anyway)
            buffer.force();
        }
        
        channel.close();
        file.close();
        
        /**
         * ADVANTAGES:
         * 
         * 1. Process files larger than heap
         * 2. No explicit read/write calls
         * 3. OS handles caching
         * 4. Multiple processes can share
         * 5. Very fast for random access
         * 
         * COMPARED TO TRADITIONAL I/O:
         * 
         * Traditional (read/write):
         * - Copy: Disk → OS cache → Java heap
         * - Two copies in memory
         * - GC pressure
         * 
         * Memory-mapped:
         * - Copy: Disk → OS cache (mapped)
         * - One copy (OS cache)
         * - No GC pressure
         * - Faster, more efficient
         */
    }
    
    private static void processChunk(MappedByteBuffer buffer, long offset) {
        // Example: Set all bytes to value based on position
        int size = buffer.capacity();
        for (int i = 0; i < size; i++) {
            buffer.put(i, (byte) ((offset + i) % 256));
        }
    }
    
    /**
     * INTER-PROCESS COMMUNICATION:
     */
    public static void interProcessCommunication() throws Exception {
        /**
         * PROCESS 1 (Writer):
         */
        class Writer {
            public void write() throws Exception {
                RandomAccessFile file = new RandomAccessFile("shared.dat", "rw");
                file.setLength(1024);
                
                FileChannel channel = file.getChannel();
                MappedByteBuffer buffer = channel.map(
                    FileChannel.MapMode.READ_WRITE, 0, 1024);
                
                // Write data
                buffer.putInt(0, 42);
                buffer.putLong(4, System.currentTimeMillis());
                
                // Force to disk (ensure visible to other processes)
                buffer.force();
                
                channel.close();
                file.close();
            }
        }
        
        /**
         * PROCESS 2 (Reader):
         */
        class Reader {
            public void read() throws Exception {
                RandomAccessFile file = new RandomAccessFile("shared.dat", "r");
                FileChannel channel = file.getChannel();
                
                MappedByteBuffer buffer = channel.map(
                    FileChannel.MapMode.READ_ONLY, 0, 1024);
                
                // Read data
                int value = buffer.getInt(0);
                long timestamp = buffer.getLong(4);
                
                System.out.printf("Read: %d, %d%n", value, timestamp);
                
                channel.close();
                file.close();
            }
        }
        
        /**
         * SYNCHRONIZATION:
         * 
         * Memory mapping does NOT provide synchronization
         * Changes may not be immediately visible
         * 
         * Need additional synchronization:
         * - File locks (FileLock)
         * - External coordination
         * - Semaphores
         */
    }
}
```

### Performance and Use Cases

```java
/**
 * MEMORY-MAPPED FILE PERFORMANCE:
 */

public class MappedFilePerformance {
    
    /**
     * BENCHMARK: Memory-mapped vs Traditional I/O
     */
    public static void benchmarkReadPerformance() throws Exception {
        final long SIZE = 100 * 1024 * 1024;  // 100MB
        String filename = "benchmark.dat";
        
        // Create test file
        createTestFile(filename, SIZE);
        
        // Benchmark 1: Memory-mapped
        long start = System.nanoTime();
        long sum1 = readMapped(filename, SIZE);
        long mappedTime = System.nanoTime() - start;
        
        // Benchmark 2: Traditional I/O
        start = System.nanoTime();
        long sum2 = readTraditional(filename, SIZE);
        long traditionalTime = System.nanoTime() - start;
        
        // Benchmark 3: BufferedInputStream
        start = System.nanoTime();
        long sum3 = readBuffered(filename, SIZE);
        long bufferedTime = System.nanoTime() - start;
        
        System.out.printf("Memory-mapped:  %,d ms (%.0f MB/s)%n",
            mappedTime / 1_000_000,
            SIZE / 1024.0 / 1024 / (mappedTime / 1_000_000_000.0));
        
        System.out.printf("Traditional:    %,d ms (%.0f MB/s)%n",
            traditionalTime / 1_000_000,
            SIZE / 1024.0 / 1024 / (traditionalTime / 1_000_000_000.0));
        
        System.out.printf("Buffered:       %,d ms (%.0f MB/s)%n",
            bufferedTime / 1_000_000,
            SIZE / 1024.0 / 1024 / (bufferedTime / 1_000_000_000.0));
        
        /**
         * TYPICAL RESULTS:
         * 
         * Memory-mapped:  100 ms (1000 MB/s)
         * Traditional:    500 ms (200 MB/s)
         * Buffered:       300 ms (333 MB/s)
         * 
         * Memory-mapped is 5x faster!
         */
    }
    
    private static void createTestFile(String filename, long size) 
            throws Exception {
        RandomAccessFile file = new RandomAccessFile(filename, "rw");
        file.setLength(size);
        
        FileChannel channel = file.getChannel();
        MappedByteBuffer buffer = channel.map(
            FileChannel.MapMode.READ_WRITE, 0, size);
        
        for (int i = 0; i < size; i++) {
            buffer.put(i, (byte) (i % 256));
        }
        
        buffer.force();
        channel.close();
        file.close();
    }
    
    private static long readMapped(String filename, long size) 
            throws Exception {
        RandomAccessFile file = new RandomAccessFile(filename, "r");
        FileChannel channel = file.getChannel();
        MappedByteBuffer buffer = channel.map(
            FileChannel.MapMode.READ_ONLY, 0, size);
        
        long sum = 0;
        for (int i = 0; i < size; i++) {
            sum += buffer.get(i);
        }
        
        channel.close();
        file.close();
        return sum;
    }
    
    private static long readTraditional(String filename, long size) 
            throws Exception {
        RandomAccessFile file = new RandomAccessFile(filename, "r");
        byte[] chunk = new byte[8192];
        
        long sum = 0;
        int bytesRead;
        while ((bytesRead = file.read(chunk)) != -1) {
            for (int i = 0; i < bytesRead; i++) {
                sum += chunk[i];
            }
        }
        
        file.close();
        return sum;
    }
    
    private static long readBuffered(String filename, long size) 
            throws Exception {
        java.io.FileInputStream fis = new java.io.FileInputStream(filename);
        java.io.BufferedInputStream bis = new java.io.BufferedInputStream(fis);
        
        long sum = 0;
        int b;
        while ((b = bis.read()) != -1) {
            sum += b;
        }
        
        bis.close();
        return sum;
    }
    
    /**
     * USE CASES FOR MEMORY-MAPPED FILES:
     */
    public static void useCases() {
        /**
         * IDEAL FOR:
         * 
         * 1. Large file processing (>1GB)
         *    - Database files
         *    - Log files
         *    - Data analysis
         * 
         * 2. Random access patterns
         *    - Index files
         *    - Sparse data
         *    - Frequent seeks
         * 
         * 3. Inter-process communication
         *    - Shared memory
         *    - Lock-free queues
         *    - Producer-consumer
         * 
         * 4. Memory-efficient processing
         *    - Files larger than heap
         *    - Avoid GC pressure
         *    - OS manages paging
         * 
         * NOT IDEAL FOR:
         * 
         * 1. Small files (<10MB)
         *    - Overhead not worth it
         *    - Traditional I/O faster
         * 
         * 2. Sequential access only
         *    - Buffered streams work well
         *    - Less complexity
         * 
         * 3. Frequent writes that must persist
         *    - OS decides when to flush
         *    - Use force() explicitly
         *    - Traditional I/O more predictable
         * 
         * 4. 32-bit JVM
         *    - Limited address space
         *    - Can't map large files
         */
    }
}
```

---

## 4. Native Memory Leaks

### Detecting Leaks

```java
/**
 * NATIVE MEMORY LEAK PATTERNS:
 */

public class NativeMemoryLeaks {
    
    /**
     * LEAK 1: Forgotten DirectByteBuffers
     */
    public static class DirectBufferLeak {
        private java.util.List<java.nio.ByteBuffer> buffers = 
            new java.util.ArrayList<>();
        
        public void leakMemory() {
            // Allocate but never clean up
            for (int i = 0; i < 1000; i++) {
                java.nio.ByteBuffer buffer = 
                    java.nio.ByteBuffer.allocateDirect(1024 * 1024);  // 1MB each
                buffers.add(buffer);
            }
            
            /**
             * PROBLEM:
             * - 1000 buffers = 1GB native memory
             * - Buffers in collection (reachable)
             * - GC won't clean them
             * - Native memory grows indefinitely
             * 
             * SOLUTION:
             * - Clean buffers explicitly
             * - Remove from collection when done
             * - Use weak references
             */
        }
        
        public void fixedVersion() {
            for (int i = 0; i < 1000; i++) {
                java.nio.ByteBuffer buffer = 
                    java.nio.ByteBuffer.allocateDirect(1024 * 1024);
                
                try {
                    // Use buffer
                    buffer.putInt(42);
                    
                } finally {
                    // Clean up
                    if (buffer instanceof sun.nio.ch.DirectBuffer) {
                        ((sun.nio.ch.DirectBuffer) buffer).cleaner().clean();
                    }
                }
            }
        }
    }
    
    /**
     * LEAK 2: Memory-mapped files not closed
     */
    public static class MappedFileLeak {
        public void leakMemory() throws Exception {
            for (int i = 0; i < 100; i++) {
                RandomAccessFile file = new RandomAccessFile("data" + i + ".bin", "rw");
                FileChannel channel = file.getChannel();
                
                MappedByteBuffer buffer = channel.map(
                    FileChannel.MapMode.READ_WRITE, 0, 10 * 1024 * 1024);  // 10MB
                
                // Use buffer...
                
                // LEAK: File and channel never closed!
            }
            
            /**
             * PROBLEM:
             * - 100 files × 10MB = 1GB mapped
             * - File handles leak
             * - Native memory not released
             * - OS resource exhaustion
             * 
             * SOLUTION:
             * - Always close file and channel
             * - Use try-with-resources
             */
        }
        
        public void fixedVersion() throws Exception {
            for (int i = 0; i < 100; i++) {
                try (RandomAccessFile file = new RandomAccessFile("data" + i + ".bin", "rw");
                     FileChannel channel = file.getChannel()) {
                    
                    MappedByteBuffer buffer = channel.map(
                        FileChannel.MapMode.READ_WRITE, 0, 10 * 1024 * 1024);
                    
                    // Use buffer...
                    
                }  // Automatic close
            }
        }
    }
    
    /**
     * LEAK 3: JNI allocations
     */
    public static class JNILeak {
        /**
         * Native code that leaks:
         * 
         * JNIEXPORT void JNICALL Java_MyClass_allocate(JNIEnv *env, jobject obj) {
         *     void* ptr = malloc(1024 * 1024);  // 1MB
         *     // LEAK: Never freed!
         * }
         * 
         * PROBLEM:
         * - Native malloc/new not tracked by JVM
         * - No automatic cleanup
         * - Memory grows until process crash
         * 
         * SOLUTION:
         * - Always pair malloc with free
         * - Track allocations
         * - Use RAII pattern in C++
         */
    }
    
    /**
     * DETECTING NATIVE MEMORY LEAKS:
     */
    public static void detectLeaks() {
        /**
         * METHOD 1: Monitor process memory
         */
        Runtime runtime = Runtime.getRuntime();
        
        long heapUsed = runtime.totalMemory() - runtime.freeMemory();
        long heapMax = runtime.maxMemory();
        
        System.out.printf("Heap used: %,d MB%n", heapUsed / (1024 * 1024));
        System.out.printf("Heap max: %,d MB%n", heapMax / (1024 * 1024));
        
        // Get process memory (Linux)
        try {
            Process proc = Runtime.getRuntime().exec("ps -o rss= -p " + 
                ProcessHandle.current().pid());
            java.io.BufferedReader reader = new java.io.BufferedReader(
                new java.io.InputStreamReader(proc.getInputStream()));
            String rss = reader.readLine();
            long processMemory = Long.parseLong(rss.trim());
            
            System.out.printf("Process memory: %,d MB%n", processMemory / 1024);
            
            long nativeMemory = processMemory - (heapUsed / 1024);
            System.out.printf("Native memory (estimated): %,d MB%n", nativeMemory / 1024);
            
        } catch (Exception e) {
            // Fallback: Use OperatingSystemMXBean
        }
        
        /**
         * METHOD 2: Monitor DirectByteBuffer pool
         */
        for (java.lang.management.BufferPoolMXBean pool : 
             java.lang.management.ManagementFactory.getPlatformMXBeans(
                 java.lang.management.BufferPoolMXBean.class)) {
            
            System.out.printf("%s pool:%n", pool.getName());
            System.out.printf("  Count: %,d%n", pool.getCount());
            System.out.printf("  Used: %,d MB%n", 
                pool.getMemoryUsed() / (1024 * 1024));
        }
        
        /**
         * METHOD 3: Native Memory Tracking (NMT)
         * 
         * JVM FLAGS:
         * -XX:NativeMemoryTracking=summary  (or detail)
         * 
         * Then use:
         * jcmd <pid> VM.native_memory summary
         * 
         * OUTPUT:
         * Native Memory Tracking:
         * 
         * Total: reserved=5GB, committed=3GB
         * -     Java Heap: reserved=4GB, committed=2GB
         * -        Thread: reserved=50MB, committed=50MB
         * -          Code: reserved=250MB, committed=150MB
         * -            GC: reserved=200MB, committed=100MB
         * -       Internal: reserved=500MB, committed=500MB
         * 
         * Trending:
         * jcmd <pid> VM.native_memory summary.diff
         */
    }
    
    /**
     * PREVENTING LEAKS:
     */
    public static void preventLeaks() {
        /**
         * 1. ALWAYS CLEAN DirectByteBuffers
         * 
         * try {
         *     ByteBuffer buffer = ByteBuffer.allocateDirect(size);
         *     // Use buffer
         * } finally {
         *     cleanDirectBuffer(buffer);
         * }
         * 
         * 2. CLOSE FILES AND CHANNELS
         * 
         * try (RandomAccessFile file = ...; FileChannel channel = ...) {
         *     // Use file
         * }
         * 
         * 3. SET LIMITS
         * 
         * -XX:MaxDirectMemorySize=2g
         * 
         * 4. MONITOR REGULARLY
         * 
         * - Track direct buffer count
         * - Watch process memory growth
         * - Alert on anomalies
         * 
         * 5. USE BUFFER POOLS
         * 
         * - Reuse buffers
         * - Limit total allocation
         * - Explicit lifecycle management
         * 
         * 6. ENABLE NATIVE MEMORY TRACKING
         * 
         * -XX:NativeMemoryTracking=summary
         */
    }
}
```

---

## 5. Off-Heap Caching (Ehcache, Chronicle Map)

### Ehcache Off-Heap Example

```java
/**
 * EHCACHE OFF-HEAP CACHING:
 */

public class EhcacheOffHeapDemo {
    
    /**
     * BASIC CONFIGURATION:
     */
    public static void basicEhcache() {
        /**
         * Maven dependency:
         * <dependency>
         *     <groupId>org.ehcache</groupId>
         *     <artifactId>ehcache</artifactId>
         *     <version>3.10.8</version>
         * </dependency>
         */
        
        /*
        // Create cache manager with off-heap
        CacheManager cacheManager = CacheManagerBuilder.newCacheManagerBuilder()
            .with(CacheManagerBuilder.persistence("cache-data"))
            .withCache("myCache",
                CacheConfigurationBuilder.newCacheConfigurationBuilder(
                    Long.class, String.class,
                    ResourcePoolsBuilder.newResourcePoolsBuilder()
                        .heap(100, EntryUnit.ENTRIES)      // 100 entries on heap
                        .offheap(10, MemoryUnit.MB)        // 10MB off-heap
                        .disk(100, MemoryUnit.MB, true)    // 100MB disk (persistent)
                )
            )
            .build(true);
        
        Cache<Long, String> cache = cacheManager.getCache("myCache", 
            Long.class, String.class);
        
        // Put data (goes to off-heap)
        for (long i = 0; i < 1000; i++) {
            cache.put(i, "Value " + i);
        }
        
        // Get data (retrieved from off-heap)
        String value = cache.get(42L);
        System.out.println("Retrieved: " + value);
        
        // Cleanup
        cacheManager.close();
        */
        
        /**
         * STORAGE TIERS:
         * 
         * 1. HEAP (Fast, GC impact)
         *    - Hot entries
         *    - Fast access
         *    - Limited by heap size
         * 
         * 2. OFF-HEAP (Fast, no GC)
         *    - Warm entries
         *    - Serialization required
         *    - Limited by MaxDirectMemorySize
         * 
         * 3. DISK (Slow, persistent)
         *    - Cold entries
         *    - Survives restarts
         *    - Limited by disk space
         * 
         * DATA FLOW:
         * 
         * Write: App → Heap → Off-heap → Disk
         * Read:  App ← Heap ← Off-heap ← Disk
         * 
         * Promotion: Disk → Off-heap → Heap (on access)
         * Eviction:  Heap → Off-heap → Disk (LRU)
         */
    }
    
    /**
     * PERFORMANCE CHARACTERISTICS:
     */
    public static void performanceComparison() {
        /**
         * BENCHMARK RESULTS (1M entries, 1KB each):
         * 
         * HEAP CACHE:
         * - Memory: 1GB heap
         * - Get: 50 ns
         * - Put: 100 ns
         * - GC pause: 500ms (Young GC)
         * 
         * OFF-HEAP CACHE:
         * - Memory: 1GB native
         * - Get: 500 ns (10x slower, serialization)
         * - Put: 1000 ns (10x slower, serialization)
         * - GC pause: <10ms (minimal impact)
         * 
         * DISK CACHE:
         * - Memory: Minimal
         * - Get: 100,000 ns (1000x slower, I/O)
         * - Put: 200,000 ns (1000x slower, I/O)
         * - GC pause: 0ms (no impact)
         * 
         * TRADE-OFFS:
         * 
         * Heap: Fastest, but GC pauses
         * Off-heap: Moderate speed, no GC
         * Disk: Slowest, but persistent
         * 
         * RECOMMENDATION:
         * 
         * Use tiered caching:
         * - Heap: 10% of data (hottest)
         * - Off-heap: 80% of data (warm)
         * - Disk: 10% of data (cold) or overflow
         */
    }
}
```

### Chronicle Map Example

```java
/**
 * CHRONICLE MAP OFF-HEAP:
 */

public class ChronicleMapDemo {
    
    /**
     * BASIC USAGE:
     */
    public static void basicChronicleMap() throws Exception {
        /**
         * Maven dependency:
         * <dependency>
         *     <groupId>net.openhft</groupId>
         *     <artifactId>chronicle-map</artifactId>
         *     <version>3.23.4</version>
         * </dependency>
         */
        
        /*
        // Create off-heap map
        ChronicleMap<Long, String> map = ChronicleMap
            .of(Long.class, String.class)
            .name("my-map")
            .entries(1_000_000)                    // Expected entries
            .averageValueSize(100)                 // Average value size
            .create();
        
        // Put data (stored off-heap)
        for (long i = 0; i < 10000; i++) {
            map.put(i, "Value " + i);
        }
        
        // Get data (from off-heap)
        String value = map.get(42L);
        System.out.println("Retrieved: " + value);
        
        // Statistics
        System.out.println("Size: " + map.size());
        System.out.println("Off-heap memory: " + 
            map.offHeapMemoryUsed() / (1024 * 1024) + " MB");
        
        // Cleanup
        map.close();
        */
        
        /**
         * FEATURES:
         * 
         * 1. ZERO GARBAGE
         *    - All data off-heap
         *    - No GC impact
         * 
         * 2. MEMORY-MAPPED
         *    - Can persist to file
         *    - Survives restarts
         *    - Inter-process sharing
         * 
         * 3. CONCURRENT
         *    - Lock-free reads
         *    - Fine-grained locking
         *    - High throughput
         * 
         * 4. PREDICTABLE
         *    - Constant-time operations
         *    - No rehashing
         *    - Fixed memory usage
         */
    }
    
    /**
     * PERSISTENT MAP:
     */
    public static void persistentMap() throws Exception {
        /*
        // Create persisted map
        ChronicleMap<Long, String> map = ChronicleMap
            .of(Long.class, String.class)
            .name("persisted-map")
            .entries(1_000_000)
            .averageValueSize(100)
            .createPersistedTo(new File("map.dat"));
        
        // Write data
        map.put(1L, "Persistent value");
        
        // Close
        map.close();
        
        // Later: Reopen map (data still there)
        ChronicleMap<Long, String> reopened = ChronicleMap
            .of(Long.class, String.class)
            .name("persisted-map")
            .entries(1_000_000)
            .averageValueSize(100)
            .createOrRecoverPersistedTo(new File("map.dat"), false);
        
        // Data survived restart
        String value = reopened.get(1L);
        System.out.println("After restart: " + value);
        
        reopened.close();
        */
        
        /**
         * USE CASES:
         * 
         * 1. Large caches (>10GB)
         * 2. Low-latency trading systems
         * 3. Real-time analytics
         * 4. Inter-process communication
         * 5. Event sourcing
         * 6. Market data storage
         */
    }
    
    /**
     * PERFORMANCE COMPARISON:
     */
    public static void performanceBenchmark() {
        /**
         * BENCHMARK (1M entries, 100 bytes each):
         * 
         * ConcurrentHashMap (heap):
         * - Memory: 150MB heap
         * - Put: 100 ns
         * - Get: 50 ns
         * - GC impact: HIGH
         * 
         * Chronicle Map (off-heap):
         * - Memory: 100MB native
         * - Put: 200 ns
         * - Get: 150 ns
         * - GC impact: NONE
         * 
         * SCALING (10M entries):
         * 
         * ConcurrentHashMap:
         * - Memory: 1.5GB heap
         * - GC pause: 2-5 seconds
         * - Unusable for low-latency
         * 
         * Chronicle Map:
         * - Memory: 1GB native
         * - GC pause: 0ms
         * - Stable latency
         * 
         * RECOMMENDATION:
         * 
         * Use Chronicle Map when:
         * - Cache > 1GB
         * - Low latency required
         * - GC pauses unacceptable
         * - Persistence needed
         */
    }
}
```

---

## 6. sun.misc.Unsafe Usage (Deprecated)

### Unsafe API Basics

```java
/**
 * sun.misc.Unsafe:
 * 
 * Low-level memory access API
 * Deprecated in Java 9+
 * Removed in future versions
 * 
 * REPLACEMENT: Foreign Memory Access API (JEP 393)
 */

public class UnsafeDemo {
    
    private static final sun.misc.Unsafe UNSAFE;
    
    static {
        try {
            java.lang.reflect.Field field = 
                sun.misc.Unsafe.class.getDeclaredField("theUnsafe");
            field.setAccessible(true);
            UNSAFE = (sun.misc.Unsafe) field.get(null);
        } catch (Exception e) {
            throw new RuntimeException("Cannot access Unsafe", e);
        }
    }
    
    /**
     * DIRECT MEMORY ALLOCATION:
     */
    public static void directMemoryAllocation() {
        // Allocate 1KB off-heap
        long address = UNSAFE.allocateMemory(1024);
        
        try {
            // Write data
            UNSAFE.putInt(address, 42);
            UNSAFE.putLong(address + 4, 12345L);
            
            // Read data
            int value1 = UNSAFE.getInt(address);
            long value2 = UNSAFE.getLong(address + 4);
            
            System.out.printf("Read: %d, %d%n", value1, value2);
            
        } finally {
            // CRITICAL: Must free memory
            UNSAFE.freeMemory(address);
        }
        
        /**
         * DANGERS:
         * 
         * 1. No bounds checking
         *    - Can read/write anywhere in process memory
         *    - Segfaults possible
         * 
         * 2. Manual memory management
         *    - Must call freeMemory
         *    - Easy to leak
         * 
         * 3. No type safety
         *    - Can interpret bytes any way
         *    - Corruption possible
         * 
         * 4. Platform-dependent
         *    - Endianness issues
         *    - Alignment requirements
         */
    }
    
    /**
     * ARRAY MANIPULATION:
     */
    public static void arrayManipulation() {
        int[] array = new int[10];
        
        // Get array base offset
        long baseOffset = UNSAFE.arrayBaseOffset(int[].class);
        long indexScale = UNSAFE.arrayIndexScale(int[].class);
        
        // Write directly to array memory
        for (int i = 0; i < 10; i++) {
            long offset = baseOffset + (i * indexScale);
            UNSAFE.putInt(array, offset, i * 10);
        }
        
        // Read directly from array memory
        for (int i = 0; i < 10; i++) {
            long offset = baseOffset + (i * indexScale);
            int value = UNSAFE.getInt(array, offset);
            System.out.print(value + " ");
        }
        
        /**
         * OUTPUT: 0 10 20 30 40 50 60 70 80 90
         * 
         * WHY USE UNSAFE FOR ARRAYS?
         * 
         * - Bypass bounds checking
         * - Atomic operations
         * - Volatile access
         * - Compare-and-swap
         */
    }
    
    /**
     * COMPARE-AND-SWAP (CAS):
     */
    static class Counter {
        private volatile long count = 0;
        private static final long COUNT_OFFSET;
        
        static {
            try {
                COUNT_OFFSET = UNSAFE.objectFieldOffset(
                    Counter.class.getDeclaredField("count"));
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
        
        public void increment() {
            long current;
            do {
                current = count;
            } while (!UNSAFE.compareAndSwapLong(this, COUNT_OFFSET, 
                current, current + 1));
        }
        
        public long getCount() {
            return count;
        }
        
        /**
         * CAS OPERATION:
         * 
         * compareAndSwapLong(object, offset, expected, newValue)
         * 
         * Atomically:
         * 1. Read value at offset
         * 2. If equals expected: Write newValue, return true
         * 3. Else: Return false
         * 
         * USES:
         * - AtomicInteger/Long/Reference
         * - Lock-free algorithms
         * - Concurrent data structures
         */
    }
    
    /**
     * WARNING: Unsafe is being removed!
     */
    public static void deprecationWarning() {
        /**
         * STATUS:
         * 
         * Java 8: Available
         * Java 9+: Deprecated, shows warnings
         * Java 17+: Restricted by default (--add-exports needed)
         * Future: Will be removed entirely
         * 
         * MIGRATION PATH:
         * 
         * Replace with:
         * - VarHandle (JDK 9+) for atomic operations
         * - Foreign Memory Access API (JDK 14+) for memory
         * - MethodHandles for reflection
         * 
         * DO NOT USE UNSAFE IN NEW CODE!
         */
    }
}
```

---

## 7. Foreign Memory Access API (JEP 393)

### Modern Memory Access

```java
/**
 * FOREIGN MEMORY ACCESS API:
 * 
 * Modern replacement for Unsafe
 * Introduced in JDK 14 (incubator)
 * Finalized in JDK 19 (JEP 424)
 * 
 * FEATURES:
 * - Safe memory access
 * - Explicit lifecycle management
 * - Type-safe operations
 * - Better performance than ByteBuffer
 */

import java.lang.foreign.*;

public class ForeignMemoryDemo {
    
    /**
     * BASIC MEMORY ALLOCATION:
     */
    public static void basicAllocation() {
        // Allocate 1KB off-heap
        try (Arena arena = Arena.ofConfined()) {
            MemorySegment segment = arena.allocate(1024);
            
            // Write data
            segment.setAtIndex(ValueLayout.JAVA_INT, 0, 42);
            segment.setAtIndex(ValueLayout.JAVA_LONG, 1, 12345L);
            
            // Read data
            int value1 = segment.getAtIndex(ValueLayout.JAVA_INT, 0);
            long value2 = segment.getAtIndex(ValueLayout.JAVA_LONG, 1);
            
            System.out.printf("Read: %d, %d%n", value1, value2);
            
        }  // Automatic cleanup
        
        /**
         * BENEFITS OVER UNSAFE:
         * 
         * 1. Automatic cleanup (try-with-resources)
         * 2. Bounds checking
         * 3. Type safety (ValueLayout)
         * 4. Clear lifecycle (Arena)
         * 5. Safe to use
         */
    }
    
    /**
     * ARENA TYPES:
     */
    public static void arenaTypes() {
        // 1. CONFINED ARENA (single thread)
        try (Arena confined = Arena.ofConfined()) {
            MemorySegment segment = confined.allocate(1024);
            // Can only be accessed by current thread
            // Fastest option
        }
        
        // 2. SHARED ARENA (multiple threads)
        try (Arena shared = Arena.ofShared()) {
            MemorySegment segment = shared.allocate(1024);
            // Can be accessed by multiple threads
            // Slower, but thread-safe
        }
        
        // 3. GLOBAL ARENA (never freed)
        MemorySegment global = Arena.global().allocate(1024);
        // Never freed (until JVM exit)
        // Use for truly global data
        
        // 4. AUTO ARENA (GC-managed)
        try (Arena auto = Arena.ofAuto()) {
            MemorySegment segment = auto.allocate(1024);
            // Freed by GC (like DirectByteBuffer)
            // Convenient but less control
        }
        
        /**
         * CHOOSING ARENA:
         * 
         * Confined: Default choice (fastest)
         * Shared: When multiple threads need access
         * Global: For truly static data
         * Auto: When automatic cleanup needed
         */
    }
    
    /**
     * MEMORY LAYOUTS:
     */
    public static void memoryLayouts() {
        try (Arena arena = Arena.ofConfined()) {
            // Define struct layout
            StructLayout pointLayout = MemoryLayout.structLayout(
                ValueLayout.JAVA_DOUBLE.withName("x"),
                ValueLayout.JAVA_DOUBLE.withName("y")
            );
            
            // Allocate struct
            MemorySegment point = arena.allocate(pointLayout);
            
            // Get field offsets
            long xOffset = pointLayout.byteOffset(
                MemoryLayout.PathElement.groupElement("x"));
            long yOffset = pointLayout.byteOffset(
                MemoryLayout.PathElement.groupElement("y"));
            
            // Write fields
            point.set(ValueLayout.JAVA_DOUBLE, xOffset, 3.0);
            point.set(ValueLayout.JAVA_DOUBLE, yOffset, 4.0);
            
            // Read fields
            double x = point.get(ValueLayout.JAVA_DOUBLE, xOffset);
            double y = point.get(ValueLayout.JAVA_DOUBLE, yOffset);
            
            System.out.printf("Point: (%.1f, %.1f)%n", x, y);
            
            /**
             * BENEFITS:
             * 
             * - Type-safe struct access
             * - Automatic offset calculation
             * - Platform-independent
             * - Self-documenting
             */
        }
    }
    
    /**
     * ARRAY ALLOCATION:
     */
    public static void arrayAllocation() {
        try (Arena arena = Arena.ofConfined()) {
            // Allocate int array
            MemorySegment array = arena.allocateArray(
                ValueLayout.JAVA_INT, 1000);
            
            // Write array
            for (int i = 0; i < 1000; i++) {
                array.setAtIndex(ValueLayout.JAVA_INT, i, i * 10);
            }
            
            // Read array
            for (int i = 0; i < 10; i++) {
                int value = array.getAtIndex(ValueLayout.JAVA_INT, i);
                System.out.print(value + " ");
            }
            System.out.println();
            
            /**
             * PERFORMANCE:
             * 
             * Foreign Memory API: ~5 ns/access
             * DirectByteBuffer: ~10 ns/access
             * Heap array: ~2 ns/access
             * 
             * Foreign Memory is 2x faster than DirectByteBuffer!
             */
        }
    }
    
    /**
     * NATIVE MEMORY MAPPING:
     */
    public static void memoryMapping() throws Exception {
        // Map file to memory
        try (Arena arena = Arena.ofConfined()) {
            java.nio.file.Path path = java.nio.file.Path.of("data.bin");
            
            MemorySegment mapped = MemorySegment.mapFile(
                path,
                0,                          // Offset
                1024 * 1024,                // Size (1MB)
                FileChannel.MapMode.READ_WRITE,
                arena
            );
            
            // Write to mapped memory
            mapped.setAtIndex(ValueLayout.JAVA_INT, 0, 42);
            
            // Read from mapped memory
            int value = mapped.getAtIndex(ValueLayout.JAVA_INT, 0);
            System.out.println("Mapped value: " + value);
            
            // Force to disk
            mapped.force();
            
            /**
             * BENEFITS OVER MappedByteBuffer:
             * 
             * - Cleaner API
             * - Better performance
             * - Automatic cleanup
             * - Type safety
             */
        }
    }
    
    /**
     * CALLING NATIVE CODE:
     */
    public static void nativeCall() {
        /**
         * Foreign Function & Memory API (JEP 442)
         * 
         * Call native functions directly:
         */
        
        /*
        // Load native library
        SymbolLookup stdlib = Linker.nativeLinker().defaultLookup();
        
        // Find strlen function
        MemorySegment strlenAddress = stdlib.find("strlen").orElseThrow();
        
        // Create function descriptor
        FunctionDescriptor strlenDescriptor = FunctionDescriptor.of(
            ValueLayout.JAVA_LONG,     // Return type
            ValueLayout.ADDRESS        // Parameter type
        );
        
        // Create method handle
        MethodHandle strlen = Linker.nativeLinker().downcallHandle(
            strlenAddress, strlenDescriptor);
        
        // Call native function
        try (Arena arena = Arena.ofConfined()) {
            MemorySegment cString = arena.allocateUtf8String("Hello");
            long length = (long) strlen.invoke(cString);
            System.out.println("Length: " + length);  // 5
        }
        */
        
        /**
         * BENEFITS:
         * 
         * - No JNI overhead
         * - Type-safe
         * - Automatic marshalling
         * - Better performance
         */
    }
}
```

### Performance Comparison

```java
/**
 * MEMORY API PERFORMANCE COMPARISON:
 */

public class MemoryAPIBenchmark {
    
    public static void benchmarkAll() {
        final int SIZE = 10_000_000;
        final int ITERATIONS = 10;
        
        System.out.println("=== Sequential Write ===");
        benchmarkSequentialWrite(SIZE, ITERATIONS);
        
        System.out.println("\n=== Sequential Read ===");
        benchmarkSequentialRead(SIZE, ITERATIONS);
        
        System.out.println("\n=== Random Access ===");
        benchmarkRandomAccess(SIZE, ITERATIONS);
    }
    
    private static void benchmarkSequentialWrite(int size, int iterations) {
        // Heap array
        long start = System.nanoTime();
        for (int iter = 0; iter < iterations; iter++) {
            int[] array = new int[size];
            for (int i = 0; i < size; i++) {
                array[i] = i;
            }
        }
        long heapTime = System.nanoTime() - start;
        
        // DirectByteBuffer
        start = System.nanoTime();
        for (int iter = 0; iter < iterations; iter++) {
            java.nio.IntBuffer buffer = 
                java.nio.ByteBuffer.allocateDirect(size * 4).asIntBuffer();
            for (int i = 0; i < size; i++) {
                buffer.put(i, i);
            }
        }
        long directTime = System.nanoTime() - start;
        
        // Foreign Memory API
        start = System.nanoTime();
        for (int iter = 0; iter < iterations; iter++) {
            try (Arena arena = Arena.ofConfined()) {
                MemorySegment segment = arena.allocateArray(
                    ValueLayout.JAVA_INT, size);
                for (int i = 0; i < size; i++) {
                    segment.setAtIndex(ValueLayout.JAVA_INT, i, i);
                }
            }
        }
        long foreignTime = System.nanoTime() - start;
        
        System.out.printf("Heap:          %,d ms%n", heapTime / 1_000_000);
        System.out.printf("DirectBuffer:  %,d ms%n", directTime / 1_000_000);
        System.out.printf("Foreign API:   %,d ms%n", foreignTime / 1_000_000);
        
        /**
         * TYPICAL RESULTS:
         * 
         * Heap:          200 ms
         * DirectBuffer:  400 ms
         * Foreign API:   300 ms
         * 
         * Heap fastest for sequential write
         * Foreign API faster than DirectBuffer
         */
    }
    
    private static void benchmarkSequentialRead(int size, int iterations) {
        // Pre-allocate
        int[] array = new int[size];
        for (int i = 0; i < size; i++) array[i] = i;
        
        java.nio.IntBuffer buffer = 
            java.nio.ByteBuffer.allocateDirect(size * 4).asIntBuffer();
        for (int i = 0; i < size; i++) buffer.put(i, i);
        
        Arena arena = Arena.ofConfined();
        MemorySegment segment = arena.allocateArray(ValueLayout.JAVA_INT, size);
        for (int i = 0; i < size; i++) {
            segment.setAtIndex(ValueLayout.JAVA_INT, i, i);
        }
        
        // Benchmark reads
        long start = System.nanoTime();
        for (int iter = 0; iter < iterations; iter++) {
            long sum = 0;
            for (int i = 0; i < size; i++) {
                sum += array[i];
            }
        }
        long heapTime = System.nanoTime() - start;
        
        start = System.nanoTime();
        for (int iter = 0; iter < iterations; iter++) {
            long sum = 0;
            for (int i = 0; i < size; i++) {
                sum += buffer.get(i);
            }
        }
        long directTime = System.nanoTime() - start;
        
        start = System.nanoTime();
        for (int iter = 0; iter < iterations; iter++) {
            long sum = 0;
            for (int i = 0; i < size; i++) {
                sum += segment.getAtIndex(ValueLayout.JAVA_INT, i);
            }
        }
        long foreignTime = System.nanoTime() - start;
        
        arena.close();
        
        System.out.printf("Heap:          %,d ms%n", heapTime / 1_000_000);
        System.out.printf("DirectBuffer:  %,d ms%n", directTime / 1_000_000);
        System.out.printf("Foreign API:   %,d ms%n", foreignTime / 1_000_000);
        
        /**
         * TYPICAL RESULTS:
         * 
         * Heap:          100 ms
         * DirectBuffer:  200 ms
         * Foreign API:   150 ms
         * 
         * Heap fastest for sequential read
         * Foreign API 33% faster than DirectBuffer
         */
    }
    
    private static void benchmarkRandomAccess(int size, int iterations) {
        // ... similar pattern ...
        
        /**
         * TYPICAL RESULTS:
         * 
         * Heap:          300 ms
         * DirectBuffer:  500 ms
         * Foreign API:   400 ms
         * 
         * Foreign API better than DirectBuffer
         * Still slower than heap due to off-heap access
         */
    }
}
```

---

## Summary

### Key Concepts

**Native vs Heap Memory:**

- Heap: GC-managed, automatic, safer, GC pauses
- Native: Manual, larger allocations, no GC, faster for I/O

**DirectByteBuffer:**

- Wrapper around native memory
- Automatic cleanup via Cleaner (delayed)
- Manual cleanup recommended for large buffers
- Limited by -XX:MaxDirectMemorySize

**Memory-Mapped Files:**

- OS maps file to memory
- Fast random access (10x faster than traditional I/O)
- Ideal for large files (>1GB)
- Inter-process communication

**Off-Heap Caching:**

- Ehcache: Tiered (heap/off-heap/disk), automatic
- Chronicle Map: Lock-free, persistent, predictable

**Foreign Memory API:**

- Modern replacement for Unsafe
- Type-safe, automatic cleanup, better performance
- Arena-based lifecycle management
- FFI for native calls

### Performance Characteristics

|Operation|Heap|DirectBuffer|Foreign API|Mapped File|
|---|---|---|---|---|
|Sequential write|2 ns|4 ns|3 ns|3 ns|
|Sequential read|1 ns|2 ns|1.5 ns|1.5 ns|
|Random access|3 ns|5 ns|4 ns|10 ns|
|Allocation|10 ns|1000 ns|500 ns|10000 ns|
|GC impact|High|None|None|None|

### Use Case Guide

**Use Heap When:**

- Data < 1GB
- Short-lived objects
- GC pauses acceptable
- Normal application objects

**Use DirectByteBuffer When:**

- I/O operations (NIO)
- Network buffers
- Medium-sized data (10MB-1GB)
- JDK < 14

**Use Foreign Memory API When:**

- JDK 19+
- Type safety important
- Better performance needed
- Native library integration

**Use Memory-Mapped Files When:**

- Large files (>1GB)
- Random access patterns
- Inter-process communication
- File-backed data

**Use Off-Heap Caching When:**

- Cache > 1GB
- GC pauses unacceptable
- Low latency required
- Persistence needed

### JVM Flags Reference

```bash
# Direct memory limits
-XX:MaxDirectMemorySize=2g          # Max direct buffer memory

# Native memory tracking
-XX:NativeMemoryTracking=summary    # Enable tracking (summary)
-XX:NativeMemoryTracking=detail     # Enable tracking (detail)

# Then use:
jcmd <pid> VM.native_memory summary
jcmd <pid> VM.native_memory detail

# Monitoring
jcmd <pid> GC.heap_info             # Heap info
jcmd <pid> VM.info                  # VM info

# Java 17+ Unsafe access
--add-exports java.base/sun.misc=ALL-UNNAMED
--add-exports java.base/jdk.internal.ref=ALL-UNNAMED
```

### Best Practices

**DirectByteBuffer:**

1. ✅ Always clean large buffers manually
2. ✅ Use try-with-resources pattern
3. ✅ Set -XX:MaxDirectMemorySize
4. ✅ Monitor native memory growth
5. ✅ Pool buffers when possible

**Memory-Mapped Files:**

1. ✅ Use for large files (>100MB)
2. ✅ Always close FileChannel
3. ✅ Call force() for critical writes
4. ✅ Consider OS page cache size
5. ✅ Test on target platform

**Off-Heap Caching:**

1. ✅ Use tiered caching (heap + off-heap)
2. ✅ Size appropriately
3. ✅ Monitor hit rates
4. ✅ Measure serialization overhead
5. ✅ Consider Chronicle Map for >10GB

**Foreign Memory API:**

1. ✅ Use Arena.ofConfined() by default
2. ✅ Prefer Foreign API over Unsafe
3. ✅ Use ValueLayout for type safety
4. ✅ Leverage try-with-resources
5. ✅ Test thoroughly (newer API)

### Common Pitfalls

**❌ Forgetting to clean DirectByteBuffer:**

```java
ByteBuffer buffer = ByteBuffer.allocateDirect(1024 * 1024);
// LEAK: Never cleaned, waits for GC
```

**❌ Not closing FileChannel:**

```java
FileChannel channel = file.getChannel();
MappedByteBuffer buffer = channel.map(...);
// LEAK: Channel never closed
```

**❌ Exceeding MaxDirectMemorySize:**

```java
// -XX:MaxDirectMemorySize=1g
ByteBuffer buffer = ByteBuffer.allocateDirect(2_000_000_000);
// OutOfMemoryError: Direct buffer memory
```

**❌ Using Unsafe in new code:**

```java
Unsafe.allocateMemory(1024);  // DEPRECATED, will be removed
// Use Foreign Memory API instead
```

---
