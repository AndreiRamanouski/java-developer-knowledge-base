# Java Garbage Collection Algorithms and Tuning

## Overview

Garbage Collection (GC) is the automatic memory management process in Java. Understanding GC algorithms and tuning is critical for application performance, latency, and throughput optimization.

---

## 1. Garbage Collection Fundamentals

### The Generational Hypothesis

```java
/**
 * GENERATIONAL HYPOTHESIS:
 * 
 * Key Observations:
 * 1. Most objects die young (short-lived)
 * 2. Few objects survive long (long-lived)
 * 3. Old objects rarely reference young objects
 * 
 * Implications:
 * - Focus GC effort on young generation (where most garbage is)
 * - Collect young generation frequently (Minor GC)
 * - Collect old generation infrequently (Major GC)
 * 
 * STATISTICS:
 * 
 * Typical Object Lifetime Distribution:
 * - 90-95% of objects die within one GC cycle
 * - 4-9% survive to old generation
 * - 1% become long-lived
 * 
 * Example:
 * 
 * void processRequest(Request req) {
 *     // These objects die immediately after method returns
 *     String temp = req.getData();        // Dies young
 *     List<String> items = parse(temp);   // Dies young
 *     Result result = process(items);     // Dies young
 *     return result;
 * }
 * 
 * // Only long-lived objects
 * static final Cache cache = new Cache();  // Long-lived
 * static final Logger logger = new Logger(); // Long-lived
 */

public class GenerationalHypothesisDemo {
    
    public static void main(String[] args) {
        // Simulate typical application behavior
        
        // Long-lived objects (5%)
        List<byte[]> longLived = new ArrayList<>();
        
        for (int i = 0; i < 1000; i++) {
            // Short-lived objects (95%)
            for (int j = 0; j < 1000; j++) {
                String temp = "temporary" + j; // Dies young
                Object obj = new Object();     // Dies young
            }
            
            // Occasional long-lived object
            if (i % 20 == 0) {
                longLived.add(new byte[1024]); // Survives to Old Gen
            }
        }
        
        /**
         * MEMORY BEHAVIOR:
         * 
         * Time 0:
         * Young Gen: [obj1, obj2, obj3, ...]  (95% of allocations)
         * Old Gen: []
         * 
         * After Minor GC:
         * Young Gen: []                        (cleared)
         * Old Gen: [long-lived objects]        (5% promoted)
         * 
         * After 100 cycles:
         * Young Gen: [current allocations]
         * Old Gen: [accumulated long-lived]    (slowly fills)
         */
    }
}
```

---

## 2. GC Phases: Mark, Sweep, Compact

### Mark Phase

```java
/**
 * MARK PHASE:
 * 
 * Goal: Identify all live (reachable) objects
 * 
 * Process:
 * 1. Start from GC Roots (references that are definitely alive)
 * 2. Traverse object graph
 * 3. Mark all reachable objects as "alive"
 * 4. Unmarked objects are garbage
 * 
 * GC ROOTS:
 * - Local variables on thread stacks
 * - Static variables
 * - JNI references
 * - Active threads
 * - Synchronized objects (locks)
 * 
 * MARKING ALGORITHM (Depth-First Search):
 */

public class MarkPhaseExplainer {
    
    /**
     * OBJECT GRAPH EXAMPLE:
     * 
     * GC Roots:
     * ┌────────────┐
     * │ Thread     │
     * │ Stack      │
     * │  - root1 ──┼──→ [A] ──→ [B] ──→ [C]
     * │  - root2 ──┼──→ [D]      ↓
     * └────────────┘              [E]
     * 
     * Static:                     [F] ──→ [G]
     * staticVar ───────────────→   ↑
     *                              │
     * Unreachable:              [X] ─┘ [Y]  [Z]
     * 
     * MARK PROCESS:
     * 
     * Step 1: Mark root1 → A (mark A)
     * Step 2: From A → B (mark B)
     * Step 3: From B → C, E (mark C, E)
     * Step 4: Mark root2 → D (mark D)
     * Step 5: Mark staticVar → F (mark F)
     * Step 6: From F → G (mark G)
     * 
     * Result:
     * Live objects: A, B, C, D, E, F, G
     * Garbage: X, Y, Z (unmarked)
     */
    
    // Simplified mark algorithm (conceptual)
    public void markPhase(Set<Object> gcRoots) {
        Set<Object> marked = new HashSet<>();
        Queue<Object> queue = new LinkedList<>(gcRoots);
        
        while (!queue.isEmpty()) {
            Object obj = queue.poll();
            
            if (!marked.contains(obj)) {
                marked.add(obj);
                
                // Add all objects referenced by this object
                for (Object referenced : getReferencedObjects(obj)) {
                    queue.offer(referenced);
                }
            }
        }
        
        // marked set contains all live objects
        // Everything else is garbage
    }
    
    private Set<Object> getReferencedObjects(Object obj) {
        // In reality, JVM uses object layout metadata
        // to find all references
        return Collections.emptySet();
    }
}
```

### Sweep Phase

```java
/**
 * SWEEP PHASE:
 * 
 * Goal: Reclaim memory from dead (unmarked) objects
 * 
 * Process:
 * 1. Scan through heap
 * 2. Find unmarked objects
 * 3. Add their memory to free list
 * 4. Clear marks on live objects
 * 
 * Result: Memory freed, but heap fragmented
 */

public class SweepPhaseExplainer {
    
    /**
     * SWEEP EXAMPLE:
     * 
     * BEFORE SWEEP:
     * Heap:
     * ┌───┬───┬───┬───┬───┬───┬───┬───┐
     * │ A │ X │ B │ Y │ C │ Z │ D │   │
     * └───┴───┴───┴───┴───┴───┴───┴───┘
     *   ✓   ✗   ✓   ✗   ✓   ✗   ✓
     * (✓ = marked/live, ✗ = unmarked/garbage)
     * 
     * AFTER SWEEP:
     * Heap:
     * ┌───┬───┬───┬───┬───┬───┬───┬───┐
     * │ A │ F │ B │ F │ C │ F │ D │ F │
     * └───┴───┴───┴───┴───┴───┴───┴───┘
     *   ✓       ✓       ✓       ✓
     * (F = free space)
     * 
     * PROBLEM: Fragmentation!
     * - Free space exists but is scattered
     * - Hard to allocate large objects
     * - Solution: Compaction
     */
    
    /**
     * FREE LIST:
     * 
     * After sweep, GC maintains a free list:
     * Free blocks: [1-byte at pos 2], [1-byte at pos 4], [1-byte at pos 6]
     * 
     * Next allocation:
     * - Need 1 byte? Use free list
     * - Need 3 bytes? Cannot satisfy (even though 3 bytes free)
     */
}
```

### Compact Phase

```java
/**
 * COMPACT PHASE:
 * 
 * Goal: Eliminate fragmentation
 * 
 * Process:
 * 1. Move all live objects together
 * 2. Update all references
 * 3. Leave contiguous free space at end
 * 
 * Benefits:
 * - No fragmentation
 * - Fast allocation (bump-the-pointer)
 * 
 * Cost:
 * - Expensive (must move objects and update references)
 * - Stop-the-world required
 */

public class CompactPhaseExplainer {
    
    /**
     * COMPACTION EXAMPLE:
     * 
     * BEFORE COMPACTION:
     * ┌───┬───┬───┬───┬───┬───┬───┬───┐
     * │ A │ F │ B │ F │ C │ F │ D │ F │
     * └───┴───┴───┴───┴───┴───┴───┴───┘
     * 
     * AFTER COMPACTION:
     * ┌───┬───┬───┬───┬───┬───┬───┬───┐
     * │ A │ B │ C │ D │ F │ F │ F │ F │
     * └───┴───┴───┴───┴───┴───┴───┴───┘
     * 
     * Benefits:
     * - Contiguous free space
     * - Fast allocation: just bump pointer
     * - No fragmentation
     * 
     * REFERENCE UPDATE EXAMPLE:
     * 
     * BEFORE:
     * Stack: ref1 = 0x1000 (pointing to A)
     *        ref2 = 0x3000 (pointing to B)
     * 
     * AFTER:
     * Stack: ref1 = 0x1000 (A didn't move)
     *        ref2 = 0x2000 (B moved to new location)
     * 
     * All references must be updated!
     */
    
    /**
     * COMPACTION ALGORITHMS:
     * 
     * 1. Two-Pass (used by Serial GC):
     *    Pass 1: Calculate new addresses
     *    Pass 2: Move objects and update references
     * 
     * 2. Three-Pass (Lisp2):
     *    Pass 1: Mark live objects
     *    Pass 2: Calculate new addresses
     *    Pass 3: Move objects and update references
     * 
     * 3. Thread Local Allocation Buffer (TLAB):
     *    - Each thread compacts its own region
     *    - Parallel compaction possible
     */
}
```

---

## 3. Stop-The-World Pauses

### Understanding STW

```java
/**
 * STOP-THE-WORLD (STW) PAUSE:
 * 
 * Definition:
 * All application threads are paused while GC runs
 * 
 * Why needed:
 * 1. Ensure consistent heap snapshot
 * 2. Prevent object references from changing
 * 3. Safe to move objects
 * 
 * Impact:
 * - Application unresponsive during pause
 * - User-visible latency
 * - Critical for low-latency applications
 * 
 * PAUSE TYPES:
 * 
 * 1. Full STW (Old collectors):
 *    - All threads stopped
 *    - All GC work done during pause
 *    - Can be hundreds of milliseconds
 * 
 * 2. Partial STW (G1, CMS):
 *    - Some phases concurrent
 *    - Only critical phases STW
 *    - Pauses reduced to tens of milliseconds
 * 
 * 3. Nearly No STW (ZGC, Shenandoah):
 *    - Most work concurrent
 *    - Sub-millisecond pauses
 *    - Pauses < 10ms regardless of heap size
 */

public class StopTheWorldDemo {
    
    private static volatile boolean running = true;
    private static final AtomicLong operations = new AtomicLong();
    
    public static void main(String[] args) throws InterruptedException {
        // Start application thread
        Thread appThread = new Thread(() -> {
            while (running) {
                // Simulate application work
                operations.incrementAndGet();
                
                // Allocate objects (triggers GC)
                for (int i = 0; i < 1000; i++) {
                    byte[] data = new byte[1024];
                }
            }
        });
        
        appThread.start();
        
        // Monitor operations per second
        long lastCount = 0;
        for (int i = 0; i < 10; i++) {
            Thread.sleep(1000);
            long currentCount = operations.get();
            long opsPerSec = currentCount - lastCount;
            lastCount = currentCount;
            
            System.out.println("Ops/sec: " + opsPerSec);
            
            /**
             * EXPECTED OUTPUT (with GC pauses):
             * 
             * Ops/sec: 1000000
             * Ops/sec: 1000000
             * Ops/sec: 500000   ← GC pause! (500ms pause)
             * Ops/sec: 1000000
             * Ops/sec: 1000000
             * Ops/sec: 200000   ← Long GC pause! (800ms)
             * 
             * With low-latency GC (ZGC/Shenandoah):
             * Ops/sec: 1000000
             * Ops/sec: 999000   ← Minimal impact
             * Ops/sec: 998000
             */
        }
        
        running = false;
        appThread.join();
    }
    
    /**
     * MEASURING STW PAUSES:
     * 
     * Enable GC logs:
     * -Xlog:gc*:file=gc.log:time,uptime,level,tags
     * 
     * Look for:
     * [0.234s][info][gc] GC(10) Pause Young 52M->8M(256M) 5.234ms
     *                                                      ^^^^^^
     *                                                      Pause time
     */
}
```

### Safepoint Analysis

```java
/**
 * SAFEPOINTS:
 * 
 * Definition:
 * Points in code where thread state is known and can be safely paused
 * 
 * Where safepoints occur:
 * 1. Method return
 * 2. Loop back edges (end of loop)
 * 3. Before throwing exception
 * 4. JNI calls
 * 
 * NOT safepoints:
 * - Middle of method
 * - Middle of loop iteration
 * - During object allocation
 * 
 * SAFEPOINT PROCESS:
 * 
 * 1. GC thread requests safepoint
 * 2. Running threads continue until next safepoint
 * 3. All threads reach safepoint
 * 4. GC proceeds
 * 5. Threads resume
 * 
 * PROBLEM: Time to safepoint can be long!
 */

public class SafepointDemo {
    
    // BAD: Loop without safepoint
    public void countedLoopBad() {
        int sum = 0;
        // Counted loop - JIT may not insert safepoint!
        for (int i = 0; i < 1000000000; i++) {
            sum += i;
        }
        // GC must wait until loop completes!
    }
    
    // GOOD: Loop with safepoint
    public void countedLoopGood() {
        int sum = 0;
        for (int i = 0; i < 1000000000; i++) {
            sum += i;
            
            // Force safepoint periodically
            if (i % 1000000 == 0) {
                // Method call inserts safepoint
                Thread.yield();
            }
        }
    }
    
    /**
     * SAFEPOINT TUNING:
     * 
     * Flags:
     * -XX:+UnlockDiagnosticVMOptions
     * -XX:+PrintSafepointStatistics
     * -XX:PrintSafepointStatisticsCount=1
     * 
     * Output shows:
     * - Time to reach safepoint
     * - Time at safepoint
     * - Which operation triggered safepoint
     * 
     * Example output:
     *          vmop    [threads: total initially_running wait_to_block]
     * 0.234:   GenCollectForAllocation  [10    2    0.004]
     *                                          ^      ^
     *                                          |      Time waiting for threads
     *                                          Running threads
     */
}
```

---

## 4. Garbage Collectors

### Serial GC (-XX:+UseSerialGC)

```java
/**
 * SERIAL GC:
 * 
 * Characteristics:
 * - Single-threaded
 * - Stop-the-world for all GC
 * - Simplest collector
 * - Lowest memory footprint
 * 
 * Algorithm:
 * - Young Gen: Serial copying collector
 * - Old Gen: Serial mark-sweep-compact
 * 
 * Best for:
 * - Single-CPU machines
 * - Small heaps (< 100MB)
 * - Client applications
 * - Embedded systems
 * 
 * Avoid for:
 * - Server applications
 * - Large heaps
 * - Multi-core systems
 * - Low-latency requirements
 */

public class SerialGCDemo {
    
    /**
     * SERIAL GC PHASES:
     * 
     * YOUNG GC (Minor GC):
     * 1. STW pause starts
     * 2. Mark live objects in Eden
     * 3. Copy live objects to Survivor
     * 4. Promote old objects to Old Gen
     * 5. Resume application
     * 
     * Timeline:
     * [App][GC: 10ms][App][GC: 12ms][App]...
     * 
     * OLD GC (Major GC):
     * 1. STW pause starts
     * 2. Mark all live objects
     * 3. Sweep dead objects
     * 4. Compact heap
     * 5. Resume application
     * 
     * Timeline:
     * [App][Major GC: 500ms][App]
     * 
     * PERFORMANCE:
     * 
     * Young GC:
     * - Frequency: Every few seconds
     * - Duration: 5-20ms
     * 
     * Major GC:
     * - Frequency: Every few minutes
     * - Duration: 100-1000ms (depends on heap size)
     */
    
    public static void main(String[] args) {
        // Run with: -XX:+UseSerialGC -Xlog:gc*
        
        List<byte[]> data = new ArrayList<>();
        
        for (int i = 0; i < 1000; i++) {
            // Allocate 1MB
            data.add(new byte[1024 * 1024]);
            
            // Keep only recent data
            if (data.size() > 100) {
                data.remove(0);
            }
            
            if (i % 100 == 0) {
                System.out.println("Iteration: " + i);
            }
        }
        
        /**
         * EXPECTED GC LOG:
         * 
         * [0.234s][info][gc] GC(0) Pause Young 25M->5M(128M) 8.234ms
         * [0.456s][info][gc] GC(1) Pause Young 30M->6M(128M) 9.123ms
         * [2.345s][info][gc] GC(2) Pause Full 120M->95M(128M) 456.789ms
         *                                                      ^^^^^^^^
         *                                                      Long pause!
         */
    }
}
```

### Parallel GC (-XX:+UseParallelGC)

```java
/**
 * PARALLEL GC (Throughput Collector):
 * 
 * Characteristics:
 * - Multi-threaded
 * - Stop-the-world for all GC
 * - Optimized for throughput
 * - Default in Java 8
 * 
 * Algorithm:
 * - Young Gen: Parallel copying collector
 * - Old Gen: Parallel mark-sweep-compact
 * 
 * Threads:
 * - Default: (# of CPUs)
 * - Configure: -XX:ParallelGCThreads=N
 * 
 * Best for:
 * - Batch processing
 * - Scientific computing
 * - Applications where throughput > latency
 * - Multi-core systems
 * 
 * Tuning Goals:
 * - Maximize throughput
 * - Minimize GC overhead
 * - GC time < 1% of total time
 */

public class ParallelGCDemo {
    
    /**
     * PARALLEL GC PHASES:
     * 
     * YOUNG GC:
     * ┌──────────────────────────────────┐
     * │    Application Threads           │
     * ├──────────────────────────────────┤
     * │    [STW Pause - Young GC]        │
     * │    Thread 1: Mark Eden region 1  │
     * │    Thread 2: Mark Eden region 2  │ ← Parallel
     * │    Thread 3: Mark Eden region 3  │
     * │    Thread 4: Mark Eden region 4  │
     * ├──────────────────────────────────┤
     * │    Application Threads           │
     * └──────────────────────────────────┘
     * 
     * OLD GC:
     * Similar parallelism for marking, sweeping, compacting
     * 
     * SPEEDUP:
     * 
     * Serial GC: 100ms pause
     * Parallel GC (4 threads): ~30ms pause
     * Speedup: 3.3x (not linear due to overhead)
     */
    
    public static void main(String[] args) {
        // Run with: -XX:+UseParallelGC -XX:ParallelGCThreads=4
        
        /**
         * TUNING FLAGS:
         * 
         * Thread count:
         * -XX:ParallelGCThreads=N (default: # of CPUs)
         * 
         * Throughput goal:
         * -XX:GCTimeRatio=N (default: 99)
         * Goal: GC time < 1/(1+N) of total time
         * N=99 means: GC < 1% of time
         * 
         * Max pause time:
         * -XX:MaxGCPauseMillis=N (soft goal, not guaranteed)
         * 
         * Heap sizing:
         * -XX:+UseAdaptiveSizePolicy (default: enabled)
         * Automatically adjusts generation sizes
         */
        
        List<byte[]> data = new ArrayList<>();
        
        long start = System.currentTimeMillis();
        
        for (int i = 0; i < 10000; i++) {
            data.add(new byte[1024 * 100]); // 100KB
            
            if (data.size() > 1000) {
                data.remove(0);
            }
        }
        
        long elapsed = System.currentTimeMillis() - start;
        System.out.println("Total time: " + elapsed + "ms");
        
        /**
         * COMPARISON:
         * 
         * Serial GC:   Total time: 5000ms (includes 500ms GC pauses)
         * Parallel GC: Total time: 4700ms (includes 200ms GC pauses)
         * 
         * Throughput improved by ~6%
         */
    }
}
```

### CMS GC (-XX:+UseConcMarkSweepGC) [Deprecated]

```java
/**
 * CMS (Concurrent Mark Sweep):
 * 
 * Characteristics:
 * - Low-pause collector
 * - Most work done concurrently
 * - Old Gen only (Young Gen uses ParNew)
 * - No compaction → fragmentation
 * - Deprecated in Java 9, removed in Java 14
 * 
 * Algorithm:
 * - Young Gen: ParNew (parallel copying)
 * - Old Gen: Concurrent mark-sweep (no compact)
 * 
 * Best for:
 * - Low-latency applications
 * - Applications sensitive to pause times
 * - Replaced by G1 GC in modern Java
 */

public class CMSGCDemo {
    
    /**
     * CMS PHASES:
     * 
     * 1. Initial Mark (STW) - 10ms
     *    Mark GC roots
     * 
     * 2. Concurrent Mark - 500ms (concurrent!)
     *    Traverse object graph
     *    Application runs concurrently
     * 
     * 3. Concurrent Preclean - 50ms (concurrent!)
     *    Handle objects modified during concurrent mark
     * 
     * 4. Remark (STW) - 50ms
     *    Final marking of modified objects
     * 
     * 5. Concurrent Sweep - 300ms (concurrent!)
     *    Reclaim memory from dead objects
     * 
     * 6. Concurrent Reset - 10ms (concurrent!)
     *    Prepare for next cycle
     * 
     * Timeline:
     * ┌─────────────────────────────────────────┐
     * │ App │STW│  App (Concurrent Mark)  │STW│ │
     * │     │10ms│       500ms            │50ms││
     * └─────────────────────────────────────────┘
     * 
     * Total pause: 60ms
     * Total GC: 910ms
     * GC overhead: 850ms concurrent (doesn't stop app)
     */
    
    /**
     * CMS PROBLEMS:
     * 
     * 1. Fragmentation:
     *    - No compaction
     *    - Eventually triggers Full GC
     *    - Full GC is STW and slow
     * 
     * 2. Concurrent Mode Failure:
     *    - Old Gen fills up during concurrent cycle
     *    - Falls back to Serial Full GC
     *    - Very long pause
     * 
     * 3. CPU overhead:
     *    - Concurrent phases use CPU
     *    - Less CPU for application
     *    - Typically 20-30% overhead
     * 
     * 4. Floating garbage:
     *    - Objects die during concurrent mark
     *    - Not collected until next cycle
     *    - Need larger heap
     */
    
    /**
     * CMS TUNING:
     * 
     * -XX:+UseConcMarkSweepGC
     * -XX:+UseParNewGC (Young Gen collector)
     * 
     * Thread count:
     * -XX:ParallelCMSThreads=N (default: (ParallelGCThreads + 3) / 4)
     * 
     * Trigger threshold:
     * -XX:CMSInitiatingOccupancyFraction=70
     * Start CMS when Old Gen 70% full
     * 
     * Incremental mode (deprecated):
     * -XX:+CMSIncrementalMode
     */
}
```

### G1 GC (-XX:+UseG1GC)

```java
/**
 * G1 (Garbage First):
 * 
 * Characteristics:
 * - Region-based heap layout
 * - Predictable pause times
 * - Concurrent and parallel
 * - Default in Java 9+
 * - Compacting collector
 * 
 * Heap Layout:
 * ┌─────────────────────────────────────┐
 * │  Region 1 │ Region 2 │ Region 3 │...│
 * │   Eden    │   Eden   │ Survivor │   │
 * │  Region 10│ Region 11│ Region 12│   │
 * │   Old     │   Old    │ Humongous│   │
 * └─────────────────────────────────────┘
 * 
 * Regions: 1-32MB each (2048 regions max)
 * 
 * Goals:
 * - Pause time target (default: 200ms)
 * - Collect regions with most garbage first
 * - Incremental compaction
 * 
 * Best for:
 * - Large heaps (>6GB)
 * - Predictable pause times
 * - General-purpose applications
 * - Recommended for most workloads
 */

public class G1GCDemo {
    
    /**
     * G1 GC PHASES:
     * 
     * YOUNG GC (Evacuation Pause):
     * 1. STW pause
     * 2. Collect Eden and Survivor regions
     * 3. Copy live objects to Survivor or Old
     * 4. Regions become free
     * 
     * Timeline: [App][Young GC: 20ms][App][Young GC: 25ms]...
     * 
     * CONCURRENT MARKING CYCLE:
     * 1. Initial Mark (STW) - 5ms
     *    Piggyback on Young GC
     * 
     * 2. Concurrent Root Scan - concurrent
     *    Scan Survivor regions
     * 
     * 3. Concurrent Mark - concurrent
     *    Mark live objects
     * 
     * 4. Remark (STW) - 10ms
     *    Finalize marking
     * 
     * 5. Cleanup (partly STW) - 5ms
     *    Identify empty regions
     * 
     * MIXED GC:
     * - Collects Young + some Old regions
     * - Old regions selected by garbage amount
     * - "Garbage First" - collect regions with most garbage
     * 
     * Timeline:
     * ┌────────────────────────────────────────────┐
     * │[Young][Concurrent Mark][Mixed][Mixed][...]│
     * │  20ms      500ms          30ms   30ms      │
     * └────────────────────────────────────────────┘
     */
    
    public static void main(String[] args) {
        // Run with: -XX:+UseG1GC -XX:MaxGCPauseMillis=200
        
        List<byte[]> data = new ArrayList<>();
        
        for (int i = 0; i < 10000; i++) {
            // Allocate objects
            data.add(new byte[1024 * 100]);
            
            // Simulate different object lifetimes
            if (i % 100 == 0) {
                // Clear old data (creates garbage)
                data.subList(0, Math.min(50, data.size())).clear();
            }
            
            if (i % 1000 == 0) {
                System.out.println("Iteration: " + i);
            }
        }
        
        /**
         * EXPECTED BEHAVIOR:
         * 
         * 1. Frequent Young GCs (every 1-2 seconds)
         *    - Pause: 10-30ms
         *    - Collect Eden regions
         * 
         * 2. Concurrent marking cycle (every 30-60 seconds)
         *    - Minimal pauses
         *    - Identifies garbage in Old regions
         * 
         * 3. Mixed GCs (after marking cycle)
         *    - Pause: 20-50ms
         *    - Collect Young + Old regions with most garbage
         * 
         * 4. No Full GC (if tuned properly)
         *    - Full GC only if heap exhausted
         *    - Indicates tuning needed
         */
    }
    
    /**
     * G1 TUNING:
     * 
     * Basic flags:
     * -XX:+UseG1GC
     * -XX:MaxGCPauseMillis=200 (pause time goal)
     * -XX:G1HeapRegionSize=16M (region size: 1-32MB)
     * 
     * Advanced flags:
     * -XX:G1NewSizePercent=5      (min young gen: 5% of heap)
     * -XX:G1MaxNewSizePercent=60  (max young gen: 60% of heap)
     * -XX:InitiatingHeapOccupancyPercent=45 (trigger marking at 45% full)
     * -XX:G1MixedGCCountTarget=8  (number of mixed GCs in cycle)
     * -XX:G1MixedGCLiveThresholdPercent=85 (don't collect if >85% live)
     * 
     * Monitoring:
     * -Xlog:gc*:file=gc.log:time,uptime,level,tags
     * -XX:+PrintAdaptiveSizePolicy
     */
}
```

### ZGC (-XX:+UseZGC)

```java
/**
 * ZGC (Z Garbage Collector):
 * 
 * Characteristics:
 * - Ultra-low latency (<10ms pauses)
 * - Concurrent compacting collector
 * - Scalable (handles multi-TB heaps)
 * - Pause times independent of heap size
 * - Uses colored pointers and load barriers
 * - Available: Java 11+ (production: Java 15+)
 * 
 * Goals:
 * - Pause times < 10ms
 * - Pause times do NOT increase with heap size
 * - Support heaps from 8MB to 16TB
 * 
 * Best for:
 * - Very large heaps (>100GB)
 * - Ultra-low latency requirements
 * - Applications that can't tolerate pauses
 * - High-throughput, low-latency services
 */

public class ZGCDemo {
    
    /**
     * ZGC PHASES:
     * 
     * 1. Pause Mark Start (STW) - <1ms
     *    Mark GC roots
     * 
     * 2. Concurrent Mark - concurrent (no pause)
     *    Traverse object graph
     * 
     * 3. Pause Mark End (STW) - <1ms
     *    Finalize marking
     * 
     * 4. Concurrent Prepare for Relocation - concurrent
     *    Select regions to compact
     * 
     * 5. Pause Relocate Start (STW) - <1ms
     *    Relocate GC roots
     * 
     * 6. Concurrent Relocate - concurrent
     *    Move objects, update references
     * 
     * Timeline:
     * ┌─────────────────────────────────────────────┐
     * │ App │P│    App (Concurrent)    │P│    App   │
     * │     │1ms│       1000ms         │1ms│        │
     * └─────────────────────────────────────────────┘
     * 
     * Total pause: 2ms (regardless of heap size!)
     * Total GC time: 1002ms
     * GC overhead: 1000ms concurrent
     */
    
    /**
     * COLORED POINTERS:
     * 
     * ZGC uses special pointer encoding:
     * 
     * 64-bit pointer:
     * ┌────────────┬─────┬─────┬─────┬─────┬──────────┐
     * │ Unused     │ M1  │ M2  │ Remap│Final│ Address  │
     * │ 18 bits    │ 1b  │ 1b  │ 1b  │ 1b  │ 42 bits  │
     * └────────────┴─────┴─────┴─────┴─────┴──────────┘
     * 
     * Metadata bits track object state:
     * - Which GC phase object belongs to
     * - Whether pointer needs updating
     * 
     * Load Barrier:
     * - Every object load goes through barrier
     * - Checks metadata bits
     * - Updates reference if needed
     * - Enables concurrent relocation
     */
    
    public static void main(String[] args) {
        // Run with: -XX:+UseZGC -Xmx10g -Xlog:gc*
        
        /**
         * EXAMPLE: Processing 10GB of data
         * 
         * With G1 GC:
         * - Pause times: 50-200ms
         * - Pauses increase with heap size
         * - Full GC: 1-5 seconds
         * 
         * With ZGC:
         * - Pause times: 1-5ms (always!)
         * - Constant regardless of heap size
         * - No Full GC needed
         */
        
        List<byte[]> data = new ArrayList<>();
        
        long start = System.currentTimeMillis();
        long totalAllocated = 0;
        
        while (totalAllocated < 10L * 1024 * 1024 * 1024) { // 10GB
            data.add(new byte[1024 * 1024]); // 1MB
            totalAllocated += 1024 * 1024;
            
            // Keep working set small
            if (data.size() > 1000) {
                data.subList(0, 500).clear();
            }
            
            if (totalAllocated % (1024L * 1024 * 1024) == 0) {
                System.out.println("Allocated: " + (totalAllocated / 1024 / 1024 / 1024) + "GB");
            }
        }
        
        long elapsed = System.currentTimeMillis() - start;
        System.out.println("Total time: " + elapsed + "ms");
        
        /**
         * EXPECTED RESULTS:
         * 
         * ZGC Log:
         * [0.234s][info][gc] GC(0) Pause Mark Start 0.823ms
         * [1.456s][info][gc] GC(0) Concurrent Mark 1221.456ms
         * [1.457s][info][gc] GC(0) Pause Mark End 0.567ms
         * [2.678s][info][gc] GC(0) Concurrent Relocate 1220.123ms
         * 
         * Max pause: <1ms
         * Total GC cycle: ~2.5 seconds
         * Application impact: minimal
         */
    }
    
    /**
     * ZGC TUNING:
     * 
     * Basic flags:
     * -XX:+UseZGC
     * -Xmx<size> (heap size)
     * 
     * Generational ZGC (Java 21+):
     * -XX:+UseZGC -XX:+ZGenerational
     * - Better throughput
     * - Still ultra-low pauses
     * 
     * Monitoring:
     * -Xlog:gc*:file=gc.log
     * -XX:+UnlockDiagnosticVMOptions
     * -XX:+ZUncommit (return unused memory to OS)
     * 
     * CPU Considerations:
     * - Uses ~10-20% more CPU than G1
     * - Needs spare CPU for concurrent work
     * - Not recommended if CPU constrained
     * 
     * Memory Considerations:
     * - Needs extra memory for concurrent work
     * - Heap should have ~20% headroom
     * - Example: If app needs 8GB, set -Xmx10g
     */
}
```

### Shenandoah GC (-XX:+UseShenandoahGC)

```java
/**
 * SHENANDOAH GC:
 * 
 * Characteristics:
 * - Ultra-low latency (similar to ZGC)
 * - Concurrent compacting collector
 * - Uses Brooks forwarding pointers
 * - Available: Java 12+ (Red Hat backported to Java 8)
 * 
 * Goals:
 * - Pause times < 10ms
 * - Independent of heap size
 * - Lower overhead than ZGC
 * 
 * Differences from ZGC:
 * - Uses forwarding pointers (not colored pointers)
 * - Slightly lower CPU overhead
 * - Slightly higher memory overhead
 * - Both achieve similar pause times
 * 
 * Best for:
 * - Similar use cases as ZGC
 * - When ZGC not available (older Java versions)
 * - Slightly lower CPU usage preference
 */

public class ShenandoahGCDemo {
    
    /**
     * SHENANDOAH PHASES:
     * 
     * 1. Init Mark (STW) - <1ms
     * 2. Concurrent Mark - concurrent
     * 3. Final Mark (STW) - <1ms
     * 4. Concurrent Cleanup - concurrent
     * 5. Concurrent Evacuation - concurrent (key difference!)
     * 6. Init Update Refs (STW) - <1ms
     * 7. Concurrent Update Refs - concurrent
     * 8. Final Update Refs (STW) - <1ms
     * 
     * Timeline:
     * ┌──────────────────────────────────────────────┐
     * │ App │P│ App (Concurrent) │P│ App │P│ App │P││
     * │     │1ms│    800ms       │1ms│   │1ms│   │1││
     * └──────────────────────────────────────────────┘
     * 
     * Total pauses: 4ms
     */
    
    /**
     * FORWARDING POINTERS:
     * 
     * Brooks-style forwarding:
     * 
     * Every object has a hidden forwarding pointer:
     * ┌───────────────────────┐
     * │ Forwarding Pointer    │ ← Hidden, before object
     * ├───────────────────────┤
     * │ Object Header         │
     * │ Object Fields         │
     * └───────────────────────┘
     * 
     * During relocation:
     * - Object A moved to new location
     * - Forwarding pointer updated
     * - Application can still access via old reference
     * - Barrier forwards to new location
     * 
     * Memory overhead: 1 word (8 bytes) per object
     */
    
    public static void main(String[] args) {
        // Run with: -XX:+UseShenandoahGC -Xmx8g
        
        /**
         * SHENANDOAH TUNING:
         * 
         * Basic:
         * -XX:+UseShenandoahGC
         * -Xmx<size>
         * 
         * Heuristics modes:
         * -XX:ShenandoahGCHeuristics=adaptive (default)
         * -XX:ShenandoahGCHeuristics=static
         * -XX:ShenandoahGCHeuristics=compact
         * 
         * Adaptive: Adjusts based on application behavior
         * Static: Fixed GC trigger points
         * Compact: More aggressive compaction
         * 
         * Advanced:
         * -XX:ShenandoahMinFreeThreshold=10  (start GC at 10% free)
         * -XX:ShenandoahGuaranteedGCInterval=20000 (max 20s between GCs)
         */
        
        List<byte[]> data = new ArrayList<>();
        
        for (int i = 0; i < 10000; i++) {
            data.add(new byte[1024 * 100]);
            
            if (data.size() > 1000) {
                data.subList(0, 500).clear();
            }
        }
        
        /**
         * COMPARISON: ZGC vs Shenandoah
         * 
         * Metric              │ ZGC      │ Shenandoah
         * ────────────────────┼──────────┼────────────
         * Pause Time          │ 1-5ms    │ 1-5ms
         * CPU Overhead        │ 15-20%   │ 10-15%
         * Memory Overhead     │ Low      │ Medium (forwarding pointers)
         * Heap Size Support   │ 8MB-16TB │ 8MB-16TB
         * Availability        │ Java 11+ │ Java 12+ (8+ with backport)
         * Maturity            │ High     │ High
         * 
         * Both are excellent low-latency collectors
         * Choice often comes down to Java version availability
         */
    }
}
```

---

## 5. GC Tuning Parameters

### Heap Sizing

```java
/**
 * HEAP SIZING PARAMETERS:
 * 
 * Basic Parameters:
 * -Xms<size>    Initial heap size
 * -Xmx<size>    Maximum heap size
 * -Xmn<size>    Young generation size
 * 
 * Examples:
 * -Xms2g -Xmx4g    Heap: 2GB initial, 4GB maximum
 * -Xms4g -Xmx4g    Heap: 4GB fixed (recommended)
 * -Xmn1g           Young Gen: 1GB fixed
 */

public class HeapSizingDemo {
    
    /**
     * SIZING GUIDELINES:
     * 
     * 1. Fixed Heap Size:
     *    -Xms = -Xmx (RECOMMENDED)
     *    - Avoids heap resizing overhead
     *    - Predictable performance
     *    - Prevents memory fragmentation
     * 
     * 2. Heap Size:
     *    - Start with: 25% of physical RAM
     *    - Maximum: 75% of physical RAM
     *    - Leave room for OS, other processes
     * 
     * 3. Young Gen Size:
     *    - Typically: 25-50% of heap
     *    - Larger Young Gen:
     *      + Fewer Minor GCs
     *      - Longer Minor GC pauses
     *    - Smaller Young Gen:
     *      + Shorter Minor GC pauses
     *      - More frequent Minor GCs
     * 
     * EXAMPLE SCENARIOS:
     * 
     * Scenario 1: Web Application (low latency)
     * Physical RAM: 16GB
     * -Xms8g -Xmx8g (50% of RAM)
     * -Xmn2g (25% of heap)
     * 
     * Scenario 2: Batch Processing (high throughput)
     * Physical RAM: 32GB
     * -Xms24g -Xmx24g (75% of RAM)
     * -Xmn12g (50% of heap)
     * 
     * Scenario 3: Microservice (small footprint)
     * Physical RAM: 2GB container
     * -Xms512m -Xmx512m (25% of RAM)
     * -Xmn256m (50% of heap)
     */
    
    public static void main(String[] args) {
        // Print heap settings
        Runtime runtime = Runtime.getRuntime();
        
        long maxMemory = runtime.maxMemory() / 1024 / 1024;
        long totalMemory = runtime.totalMemory() / 1024 / 1024;
        long freeMemory = runtime.freeMemory() / 1024 / 1024;
        
        System.out.println("Max Memory: " + maxMemory + "MB");
        System.out.println("Total Memory: " + totalMemory + "MB");
        System.out.println("Free Memory: " + freeMemory + "MB");
        System.out.println("Used Memory: " + (totalMemory - freeMemory) + "MB");
    }
}
```

### Generation Ratios

```java
/**
 * GENERATION RATIO PARAMETERS:
 * 
 * -XX:NewRatio=N
 * Ratio of Old Gen to Young Gen
 * NewRatio=2 means Old:Young = 2:1
 * (Old Gen is 2x size of Young Gen)
 * 
 * -XX:SurvivorRatio=N
 * Ratio of Eden to one Survivor space
 * SurvivorRatio=8 means Eden:Survivor = 8:1
 * (Eden is 8x size of one Survivor)
 * 
 * -XX:MaxTenuringThreshold=N
 * Maximum GC cycles before promotion to Old Gen
 * Default: 15 (objects promoted after 15 Minor GCs)
 */

public class GenerationRatioDemo {
    
    /**
     * MEMORY LAYOUT EXAMPLES:
     * 
     * Example 1: Default Settings
     * Heap: 4GB
     * NewRatio: 2
     * SurvivorRatio: 8
     * 
     * Calculation:
     * Old Gen: 4GB * 2/3 = 2.67GB
     * Young Gen: 4GB * 1/3 = 1.33GB
     *   - Eden: 1.33GB * 8/10 = 1.07GB
     *   - Survivor S0: 1.33GB * 1/10 = 133MB
     *   - Survivor S1: 1.33GB * 1/10 = 133MB
     * 
     * ┌─────────────────────────────────────┐
     * │  Old Gen: 2.67GB                    │
     * ├─────────────────┬──────────┬────────┤
     * │  Eden: 1.07GB   │S0: 133MB │S1: ... │
     * └─────────────────┴──────────┴────────┘
     * 
     * Example 2: Young Gen Heavy (batch processing)
     * Heap: 4GB
     * NewRatio: 1 (1:1 ratio)
     * SurvivorRatio: 6
     * 
     * Old Gen: 2GB
     * Young Gen: 2GB
     *   - Eden: 2GB * 6/8 = 1.5GB
     *   - Survivor S0: 2GB * 1/8 = 250MB
     *   - Survivor S1: 2GB * 1/8 = 250MB
     * 
     * ┌──────────────────────────┐
     * │  Old Gen: 2GB            │
     * ├──────────────┬───────┬───┤
     * │  Eden: 1.5GB │S0: ... │..│
     * └──────────────┴───────┴───┘
     * 
     * Example 3: Old Gen Heavy (caching application)
     * Heap: 4GB
     * NewRatio: 4 (4:1 ratio)
     * SurvivorRatio: 8
     * 
     * Old Gen: 4GB * 4/5 = 3.2GB
     * Young Gen: 4GB * 1/5 = 800MB
     *   - Eden: 800MB * 8/10 = 640MB
     *   - Survivor S0: 800MB * 1/10 = 80MB
     *   - Survivor S1: 800MB * 1/10 = 80MB
     */
    
    /**
     * TUNING STRATEGIES:
     * 
     * High Allocation Rate:
     * - Increase Young Gen size (-Xmn)
     * - Or decrease NewRatio
     * - Reduces Minor GC frequency
     * 
     * High Object Retention:
     * - Increase MaxTenuringThreshold
     * - Keeps objects in Young Gen longer
     * - Reduces premature promotion
     * 
     * Large Survivor Objects:
     * - Decrease SurvivorRatio
     * - Larger Survivor spaces
     * - Prevents promotion due to space
     * 
     * COMMON CONFIGURATIONS:
     * 
     * Low-latency web app:
     * -Xmx4g -XX:NewRatio=2 -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=15
     * 
     * High-throughput batch:
     * -Xmx8g -XX:NewRatio=1 -XX:SurvivorRatio=6 -XX:MaxTenuringThreshold=10
     * 
     * Caching application:
     * -Xmx16g -XX:NewRatio=4 -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=20
     */
}
```

### GC Behavior Tuning

```java
/**
 * GC BEHAVIOR PARAMETERS:
 * 
 * For G1 GC:
 * -XX:MaxGCPauseMillis=N
 * Target maximum pause time (default: 200ms)
 * 
 * -XX:GCPauseIntervalMillis=N
 * Target interval between pauses
 * 
 * -XX:InitiatingHeapOccupancyPercent=N
 * Heap occupancy % to trigger marking cycle (default: 45)
 * 
 * For Parallel GC:
 * -XX:GCTimeRatio=N
 * Ratio of app time to GC time (default: 99)
 * GCTimeRatio=99 means: app runs 99ms for every 1ms of GC
 * 
 * For All GCs:
 * -XX:ParallelGCThreads=N
 * Number of threads for parallel GC phases
 * 
 * -XX:ConcGCThreads=N
 * Number of threads for concurrent GC phases (G1, CMS, ZGC, Shenandoah)
 */

public class GCBehaviorTuningDemo {
    
    /**
     * TUNING GOALS:
     * 
     * 1. THROUGHPUT (batch processing):
     *    Goal: Maximize application throughput
     *    -XX:+UseParallelGC
     *    -XX:GCTimeRatio=99
     *    -Xmx16g -Xms16g
     *    -XX:NewRatio=1
     *    Result: ~1% time in GC, large heap, large young gen
     * 
     * 2. LOW LATENCY (web application):
     *    Goal: Minimize pause times
     *    -XX:+UseG1GC
     *    -XX:MaxGCPauseMillis=50
     *    -Xmx8g -Xms8g
     *    Result: Pauses < 50ms, may sacrifice throughput
     * 
     * 3. ULTRA-LOW LATENCY (trading system):
     *    Goal: Sub-millisecond pauses
     *    -XX:+UseZGC
     *    -Xmx32g -Xms32g
     *    Result: Pauses < 10ms, higher CPU usage
     * 
     * 4. MEMORY EFFICIENCY (microservice):
     *    Goal: Minimize memory footprint
     *    -XX:+UseSerialGC
     *    -Xmx512m -Xms512m
     *    Result: Small heap, tolerate longer pauses
     */
    
    /**
     * ADVANCED TUNING EXAMPLES:
     * 
     * Example 1: E-commerce Backend
     * Requirements:
     * - Heap: 16GB
     * - Pause target: < 100ms
     * - High transaction rate
     * 
     * Tuning:
     * -Xms16g -Xmx16g
     * -XX:+UseG1GC
     * -XX:MaxGCPauseMillis=100
     * -XX:InitiatingHeapOccupancyPercent=40
     * -XX:G1ReservePercent=15
     * -XX:ParallelGCThreads=8
     * -XX:ConcGCThreads=2
     * 
     * Explanation:
     * - Fixed 16GB heap
     * - G1 GC with 100ms pause target
     * - Start marking at 40% (earlier to avoid Full GC)
     * - 15% reserve for to-space
     * - 8 parallel threads, 2 concurrent threads
     * 
     * Example 2: Real-time Analytics
     * Requirements:
     * - Heap: 64GB
     * - Pause target: < 10ms
     * - Continuous processing
     * 
     * Tuning:
     * -Xms64g -Xmx64g
     * -XX:+UseZGC
     * -XX:ZUncommit
     * -XX:ZUncommitDelay=300
     * -XX:ParallelGCThreads=16
     * 
     * Explanation:
     * - Fixed 64GB heap
     * - ZGC for ultra-low latency
     * - Uncommit unused memory after 5 minutes
     * - 16 parallel threads for fast GC
     * 
     * Example 3: Batch Data Processing
     * Requirements:
     * - Heap: 32GB
     * - Maximize throughput
     * - Pause time not critical
     * 
     * Tuning:
     * -Xms32g -Xmx32g
     * -XX:+UseParallelGC
     * -XX:GCTimeRatio=99
     * -XX:NewRatio=1
     * -XX:SurvivorRatio=6
     * -XX:MaxTenuringThreshold=10
     * -XX:ParallelGCThreads=16
     * 
     * Explanation:
     * - Fixed 32GB heap
     * - Parallel GC for throughput
     * - 99:1 app:GC ratio (1% GC overhead)
     * - Large young gen (50% of heap)
     * - 16 parallel threads for fast collection
     */
}
```

---

## 6. GC Logs Analysis

### Enabling GC Logging

```bash
# Java 8 and earlier
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
-XX:+PrintGCTimeStamps
-Xloggc:gc.log
-XX:+UseGCLogFileRotation
-XX:NumberOfGCLogFiles=10
-XX:GCLogFileSize=100M

# Java 9 and later (Unified Logging)
-Xlog:gc*:file=gc.log:time,uptime,level,tags:filecount=10,filesize=100M
```

### Reading GC Logs

```java
/**
 * GC LOG ANALYSIS:
 * 
 * G1 GC YOUNG COLLECTION LOG:
 * 
 * [2024-01-15T10:30:45.123+0000][0.234s][info][gc] GC(10) Pause Young (Normal) (G1 Evacuation Pause)
 * [2024-01-15T10:30:45.123+0000][0.234s][info][gc] GC(10) Using 8 workers of 8 for evacuation
 * [2024-01-15T10:30:45.145+0000][0.256s][info][gc,start] GC(10) Eden: 512.0M(512.0M)->0.0B(486.0M)
 * [2024-01-15T10:30:45.145+0000][0.256s][info][gc] GC(10) Survivor: 32.0M->58.0M Heap: 1.5G(4.0G)->1.1G(4.0G)
 * [2024-01-15T10:30:45.145+0000][0.256s][info][gc,cpu] GC(10) User=0.18s Sys=0.01s Real=0.02s
 *                                                                                      ^^^^^^^^^
 *                                                                                      Pause time: 20ms
 * 
 * BREAKDOWN:
 * - GC(10): GC event number 10
 * - Pause Young: Young generation collection
 * - Eden: 512MB->0MB (Eden cleared)
 * - Survivor: 32MB->58MB (survivors increased)
 * - Heap: 1.5GB->1.1GB (400MB collected)
 * - User: 0.18s (CPU time in user mode)
 * - Sys: 0.01s (CPU time in kernel mode)
 * - Real: 0.02s (wall clock time = pause time)
 * 
 * G1 GC MIXED COLLECTION LOG:
 * 
 * [2024-01-15T10:31:00.123+0000][15.234s][info][gc] GC(15) Pause Mixed (G1 Evacuation Pause)
 * [2024-01-15T10:31:00.123+0000][15.234s][info][gc] GC(15) Using 8 workers of 8 for evacuation
 * [2024-01-15T10:31:00.175+0000][15.286s][info][gc] GC(15) Eden: 486.0M(486.0M)->0.0B(460.0M)
 * [2024-01-15T10:31:00.175+0000][15.286s][info][gc] GC(15) Survivor: 58.0M->84.0M
 * [2024-01-15T10:31:00.175+0000][15.286s][info][gc] GC(15) Old: 564.0M->432.0M
 * [2024-01-15T10:31:00.175+0000][15.286s][info][gc] GC(15) Heap: 2.1G(4.0G)->1.5G(4.0G)
 * [2024-01-15T10:31:00.175+0000][15.286s][info][gc,cpu] GC(15) User=0.35s Sys=0.02s Real=0.05s
 *                                                                                      ^^^^^^^^^
 *                                                                                      Pause time: 50ms
 * 
 * BREAKDOWN:
 * - Pause Mixed: Collecting Young + Old regions
 * - Old: 564MB->432MB (132MB collected from Old Gen)
 * - Real: 0.05s = 50ms pause
 * 
 * FULL GC LOG (BAD - indicates problem):
 * 
 * [2024-01-15T10:35:00.123+0000][300.234s][warning][gc] GC(20) Pause Full (Allocation Failure)
 * [2024-01-15T10:35:00.123+0000][300.234s][info][gc] GC(20) Using 8 workers of 8 for full compaction
 * [2024-01-15T10:35:01.523+0000][301.634s][info][gc] GC(20) Heap: 3.9G(4.0G)->2.1G(4.0G)
 * [2024-01-15T10:35:01.523+0000][301.634s][info][gc,cpu] GC(20) User=10.23s Sys=0.15s Real=1.40s
 *                                                                                       ^^^^^^^^^^
 *                                                                                       1.4 SECOND PAUSE!
 * 
 * PROBLEMS INDICATED:
 * - Full GC occurred (expensive!)
 * - Allocation Failure (heap exhausted)
 * - 1.4 second pause (application frozen)
 * - Needs tuning: increase heap or tune GC
 */

public class GCLogAnalysisDemo {
    
    /**
     * KEY METRICS TO MONITOR:
     * 
     * 1. Pause Time:
     *    - Young GC: Should be < 50ms
     *    - Mixed GC: Should be < 100ms
     *    - Full GC: Should NEVER happen (if > 1s, critical!)
     * 
     * 2. Pause Frequency:
     *    - Young GC: Every few seconds (normal)
     *    - Mixed GC: Every 30-60 seconds (normal)
     *    - Full GC: Never or very rare
     * 
     * 3. Heap Usage:
     *    - After GC: Should be < 70% of max
     *    - If consistently > 80%: Increase heap or optimize memory
     * 
     * 4. GC Overhead:
     *    - Time in GC / Total time
     *    - Should be < 5%
     *    - If > 10%: Tuning needed
     * 
     * 5. Allocation Rate:
     *    - MB/second allocated
     *    - High rate → frequent Young GCs
     *    - Optimize object allocation
     * 
     * 6. Promotion Rate:
     *    - Objects promoted to Old Gen
     *    - High rate → Old Gen fills quickly
     *    - May indicate memory leak
     */
    
    /**
     * ANALYZING PROBLEMS:
     * 
     * Problem 1: Frequent Young GCs
     * Symptoms:
     * - Young GC every 1-2 seconds
     * - Short pauses but very frequent
     * 
     * Analysis:
     * - High allocation rate
     * - Young Gen too small
     * 
     * Solution:
     * - Increase Young Gen size (-Xmn)
     * - Reduce object allocation in code
     * 
     * Problem 2: Long Young GC Pauses
     * Symptoms:
     * - Young GC pauses > 100ms
     * - Survivor spaces full
     * 
     * Analysis:
     * - Too many surviving objects
     * - Survivor spaces too small
     * 
     * Solution:
     * - Increase SurvivorRatio
     * - Increase MaxTenuringThreshold
     * 
     * Problem 3: Frequent Full GCs
     * Symptoms:
     * - Full GC every few minutes
     * - Long pauses (> 1 second)
     * - Old Gen fills quickly
     * 
     * Analysis:
     * - Memory leak
     * - Heap too small
     * - High promotion rate
     * 
     * Solution:
     * - Increase heap size
     * - Find memory leak with profiler
     * - Reduce object lifetimes
     * 
     * Problem 4: Long Mixed GC Pauses (G1)
     * Symptoms:
     * - Mixed GC pauses > 200ms
     * - Many old regions collected
     * 
     * Analysis:
     * - Too many regions in collection set
     * - MaxGCPauseMillis too aggressive
     * 
     * Solution:
     * - Increase MaxGCPauseMillis
     * - Decrease G1MixedGCCountTarget
     * 
     * Problem 5: Allocation Failures
     * Symptoms:
     * - Full GC triggered by "Allocation Failure"
     * - Heap nearly full
     * 
     * Analysis:
     * - Not enough space for new objects
     * - GC can't keep up
     * 
     * Solution:
     * - Increase heap size
     * - Start GC earlier (lower InitiatingHeapOccupancyPercent)
     * - Switch to ZGC/Shenandoah for large heaps
     */
}
```

### GC Log Analysis Tools

```java
/**
 * GC LOG ANALYSIS TOOLS:
 * 
 * 1. GCeasy (https://gceasy.io)
 *    - Upload GC log
 *    - Get visual analysis
 *    - Recommendations
 *    - Free for small logs
 * 
 * 2. GCViewer (https://github.com/chewiebug/GCViewer)
 *    - Desktop application
 *    - Visualize GC events
 *    - Calculate statistics
 *    - Free and open source
 * 
 * 3. JClarity Censum (commercial)
 *    - Advanced analysis
 *    - Root cause analysis
 *    - Tuning recommendations
 * 
 * 4. Command-line analysis:
 */

public class GCLogToolsDemo {
    
    /**
     * MANUAL ANALYSIS WITH UNIX TOOLS:
     * 
     * Extract pause times:
     * $ grep "Real=" gc.log | awk '{print $NF}' | sed 's/Real=//' | sed 's/s//'
     * 0.023
     * 0.034
     * 0.028
     * 
     * Calculate average pause time:
     * $ grep "Real=" gc.log | awk '{sum+=$NF} END {print sum/NR}'
     * 0.0283333  (28.3ms average)
     * 
     * Count GC events:
     * $ grep -c "Pause Young" gc.log
     * 1234  (1234 Young GCs)
     * 
     * Find longest pause:
     * $ grep "Real=" gc.log | awk '{print $NF}' | sort -n | tail -1
     * 1.234s  (longest pause: 1.2 seconds)
     * 
     * Find Full GCs:
     * $ grep "Pause Full" gc.log
     * [warn][gc] GC(50) Pause Full (Allocation Failure) 1.234s
     * 
     * Calculate GC overhead:
     * $ grep "Real=" gc.log | awk '{sum+=$NF} END {print sum}'
     * 45.67  (45.67 seconds in GC)
     * 
     * If application ran for 1000 seconds:
     * GC overhead = 45.67 / 1000 = 4.5%
     */
    
    /**
     * PYTHON SCRIPT FOR GC ANALYSIS:
     */
    public static String pythonAnalysisScript = """
        import re
        import sys
        
        def analyze_gc_log(filename):
            with open(filename, 'r') as f:
                lines = f.readlines()
            
            young_gcs = []
            mixed_gcs = []
            full_gcs = []
            
            for line in lines:
                if 'Pause Young' in line:
                    match = re.search(r'Real=([\d.]+)s', line)
                    if match:
                        young_gcs.append(float(match.group(1)) * 1000)  # Convert to ms
                
                elif 'Pause Mixed' in line:
                    match = re.search(r'Real=([\d.]+)s', line)
                    if match:
                        mixed_gcs.append(float(match.group(1)) * 1000)
                
                elif 'Pause Full' in line:
                    match = re.search(r'Real=([\d.]+)s', line)
                    if match:
                        full_gcs.append(float(match.group(1)) * 1000)
            
            print(f"Young GC count: {len(young_gcs)}")
            print(f"Young GC avg pause: {sum(young_gcs)/len(young_gcs):.2f}ms")
            print(f"Young GC max pause: {max(young_gcs):.2f}ms")
            print()
            print(f"Mixed GC count: {len(mixed_gcs)}")
            if mixed_gcs:
                print(f"Mixed GC avg pause: {sum(mixed_gcs)/len(mixed_gcs):.2f}ms")
                print(f"Mixed GC max pause: {max(mixed_gcs):.2f}ms")
            print()
            print(f"Full GC count: {len(full_gcs)}")
            if full_gcs:
                print(f"Full GC avg pause: {sum(full_gcs)/len(full_gcs):.2f}ms")
                print(f"Full GC max pause: {max(full_gcs):.2f}ms")
        
        if __name__ == '__main__':
            analyze_gc_log(sys.argv[1])
        """;
    
    /**
     * EXAMPLE OUTPUT:
     * 
     * Young GC count: 1234
     * Young GC avg pause: 28.34ms
     * Young GC max pause: 156.78ms
     * 
     * Mixed GC count: 45
     * Mixed GC avg pause: 67.23ms
     * Mixed GC max pause: 234.56ms
     * 
     * Full GC count: 2
     * Full GC avg pause: 1234.56ms
     * Full GC max pause: 1876.54ms
     * 
     * INTERPRETATION:
     * - Young GCs: Normal frequency and duration
     * - Mixed GCs: Acceptable
     * - Full GCs: PROBLEM! 2 Full GCs with >1s pauses
     *   → Need to increase heap or investigate memory leak
     */
}
```

---

## 7. When to Choose Which GC

### Decision Matrix

```java
/**
 * GC SELECTION GUIDE:
 * 
 * ┌─────────────────┬──────────┬───────────┬─────────┬────────┬─────┬─────────────┐
 * │ Requirement     │ Serial   │ Parallel  │  CMS    │   G1   │ ZGC │ Shenandoah  │
 * ├─────────────────┼──────────┼───────────┼─────────┼────────┼─────┼─────────────┤
 * │ Heap < 100MB    │  ✓✓✓     │    ✓      │    ✗    │   ✗    │  ✗  │     ✗       │
 * │ Heap 100MB-4GB  │   ✓      │   ✓✓      │    ✓    │  ✓✓    │  ✗  │     ✗       │
 * │ Heap 4GB-32GB   │   ✗      │   ✓✓      │    ✓    │  ✓✓✓   │  ✓  │     ✓       │
 * │ Heap > 32GB     │   ✗      │    ✗      │    ✗    │   ✓    │ ✓✓✓ │    ✓✓✓      │
 * │                 │          │           │         │        │     │             │
 * │ Latency < 10ms  │   ✗      │    ✗      │    ✗    │   ✗    │ ✓✓✓ │    ✓✓✓      │
 * │ Latency < 50ms  │   ✗      │    ✗      │   ✓✓    │  ✓✓✓   │ ✓✓✓ │    ✓✓✓      │
 * │ Latency < 200ms │   ✓      │   ✓✓      │  ✓✓✓    │  ✓✓✓   │ ✓✓✓ │    ✓✓✓      │
 * │ Latency OK      │  ✓✓✓     │  ✓✓✓      │  ✓✓✓    │  ✓✓✓   │ ✓✓✓ │    ✓✓✓      │
 * │                 │          │           │         │        │     │             │
 * │ Throughput      │   ✓✓     │   ✓✓✓     │   ✓✓    │  ✓✓✓   │  ✓✓ │     ✓✓      │
 * │ Memory Overhead │  ✓✓✓     │   ✓✓      │    ✓    │   ✓✓   │  ✓  │     ✓       │
 * │ CPU Overhead    │  ✓✓✓     │   ✓✓      │    ✓    │   ✓✓   │  ✓  │     ✓✓      │
 * │                 │          │           │         │        │     │             │
 * │ Single Core     │  ✓✓✓     │    ✗      │    ✗    │   ✗    │  ✗  │     ✗       │
 * │ Multi Core      │   ✗      │   ✓✓✓     │  ✓✓✓    │  ✓✓✓   │ ✓✓✓ │    ✓✓✓      │
 * │                 │          │           │         │        │     │             │
 * │ Java 8          │   ✓      │    ✓      │    ✓    │   ✓    │  ✗  │     ✗       │
 * │ Java 11+        │   ✓      │    ✓      │    ✗    │   ✓    │  ✓  │     ✓       │
 * │ Java 17+        │   ✓      │    ✓      │    ✗    │   ✓    │ ✓✓  │    ✓✓       │
 * └─────────────────┴──────────┴───────────┴─────────┴────────┴─────┴─────────────┘
 * 
 * ✓✓✓ = Excellent    ✓✓ = Good    ✓ = Acceptable    ✗ = Not Recommended
 */

public class GCSelectionGuide {
    
    /**
     * USE CASES:
     * 
     * 1. MICROSERVICE / CONTAINER
     *    Requirements:
     *    - Small heap (< 1GB)
     *    - Minimal overhead
     *    - Fast startup
     * 
     *    Recommendation: Serial GC
     *    -XX:+UseSerialGC -Xmx512m
     * 
     * 2. WEB APPLICATION
     *    Requirements:
     *    - Medium heap (4-16GB)
     *    - Low latency (< 100ms)
     *    - Consistent response times
     * 
     *    Recommendation: G1 GC
     *    -XX:+UseG1GC -Xmx8g -XX:MaxGCPauseMillis=50
     * 
     * 3. BATCH PROCESSING
     *    Requirements:
     *    - Large heap (8-32GB)
     *    - Maximum throughput
     *    - Latency not critical
     * 
     *    Recommendation: Parallel GC
     *    -XX:+UseParallelGC -Xmx24g -XX:GCTimeRatio=99
     * 
     * 4. REAL-TIME TRADING
     *    Requirements:
     *    - Large heap (32-128GB)
     *    - Ultra-low latency (< 10ms)
     *    - Predictable pauses
     * 
     *    Recommendation: ZGC or Shenandoah
     *    -XX:+UseZGC -Xmx64g
     *    or
     *    -XX:+UseShenandoahGC -Xmx64g
     * 
     * 5. BIG DATA PROCESSING
     *    Requirements:
     *    - Very large heap (> 100GB)
     *    - Process huge datasets
     *    - Tolerate some pauses
     * 
     *    Recommendation: ZGC
     *    -XX:+UseZGC -Xmx256g
     * 
     * 6. CACHING SERVER
     *    Requirements:
     *    - Large heap (16-64GB)
     *    - Long-lived objects
     *    - Low GC overhead
     * 
     *    Recommendation: G1 GC or ZGC
     *    -XX:+UseG1GC -Xmx32g -XX:MaxGCPauseMillis=100
     *    or
     *    -XX:+UseZGC -Xmx32g (if Java 15+)
     * 
     * 7. ANDROID APPLICATION
     *    Requirements:
     *    - Small heap
     *    - Battery efficiency
     *    - Client device
     * 
     *    Recommendation: Serial GC (or Android's ART)
     *    -XX:+UseSerialGC
     * 
     * 8. ELASTICSEARCH / LUCENE
     *    Requirements:
     *    - Large heap (8-32GB)
     *    - Low latency important
     *    - Many short-lived objects
     * 
     *    Recommendation: G1 GC
     *    -XX:+UseG1GC -Xmx31g -XX:MaxGCPauseMillis=100
     *    (Note: Elasticsearch recommends < 32GB heap)
     */
    
    /**
     * MIGRATION PATHS:
     * 
     * Current: CMS GC (deprecated)
     * Migrate to: G1 GC
     * Reason: CMS removed in Java 14, G1 is drop-in replacement
     * 
     * Current: Parallel GC (high pauses)
     * Migrate to: G1 GC
     * Reason: Better pause time predictability
     * 
     * Current: G1 GC (pauses still too high)
     * Migrate to: ZGC or Shenandoah
     * Reason: Ultra-low latency requirements
     * 
     * Current: Serial GC (scaling issues)
     * Migrate to: Parallel GC or G1 GC
     * Reason: Utilize multiple cores
     */
    
    /**
     * QUICK DECISION TREE:
     * 
     * 1. What's your heap size?
     *    < 100MB → Serial GC
     *    100MB-4GB → Parallel or G1
     *    4GB-32GB → G1 GC
     *    > 32GB → ZGC or Shenandoah
     * 
     * 2. What's your latency requirement?
     *    Don't care → Parallel GC
     *    < 200ms → G1 GC
     *    < 50ms → G1 GC (tuned) or ZGC
     *    < 10ms → ZGC or Shenandoah
     * 
     * 3. What's your priority?
     *    Throughput → Parallel GC
     *    Latency → G1 GC, ZGC, or Shenandoah
     *    Balance → G1 GC
     *    Memory → Serial GC
     * 
     * 4. What's your Java version?
     *    Java 8 → Parallel or G1
     *    Java 11+ → G1 or ZGC
     *    Java 15+ → ZGC (production-ready)
     *    Java 17+ → ZGC (generational mode)
     */
}
```

---

## Summary

### Quick Reference

```bash
# Serial GC (small heaps, single CPU)
-XX:+UseSerialGC -Xms512m -Xmx512m

# Parallel GC (throughput, batch processing)
-XX:+UseParallelGC -Xms4g -Xmx4g -XX:GCTimeRatio=99

# G1 GC (general purpose, low latency)
-XX:+UseG1GC -Xms8g -Xmx8g -XX:MaxGCPauseMillis=200

# ZGC (ultra-low latency, large heaps)
-XX:+UseZGC -Xms32g -Xmx32g

# Shenandoah GC (ultra-low latency, alternative to ZGC)
-XX:+UseShenandoahGC -Xms32g -Xmx32g

# Enable GC logging
-Xlog:gc*:file=gc.log:time,uptime,level,tags
```

### Key Takeaways

**Generational Hypothesis:**

- Most objects die young
- Focus GC on young generation
- Collect young gen frequently, old gen rarely

**GC Phases:**

- Mark: Find live objects
- Sweep: Reclaim dead object memory
- Compact: Eliminate fragmentation

**Collector Choice:**

- Small heap → Serial GC
- Throughput → Parallel GC
- Low latency → G1 GC
- Ultra-low latency → ZGC/Shenandoah

**Tuning Goals:**

- Minimize pause times
- Maximize throughput
- Reduce GC frequency
- Avoid Full GCs

### Common Issues and Solutions

|Issue|Symptom|Solution|
|---|---|---|
|Frequent Young GCs|GC every 1-2s|Increase Young Gen size|
|Long Young GC pauses|Pauses > 100ms|Increase Survivor space|
|Frequent Full GCs|Full GC every few minutes|Increase heap or fix memory leak|
|Long Full GC pauses|Pauses > 1s|Switch to low-latency GC|
|High GC overhead|>10% time in GC|Increase heap or optimize code|
|Allocation failures|OutOfMemoryError|Increase heap size|

---
