# Java Object Layout and Memory Overhead

## Overview

Understanding how Java objects are laid out in memory is crucial for memory optimization and performance tuning. This guide covers object headers, alignment, padding, and practical optimization techniques.

---

## 1. Object Header (Mark Word and Class Pointer)

### Object Header Structure

```java
/**
 * OBJECT LAYOUT IN MEMORY:
 * 
 * Every Java object has:
 * 1. Object Header
 *    a. Mark Word (8 bytes on 64-bit JVM, 4 bytes on 32-bit)
 *    b. Class Pointer (klass pointer - 8 bytes, or 4 bytes with compressed oops)
 * 2. Instance Fields
 * 3. Padding (to 8-byte boundary)
 * 
 * MEMORY LAYOUT:
 * 
 * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 * â”‚          Object Header (12-16 bytes)        â”‚
 * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 * â”‚  Mark Word (8 bytes)                        â”‚
 * â”‚  - Hash code                                â”‚
 * â”‚  - GC generation age                        â”‚
 * â”‚  - Lock state                               â”‚
 * â”‚  - Thread ID (if biased)                    â”‚
 * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 * â”‚  Class Pointer (4-8 bytes)                  â”‚
 * â”‚  - Points to Class metadata                 â”‚
 * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 * â”‚  Instance Fields                            â”‚
 * â”‚  - Aligned by size (8, 4, 2, 1 bytes)       â”‚
 * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 * â”‚  Padding (align to 8 bytes)                 â”‚
 * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 */

public class ObjectHeaderDemo {
    
    /**
     * EMPTY OBJECT:
     */
    static class EmptyObject {
        // No fields
    }
    
    /**
     * MEMORY LAYOUT OF EmptyObject:
     * 
     * With compressed oops (default on 64-bit JVM with heap < 32GB):
     * 
     * Offset | Size | Description
     * -------+------+------------------
     *   0    |  8   | Mark Word
     *   8    |  4   | Class Pointer (compressed)
     *  12    |  4   | Padding
     * -------+------+------------------
     * Total: 16 bytes
     * 
     * Without compressed oops:
     * 
     * Offset | Size | Description
     * -------+------+------------------
     *   0    |  8   | Mark Word
     *   8    |  8   | Class Pointer
     * -------+------+------------------
     * Total: 16 bytes (no padding needed, already aligned)
     */
    
    /**
     * MARK WORD CONTENTS:
     * 
     * 64-bit Mark Word (8 bytes):
     * 
     * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     * â”‚  unused:25 | identity_hashcode:31 | unused:1 | age:4 |    â”‚
     * â”‚  biased_lock:1 | lock:2                                   â”‚
     * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     * 
     * Lock states (last 3 bits):
     * 001 - Unlocked
     * 101 - Biased
     * 000 - Lightweight locked
     * 010 - Heavyweight locked
     * 011 - Marked for GC
     * 
     * EXAMPLES:
     * 
     * 1. Unlocked object:
     *    Mark word contains hash code, age, lock state = 001
     * 
     * 2. Biased lock:
     *    Mark word contains thread ID, epoch, age, lock state = 101
     * 
     * 3. Lightweight lock:
     *    Mark word contains pointer to lock record on stack, state = 000
     * 
     * 4. Heavyweight lock:
     *    Mark word contains pointer to ObjectMonitor, state = 010
     */
    
    /**
     * DEMONSTRATING OBJECT SIZE:
     */
    public static void main(String[] args) {
        EmptyObject obj = new EmptyObject();
        
        // Using JOL (Java Object Layout) tool
        // System.out.println(ClassLayout.parseInstance(obj).toPrintable());
        
        /**
         * OUTPUT (with compressed oops):
         * 
         * EmptyObject object internals:
         *  OFFSET  SIZE   TYPE DESCRIPTION                    VALUE
         *       0    12        (object header)                N/A
         *      12     4        (loss due to the next object alignment)
         * Instance size: 16 bytes
         * Space losses: 0 bytes internal + 4 bytes external = 4 bytes total
         */
    }
}
```

### Mark Word in Different States

```java
/**
 * MARK WORD STATE TRANSITIONS:
 */

public class MarkWordStatesDemo {
    
    private final Object lock = new Object();
    
    /**
     * STATE 1: UNLOCKED (Normal)
     * 
     * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     * â”‚ unused:25 | hash:31 | unused:1 | age:4 | biased:0 | 01    â”‚
     * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     * 
     * Contains:
     * - Identity hash code (31 bits) - lazy, computed on first hashCode() call
     * - GC age (4 bits) - number of GC survivals (max 15)
     * - Biased lock flag (1 bit) - 0 for unbiased
     * - Lock state (2 bits) - 01 for unlocked
     */
    public void unlocked() {
        Object obj = new Object();
        
        // At this point: Mark word is in unlocked state
        // Hash code not computed yet
        
        int hash = obj.hashCode();  // Triggers hash code computation
        
        // Now: Mark word contains hash code
    }
    
    /**
     * STATE 2: BIASED LOCK
     * 
     * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     * â”‚ thread_id:54 | epoch:2 | unused:1 | age:4 | biased:1 | 01 â”‚
     * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     * 
     * Contains:
     * - Thread ID (54 bits) - ID of thread holding bias
     * - Epoch (2 bits) - timestamp for bulk revocation
     * - GC age (4 bits)
     * - Biased lock flag (1 bit) - 1 for biased
     * - Lock state (2 bits) - 01
     */
    public void biasedLock() {
        Object obj = new Object();
        
        // First synchronized block
        synchronized (obj) {
            // Mark word now contains current thread ID
            // Subsequent locks by same thread are nearly free
        }
        
        // Lock released, but bias remains
        
        synchronized (obj) {
            // Just checks thread ID in mark word
            // No CAS needed!
        }
    }
    
    /**
     * STATE 3: LIGHTWEIGHT LOCK
     * 
     * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     * â”‚ ptr_to_lock_record:62                            | 00      â”‚
     * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     * 
     * Contains:
     * - Pointer to lock record on stack (62 bits)
     * - Lock state (2 bits) - 00
     */
    public void lightweightLock() throws InterruptedException {
        Object obj = new Object();
        
        Thread t1 = new Thread(() -> {
            synchronized (obj) {
                try { Thread.sleep(100); } catch (InterruptedException e) {}
            }
        });
        
        Thread t2 = new Thread(() -> {
            synchronized (obj) {
                // If t1 still holds lock: inflate to heavyweight
                // If not: lightweight lock
            }
        });
        
        t1.start();
        Thread.sleep(10);
        t2.start();
        
        t1.join();
        t2.join();
    }
    
    /**
     * STATE 4: HEAVYWEIGHT LOCK
     * 
     * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     * â”‚ ptr_to_heavyweight_monitor:62                    | 10      â”‚
     * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     * 
     * Contains:
     * - Pointer to ObjectMonitor (62 bits)
     * - Lock state (2 bits) - 10
     */
    public void heavyweightLock() throws InterruptedException {
        Object obj = new Object();
        
        // High contention causes inflation
        Thread[] threads = new Thread[10];
        for (int i = 0; i < 10; i++) {
            threads[i] = new Thread(() -> {
                synchronized (obj) {
                    try { Thread.sleep(10); } catch (InterruptedException e) {}
                }
            });
            threads[i].start();
        }
        
        for (Thread t : threads) {
            t.join();
        }
    }
    
    /**
     * HASH CODE AND LOCKING:
     * 
     * Important: Once hash code is computed, object cannot be biased!
     * Reason: Mark word needs to store hash code, no room for thread ID
     */
    public void hashCodeAndLocking() {
        Object obj = new Object();
        
        // Compute hash code first
        int hash = obj.hashCode();
        
        // Now synchronize
        synchronized (obj) {
            // Cannot use biased locking!
            // Will use lightweight or heavyweight lock
        }
    }
}
```

---

## 2. Field Alignment and Padding

### Field Ordering and Alignment

```java
/**
 * FIELD ALIGNMENT RULES:
 * 
 * 1. Fields are aligned by their size:
 *    - long, double: 8-byte alignment
 *    - int, float: 4-byte alignment
 *    - short, char: 2-byte alignment
 *    - byte, boolean: 1-byte alignment
 *    - references: 4 or 8 bytes (depending on compressed oops)
 * 
 * 2. JVM reorders fields for efficiency:
 *    - Largest fields first (longs, doubles)
 *    - Then ints and floats
 *    - Then shorts and chars
 *    - Then bytes and booleans
 *    - References grouped together
 * 
 * 3. Object size rounded up to 8-byte boundary
 */

public class FieldAlignmentDemo {
    
    /**
     * EXAMPLE 1: Simple class
     */
    static class SimpleClass {
        byte b;      // 1 byte
        int i;       // 4 bytes
        long l;      // 8 bytes
    }
    
    /**
     * MEMORY LAYOUT (with compressed oops):
     * 
     * User-declared order:  byte, int, long
     * Actual order in memory: long, int, byte + padding
     * 
     * Offset | Size | Type       | Field
     * -------+------+------------+---------
     *   0    |  8   | (header)   | mark word
     *   8    |  4   | (header)   | class pointer
     *  12    |  4   | (padding)  | alignment gap
     *  16    |  8   | long       | l
     *  24    |  4   | int        | i
     *  28    |  1   | byte       | b
     *  29    |  3   | (padding)  | alignment gap
     * -------+------+------------+---------
     * Total: 32 bytes
     * 
     * WHY REORDERED?
     * 
     * Original order would waste space:
     * 0-12: header
     * 12: byte b (1 byte)
     * 13-15: padding (3 bytes) - align int to 4-byte boundary
     * 16: int i (4 bytes)
     * 20-23: padding (4 bytes) - align long to 8-byte boundary
     * 24: long l (8 bytes)
     * Total: 32 bytes (same total, but more fragmented)
     */
    
    /**
     * EXAMPLE 2: Multiple small fields
     */
    static class SmallFields {
        byte b1;     // 1 byte
        byte b2;     // 1 byte
        byte b3;     // 1 byte
        byte b4;     // 1 byte
        int i;       // 4 bytes
    }
    
    /**
     * MEMORY LAYOUT:
     * 
     * Offset | Size | Type       | Field
     * -------+------+------------+---------
     *   0    |  8   | (header)   | mark word
     *   8    |  4   | (header)   | class pointer
     *  12    |  4   | int        | i
     *  16    |  1   | byte       | b1
     *  17    |  1   | byte       | b2
     *  18    |  1   | byte       | b3
     *  19    |  1   | byte       | b4
     *  20    |  4   | (padding)  | alignment gap
     * -------+------+------------+---------
     * Total: 24 bytes
     * 
     * GOOD PACKING:
     * Small fields packed together after larger fields
     * Minimal padding needed
     */
    
    /**
     * EXAMPLE 3: Mixed field sizes
     */
    static class MixedFields {
        boolean flag;  // 1 byte
        long l1;       // 8 bytes
        int i1;        // 4 bytes
        short s1;      // 2 bytes
        long l2;       // 8 bytes
        byte b1;       // 1 byte
    }
    
    /**
     * MEMORY LAYOUT:
     * 
     * Offset | Size | Type       | Field
     * -------+------+------------+---------
     *   0    |  8   | (header)   | mark word
     *   8    |  4   | (header)   | class pointer
     *  12    |  4   | (padding)  | alignment gap
     *  16    |  8   | long       | l1 (reordered first)
     *  24    |  8   | long       | l2 (reordered second)
     *  32    |  4   | int        | i1
     *  36    |  2   | short      | s1
     *  38    |  1   | byte       | b1
     *  39    |  1   | boolean    | flag
     * -------+------+------------+---------
     * Total: 40 bytes
     * 
     * OPTIMAL PACKING:
     * - Longs first (8-byte alignment)
     * - Then int (4-byte alignment)
     * - Then short (2-byte alignment)
     * - Then byte and boolean (1-byte alignment)
     * - No wasted space!
     */
    
    /**
     * EXAMPLE 4: Suboptimal layout
     */
    static class SuboptimalLayout {
        byte b1;       // 1 byte
        long l1;       // 8 bytes
        byte b2;       // 1 byte
        long l2;       // 8 bytes
    }
    
    /**
     * USER EXPECTATION (if no reordering):
     * 
     * 0-12: header
     * 12: byte b1 (1 byte)
     * 13-15: padding (3 bytes) - wasted!
     * 16: long l1 (8 bytes)
     * 24: byte b2 (1 byte)
     * 25-31: padding (7 bytes) - wasted!
     * 32: long l2 (8 bytes)
     * Total: 40 bytes with 10 bytes wasted
     * 
     * ACTUAL LAYOUT (with reordering):
     * 
     * Offset | Size | Type       | Field
     * -------+------+------------+---------
     *   0    |  8   | (header)   | mark word
     *   8    |  4   | (header)   | class pointer
     *  12    |  4   | (padding)  | alignment gap
     *  16    |  8   | long       | l1 (reordered)
     *  24    |  8   | long       | l2 (reordered)
     *  32    |  1   | byte       | b1
     *  33    |  1   | byte       | b2
     *  34    |  6   | (padding)  | alignment gap
     * -------+------+------------+---------
     * Total: 40 bytes with only 10 bytes padding
     * 
     * JVM reordering saves the day!
     */
}
```

### Alignment Gaps

```java
/**
 * UNDERSTANDING PADDING:
 */

public class PaddingDemo {
    
    /**
     * EXAMPLE 1: Single byte field
     */
    static class OneByte {
        byte b;  // 1 byte
    }
    
    /**
     * MEMORY LAYOUT:
     * 
     * Offset | Size | Type       | Field
     * -------+------+------------+---------
     *   0    |  8   | (header)   | mark word
     *   8    |  4   | (header)   | class pointer
     *  12    |  1   | byte       | b
     *  13    |  3   | (padding)  | alignment gap
     * -------+------+------------+---------
     * Total: 16 bytes
     * 
     * OVERHEAD: 15 bytes for 1 byte of data!
     * Efficiency: 6.25% (1/16)
     */
    
    /**
     * EXAMPLE 2: Adding more bytes improves efficiency
     */
    static class EightBytes {
        byte b1, b2, b3, b4, b5, b6, b7, b8;  // 8 bytes
    }
    
    /**
     * MEMORY LAYOUT:
     * 
     * Offset | Size | Type       | Field
     * -------+------+------------+---------
     *   0    |  8   | (header)   | mark word
     *   8    |  4   | (header)   | class pointer
     *  12    |  8   | byte[8]    | b1..b8
     *  20    |  4   | (padding)  | alignment gap
     * -------+------+------------+---------
     * Total: 24 bytes
     * 
     * OVERHEAD: 16 bytes for 8 bytes of data
     * Efficiency: 33.3% (8/24)
     * Better, but still wasteful!
     */
    
    /**
     * EXAMPLE 3: Reference field
     */
    static class OneReference {
        Object ref;  // 4 bytes (compressed) or 8 bytes (uncompressed)
    }
    
    /**
     * MEMORY LAYOUT (compressed oops):
     * 
     * Offset | Size | Type       | Field
     * -------+------+------------+---------
     *   0    |  8   | (header)   | mark word
     *   8    |  4   | (header)   | class pointer
     *  12    |  4   | reference  | ref
     * -------+------+------------+---------
     * Total: 16 bytes
     * 
     * PERFECT FIT: No padding needed!
     * Efficiency: 25% (4/16) for actual data
     */
    
    /**
     * EXAMPLE 4: Optimal packing
     */
    static class Optimal {
        long l;     // 8 bytes
        int i;      // 4 bytes
        byte b;     // 1 byte
        boolean f;  // 1 byte
        short s;    // 2 bytes
    }
    
    /**
     * MEMORY LAYOUT:
     * 
     * Offset | Size | Type       | Field
     * -------+------+------------+---------
     *   0    |  8   | (header)   | mark word
     *   8    |  4   | (header)   | class pointer
     *  12    |  4   | (padding)  | alignment gap
     *  16    |  8   | long       | l
     *  24    |  4   | int        | i
     *  28    |  2   | short      | s
     *  30    |  1   | byte       | b
     *  31    |  1   | boolean    | f
     * -------+------+------------+---------
     * Total: 32 bytes
     * 
     * Data: 16 bytes
     * Overhead: 16 bytes (header + padding)
     * Efficiency: 50%
     * 
     * This is about as good as it gets for an object!
     */
    
    /**
     * CALCULATING OBJECT SIZE:
     * 
     * Formula:
     * 1. Start with 12 bytes (8 mark + 4 compressed class pointer)
     * 2. Add instance fields (reordered optimally)
     * 3. Round up to nearest 8-byte boundary
     * 
     * Example: Object with int and byte
     * - Header: 12 bytes
     * - Fields: 4 (int) + 1 (byte) = 5 bytes
     * - Total: 17 bytes
     * - Rounded: 24 bytes (next multiple of 8)
     */
}
```

---

## 3. Compressed Oops (-XX:+UseCompressedOops)

### Understanding Compressed Oops

```java
/**
 * COMPRESSED OOPS (Ordinary Object Pointers):
 * 
 * Problem: 64-bit JVM uses 8-byte references
 * - Doubles memory usage for pointers
 * - Worse cache utilization
 * - Lower performance
 * 
 * Solution: Compress references to 4 bytes
 * - Works for heaps up to 32GB
 * - Enabled by default when heap < 32GB
 * 
 * HOW IT WORKS:
 * 
 * Objects are 8-byte aligned (addresses divisible by 8)
 * Last 3 bits are always 0 (for 8-byte alignment)
 * Don't store these 3 bits!
 * 
 * 32-bit compressed reference:
 * - Represents 35 bits of addressing (32 stored + 3 implicit zeros)
 * - 2^35 = 32GB addressable
 * 
 * CONVERSION:
 * 
 * Compress: compressed = (address >> 3)
 * Decompress: address = (compressed << 3)
 * 
 * Example:
 * Real address:        0x0000000100000000 (4GB)
 * Compressed (>> 3):   0x20000000 (shift right 3 = divide by 8)
 * Decompressed (<< 3): 0x0000000100000000 (shift left 3 = multiply by 8)
 */

public class CompressedOopsDemo {
    
    /**
     * MEMORY SAVINGS:
     */
    static class ManyReferences {
        Object ref1, ref2, ref3, ref4, ref5;
        Object ref6, ref7, ref8, ref9, ref10;
    }
    
    /**
     * WITHOUT COMPRESSED OOPS:
     * 
     * Offset | Size | Type       | Field
     * -------+------+------------+---------
     *   0    |  8   | (header)   | mark word
     *   8    |  8   | (header)   | class pointer (8 bytes!)
     *  16    |  8   | reference  | ref1
     *  24    |  8   | reference  | ref2
     *  32    |  8   | reference  | ref3
     *  40    |  8   | reference  | ref4
     *  48    |  8   | reference  | ref5
     *  56    |  8   | reference  | ref6
     *  64    |  8   | reference  | ref7
     *  72    |  8   | reference  | ref8
     *  80    |  8   | reference  | ref9
     *  88    |  8   | reference  | ref10
     * -------+------+------------+---------
     * Total: 96 bytes
     * 
     * WITH COMPRESSED OOPS (default):
     * 
     * Offset | Size | Type       | Field
     * -------+------+------------+---------
     *   0    |  8   | (header)   | mark word
     *   8    |  4   | (header)   | class pointer (4 bytes!)
     *  12    |  4   | reference  | ref1
     *  16    |  4   | reference  | ref2
     *  20    |  4   | reference  | ref3
     *  24    |  4   | reference  | ref4
     *  28    |  4   | reference  | ref5
     *  32    |  4   | reference  | ref6
     *  36    |  4   | reference  | ref7
     *  40    |  4   | reference  | ref8
     *  44    |  4   | reference  | ref9
     *  48    |  4   | reference  | ref10
     *  52    |  4   | (padding)  | alignment gap
     * -------+------+------------+---------
     * Total: 56 bytes
     * 
     * SAVINGS: 96 - 56 = 40 bytes (41.7% reduction!)
     */
    
    /**
     * COMPRESSED CLASS POINTER:
     * 
     * Also compressed using same technique
     * Class metadata stored in compressed class space
     * Limited to 1GB by default
     * 
     * JVM Flag: -XX:CompressedClassSpaceSize=1g
     */
    
    /**
     * PERFORMANCE IMPACT:
     */
    static class Node {
        int value;
        Node next;  // 4 bytes (compressed) vs 8 bytes (uncompressed)
    }
    
    /**
     * LINKED LIST MEMORY:
     * 
     * 1000 nodes with compressed oops:
     * - Per node: 24 bytes (12 header + 4 int + 4 ref + 4 padding)
     * - Total: 24KB
     * 
     * 1000 nodes without compressed oops:
     * - Per node: 32 bytes (16 header + 4 int + 8 ref + 4 padding)
     * - Total: 32KB
     * 
     * Savings: 8KB (25%)
     * 
     * CACHE BENEFITS:
     * More objects fit in CPU cache
     * Better cache hit rate
     * Faster traversal
     */
    
    /**
     * WHEN COMPRESSED OOPS DISABLED:
     * 
     * 1. Heap > 32GB
     *    -Xmx40g â†’ Compressed oops off
     * 
     * 2. Manually disabled
     *    -XX:-UseCompressedOops
     * 
     * 3. Using large pages that prevent alignment
     *    (rare scenario)
     * 
     * CHECKING IF ENABLED:
     * 
     * java -XX:+PrintFlagsFinal -version | grep UseCompressedOops
     * 
     * Output:
     * bool UseCompressedOops = true
     */
    
    /**
     * ZERO-BASED COMPRESSED OOPS:
     * 
     * If heap base address is 0:
     * - Compression: just shift right 3
     * - Decompression: just shift left 3
     * - No base address addition needed
     * - Faster!
     * 
     * JVM tries to allocate heap at address 0
     * Not always possible (OS restrictions)
     * 
     * Flag: -XX:+UseCompressedOops
     * Check: -XX:+PrintCompressedOopsMode
     */
}
```

### Heap Size and Compressed Oops

```java
/**
 * HEAP SIZE THRESHOLDS:
 */

public class HeapSizeThresholds {
    
    /**
     * COMPRESSED OOPS THRESHOLDS:
     * 
     * Heap Size        | Compressed Oops | Object Addressing
     * -----------------+-----------------+-------------------
     * < 4GB            | Yes (default)   | Zero-based
     * 4GB - 32GB       | Yes (default)   | Non-zero based
     * > 32GB           | No              | Full 64-bit
     * 
     * WHY 32GB LIMIT?
     * 
     * 32-bit compressed pointer + 3-bit shift = 35 bits
     * 2^35 bytes = 32GB
     * 
     * Beyond 32GB: Must use full 64-bit pointers
     */
    
    /**
     * MEMORY BREAKPOINTS:
     */
    public static void analyzeHeapSize() {
        /**
         * SCENARIO 1: -Xmx31g
         * 
         * Compressed oops: YES
         * Object header: 12 bytes (8 mark + 4 compressed class)
         * References: 4 bytes
         * 
         * SCENARIO 2: -Xmx32g
         * 
         * Compressed oops: YES (at the limit)
         * Object header: 12 bytes
         * References: 4 bytes
         * 
         * SCENARIO 3: -Xmx33g
         * 
         * Compressed oops: NO (exceeds 32GB)
         * Object header: 16 bytes (8 mark + 8 class pointer)
         * References: 8 bytes
         * 
         * MEMORY IMPACT:
         * 
         * 100 million objects with one reference each:
         * 
         * At 32GB (compressed):
         * - Object: 16 bytes (12 header + 4 ref)
         * - Total: 1.6GB
         * 
         * At 33GB (uncompressed):
         * - Object: 24 bytes (16 header + 8 ref)
         * - Total: 2.4GB
         * 
         * Difference: 800MB (50% more!)
         */
    }
    
    /**
     * OPTIMIZATION STRATEGY:
     * 
     * If you need > 32GB heap:
     * 
     * Option 1: Use multiple JVM instances
     * - Each < 32GB
     * - Benefits from compressed oops
     * - Better cache utilization
     * 
     * Option 2: Accept uncompressed oops cost
     * - Needed if single JVM required
     * - Monitor memory usage increase
     * 
     * Option 3: Use off-heap memory
     * - Store large data structures off-heap
     * - Keep heap < 32GB
     * - Use DirectByteBuffer, Memory-mapped files
     */
}
```

---

## 4. Array Object Layout

### Array Memory Structure

```java
/**
 * ARRAY LAYOUT:
 * 
 * Arrays have additional header field: length
 * 
 * ARRAY MEMORY LAYOUT:
 * 
 * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 * â”‚  Mark Word (8 bytes)                        â”‚
 * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 * â”‚  Class Pointer (4 bytes with compressed)    â”‚
 * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 * â”‚  Array Length (4 bytes)                     â”‚
 * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 * â”‚  Array Elements (aligned)                   â”‚
 * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 * â”‚  Padding (to 8-byte boundary)               â”‚
 * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 */

public class ArrayLayoutDemo {
    
    /**
     * EXAMPLE 1: Empty array
     */
    public void emptyArray() {
        int[] arr = new int[0];
        
        /**
         * MEMORY LAYOUT:
         * 
         * Offset | Size | Type       | Description
         * -------+------+------------+------------------
         *   0    |  8   | (header)   | mark word
         *   8    |  4   | (header)   | class pointer
         *  12    |  4   | int        | length (0)
         * -------+------+------------+------------------
         * Total: 16 bytes
         * 
         * Even empty array has 16-byte overhead!
         */
    }
    
    /**
     * EXAMPLE 2: Primitive array
     */
    public void primitiveArrays() {
        byte[] bytes = new byte[10];
        int[] ints = new int[10];
        long[] longs = new long[10];
        
        /**
         * byte[10]:
         * 
         * Offset | Size | Type       | Description
         * -------+------+------------+------------------
         *   0    |  8   | (header)   | mark word
         *   8    |  4   | (header)   | class pointer
         *  12    |  4   | int        | length (10)
         *  16    | 10   | byte[10]   | elements
         *  26    |  6   | (padding)  | align to 8 bytes
         * -------+------+------------+------------------
         * Total: 32 bytes
         * Data: 10 bytes
         * Overhead: 22 bytes (68.75%)
         * 
         * int[10]:
         * 
         * Offset | Size | Type       | Description
         * -------+------+------------+------------------
         *   0    |  8   | (header)   | mark word
         *   8    |  4   | (header)   | class pointer
         *  12    |  4   | int        | length (10)
         *  16    | 40   | int[10]    | elements (4 bytes each)
         * -------+------+------------+------------------
         * Total: 56 bytes
         * Data: 40 bytes
         * Overhead: 16 bytes (28.6%)
         * 
         * long[10]:
         * 
         * Offset | Size | Type       | Description
         * -------+------+------------+------------------
         *   0    |  8   | (header)   | mark word
         *   8    |  4   | (header)   | class pointer
         *  12    |  4   | int        | length (10)
         *  16    | 80   | long[10]   | elements (8 bytes each)
         * -------+------+------------+------------------
         * Total: 96 bytes
         * Data: 80 bytes
         * Overhead: 16 bytes (16.7%)
         * 
         * OBSERVATION:
         * Larger element types â†’ Lower overhead percentage
         */
    }
    
    /**
     * EXAMPLE 3: Object array
     */
    public void objectArray() {
        String[] strings = new String[10];
        
        /**
         * String[10] (with compressed oops):
         * 
         * Offset | Size | Type       | Description
         * -------+------+------------+------------------
         *   0    |  8   | (header)   | mark word
         *   8    |  4   | (header)   | class pointer
         *  12    |  4   | int        | length (10)
         *  16    | 40   | ref[10]    | references (4 bytes each)
         * -------+------+------------+------------------
         * Total: 56 bytes (just the array)
         * 
         * IMPORTANT:
         * This is just the array object itself!
         * Each String object is separate.
         * 
         * Total memory:
         * - Array: 56 bytes
         * - 10 String objects: 10 Ã— (24 bytes + actual string data)
         * - Plus char[] arrays inside each String
         */
        
        for (int i = 0; i < 10; i++) {
            strings[i] = "Item " + i;
        }
        
        /**
         * FULL MEMORY BREAKDOWN:
         * 
         * 1. String[] array: 56 bytes
         * 2. Each String object: ~24 bytes
         * 3. Each char[] inside String: 24 + (chars Ã— 2)
         * 
         * For "Item 0" (6 chars):
         * - String[]: 56 bytes
         * - String object: 24 bytes
         * - char[6]: 24 + 12 = 36 bytes
         * Total for one: 116 bytes
         * Total for 10: ~1000 bytes
         */
    }
    
    /**
     * EXAMPLE 4: Multi-dimensional arrays
     */
    public void multiDimensionalArrays() {
        int[][] matrix = new int[10][20];
        
        /**
         * MEMORY STRUCTURE:
         * 
         * int[10][20] is actually:
         * - One int[][] array (10 elements)
         * - 10 int[] arrays (20 elements each)
         * 
         * Main array (int[][10]):
         * Offset | Size | Type       | Description
         * -------+------+------------+------------------
         *   0    |  8   | (header)   | mark word
         *   8    |  4   | (header)   | class pointer
         *  12    |  4   | int        | length (10)
         *  16    | 40   | ref[10]    | references to int[] arrays
         * -------+------+------------+------------------
         * Total: 56 bytes
         * 
         * Each sub-array (int[20]):
         * Offset | Size | Type       | Description
         * -------+------+------------+------------------
         *   0    |  8   | (header)   | mark word
         *   8    |  4   | (header)   | class pointer
         *  12    |  4   | int        | length (20)
         *  16    | 80   | int[20]    | elements
         * -------+------+------------+------------------
         * Total per sub-array: 96 bytes
         * 
         * TOTAL MEMORY:
         * - Main array: 56 bytes
         * - 10 sub-arrays: 10 Ã— 96 = 960 bytes
         * - Grand total: 1016 bytes
         * - Actual data: 10 Ã— 20 Ã— 4 = 800 bytes
         * - Overhead: 216 bytes (27%)
         * 
         * COMPARISON WITH 1D ARRAY:
         * 
         * int[200] (equivalent size):
         * - Header: 16 bytes
         * - Data: 800 bytes
         * - Total: 816 bytes
         * - Overhead: 16 bytes (2%)
         * 
         * Multi-dimensional arrays have higher overhead!
         */
    }
    
    /**
     * CALCULATING ARRAY SIZE:
     * 
     * Formula:
     * 1. Base: 16 bytes (12 header + 4 length)
     * 2. Add: elements Ã— element_size
     * 3. Round up to 8-byte boundary
     * 
     * Examples:
     * - byte[10]: 16 + 10 = 26 â†’ 32 bytes
     * - int[10]: 16 + 40 = 56 bytes (already aligned)
     * - long[10]: 16 + 80 = 96 bytes (already aligned)
     * - Object[10] (compressed): 16 + 40 = 56 bytes
     * - Object[10] (uncompressed): 16 + 80 = 96 bytes
     */
}
```

---

## 5. Memory Footprint Calculation

### Manual Calculation

```java
/**
 * CALCULATING OBJECT MEMORY FOOTPRINT:
 */

public class MemoryFootprintCalculation {
    
    /**
     * FORMULA:
     * 
     * 1. Object Header:
     *    - Mark word: 8 bytes
     *    - Class pointer: 4 bytes (compressed) or 8 bytes (uncompressed)
     *    - Total: 12 bytes (compressed) or 16 bytes (uncompressed)
     * 
     * 2. Instance Fields:
     *    - Sorted by size (8, 4, 2, 1 bytes)
     *    - References: 4 bytes (compressed) or 8 bytes (uncompressed)
     * 
     * 3. Alignment Padding:
     *    - Round total to 8-byte boundary
     * 
     * 4. Arrays:
     *    - Add 4 bytes for length field
     */
    
    /**
     * EXAMPLE 1: Simple class
     */
    static class Person {
        String name;    // 4 bytes (compressed reference)
        int age;        // 4 bytes
        boolean active; // 1 byte
    }
    
    /**
     * CALCULATION:
     * 
     * Header: 12 bytes (8 mark + 4 class)
     * Fields:
     *   - name (reference): 4 bytes
     *   - age (int): 4 bytes
     *   - active (boolean): 1 byte
     * Subtotal: 12 + 4 + 4 + 1 = 21 bytes
     * Rounded to 8: 24 bytes
     * 
     * MEMORY LAYOUT:
     * 0-11: Header (12 bytes)
     * 12-15: age (int, 4 bytes)
     * 16-19: name (reference, 4 bytes)
     * 20: active (boolean, 1 byte)
     * 21-23: Padding (3 bytes)
     * Total: 24 bytes
     */
    
    /**
     * EXAMPLE 2: With inheritance
     */
    static class Animal {
        int weight;     // 4 bytes
    }
    
    static class Dog extends Animal {
        String breed;   // 4 bytes (compressed reference)
        boolean trained;// 1 byte
    }
    
    /**
     * CALCULATION:
     * 
     * Dog contains:
     * - Header: 12 bytes
     * - weight (from Animal): 4 bytes
     * - breed: 4 bytes
     * - trained: 1 byte
     * Subtotal: 12 + 4 + 4 + 1 = 21 bytes
     * Rounded: 24 bytes
     * 
     * IMPORTANT:
     * Only one object header!
     * Parent fields included in child object.
     */
    
    /**
     * EXAMPLE 3: Complex object graph
     */
    static class Employee {
        String name;        // Reference: 4 bytes
        int id;             // Int: 4 bytes
        Department dept;    // Reference: 4 bytes
    }
    
    static class Department {
        String name;        // Reference: 4 bytes
        int code;           // Int: 4 bytes
    }
    
    /**
     * CALCULATION:
     * 
     * Employee object:
     * - Header: 12 bytes
     * - id: 4 bytes
     * - name: 4 bytes
     * - dept: 4 bytes
     * Total: 24 bytes
     * 
     * Department object:
     * - Header: 12 bytes
     * - code: 4 bytes
     * - name: 4 bytes
     * - Padding: 4 bytes
     * Total: 24 bytes
     * 
     * String "John" (estimate):
     * - String object: 24 bytes
     * - char[4]: 24 + 8 = 32 bytes
     * 
     * String "Engineering" (estimate):
     * - String object: 24 bytes
     * - char[11]: 24 + 22 = 46 â†’ 48 bytes
     * 
     * TOTAL FOR ONE EMPLOYEE:
     * - Employee: 24 bytes
     * - Department: 24 bytes
     * - "John": 56 bytes
     * - "Engineering": 72 bytes
     * Total: 176 bytes
     * 
     * For 1000 employees in same department:
     * - 1000 Employee objects: 24,000 bytes
     * - 1 Department object: 24 bytes
     * - 1000 unique names: ~56,000 bytes (average)
     * - 1 department name: 72 bytes
     * Total: ~80KB
     */
    
    /**
     * EXAMPLE 4: Array calculation
     */
    public static void arrayCalculation() {
        int[] arr = new int[100];
        
        /**
         * CALCULATION:
         * 
         * Header: 12 bytes (8 mark + 4 class)
         * Length: 4 bytes
         * Elements: 100 Ã— 4 = 400 bytes
         * Total: 416 bytes (already 8-byte aligned)
         */
        
        String[] strings = new String[100];
        
        /**
         * String[100]:
         * - Header: 12 bytes
         * - Length: 4 bytes
         * - References: 100 Ã— 4 = 400 bytes
         * Total: 416 bytes (just the array)
         * 
         * Plus: Memory for each String object
         */
    }
    
    /**
     * MEMORY CALCULATOR METHOD:
     */
    public static int calculateObjectSize(Class<?> clazz) {
        int size = 12; // Header with compressed oops
        
        java.lang.reflect.Field[] fields = clazz.getDeclaredFields();
        for (java.lang.reflect.Field field : fields) {
            if (java.lang.reflect.Modifier.isStatic(field.getModifiers())) {
                continue; // Skip static fields
            }
            
            Class<?> type = field.getType();
            if (type == boolean.class || type == byte.class) {
                size += 1;
            } else if (type == short.class || type == char.class) {
                size += 2;
            } else if (type == int.class || type == float.class) {
                size += 4;
            } else if (type == long.class || type == double.class) {
                size += 8;
            } else {
                size += 4; // Reference (compressed)
            }
        }
        
        // Round to 8-byte boundary
        return ((size + 7) / 8) * 8;
    }
}
```

### Real-World Examples

```java
/**
 * PRACTICAL MEMORY CALCULATIONS:
 */

public class RealWorldMemoryExamples {
    
    /**
     * EXAMPLE 1: HashMap entry
     */
    static class HashMapEntry<K, V> {
        final int hash;
        final K key;
        V value;
        HashMapEntry<K, V> next;
    }
    
    /**
     * CALCULATION:
     * 
     * Header: 12 bytes
     * hash (int): 4 bytes
     * key (reference): 4 bytes
     * value (reference): 4 bytes
     * next (reference): 4 bytes
     * Padding: 4 bytes
     * Total: 32 bytes per entry
     * 
     * HashMap with 1000 entries:
     * - Entries: 32KB
     * - Plus keys and values
     * - Plus array backing structure
     */
    
    /**
     * EXAMPLE 2: ArrayList
     */
    static class ArrayList<E> {
        Object[] elementData;  // 4 bytes
        int size;              // 4 bytes
    }
    
    /**
     * CALCULATION:
     * 
     * ArrayList object:
     * - Header: 12 bytes
     * - elementData: 4 bytes
     * - size: 4 bytes
     * - Padding: 4 bytes
     * Total: 24 bytes
     * 
     * Object[] array (capacity 10):
     * - Header: 12 bytes
     * - Length: 4 bytes
     * - Elements: 10 Ã— 4 = 40 bytes
     * Total: 56 bytes
     * 
     * ArrayList<String> with 10 strings:
     * - ArrayList: 24 bytes
     * - Object[10]: 56 bytes
     * - 10 String objects: ~560 bytes
     * Total: ~640 bytes
     */
    
    /**
     * EXAMPLE 3: LinkedList node
     */
    static class Node<E> {
        E item;        // 4 bytes
        Node<E> next;  // 4 bytes
        Node<E> prev;  // 4 bytes
    }
    
    /**
     * CALCULATION:
     * 
     * Header: 12 bytes
     * item: 4 bytes
     * next: 4 bytes
     * prev: 4 bytes
     * Total: 24 bytes per node
     * 
     * LinkedList with 1000 Integer objects:
     * - 1000 Nodes: 24,000 bytes
     * - 1000 Integers: 16,000 bytes (16 bytes each)
     * Total: 40KB
     * 
     * Compare to ArrayList<Integer>:
     * - ArrayList: 24 bytes
     * - int[1000]: 4016 bytes
     * - 1000 Integers: 16,000 bytes
     * Total: 20KB
     * 
     * LinkedList uses 2x memory of ArrayList!
     */
    
    /**
     * EXAMPLE 4: String memory
     */
    public void stringMemory() {
        String str = "Hello World";
        
        /**
         * String object:
         * 
         * class String {
         *     private final byte[] value;  // 4 bytes (JDK 9+)
         *     private final byte coder;    // 1 byte
         *     private int hash;            // 4 bytes
         * }
         * 
         * String object:
         * - Header: 12 bytes
         * - value: 4 bytes
         * - coder: 1 byte
         * - hash: 4 bytes
         * - Padding: 3 bytes
         * Total: 24 bytes
         * 
         * byte[] (11 characters, Latin-1):
         * - Header: 12 bytes
         * - Length: 4 bytes
         * - Data: 11 bytes
         * - Padding: 5 bytes
         * Total: 32 bytes
         * 
         * Complete "Hello World":
         * - String: 24 bytes
         * - byte[]: 32 bytes
         * Total: 56 bytes
         * 
         * String with emoji "Hello ğŸ˜€":
         * - String: 24 bytes
         * - byte[] (10 bytes UTF-16): 32 bytes
         * Total: 56 bytes
         */
    }
}
```

---

## 6. JOL (Java Object Layout) Tool

### Using JOL

```java
/**
 * JOL (Java Object Layout):
 * 
 * Official tool from OpenJDK for analyzing object layout
 * 
 * DEPENDENCY:
 * 
 * <dependency>
 *     <groupId>org.openjdk.jol</groupId>
 *     <artifactId>jol-core</artifactId>
 *     <version>0.17</version>
 * </dependency>
 */

import org.openjdk.jol.info.ClassLayout;
import org.openjdk.jol.info.GraphLayout;
import org.openjdk.jol.vm.VM;

public class JOLDemo {
    
    /**
     * BASIC USAGE:
     */
    static class SimpleObject {
        int x;
        byte b;
        long l;
    }
    
    public static void basicJOL() {
        SimpleObject obj = new SimpleObject();
        
        // Print layout
        System.out.println(ClassLayout.parseInstance(obj).toPrintable());
        
        /**
         * OUTPUT:
         * 
         * SimpleObject object internals:
         *  OFFSET  SIZE   TYPE DESCRIPTION                    VALUE
         *       0    12        (object header)                N/A
         *      12     4        (alignment/padding gap)        N/A
         *      16     8   long SimpleObject.l                 0
         *      24     4    int SimpleObject.x                 0
         *      28     1   byte SimpleObject.b                 0
         *      29     3        (loss due to the next object alignment)
         * Instance size: 32 bytes
         * Space losses: 4 bytes internal + 3 bytes external = 7 bytes total
         */
    }
    
    /**
     * ANALYZING ARRAYS:
     */
    public static void arrayJOL() {
        int[] arr = new int[10];
        
        System.out.println(ClassLayout.parseInstance(arr).toPrintable());
        
        /**
         * OUTPUT:
         * 
         * [I object internals:
         *  OFFSET  SIZE   TYPE DESCRIPTION                    VALUE
         *       0    16        (object header)                N/A
         *      16    40    int [I.<elements>                  N/A
         * Instance size: 56 bytes
         * Space losses: 0 bytes internal + 0 bytes external = 0 bytes total
         * 
         * Note: [I is internal name for int[]
         */
    }
    
    /**
     * OBJECT GRAPH ANALYSIS:
     */
    static class Node {
        int value;
        Node next;
    }
    
    public static void graphJOL() {
        Node head = new Node();
        head.value = 1;
        head.next = new Node();
        head.next.value = 2;
        head.next.next = new Node();
        head.next.next.value = 3;
        
        // Analyze entire object graph
        System.out.println(GraphLayout.parseInstance(head).toPrintable());
        
        /**
         * OUTPUT:
         * 
         * Node object externals:
         *           ADDRESS       SIZE TYPE        PATH
         *         70000001         24 Node        (object)
         *         70000019         24 Node        .next
         *         70000031         24 Node        .next.next
         * 
         * Totals:
         *   COUNT     AVG     SUM  DESCRIPTION
         *       3      24      72  Node
         *       3            72  (total)
         */
        
        // Get total size
        long size = GraphLayout.parseInstance(head).totalSize();
        System.out.println("Total memory: " + size + " bytes");
    }
    
    /**
     * COMPARING LAYOUTS:
     */
    static class Unoptimized {
        byte b1;
        long l1;
        byte b2;
        long l2;
    }
    
    static class Optimized {
        long l1;
        long l2;
        byte b1;
        byte b2;
    }
    
    public static void compareLayouts() {
        Unoptimized u = new Unoptimized();
        Optimized o = new Optimized();
        
        System.out.println("=== UNOPTIMIZED ===");
        System.out.println(ClassLayout.parseInstance(u).toPrintable());
        
        System.out.println("\n=== OPTIMIZED ===");
        System.out.println(ClassLayout.parseInstance(o).toPrintable());
        
        /**
         * OUTPUT shows JVM reorders both to same layout:
         * 
         * Both have same layout:
         * - Header: 12 bytes
         * - Padding: 4 bytes (to align long)
         * - long l1: 8 bytes
         * - long l2: 8 bytes
         * - byte b1: 1 byte
         * - byte b2: 1 byte
         * - Padding: 6 bytes
         * Total: 40 bytes
         * 
         * JVM is smart about field ordering!
         */
    }
    
    /**
     * VM INFORMATION:
     */
    public static void vmInfo() {
        System.out.println(VM.current().details());
        
        /**
         * OUTPUT:
         * 
         * # Running 64-bit HotSpot VM.
         * # Using compressed oop with 3-bit shift.
         * # Using compressed klass with 3-bit shift.
         * # Objects are 8 bytes aligned.
         * # Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]
         * # Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]
         */
    }
    
    /**
     * FOOTPRINT ANALYSIS:
     */
    static class Container {
        Object[] items = new Object[100];
    }
    
    public static void footprintAnalysis() {
        Container c = new Container();
        
        // Fill with objects
        for (int i = 0; i < 100; i++) {
            c.items[i] = new Object();
        }
        
        // Analyze footprint
        GraphLayout layout = GraphLayout.parseInstance(c);
        
        System.out.println("Total size: " + layout.totalSize() + " bytes");
        System.out.println("Total count: " + layout.totalCount() + " objects");
        
        System.out.println("\nBy class:");
        System.out.println(layout.toFootprint());
        
        /**
         * OUTPUT:
         * 
         * Total size: 2040 bytes
         * Total count: 102 objects
         * 
         * By class:
         *    COUNT     AVG       SUM   DESCRIPTION
         *      100      16      1600   java.lang.Object
         *        1     416       416   java.lang.Object[]
         *        1      24        24   Container
         *      102            2040   (total)
         */
    }
}
```

### Advanced JOL Usage

```java
/**
 * ADVANCED JOL FEATURES:
 */

public class AdvancedJOL {
    
    /**
     * CUSTOM LAYOUT ANALYZER:
     */
    public static void customAnalyzer() {
        Object obj = new Object();
        
        ClassLayout layout = ClassLayout.parseInstance(obj);
        
        System.out.println("Size: " + layout.instanceSize());
        System.out.println("Header size: " + layout.headerSize());
        
        // Iterate fields
        for (var field : layout.fields()) {
            System.out.printf("Field: %s, Offset: %d, Size: %d%n",
                field.name(), field.offset(), field.size());
        }
    }
    
    /**
     * SHALLOW VS DEEP SIZE:
     */
    static class Parent {
        int value;
        Child child;
    }
    
    static class Child {
        int data;
    }
    
    public static void shallowVsDeep() {
        Parent p = new Parent();
        p.child = new Child();
        
        // Shallow size: Just the Parent object
        long shallow = ClassLayout.parseInstance(p).instanceSize();
        System.out.println("Shallow size: " + shallow + " bytes");
        
        // Deep size: Parent + all referenced objects
        long deep = GraphLayout.parseInstance(p).totalSize();
        System.out.println("Deep size: " + deep + " bytes");
        
        /**
         * OUTPUT:
         * Shallow size: 24 bytes (Parent object only)
         * Deep size: 48 bytes (Parent + Child)
         */
    }
    
    /**
     * MEMORY LEAK DETECTION:
     */
    public static void memoryLeakDetection() {
        java.util.List<Object> list = new java.util.ArrayList<>();
        
        // Add objects
        for (int i = 0; i < 1000; i++) {
            list.add(new Object());
        }
        
        // Analyze
        GraphLayout layout = GraphLayout.parseInstance(list);
        
        System.out.println("Total objects: " + layout.totalCount());
        System.out.println("Total size: " + layout.totalSize() + " bytes");
        
        // Print histogram
        System.out.println(layout.toFootprint());
        
        /**
         * Useful for:
         * - Finding memory leaks
         * - Analyzing object retention
         * - Measuring collection overhead
         */
    }
    
    /**
     * COMPARING BEFORE AND AFTER:
     */
    public static void compareSnapshots() {
        java.util.List<String> list = new java.util.ArrayList<>();
        
        // Snapshot 1
        GraphLayout before = GraphLayout.parseInstance(list);
        
        // Modify
        for (int i = 0; i < 100; i++) {
            list.add("Item " + i);
        }
        
        // Snapshot 2
        GraphLayout after = GraphLayout.parseInstance(list);
        
        System.out.println("Before: " + before.totalSize() + " bytes");
        System.out.println("After: " + after.totalSize() + " bytes");
        System.out.println("Difference: " + 
            (after.totalSize() - before.totalSize()) + " bytes");
        
        /**
         * Useful for:
         * - Measuring operation costs
         * - Tracking memory growth
         * - Optimization validation
         */
    }
}
```

---

## 7. Memory Optimization Techniques

### Optimization Strategies

```java
/**
 * MEMORY OPTIMIZATION TECHNIQUES:
 */

public class MemoryOptimization {
    
    /**
     * TECHNIQUE 1: USE PRIMITIVE ARRAYS INSTEAD OF OBJECT ARRAYS
     */
    
    // Bad: Wasteful
    static class BadIntegerList {
        Integer[] values = new Integer[1000];
        
        /**
         * MEMORY:
         * - Integer[1000]: 416 bytes
         * - 1000 Integer objects: 16,000 bytes
         * Total: 16,416 bytes
         */
    }
    
    // Good: Efficient
    static class GoodIntList {
        int[] values = new int[1000];
        
        /**
         * MEMORY:
         * - int[1000]: 4,016 bytes
         * Total: 4,016 bytes
         * 
         * Savings: 12,400 bytes (75% reduction!)
         */
    }
    
    /**
     * TECHNIQUE 2: PACK BOOLEANS INTO BITS
     */
    
    // Bad: One boolean per object
    static class BadFlags {
        boolean flag1, flag2, flag3, flag4, flag5, flag6, flag7, flag8;
        
        /**
         * MEMORY:
         * - Header: 12 bytes
         * - 8 booleans: 8 bytes
         * - Padding: 4 bytes
         * Total: 24 bytes
         */
    }
    
    // Good: Pack into byte
    static class GoodFlags {
        byte flags;  // 8 flags in 1 byte
        
        boolean getFlag(int index) {
            return (flags & (1 << index)) != 0;
        }
        
        void setFlag(int index, boolean value) {
            if (value) {
                flags |= (1 << index);
            } else {
                flags &= ~(1 << index);
            }
        }
        
        /**
         * MEMORY:
         * - Header: 12 bytes
         * - byte: 1 byte
         * - Padding: 3 bytes
         * Total: 16 bytes
         * 
         * Savings: 8 bytes (33% reduction)
         * 
         * For 1000 objects: 8KB savings
         */
    }
    
    /**
     * TECHNIQUE 3: OBJECT POOLING
     */
    static class Point {
        final int x, y;
        
        Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }
    
    static class PointPool {
        private static final java.util.Map<Long, Point> pool = 
            new java.util.concurrent.ConcurrentHashMap<>();
        
        public static Point getPoint(int x, int y) {
            long key = ((long) x << 32) | (y & 0xFFFFFFFFL);
            return pool.computeIfAbsent(key, k -> new Point(x, y));
        }
        
        /**
         * BENEFIT:
         * 
         * Without pooling (1000 Point(1,2) objects):
         * - 1000 objects Ã— 24 bytes = 24KB
         * 
         * With pooling (1 Point(1,2) object):
         * - 1 object Ã— 24 bytes = 24 bytes
         * - HashMap overhead: ~100 bytes
         * Total: ~200 bytes
         * 
         * Savings: 23.8KB (99% reduction!)
         */
    }
    
    /**
     * TECHNIQUE 4: USE FLYWEIGHT PATTERN
     */
    static class Character {
        private final char value;
        
        private static final Character[] CACHE = new Character[128];
        
        static {
            for (int i = 0; i < 128; i++) {
                CACHE[i] = new Character((char) i);
            }
        }
        
        private Character(char value) {
            this.value = value;
        }
        
        public static Character valueOf(char c) {
            if (c < 128) {
                return CACHE[c];
            }
            return new Character(c);
        }
        
        /**
         * BENEFIT:
         * 
         * ASCII characters (most common) reuse cached objects
         * Reduces memory for text-heavy applications
         */
    }
    
    /**
     * TECHNIQUE 5: STRING INTERNING
     */
    public void stringInterning() {
        // Bad: New String objects
        String s1 = new String("Hello");
        String s2 = new String("Hello");
        // s1 != s2, two objects
        
        // Good: Intern strings
        String s3 = "Hello";  // From string pool
        String s4 = "Hello";  // Same object!
        // s3 == s4, one object
        
        // Manual interning
        String s5 = new String("World").intern();
        String s6 = new String("World").intern();
        // s5 == s6
        
        /**
         * BENEFIT:
         * 
         * 1000 duplicate strings without interning:
         * - 1000 String objects: 24KB
         * - 1000 char[]: 32KB
         * Total: 56KB
         * 
         * With interning:
         * - 1 String object: 24 bytes
         * - 1 char[]: 32 bytes
         * Total: 56 bytes
         * 
         * Savings: 55.94KB (99.9% reduction!)
         */
    }
    
    /**
     * TECHNIQUE 6: USE COMPACT COLLECTIONS
     */
    
    // Bad: Standard ArrayList
    static class BadList {
        java.util.List<Integer> list = new java.util.ArrayList<>();
        
        /**
         * For 10 integers:
         * - ArrayList: 24 bytes
         * - Object[10]: 56 bytes
         * - 10 Integer: 160 bytes
         * Total: 240 bytes
         */
    }
    
    // Good: Primitive collection (e.g., Eclipse Collections)
    static class GoodList {
        // org.eclipse.collections.impl.list.mutable.primitive.IntArrayList
        // IntArrayList list = new IntArrayList();
        
        /**
         * For 10 integers:
         * - IntArrayList: 32 bytes
         * - int[10]: 56 bytes
         * Total: 88 bytes
         * 
         * Savings: 152 bytes (63% reduction)
         */
    }
    
    /**
     * TECHNIQUE 7: AVOID UNNECESSARY WRAPPERS
     */
    
    // Bad: Boxing
    public void bad() {
        java.util.List<Integer> list = new java.util.ArrayList<>();
        for (int i = 0; i < 1000; i++) {
            list.add(i);  // Boxing creates Integer object
        }
        
        /**
         * Memory:
         * - 1000 Integer objects: 16KB
         */
    }
    
    // Good: Primitives
    public void good() {
        int[] arr = new int[1000];
        for (int i = 0; i < 1000; i++) {
            arr[i] = i;  // No boxing
        }
        
        /**
         * Memory:
         * - int[1000]: 4KB
         * 
         * Savings: 12KB (75% reduction)
         */
    }
    
    /**
     * TECHNIQUE 8: STRUCT-OF-ARRAYS VS ARRAY-OF-STRUCTS
     */
    
    // Array-of-Structs (typical)
    static class Particle {
        float x, y, z;     // Position
        float vx, vy, vz;  // Velocity
    }
    
    static class ParticleSystemAOS {
        Particle[] particles;
        
        /**
         * For 1000 particles:
         * - 1000 Particle objects: 32KB (32 bytes each)
         * - Particle[1000]: 416 bytes
         * Total: ~33KB
         */
    }
    
    // Struct-of-Arrays (optimized)
    static class ParticleSystemSOA {
        float[] x, y, z;      // Position arrays
        float[] vx, vy, vz;   // Velocity arrays
        
        ParticleSystemSOA(int count) {
            x = new float[count];
            y = new float[count];
            z = new float[count];
            vx = new float[count];
            vy = new float[count];
            vz = new float[count];
        }
        
        /**
         * For 1000 particles:
         * - 6 float[1000] arrays: 6 Ã— 4KB = 24KB
         * Total: 24KB
         * 
         * Savings: 9KB (27% reduction)
         * 
         * BONUS:
         * - Better cache locality
         * - SIMD vectorization possible
         * - Faster processing
         */
    }
}
```

### Real-World Optimizations

```java
/**
 * REAL-WORLD OPTIMIZATION EXAMPLES:
 */

public class RealWorldOptimizations {
    
    /**
     * EXAMPLE 1: Date/Time optimization
     */
    
    // Bad: Many LocalDateTime objects
    static class BadEventLog {
        java.util.List<java.time.LocalDateTime> timestamps = 
            new java.util.ArrayList<>();
        
        /**
         * For 10,000 events:
         * - 10,000 LocalDateTime: ~640KB
         */
    }
    
    // Good: Store as long (epoch milliseconds)
    static class GoodEventLog {
        long[] timestamps = new long[10000];
        
        /**
         * For 10,000 events:
         * - long[10000]: 80KB
         * 
         * Savings: 560KB (87% reduction!)
         * 
         * Convert when needed:
         * Instant.ofEpochMilli(timestamp)
         */
    }
    
    /**
     * EXAMPLE 2: Enum optimization
     */
    
    // Bad: String status
    static class BadOrder {
        String status;  // "PENDING", "SHIPPED", "DELIVERED"
        
        /**
         * Per order:
         * - String reference: 4 bytes
         * - String object: 24 bytes
         * - char[]: 32 bytes (average)
         * Total: 60 bytes per order
         * 
         * 1M orders: 60MB
         */
    }
    
    // Good: Enum (shared)
    enum OrderStatus {
        PENDING, SHIPPED, DELIVERED
    }
    
    static class GoodOrder {
        OrderStatus status;
        
        /**
         * Per order:
         * - Reference: 4 bytes
         * 
         * Enum instances (shared): 3 Ã— 16 bytes = 48 bytes
         * 
         * 1M orders: 4MB + 48 bytes
         * 
         * Savings: 56MB (93% reduction!)
         */
    }
    
    // Better: Byte code
    static class OptimizedOrder {
        byte status;  // 0=PENDING, 1=SHIPPED, 2=DELIVERED
        
        /**
         * Per order: 1 byte
         * 
         * 1M orders: 1MB
         * 
         * Savings: 59MB (98% reduction!)
         */
    }
    
    /**
     * EXAMPLE 3: Cache line optimization
     */
    
    // Bad: False sharing
    static class BadCounter {
        volatile long count1;
        volatile long count2;
        
        /**
         * count1 and count2 in same cache line (64 bytes)
         * Thread 1 writes count1
         * Thread 2 writes count2
         * â†’ Cache line ping-pongs between cores
         * â†’ Slow!
         */
    }
    
    // Good: Padding to avoid false sharing
    static class GoodCounter {
        volatile long count1;
        long p1, p2, p3, p4, p5, p6, p7;  // Padding (56 bytes)
        volatile long count2;
        
        /**
         * count1 and count2 in different cache lines
         * No false sharing
         * â†’ Fast!
         * 
         * Cost: 56 bytes padding
         * Benefit: Much better performance
         */
    }
    
    /**
     * EXAMPLE 4: Object graph optimization
     */
    
    // Bad: Many small objects
    static class BadGraph {
        static class Node {
            int id;
            String name;
            java.util.List<Node> neighbors;
        }
        
        /**
         * 1000 nodes:
         * - 1000 Node objects: 24KB
         * - 1000 ArrayList: 24KB
         * - 1000 String objects: 24KB
         * - 1000 char[]: 32KB
         * - Arrays for neighbors: varies
         * Total: ~100KB minimum
         */
    }
    
    // Good: Flat arrays
    static class GoodGraph {
        int[] ids;
        int[] nameOffsets;
        byte[] nameData;
        int[] edgeOffsets;
        int[] edges;
        
        /**
         * 1000 nodes:
         * - int[1000] ids: 4KB
         * - int[1001] nameOffsets: 4KB
         * - byte[] names: 10KB (packed)
         * - int[1001] edgeOffsets: 4KB
         * - int[] edges: varies
         * Total: ~30KB + edges
         * 
         * Savings: 70KB (70% reduction)
         * 
         * BONUS:
         * - Better cache locality
         * - Faster iteration
         * - Less GC pressure
         */
    }
    
    /**
     * MEASURING OPTIMIZATION IMPACT:
     */
    public static void measureOptimization() {
        // Before optimization
        BadEventLog bad = new BadEventLog();
        for (int i = 0; i < 10000; i++) {
            bad.timestamps.add(java.time.LocalDateTime.now());
        }
        
        long badSize = GraphLayout.parseInstance(bad).totalSize();
        System.out.println("Before: " + badSize + " bytes");
        
        // After optimization
        GoodEventLog good = new GoodEventLog();
        for (int i = 0; i < 10000; i++) {
            good.timestamps[i] = System.currentTimeMillis();
        }
        
        long goodSize = GraphLayout.parseInstance(good).totalSize();
        System.out.println("After: " + goodSize + " bytes");
        
        double reduction = 100.0 * (badSize - goodSize) / badSize;
        System.out.printf("Reduction: %.1f%%%n", reduction);
    }
}
```

---

## Summary

### Key Concepts

**Object Header:**

- Mark word: 8 bytes (hash, age, lock state)
- Class pointer: 4 bytes (compressed) or 8 bytes
- Total: 12-16 bytes per object

**Field Alignment:**

- Fields ordered by size: long (8) â†’ int/float (4) â†’ short/char (2) â†’ byte/boolean (1)
- Objects aligned to 8-byte boundary
- Padding fills gaps

**Compressed Oops:**

- Reduces references from 8 to 4 bytes
- Works for heaps < 32GB
- 40% memory savings for reference-heavy code
- Enabled by default

**Arrays:**

- Additional 4-byte length field
- Minimum 16 bytes (empty array)
- Element alignment by type
- Multi-dimensional = nested arrays (high overhead)

**Memory Overhead:**

- Empty object: 16 bytes
- Object with one int: 24 bytes (50% overhead)
- Object with 8 bytes data: 32 bytes (75% efficiency)

### Size Quick Reference

|Type|Size (bytes)|Example|
|---|---|---|
|boolean, byte|1|boolean flag|
|short, char|2|short count|
|int, float|4|int value|
|long, double|8|long timestamp|
|reference (compressed)|4|Object ref|
|reference (uncompressed)|8|Object ref|
|Object header (compressed)|12|mark + klass|
|Object header (uncompressed)|16|mark + klass|
|Array header (compressed)|16|header + length|

### Optimization Techniques

**Best Practices:**

1. âœ… Use primitive arrays over object arrays (75% savings)
2. âœ… Pack booleans into bytes/ints (87% savings)
3. âœ… Pool immutable objects (99% savings)
4. âœ… Intern duplicate strings (99% savings)
5. âœ… Use primitive collections (63% savings)
6. âœ… Avoid boxing in hot paths (75% savings)
7. âœ… Consider struct-of-arrays layout (27% savings + performance)
8. âœ… Store timestamps as long (87% savings)
9. âœ… Use enums over strings (93% savings)
10. âœ… Keep heap < 32GB for compressed oops

**JOL Commands:**

```java
// Single object
ClassLayout.parseInstance(obj).toPrintable()

// Object graph
GraphLayout.parseInstance(obj).toPrintable()
GraphLayout.parseInstance(obj).totalSize()
GraphLayout.parseInstance(obj).toFootprint()

// VM info
VM.current().details()
```

**JVM Flags:**

```bash
# Compressed oops
-XX:+UseCompressedOops          # Enable (default if heap < 32GB)
-XX:-UseCompressedOops          # Disable
-XX:+PrintCompressedOopsMode    # Print compression mode

# Compressed class pointers
-XX:+UseCompressedClassPointers # Enable (default)
-XX:CompressedClassSpaceSize=1g # Set class space size

# Object alignment
-XX:ObjectAlignmentInBytes=8    # Set alignment (default 8)

# Debugging
-XX:+PrintFlagsFinal            # Print all flags
java -XX:+PrintFlagsFinal -version | grep Compressed
```

### Common Pitfalls

**âŒ Using Object arrays for primitives:**

```java
Integer[] arr = new Integer[1000];  // 16KB
int[] arr = new int[1000];          // 4KB (75% savings!)
```

**âŒ Many boolean fields:**

```java
class Flags {
    boolean f1, f2, f3, f4, f5, f6, f7, f8;  // 8 bytes + overhead
}
// Better: byte flags = 0; // 1 byte, use bitwise operations
```

**âŒ Heap > 32GB without consideration:**

```java
// -Xmx40g â†’ Compressed oops OFF â†’ 50% more memory for references!
// Better: Use multiple JVMs or accept the cost
```

**âŒ Ignoring alignment:**

```java
class Bad {
    byte b1; long l1; byte b2; long l2;  // 40 bytes (padding)
}
class Good {
    long l1, l2; byte b1, b2;            // 40 bytes (but JVM reorders anyway)
}
```

---

