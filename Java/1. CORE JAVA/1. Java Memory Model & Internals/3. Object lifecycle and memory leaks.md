# Java Object Lifecycle and Memory Leaks

## Overview

Understanding object lifecycle is crucial for preventing memory leaks and building robust Java applications. This guide covers object creation, initialization, reachability, reference types, and memory leak detection.


---

## 1. Object Creation Mechanisms

### Creation via new Keyword

```java
/**
 * OBJECT CREATION WITH 'new':
 * 
 * Process:
 * 1. Check if class is loaded
 * 2. Allocate memory in heap (TLAB)
 * 3. Initialize fields to default values
 * 4. Call constructor
 * 5. Return reference
 * 
 * Memory Layout:
 * 
 * HEAP:
 * ┌────────────────────────────┐
 * │ Object Header (12-16 bytes)│
 * │  - Mark word (8 bytes)     │ ← GC info, hash code, lock
 * │  - Class pointer (4-8 bytes)│ ← Points to class metadata
 * ├────────────────────────────┤
 * │ Instance Fields            │
 * │  - int field (4 bytes)     │
 * │  - String ref (4-8 bytes)  │
 * │  - ...                     │
 * ├────────────────────────────┤
 * │ Padding (align to 8 bytes) │
 * └────────────────────────────┘
 */

public class ObjectCreationDemo {
    
    private int id;
    private String name;
    private double salary;
    
    public ObjectCreationDemo(int id, String name, double salary) {
        this.id = id;
        this.name = name;
        this.salary = salary;
    }
    
    public static void main(String[] args) {
        // Standard object creation
        ObjectCreationDemo obj = new ObjectCreationDemo(1, "Alice", 50000.0);
        
        /**
         * BYTECODE:
         * 
         * 0: new #2           // Allocate memory for ObjectCreationDemo
         * 3: dup              // Duplicate reference (for constructor)
         * 4: iconst_1         // Load constant 1
         * 5: ldc #3           // Load constant "Alice"
         * 7: ldc2_w #4        // Load constant 50000.0
         * 10: invokespecial #6 // Call constructor
         * 13: astore_1        // Store reference in local variable
         * 
         * Memory operations:
         * - Allocate 32 bytes in TLAB (header + fields + padding)
         * - Initialize: id=0, name=null, salary=0.0
         * - Call constructor
         * - Set: id=1, name="Alice", salary=50000.0
         */
        
        // Object size calculation
        // 12 bytes (header) + 4 (int) + 8 (String ref) + 8 (double) = 32 bytes
        // Already aligned to 8 bytes
    }
    
    /**
     * OBJECT SIZE ESTIMATION:
     * 
     * Formula:
     * Size = Header + Fields + Padding
     * 
     * Header:
     * - 32-bit JVM: 8 bytes
     * - 64-bit JVM (compressed oops): 12 bytes
     * - 64-bit JVM (no compression): 16 bytes
     * 
     * Fields:
     * - boolean/byte: 1 byte
     * - char/short: 2 bytes
     * - int/float: 4 bytes
     * - long/double: 8 bytes
     * - reference: 4 bytes (compressed) or 8 bytes
     * 
     * Padding:
     * - Round up to nearest 8-byte boundary
     * 
     * Examples:
     * 
     * class Empty {}
     * Size: 12 (header) + 0 (fields) + 4 (padding) = 16 bytes
     * 
     * class OneInt { int x; }
     * Size: 12 (header) + 4 (int) + 0 (padding) = 16 bytes
     * 
     * class TwoInts { int x, y; }
     * Size: 12 (header) + 8 (2 ints) + 4 (padding) = 24 bytes
     */
}
```

### Creation via Reflection

```java
import java.lang.reflect.Constructor;

/**
 * REFLECTION-BASED OBJECT CREATION:
 * 
 * Methods:
 * 1. Class.newInstance() - deprecated, uses no-arg constructor
 * 2. Constructor.newInstance() - preferred, can use any constructor
 * 3. Field.set() - set fields after creation
 * 
 * Performance:
 * - ~10-100x slower than 'new'
 * - Modern JVMs optimize repeated reflection calls
 * - Use MethodHandle for better performance
 */

public class ReflectionCreationDemo {
    
    public static void main(String[] args) throws Exception {
        
        // Method 1: Class.newInstance() - deprecated in Java 9
        // Requires public no-arg constructor
        // Can only throw checked exceptions declared by constructor
        Person p1 = Person.class.newInstance(); // DON'T USE
        
        // Method 2: Constructor.newInstance() - RECOMMENDED
        Constructor<Person> constructor = Person.class.getConstructor(String.class, int.class);
        Person p2 = constructor.newInstance("Alice", 30);
        
        // Method 3: Get constructor with no parameters
        Constructor<Person> noArgConstructor = Person.class.getDeclaredConstructor();
        noArgConstructor.setAccessible(true); // Access private constructor
        Person p3 = noArgConstructor.newInstance();
        
        // Method 4: Using Field.set()
        Person p4 = Person.class.getDeclaredConstructor().newInstance();
        var nameField = Person.class.getDeclaredField("name");
        nameField.setAccessible(true);
        nameField.set(p4, "Bob");
        
        /**
         * PERFORMANCE COMPARISON:
         * 
         * Test: Create 1,000,000 objects
         * 
         * Method                    │ Time    │ vs 'new'
         * ──────────────────────────┼─────────┼─────────
         * new Person()              │  10ms   │  1x
         * Constructor.newInstance() │ 150ms   │ 15x slower
         * Class.newInstance()       │ 200ms   │ 20x slower
         * Field.set()               │ 300ms   │ 30x slower
         * 
         * Modern JVM optimizations reduce overhead over time
         */
        
        // Benchmark
        long start = System.nanoTime();
        for (int i = 0; i < 1_000_000; i++) {
            Person p = new Person("Test", i);
        }
        long newTime = System.nanoTime() - start;
        
        start = System.nanoTime();
        Constructor<Person> ctor = Person.class.getConstructor(String.class, int.class);
        for (int i = 0; i < 1_000_000; i++) {
            Person p = ctor.newInstance("Test", i);
        }
        long reflectionTime = System.nanoTime() - start;
        
        System.out.println("new time: " + newTime / 1_000_000 + "ms");
        System.out.println("reflection time: " + reflectionTime / 1_000_000 + "ms");
        System.out.println("Slowdown: " + (reflectionTime / newTime) + "x");
    }
    
    static class Person {
        private String name;
        private int age;
        
        private Person() {} // Private no-arg constructor
        
        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }
    }
}
```

### Creation via Cloning

```java
/**
 * CLONING OBJECTS:
 * 
 * Methods:
 * 1. Implement Cloneable interface
 * 2. Override clone() method
 * 3. Handle CloneNotSupportedException
 * 
 * Types:
 * - Shallow Clone: Copy references (default)
 * - Deep Clone: Copy referenced objects recursively
 * 
 * Performance:
 * - Faster than creating new object
 * - No constructor called
 * - No field initialization
 * - Direct memory copy
 */

public class CloningDemo implements Cloneable {
    
    private int id;
    private String name;
    private Address address; // Mutable object
    
    public CloningDemo(int id, String name, Address address) {
        this.id = id;
        this.name = name;
        this.address = address;
        System.out.println("Constructor called");
    }
    
    // Shallow clone (default)
    @Override
    protected Object clone() throws CloneNotSupportedException {
        System.out.println("clone() called - no constructor!");
        return super.clone(); // Shallow copy
    }
    
    // Deep clone
    protected CloningDemo deepClone() throws CloneNotSupportedException {
        CloningDemo cloned = (CloningDemo) super.clone();
        cloned.address = (Address) this.address.clone(); // Clone mutable field
        return cloned;
    }
    
    public static void main(String[] args) throws CloneNotSupportedException {
        
        Address addr = new Address("123 Main St");
        CloningDemo original = new CloningDemo(1, "Alice", addr);
        
        // Shallow clone
        CloningDemo shallowCopy = (CloningDemo) original.clone();
        
        /**
         * SHALLOW CLONE RESULT:
         * 
         * HEAP:
         * ┌────────────────────┐
         * │ original           │
         * │  id = 1            │
         * │  name = "Alice" ───┼──→ String@0x100
         * │  address ──────────┼──→ Address@0x200
         * └────────────────────┘
         * 
         * ┌────────────────────┐
         * │ shallowCopy        │
         * │  id = 1            │
         * │  name = "Alice" ───┼──→ String@0x100 (same!)
         * │  address ──────────┼──→ Address@0x200 (same!)
         * └────────────────────┘
         * 
         * Problem: Shared mutable state!
         */
        
        shallowCopy.address.setStreet("456 Oak Ave");
        System.out.println(original.address.getStreet()); // "456 Oak Ave" - MODIFIED!
        
        // Deep clone
        CloningDemo deepCopy = original.deepClone();
        
        /**
         * DEEP CLONE RESULT:
         * 
         * HEAP:
         * ┌────────────────────┐
         * │ original           │
         * │  id = 1            │
         * │  name = "Alice" ───┼──→ String@0x100
         * │  address ──────────┼──→ Address@0x200
         * └────────────────────┘
         * 
         * ┌────────────────────┐
         * │ deepCopy           │
         * │  id = 1            │
         * │  name = "Alice" ───┼──→ String@0x100 (strings are immutable, OK to share)
         * │  address ──────────┼──→ Address@0x300 (new copy!)
         * └────────────────────┘
         * 
         * Safe: Independent mutable state
         */
        
        deepCopy.address.setStreet("789 Pine St");
        System.out.println(original.address.getStreet()); // Still "456 Oak Ave"
        
        /**
         * PERFORMANCE:
         * 
         * Operation          │ Time (1M objects)
         * ───────────────────┼──────────────────
         * new Object()       │  50ms
         * clone()            │  30ms (faster!)
         * deepClone()        │  80ms (slower due to recursion)
         * 
         * Cloning is faster because:
         * - No constructor overhead
         * - Direct memory copy
         * - No field initialization
         * 
         * But has issues:
         * - Breaks encapsulation
         * - Requires Cloneable interface
         * - Tricky with inheritance
         * - Joshua Bloch recommends copy constructors instead
         */
    }
    
    static class Address implements Cloneable {
        private String street;
        
        public Address(String street) {
            this.street = street;
        }
        
        public String getStreet() { return street; }
        public void setStreet(String street) { this.street = street; }
        
        @Override
        protected Object clone() throws CloneNotSupportedException {
            return super.clone();
        }
    }
    
    /**
     * BETTER ALTERNATIVE: Copy Constructor
     */
    public CloningDemo(CloningDemo other) {
        this.id = other.id;
        this.name = other.name;
        this.address = new Address(other.address.getStreet()); // Deep copy
        
        // Clearer intent, more flexible, no Cloneable needed
    }
}
```

### Creation via Deserialization

```java
import java.io.*;

/**
 * DESERIALIZATION:
 * 
 * Process:
 * 1. Read class metadata
 * 2. Allocate memory (no constructor called!)
 * 3. Deserialize fields
 * 4. Call readObject() if defined
 * 5. Return object
 * 
 * Security Concerns:
 * - Arbitrary code execution
 * - Bypasses constructor validation
 * - Can create invalid objects
 * - Use carefully!
 */

public class DeserializationDemo implements Serializable {
    
    private static final long serialVersionUID = 1L;
    
    private int id;
    private transient String password; // Not serialized
    
    public DeserializationDemo(int id, String password) {
        System.out.println("Constructor called");
        this.id = id;
        this.password = password;
        validate();
    }
    
    private void validate() {
        if (id < 0) {
            throw new IllegalArgumentException("ID must be positive");
        }
    }
    
    public static void main(String[] args) throws Exception {
        
        // Serialize
        DeserializationDemo original = new DeserializationDemo(1, "secret");
        
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(original);
        oos.close();
        
        // Deserialize
        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bais);
        DeserializationDemo deserialized = (DeserializationDemo) ois.readObject();
        ois.close();
        
        /**
         * IMPORTANT: Constructor NOT called during deserialization!
         * 
         * Console output:
         * "Constructor called"  ← Only once, for original
         * 
         * This means:
         * - Validation in constructor bypassed
         * - Can create invalid objects
         * - transient fields are null
         */
        
        System.out.println("ID: " + deserialized.id); // 1
        System.out.println("Password: " + deserialized.password); // null (transient)
    }
    
    /**
     * CUSTOM DESERIALIZATION:
     * 
     * Define readObject() to control deserialization
     */
    private void readObject(ObjectInputStream ois) 
            throws IOException, ClassNotFoundException {
        
        // Read default fields
        ois.defaultReadObject();
        
        // Custom initialization
        System.out.println("readObject() called");
        validate(); // Re-validate after deserialization
        
        // Initialize transient fields
        this.password = "default";
    }
    
    /**
     * SERIALIZATION PROXY PATTERN:
     * 
     * Safest way to implement serialization
     */
    private Object writeReplace() {
        return new SerializationProxy(this);
    }
    
    private static class SerializationProxy implements Serializable {
        private static final long serialVersionUID = 1L;
        private final int id;
        
        SerializationProxy(DeserializationDemo obj) {
            this.id = obj.id;
        }
        
        private Object readResolve() {
            // Goes through constructor!
            return new DeserializationDemo(id, "default");
        }
    }
    
    /**
     * DESERIALIZATION VULNERABILITIES:
     * 
     * 1. Gadget Chains:
     *    - Chain of objects that execute code
     *    - Can lead to RCE (Remote Code Execution)
     *    - Example: Apache Commons Collections exploit
     * 
     * 2. Denial of Service:
     *    - HashSet with hash collision
     *    - Large objects consuming memory
     * 
     * 3. Object Injection:
     *    - Create objects bypassing constructors
     *    - Violate invariants
     * 
     * MITIGATION:
     * - Use serialization filters (Java 9+)
     * - Validate in readObject()
     * - Use serialization proxy pattern
     * - Consider alternatives (JSON, Protocol Buffers)
     */
}
```

---

## 2. Object Initialization Order

### Initialization Sequence

```java
/**
 * INITIALIZATION ORDER:
 * 
 * For class: Parent extends GrandParent
 * 
 * Phase 1: Class Loading (once per class)
 * 1. Load GrandParent class
 * 2. Execute GrandParent static initializers
 * 3. Load Parent class
 * 4. Execute Parent static initializers
 * 5. Load Child class
 * 6. Execute Child static initializers
 * 
 * Phase 2: Instance Creation (per object)
 * 1. Allocate memory
 * 2. Initialize fields to default values (0, null, false)
 * 3. Execute GrandParent instance initializers
 * 4. Execute GrandParent constructor
 * 5. Execute Parent instance initializers
 * 6. Execute Parent constructor
 * 7. Execute Child instance initializers
 * 8. Execute Child constructor
 */

public class InitializationOrderDemo {
    
    public static void main(String[] args) {
        System.out.println("=== Creating Child instance ===");
        Child child = new Child();
        
        System.out.println("\n=== Creating another Child instance ===");
        Child child2 = new Child(); // Static initializers not run again
    }
}

class GrandParent {
    // 1. Static initializer (runs once when class loaded)
    static {
        System.out.println("1. GrandParent static initializer");
    }
    
    // 3. Instance initializer (runs before constructor)
    {
        System.out.println("3. GrandParent instance initializer");
    }
    
    // 2. Static field initialization (part of static initialization)
    private static String staticField = initStatic();
    
    private static String initStatic() {
        System.out.println("2. GrandParent static field initialization");
        return "static";
    }
    
    // 4. Instance field initialization (before constructor)
    private String instanceField = initInstance();
    
    private String initInstance() {
        System.out.println("4. GrandParent instance field initialization");
        return "instance";
    }
    
    // 5. Constructor
    public GrandParent() {
        System.out.println("5. GrandParent constructor");
    }
}

class Parent extends GrandParent {
    static {
        System.out.println("6. Parent static initializer");
    }
    
    {
        System.out.println("8. Parent instance initializer");
    }
    
    private static String staticField = initStatic();
    
    private static String initStatic() {
        System.out.println("7. Parent static field initialization");
        return "static";
    }
    
    private String instanceField = initInstance();
    
    private String initInstance() {
        System.out.println("9. Parent instance field initialization");
        return "instance";
    }
    
    public Parent() {
        System.out.println("10. Parent constructor");
    }
}

class Child extends Parent {
    static {
        System.out.println("11. Child static initializer");
    }
    
    {
        System.out.println("13. Child instance initializer");
    }
    
    private static String staticField = initStatic();
    
    private static String initStatic() {
        System.out.println("12. Child static field initialization");
        return "static";
    }
    
    private String instanceField = initInstance();
    
    private String initInstance() {
        System.out.println("14. Child instance field initialization");
        return "instance";
    }
    
    public Child() {
        System.out.println("15. Child constructor");
    }
}

/**
 * OUTPUT:
 * 
 * === Creating Child instance ===
 * 1. GrandParent static initializer
 * 2. GrandParent static field initialization
 * 6. Parent static initializer
 * 7. Parent static field initialization
 * 11. Child static initializer
 * 12. Child static field initialization
 * 3. GrandParent instance initializer
 * 4. GrandParent instance field initialization
 * 5. GrandParent constructor
 * 8. Parent instance initializer
 * 9. Parent instance field initialization
 * 10. Parent constructor
 * 13. Child instance initializer
 * 14. Child instance field initialization
 * 15. Child constructor
 * 
 * === Creating another Child instance ===
 * 3. GrandParent instance initializer
 * 4. GrandParent instance field initialization
 * 5. GrandParent constructor
 * 8. Parent instance initializer
 * 9. Parent instance field initialization
 * 10. Parent constructor
 * 13. Child instance initializer
 * 14. Child instance field initialization
 * 15. Child constructor
 * 
 * Notice: Static initializers only run once!
 */
```

### Common Initialization Pitfalls

```java
/**
 * INITIALIZATION PITFALLS:
 * 
 * 1. Using 'this' before object fully constructed
 * 2. Overriding methods called in superclass constructor
 * 3. Static initialization order dependencies
 * 4. Forward references in initialization
 */

public class InitializationPitfalls {
    
    // PITFALL 1: Forward reference
    private static int a = b + 1; // COMPILE ERROR: illegal forward reference
    private static int b = 10;
    
    // FIX: Reorder
    private static int c = 10;
    private static int d = c + 1; // OK
    
    // PITFALL 2: Complex initialization
    private static int x = compute(); // Depends on y
    private static int y = 20;
    
    private static int compute() {
        return y + 10; // y is 0 here! (default value)
    }
    
    // Result: x = 10 (not 30 as expected!)
    
    public static void main(String[] args) {
        System.out.println("x = " + x); // 10
        System.out.println("y = " + y); // 20
        
        // PITFALL 3: Calling overridden method in constructor
        new Parent();
    }
}

class Parent {
    private String value;
    
    public Parent() {
        // DANGER: Calls overridden method before Child is initialized!
        initialize();
        System.out.println("Parent constructor done");
    }
    
    protected void initialize() {
        this.value = "parent";
        System.out.println("Parent.initialize(): " + value);
    }
}

class Child extends Parent {
    private String childValue = "child"; // Not yet initialized when Parent constructor runs!
    
    @Override
    protected void initialize() {
        // Called from Parent constructor BEFORE Child constructor!
        // childValue is still null here!
        System.out.println("Child.initialize(): childValue = " + childValue); // null!
        this.childValue = "initialized";
    }
}

/**
 * OUTPUT:
 * Child.initialize(): childValue = null
 * Parent constructor done
 * 
 * EXPLANATION:
 * 1. new Child() starts
 * 2. Parent constructor runs
 * 3. Parent constructor calls initialize()
 * 4. Child.initialize() runs (overridden version)
 * 5. childValue is still null (not initialized yet!)
 * 6. Parent constructor completes
 * 7. Child instance initializer runs (childValue = "child")
 * 8. Child constructor runs
 * 
 * LESSON: Never call overridable methods from constructors!
 */

/**
 * SAFE PATTERNS:
 */
class SafeParent {
    private String value;
    
    public SafeParent() {
        // OK: Call private or final method
        initializeInternal();
    }
    
    // SAFE: private method can't be overridden
    private void initializeInternal() {
        this.value = "parent";
    }
    
    // SAFE: final method can't be overridden
    protected final void safeInitialize() {
        this.value = "parent";
    }
}
```

---

## 3. Reachability and Finalization

### Object Reachability States

```java
/**
 * OBJECT REACHABILITY STATES:
 * 
 * 1. Strongly Reachable:
 *    - Accessible via strong reference
 *    - Normal object references
 *    - Cannot be GC'd
 * 
 * 2. Softly Reachable:
 *    - Only via SoftReference
 *    - GC'd when memory pressure
 *    - Good for caches
 * 
 * 3. Weakly Reachable:
 *    - Only via WeakReference
 *    - GC'd at next GC cycle
 *    - Good for canonical mappings
 * 
 * 4. Phantom Reachable:
 *    - Only via PhantomReference
 *    - After finalization
 *    - Good for cleanup actions
 * 
 * 5. Unreachable:
 *    - No references
 *    - Eligible for GC
 */

public class ReachabilityDemo {
    
    public static void main(String[] args) {
        
        // 1. Strongly reachable
        Object strongRef = new Object();
        // Object cannot be GC'd while strongRef exists
        
        // 2. Softly reachable
        SoftReference<Object> softRef = new SoftReference<>(new Object());
        // Object GC'd only when memory is low
        
        // 3. Weakly reachable
        WeakReference<Object> weakRef = new WeakReference<>(new Object());
        // Object GC'd at next GC, regardless of memory
        
        // 4. Phantom reachable
        ReferenceQueue<Object> queue = new ReferenceQueue<>();
        PhantomReference<Object> phantomRef = 
            new PhantomReference<>(new Object(), queue);
        // Object already GC'd, phantomRef queued for cleanup
        
        /**
         * REACHABILITY HIERARCHY:
         * 
         * Strong Reference
         *     ↓
         * Soft Reference (GC'd when low memory)
         *     ↓
         * Weak Reference (GC'd at next GC)
         *     ↓
         * Phantom Reference (after finalization)
         *     ↓
         * Unreachable (GC'd)
         * 
         * Downgrade path during GC:
         * Strong → Soft → Weak → Phantom → Unreachable
         */
        
        // Make object unreachable
        strongRef = null;
        softRef.clear();
        weakRef.clear();
        phantomRef.clear();
        
        // Suggest GC (doesn't guarantee)
        System.gc();
    }
    
    /**
     * REACHABILITY EXAMPLE:
     */
    public void demonstrateReachability() {
        
        // Create object
        LargeObject obj = new LargeObject();
        
        // State 1: Strongly reachable
        // obj → LargeObject@0x1000
        // Cannot be GC'd
        
        WeakReference<LargeObject> weakRef = new WeakReference<>(obj);
        // Still strongly reachable (obj reference exists)
        
        obj = null;
        // Now only weakly reachable (only via weakRef)
        
        System.gc();
        // Object GC'd!
        
        LargeObject retrieved = weakRef.get();
        // retrieved = null (object was collected)
    }
    
    static class LargeObject {
        private byte[] data = new byte[1024 * 1024]; // 1MB
    }
}
```

### Finalization (Deprecated)

```java
/**
 * FINALIZATION:
 * 
 * Object.finalize() is called before GC (deprecated in Java 9)
 * 
 * Problems:
 * 1. Unpredictable timing
 * 2. Performance penalty
 * 3. Can resurrect objects
 * 4. Not guaranteed to run
 * 5. Blocks GC
 * 
 * Alternative: Cleaners (Java 9+)
 */

public class FinalizationDemo {
    
    private static int objectCount = 0;
    private int id;
    
    public FinalizationDemo() {
        this.id = ++objectCount;
        System.out.println("Created object " + id);
    }
    
    @Override
    @Deprecated
    protected void finalize() throws Throwable {
        try {
            System.out.println("Finalizing object " + id);
            
            // DANGER: Object resurrection!
            // resurrect(this);
            
        } finally {
            super.finalize();
        }
    }
    
    // Object resurrection
    private static FinalizationDemo resurrected;
    
    private static void resurrect(FinalizationDemo obj) {
        resurrected = obj; // Object becomes strongly reachable again!
        System.out.println("Object " + obj.id + " resurrected!");
    }
    
    public static void main(String[] args) throws InterruptedException {
        
        // Create and make eligible for GC
        new FinalizationDemo();
        new FinalizationDemo();
        new FinalizationDemo();
        
        // Request GC
        System.gc();
        
        // Wait for finalization
        Thread.sleep(1000);
        
        /**
         * PROBLEMS WITH FINALIZATION:
         * 
         * 1. Unpredictable timing:
         *    - finalize() may run seconds/minutes later
         *    - May never run if JVM exits
         *    - Cannot rely on for resource cleanup
         * 
         * 2. Performance:
         *    - Objects with finalize() are slower to GC
         *    - Requires two GC cycles:
         *      Cycle 1: Mark as finalizable
         *      Cycle 2: Actually collect
         * 
         * 3. Security:
         *    - Finalizer attack: access partially constructed object
         *    - Can bypass security checks
         * 
         * 4. Resurrection:
         *    - Object can make itself reachable again
         *    - finalize() only called once per object
         *    - Confusing and error-prone
         */
        
        if (resurrected != null) {
            System.out.println("Resurrected object is still alive: " + resurrected.id);
        }
    }
}
```

### Cleaners (Java 9+)

```java
import java.lang.ref.Cleaner;

/**
 * CLEANERS (RECOMMENDED):
 * 
 * Replacement for finalize()
 * - More predictable
 * - Better performance
 * - No object resurrection
 * - Can run cleanup in separate thread
 * 
 * Use for:
 * - Native resources (file handles, sockets)
 * - Off-heap memory
 * - Safety net for try-with-resources
 */

public class CleanerDemo implements AutoCloseable {
    
    private static final Cleaner cleaner = Cleaner.create();
    
    // Inner class holds state for cleanup
    private static class State implements Runnable {
        private final int id;
        private byte[] nativeResource; // Simulated native resource
        
        State(int id) {
            this.id = id;
            this.nativeResource = new byte[1024 * 1024]; // 1MB
            System.out.println("Allocated native resource for object " + id);
        }
        
        @Override
        public void run() {
            // Cleanup action (runs when object is GC'd)
            System.out.println("Cleaning up native resource for object " + id);
            nativeResource = null; // Release resource
        }
    }
    
    private final State state;
    private final Cleaner.Cleanable cleanable;
    
    public CleanerDemo(int id) {
        this.state = new State(id);
        this.cleanable = cleaner.register(this, state);
    }
    
    @Override
    public void close() {
        // Explicit cleanup
        cleanable.clean();
    }
    
    public static void main(String[] args) throws InterruptedException {
        
        // Method 1: Explicit cleanup (preferred)
        try (CleanerDemo demo = new CleanerDemo(1)) {
            // Use resource
        } // Cleanup happens here
        
        // Method 2: Rely on GC (safety net)
        CleanerDemo demo2 = new CleanerDemo(2);
        demo2 = null;
        System.gc();
        Thread.sleep(1000); // Give cleaner time to run
        
        /**
         * BEST PRACTICE:
         * 
         * 1. Implement AutoCloseable
         * 2. Use try-with-resources for explicit cleanup
         * 3. Use Cleaner as safety net
         * 4. Cleaner runs if close() not called
         * 
         * Pattern:
         * 
         * class Resource implements AutoCloseable {
         *     private static final Cleaner cleaner = Cleaner.create();
         *     private final Cleaner.Cleanable cleanable;
         *     
         *     public Resource() {
         *         cleanable = cleaner.register(this, new CleanupAction());
         *     }
         *     
         *     @Override
         *     public void close() {
         *         cleanable.clean(); // Explicit cleanup
         *     }
         * }
         * 
         * // Usage
         * try (Resource r = new Resource()) {
         *     // Use resource
         * } // Guaranteed cleanup
         */
    }
}
```

---

## 4. Reference Types

### Weak References

```java
import java.lang.ref.*;
import java.util.*;

/**
 * WEAK REFERENCES:
 * 
 * Characteristics:
 * - Doesn't prevent GC
 * - Cleared at next GC cycle
 * - get() returns null after GC
 * 
 * Use Cases:
 * - Canonical mappings (WeakHashMap)
 * - Cache entries
 * - Listeners without preventing GC
 */

public class WeakReferenceDemo {
    
    public static void main(String[] args) {
        
        // Create object
        LargeObject obj = new LargeObject("data");
        
        // Create weak reference
        WeakReference<LargeObject> weakRef = new WeakReference<>(obj);
        
        System.out.println("Before GC: " + weakRef.get()); // LargeObject@...
        
        // Remove strong reference
        obj = null;
        
        // Force GC
        System.gc();
        
        System.out.println("After GC: " + weakRef.get()); // null
        
        /**
         * WEAK REFERENCE LIFECYCLE:
         * 
         * Time 0: obj → LargeObject@0x1000
         *         weakRef → LargeObject@0x1000
         *         State: Strongly reachable
         * 
         * Time 1: obj = null
         *         weakRef → LargeObject@0x1000
         *         State: Weakly reachable
         * 
         * Time 2: System.gc()
         *         weakRef → null
         *         State: Unreachable, object GC'd
         */
    }
    
    /**
     * WEAKHASHMAP EXAMPLE:
     * 
     * Keys are weakly referenced
     * Entries removed when key is GC'd
     */
    public static void weakHashMapExample() {
        
        WeakHashMap<LargeObject, String> cache = new WeakHashMap<>();
        
        LargeObject key1 = new LargeObject("key1");
        LargeObject key2 = new LargeObject("key2");
        
        cache.put(key1, "value1");
        cache.put(key2, "value2");
        
        System.out.println("Size before GC: " + cache.size()); // 2
        
        // Remove strong reference to key1
        key1 = null;
        
        // Force GC
        System.gc();
        
        // Give time for cleanup
        try { Thread.sleep(100); } catch (InterruptedException e) {}
        
        System.out.println("Size after GC: " + cache.size()); // 1
        // key1's entry automatically removed!
        
        /**
         * CANONICAL MAPPING USE CASE:
         * 
         * Problem: Want to cache objects but not prevent GC
         * Solution: WeakHashMap
         * 
         * Example: String interning, object pooling
         */
    }
    
    /**
     * LISTENER MEMORY LEAK PREVENTION:
     */
    static class EventSource {
        private List<WeakReference<EventListener>> listeners = new ArrayList<>();
        
        public void addListener(EventListener listener) {
            listeners.add(new WeakReference<>(listener));
        }
        
        public void fireEvent(String event) {
            // Clean up null references
            listeners.removeIf(ref -> ref.get() == null);
            
            // Notify alive listeners
            for (WeakReference<EventListener> ref : listeners) {
                EventListener listener = ref.get();
                if (listener != null) {
                    listener.onEvent(event);
                }
            }
        }
    }
    
    interface EventListener {
        void onEvent(String event);
    }
    
    static class LargeObject {
        private String data;
        
        public LargeObject(String data) {
            this.data = data;
        }
    }
}
```

### Soft References

```java
/**
 * SOFT REFERENCES:
 * 
 * Characteristics:
 * - GC'd only when memory is low
 * - More aggressive than weak references
 * - Guaranteed cleared before OutOfMemoryError
 * 
 * Use Cases:
 * - Memory-sensitive caches
 * - Image caches
 * - Computed values that can be regenerated
 */

public class SoftReferenceDemo {
    
    /**
     * SOFT REFERENCE CACHE:
     */
    static class ImageCache {
        private Map<String, SoftReference<byte[]>> cache = new HashMap<>();
        
        public byte[] getImage(String filename) {
            SoftReference<byte[]> ref = cache.get(filename);
            
            if (ref != null) {
                byte[] image = ref.get();
                if (image != null) {
                    System.out.println("Cache hit: " + filename);
                    return image;
                }
            }
            
            // Cache miss or GC'd - load from disk
            System.out.println("Cache miss: " + filename);
            byte[] image = loadImageFromDisk(filename);
            cache.put(filename, new SoftReference<>(image));
            return image;
        }
        
        private byte[] loadImageFromDisk(String filename) {
            // Simulate loading 1MB image
            return new byte[1024 * 1024];
        }
    }
    
    public static void main(String[] args) {
        
        ImageCache cache = new ImageCache();
        
        // Load images (cached)
        cache.getImage("image1.jpg"); // Cache miss
        cache.getImage("image2.jpg"); // Cache miss
        cache.getImage("image3.jpg"); // Cache miss
        
        // Access again (cache hit)
        cache.getImage("image1.jpg"); // Cache hit
        cache.getImage("image2.jpg"); // Cache hit
        
        // Allocate lots of memory to trigger GC
        List<byte[]> memoryHog = new ArrayList<>();
        try {
            while (true) {
                memoryHog.add(new byte[10 * 1024 * 1024]); // 10MB
            }
        } catch (OutOfMemoryError e) {
            // Soft references were cleared to free memory
            System.out.println("OutOfMemoryError - soft refs cleared");
        }
        
        // After GC, cache entries are gone
        cache.getImage("image1.jpg"); // Cache miss (GC'd)
        
        /**
         * SOFT REFERENCE BEHAVIOR:
         * 
         * JVM guarantees:
         * - All soft references cleared before OutOfMemoryError
         * - Recently used soft references kept longer
         * - Older soft references cleared first
         * 
         * Tuning:
         * -XX:SoftRefLRUPolicyMSPerMB=1000
         * Default: 1 second per free MB
         * 
         * If 100MB free: soft refs kept for 100 seconds since last access
         * If 10MB free: soft refs kept for 10 seconds since last access
         * 
         * Calculate lifetime:
         * lifetime = (timestamp - last_access) / free_heap_mb
         * If lifetime > SoftRefLRUPolicyMSPerMB: clear reference
         */
    }
    
    /**
     * COMPARISON: Soft vs Weak vs Strong
     */
    public static void compareReferences() {
        
        // Strong reference - never GC'd (while reachable)
        byte[] strong = new byte[1024 * 1024];
        
        // Weak reference - GC'd at next GC
        WeakReference<byte[]> weak = new WeakReference<>(new byte[1024 * 1024]);
        
        // Soft reference - GC'd when memory low
        SoftReference<byte[]> soft = new SoftReference<>(new byte[1024 * 1024]);
        
        System.gc();
        
        System.out.println("After GC:");
        System.out.println("Strong: " + (strong != null)); // true
        System.out.println("Weak: " + (weak.get() != null)); // false (GC'd)
        System.out.println("Soft: " + (soft.get() != null)); // true (memory not low)
        
        /**
         * WHEN TO USE:
         * 
         * Strong Reference:
         * - Normal object references
         * - Object needed for lifetime of owner
         * 
         * Weak Reference:
         * - Canonical mappings
         * - Observers/listeners
         * - Avoid memory leaks
         * 
         * Soft Reference:
         * - Caches
         * - Expensive computed values
         * - Memory-sensitive data
         * 
         * Phantom Reference:
         * - Pre-mortem cleanup
         * - Resource finalization
         * - Rarely used
         */
    }
}
```

### Phantom References

```java
/**
 * PHANTOM REFERENCES:
 * 
 * Characteristics:
 * - get() always returns null
 * - Enqueued after finalization
 * - Used for post-mortem cleanup
 * 
 * Use Cases:
 * - Track when objects are GC'd
 * - Cleanup actions after object death
 * - Direct buffer cleanup
 */

public class PhantomReferenceDemo {
    
    public static void main(String[] args) throws InterruptedException {
        
        // Create reference queue
        ReferenceQueue<LargeObject> queue = new ReferenceQueue<>();
        
        // Create object and phantom reference
        LargeObject obj = new LargeObject(1);
        PhantomReference<LargeObject> phantomRef = 
            new PhantomReference<>(obj, queue);
        
        System.out.println("get() returns: " + phantomRef.get()); // Always null!
        
        // Make object unreachable
        obj = null;
        
        // Force GC
        System.gc();
        
        // Wait for reference to be enqueued
        Reference<?> ref = queue.remove(1000);
        
        if (ref != null) {
            System.out.println("Object was GC'd - phantom ref enqueued");
            
            // Perform cleanup
            cleanup();
            
            // Clear reference
            ref.clear();
        }
        
        /**
         * PHANTOM REFERENCE LIFECYCLE:
         * 
         * Time 0: obj → LargeObject@0x1000
         *         phantomRef → LargeObject@0x1000
         *         State: Strongly reachable
         * 
         * Time 1: obj = null
         *         phantomRef → LargeObject@0x1000
         *         State: Phantom reachable
         * 
         * Time 2: System.gc()
         *         Object finalized (if has finalize())
         *         phantomRef enqueued in queue
         *         State: Phantom reachable
         * 
         * Time 3: ref.clear()
         *         Object fully GC'd
         *         State: Unreachable
         */
    }
    
    private static void cleanup() {
        System.out.println("Performing cleanup actions");
        // Release native resources, close files, etc.
    }
    
    /**
     * PRACTICAL USE: DirectByteBuffer Cleanup
     * 
     * Java uses Phantom References internally for DirectByteBuffer cleanup
     */
    static class DirectBufferCleaner {
        private static final ReferenceQueue<byte[]> queue = new ReferenceQueue<>();
        private static final Map<PhantomReference<byte[]>, Runnable> cleaners = 
            new HashMap<>();
        
        static {
            // Background thread to process cleanup
            Thread cleanerThread = new Thread(() -> {
                while (true) {
                    try {
                        Reference<?> ref = queue.remove();
                        Runnable cleaner = cleaners.remove(ref);
                        if (cleaner != null) {
                            cleaner.run();
                        }
                    } catch (InterruptedException e) {
                        break;
                    }
                }
            });
            cleanerThread.setDaemon(true);
            cleanerThread.start();
        }
        
        public static void register(byte[] buffer, Runnable cleanup) {
            PhantomReference<byte[]> ref = new PhantomReference<>(buffer, queue);
            cleaners.put(ref, cleanup);
        }
    }
    
    /**
     * REFERENCE COMPARISON TABLE:
     * 
     * ┌──────────┬────────────────┬──────────────┬─────────────┬──────────────┐
     * │ Type     │ get() returns  │ GC'd when    │ Use Case    │ Example      │
     * ├──────────┼────────────────┼──────────────┼─────────────┼──────────────┤
     * │ Strong   │ Object         │ Never        │ Normal refs │ Object obj   │
     * │ Soft     │ Object or null │ Memory low   │ Caches      │ Image cache  │
     * │ Weak     │ Object or null │ Next GC      │ Mappings    │ WeakHashMap  │
     * │ Phantom  │ Always null    │ After final. │ Cleanup     │ DirectBuffer │
     * └──────────┴────────────────┴──────────────┴─────────────┴──────────────┘
     */
    
    static class LargeObject {
        private int id;
        private byte[] data = new byte[1024 * 1024]; // 1MB
        
        public LargeObject(int id) {
            this.id = id;
            System.out.println("Created LargeObject " + id);
        }
        
        @Override
        protected void finalize() throws Throwable {
            System.out.println("Finalizing LargeObject " + id);
        }
    }
}
```

---

## 5. Memory Leak Patterns

### Listener Leaks

```java
import java.util.*;

/**
 * MEMORY LEAK #1: LISTENERS
 * 
 * Problem:
 * - Register listener but never unregister
 * - Event source holds reference to listener
 * - Listener can't be GC'd
 * 
 * Impact:
 * - Accumulates listeners over time
 * - High memory usage
 * - Slower event dispatch
 */

public class ListenerLeakDemo {
    
    // BAD: Memory leak
    static class LeakyEventSource {
        private List<EventListener> listeners = new ArrayList<>();
        
        public void addListener(EventListener listener) {
            listeners.add(listener);
            // Problem: Never removed!
        }
        
        // Missing: removeListener() method
        
        public void fireEvent(String event) {
            for (EventListener listener : listeners) {
                listener.onEvent(event);
            }
        }
    }
    
    // GOOD: Prevent leak
    static class SafeEventSource {
        private List<EventListener> listeners = new ArrayList<>();
        
        public void addListener(EventListener listener) {
            listeners.add(listener);
        }
        
        public void removeListener(EventListener listener) {
            listeners.remove(listener);
        }
        
        public void fireEvent(String event) {
            for (EventListener listener : listeners) {
                listener.onEvent(event);
            }
        }
    }
    
    // BETTER: Use weak references
    static class WeakEventSource {
        private List<WeakReference<EventListener>> listeners = new ArrayList<>();
        
        public void addListener(EventListener listener) {
            listeners.add(new WeakReference<>(listener));
        }
        
        public void fireEvent(String event) {
            // Clean up dead references
            listeners.removeIf(ref -> ref.get() == null);
            
            // Notify alive listeners
            for (WeakReference<EventListener> ref : listeners) {
                EventListener listener = ref.get();
                if (listener != null) {
                    listener.onEvent(event);
                }
            }
        }
    }
    
    interface EventListener {
        void onEvent(String event);
    }
    
    public static void main(String[] args) {
        
        LeakyEventSource source = new LeakyEventSource();
        
        // Simulate application lifecycle
        for (int i = 0; i < 10000; i++) {
            // Create short-lived listener
            EventListener listener = event -> {
                // Process event
            };
            
            source.addListener(listener);
            
            // Listener goes out of scope but is still referenced!
            // MEMORY LEAK: listener can't be GC'd
        }
        
        // source now holds 10,000 dead listeners!
        System.out.println("Leaked listeners: " + source.listeners.size());
        
        /**
         * HEAP DUMP ANALYSIS:
         * 
         * Leaky path:
         * LeakyEventSource
         *   └─ ArrayList listeners
         *        └─ EventListener[10000]
         *             └─ Lambda instances (all leaked!)
         * 
         * Memory: ~10,000 * (object overhead + lambda) = ~500KB wasted
         * 
         * Symptom: Memory grows over time
         * Fix: Call removeListener() or use WeakReference
         */
    }
    
    /**
     * REAL-WORLD EXAMPLE: GUI Event Listeners
     */
    static class ButtonLeakExample {
        // BAD
        public void registerCallbackLeaky() {
            Button button = new Button();
            
            button.onClick(new ClickListener() {
                @Override
                public void onClick() {
                    // This anonymous class holds implicit reference
                    // to outer class!
                    processClick();
                }
            });
            
            // When ButtonLeakExample instance goes out of scope,
            // it can't be GC'd because button holds reference via listener!
        }
        
        // GOOD
        public void registerCallbackSafe() {
            Button button = new Button();
            ClickListener listener = new ClickListener() {
                @Override
                public void onClick() {
                    processClick();
                }
            };
            
            button.onClick(listener);
            
            // Later: cleanup
            button.removeListener(listener);
        }
        
        private void processClick() {
            // Process click
        }
    }
    
    static class Button {
        private List<ClickListener> listeners = new ArrayList<>();
        
        public void onClick(ClickListener listener) {
            listeners.add(listener);
        }
        
        public void removeListener(ClickListener listener) {
            listeners.remove(listener);
        }
    }
    
    interface ClickListener {
        void onClick();
    }
}
```

### Cache Leaks

```java
/**
 * MEMORY LEAK #2: CACHES
 * 
 * Problem:
 * - Cache grows unbounded
 * - Entries never evicted
 * - Eventually OutOfMemoryError
 * 
 * Solutions:
 * - Size limit
 * - TTL (Time To Live)
 * - WeakHashMap
 * - SoftReference values
 */

public class CacheLeakDemo {
    
    // BAD: Unbounded cache
    static class LeakyCache<K, V> {
        private Map<K, V> cache = new HashMap<>();
        
        public V get(K key) {
            return cache.computeIfAbsent(key, k -> loadValue(k));
        }
        
        private V loadValue(K key) {
            // Expensive operation
            return (V) ("value-" + key);
        }
        
        // Problem: cache never cleared!
        // Memory grows indefinitely
    }
    
    // GOOD: Bounded cache with LRU eviction
    static class BoundedCache<K, V> {
        private static final int MAX_SIZE = 1000;
        private Map<K, V> cache = new LinkedHashMap<K, V>(16, 0.75f, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
                return size() > MAX_SIZE;
            }
        };
        
        public synchronized V get(K key) {
            return cache.computeIfAbsent(key, k -> loadValue(k));
        }
        
        private V loadValue(K key) {
            return (V) ("value-" + key);
        }
    }
    
    // BETTER: Cache with TTL
    static class TTLCache<K, V> {
        private static class CacheEntry<V> {
            V value;
            long expiryTime;
            
            CacheEntry(V value, long ttlMillis) {
                this.value = value;
                this.expiryTime = System.currentTimeMillis() + ttlMillis;
            }
            
            boolean isExpired() {
                return System.currentTimeMillis() > expiryTime;
            }
        }
        
        private Map<K, CacheEntry<V>> cache = new HashMap<>();
        private long ttlMillis;
        
        public TTLCache(long ttlMillis) {
            this.ttlMillis = ttlMillis;
            
            // Background cleanup thread
            Thread cleanup = new Thread(() -> {
                while (true) {
                    try {
                        Thread.sleep(ttlMillis / 2);
                        cleanupExpiredEntries();
                    } catch (InterruptedException e) {
                        break;
                    }
                }
            });
            cleanup.setDaemon(true);
            cleanup.start();
        }
        
        public synchronized V get(K key) {
            CacheEntry<V> entry = cache.get(key);
            
            if (entry != null && !entry.isExpired()) {
                return entry.value;
            }
            
            // Load and cache
            V value = loadValue(key);
            cache.put(key, new CacheEntry<>(value, ttlMillis));
            return value;
        }
        
        private synchronized void cleanupExpiredEntries() {
            cache.entrySet().removeIf(entry -> entry.getValue().isExpired());
        }
        
        private V loadValue(K key) {
            return (V) ("value-" + key);
        }
    }
    
    // BEST: Use existing solution
    public static void useGuavaCache() {
        /*
        // Guava Cache (production-ready)
        Cache<String, String> cache = CacheBuilder.newBuilder()
            .maximumSize(1000)
            .expireAfterWrite(10, TimeUnit.MINUTES)
            .removalListener(notification -> {
                System.out.println("Evicted: " + notification.getKey());
            })
            .build();
        
        String value = cache.get("key", () -> expensiveOperation());
        */
    }
    
    public static void main(String[] args) {
        
        LeakyCache<Integer, String> leakyCache = new LeakyCache<>();
        
        // Simulate endless requests with unique keys
        for (int i = 0; i < 1_000_000; i++) {
            leakyCache.get(i); // Each creates new cache entry
            
            if (i % 100_000 == 0) {
                System.out.println("Cache size: " + leakyCache.cache.size());
                System.out.println("Memory used: " + 
                    (Runtime.getRuntime().totalMemory() - 
                     Runtime.getRuntime().freeMemory()) / 1024 / 1024 + "MB");
            }
        }
        
        // Result: OutOfMemoryError!
        
        /**
         * HEAP DUMP ANALYSIS:
         * 
         * LeakyCache
         *   └─ HashMap cache
         *        └─ Entry[1,000,000]
         *             └─ String values
         * 
         * Memory: ~1,000,000 * (Entry overhead + String) = ~50MB
         * 
         * With BoundedCache:
         *   └─ LinkedHashMap cache
         *        └─ Entry[1,000] (max)
         * 
         * Memory: ~1,000 * (Entry overhead + String) = ~50KB
         * 
         * 1000x memory savings!
         */
    }
}
```

### ThreadLocal Leaks

```java
/**
 * MEMORY LEAK #3: THREADLOCAL
 * 
 * Problem:
 * - ThreadLocal stores per-thread data
 * - Thread pools reuse threads
 * - ThreadLocal data persists across requests
 * - Can cause memory leaks in web servers
 * 
 * Impact:
 * - Memory grows with thread count
 * - Data leaks between requests
 * - ClassLoader leaks in application servers
 */

public class ThreadLocalLeakDemo {
    
    // BAD: Leaks memory in thread pools
    static class LeakyRequestContext {
        private static ThreadLocal<UserSession> sessionThreadLocal = 
            new ThreadLocal<>();
        
        public static void setSession(UserSession session) {
            sessionThreadLocal.set(session);
            // Problem: Never removed!
        }
        
        public static UserSession getSession() {
            return sessionThreadLocal.get();
        }
    }
    
    // GOOD: Clean up after use
    static class SafeRequestContext {
        private static ThreadLocal<UserSession> sessionThreadLocal = 
            new ThreadLocal<>();
        
        public static void setSession(UserSession session) {
            sessionThreadLocal.set(session);
        }
        
        public static UserSession getSession() {
            return sessionThreadLocal.get();
        }
        
        public static void clear() {
            sessionThreadLocal.remove(); // IMPORTANT!
        }
    }
    
    // BETTER: Use try-with-resources pattern
    static class AutoCleanRequestContext implements AutoCloseable {
        private static ThreadLocal<UserSession> sessionThreadLocal = 
            new ThreadLocal<>();
        
        public AutoCleanRequestContext(UserSession session) {
            sessionThreadLocal.set(session);
        }
        
        public static UserSession getSession() {
            return sessionThreadLocal.get();
        }
        
        @Override
        public void close() {
            sessionThreadLocal.remove();
        }
    }
    
    static class UserSession {
        private String userId;
        private byte[] data = new byte[10 * 1024]; // 10KB per session
        
        public UserSession(String userId) {
            this.userId = userId;
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        
        // Simulate web server with thread pool
        ExecutorService threadPool = Executors.newFixedThreadPool(10);
        
        // Process 1000 requests
        for (int i = 0; i < 1000; i++) {
            final int requestId = i;
            
            threadPool.submit(() -> {
                // BAD: Leaky version
                LeakyRequestContext.setSession(new UserSession("user-" + requestId));
                processRequest();
                // Session not cleared - LEAK!
            });
        }
        
        threadPool.shutdown();
        threadPool.awaitTermination(10, TimeUnit.SECONDS);
        
        /**
         * RESULT:
         * 
         * Thread pool has 10 threads
         * Each processed ~100 requests
         * Last session on each thread never cleared
         * 
         * Memory leaked: 10 threads * 10KB = 100KB
         * 
         * In real application:
         * - 200 threads
         * - 1MB session data
         * - Leak: 200MB!
         * 
         * HEAP DUMP:
         * 
         * Thread[pool-1-thread-1]
         *   └─ ThreadLocalMap
         *        └─ Entry
         *             └─ UserSession (10KB) ← LEAKED!
         * 
         * Thread[pool-1-thread-2]
         *   └─ ThreadLocalMap
         *        └─ Entry
         *             └─ UserSession (10KB) ← LEAKED!
         * 
         * ... (10 threads total)
         */
    }
    
    private static void processRequest() {
        UserSession session = LeakyRequestContext.getSession();
        // Process request
    }
    
    /**
     * PROPER PATTERN:
     */
    public static void correctPattern() {
        ExecutorService threadPool = Executors.newFixedThreadPool(10);
        
        threadPool.submit(() -> {
            try (AutoCleanRequestContext context = 
                    new AutoCleanRequestContext(new UserSession("user-123"))) {
                
                // Process request
                UserSession session = AutoCleanRequestContext.getSession();
                // ...
                
            } // Automatic cleanup!
        });
        
        threadPool.shutdown();
    }
    
    /**
     * CLASSLOADER LEAK:
     * 
     * Even worse in application servers!
     * 
     * Problem:
     * 1. Application uses ThreadLocal
     * 2. Application deployed to Tomcat
     * 3. Application redeployed
     * 4. Old ClassLoader can't be GC'd
     * 5. Entire application leaked in memory!
     * 
     * Cause:
     * - Thread pool threads (system ClassLoader)
     * - Hold ThreadLocal (application ClassLoader)
     * - ClassLoader can't be GC'd
     * 
     * Fix:
     * - Always call ThreadLocal.remove()
     * - Use servlet filters to clean up
     * - Or use request-scoped beans (Spring)
     */
}
```

---

## 6. Heap Dump Analysis

### Taking Heap Dumps

```bash
# Method 1: jmap command
jmap -dump:format=b,file=heap.hprof <pid>

# Method 2: jcmd command (preferred)
jcmd <pid> GC.heap_dump heap.hprof

# Method 3: Automatic on OutOfMemoryError
java -XX:+HeapDumpOnOutOfMemoryError \
     -XX:HeapDumpPath=/tmp/heapdump.hprof \
     YourApplication

# Method 4: JVisualVM
# 1. Connect to application
# 2. Monitor tab → Heap Dump button
# 3. Save to file

# Method 5: Programmatically
# See code below
```

### Programmatic Heap Dump

```java
import javax.management.*;
import java.lang.management.*;

/**
 * PROGRAMMATIC HEAP DUMP:
 * 
 * Useful for:
 * - Scheduled dumps
 * - Conditional dumps (on memory threshold)
 * - Automated testing
 */

public class HeapDumpDemo {
    
    public static void dumpHeap(String filePath, boolean live) {
        try {
            MBeanServer server = ManagementFactory.getPlatformMBeanServer();
            HotSpotDiagnosticMXBean mxBean = ManagementFactory.newPlatformMXBeanProxy(
                server,
                "com.sun.management:type=HotSpotDiagnostic",
                HotSpotDiagnosticMXBean.class
            );
            
            mxBean.dumpHeap(filePath, live);
            System.out.println("Heap dump created: " + filePath);
            
        } catch (Exception e) {
            System.err.println("Failed to create heap dump: " + e.getMessage());
        }
    }
    
    /**
     * CONDITIONAL HEAP DUMP:
     * 
     * Dump when memory usage exceeds threshold
     */
    public static void startMemoryMonitor() {
        Thread monitor = new Thread(() -> {
            MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
            
            while (true) {
                try {
                    Thread.sleep(60000); // Check every minute
                    
                    MemoryUsage heapUsage = memoryBean.getHeapMemoryUsage();
                    long used = heapUsage.getUsed();
                    long max = heapUsage.getMax();
                    double percent = (double) used / max * 100;
                    
                    if (percent > 90) {
                        System.out.println("Memory usage: " + percent + "%");
                        String timestamp = String.valueOf(System.currentTimeMillis());
                        dumpHeap("heap-" + timestamp + ".hprof", true);
                    }
                    
                } catch (InterruptedException e) {
                    break;
                }
            }
        });
        
        monitor.setDaemon(true);
        monitor.start();
    }
    
    public static void main(String[] args) {
        // Start memory monitor
        startMemoryMonitor();
        
        // Manual dump
        dumpHeap("manual-heap.hprof", true);
        
        /**
         * HEAP DUMP FILES:
         * 
         * Format: HPROF binary format
         * Size: Approximately heap size
         * Contains:
         * - All objects in heap
         * - Object references
         * - Class metadata
         * - Thread stacks
         * 
         * Can be large (GBs)!
         * 
         * Options:
         * - live=true: Only live objects (triggers GC first)
         * - live=false: All objects including garbage
         */
    }
}

interface HotSpotDiagnosticMXBean {
    void dumpHeap(String outputFile, boolean live) throws java.io.IOException;
}
```

### Eclipse Memory Analyzer (MAT)

```java
/**
 * ECLIPSE MAT ANALYSIS:
 * 
 * Download: https://www.eclipse.org/mat/
 * 
 * Key Features:
 * 1. Leak Suspects Report
 * 2. Dominator Tree
 * 3. Histogram
 * 4. OQL (Object Query Language)
 * 5. Path to GC Roots
 * 
 * WORKFLOW:
 * 
 * 1. Open heap dump in MAT
 * 2. Wait for parsing (creates indexes)
 * 3. Click "Leak Suspects Report"
 * 4. Identify top suspects
 * 5. Drill down into details
 */

public class MATAnalysisGuide {
    
    /**
     * LEAK SUSPECTS REPORT:
     * 
     * Automatically identifies potential leaks
     * 
     * Example output:
     * 
     * Problem Suspect 1
     * ─────────────────
     * One instance of "java.util.HashMap" loaded by
     * "<system class loader>" occupies 425.5 MB (85.1%) of memory.
     * 
     * The memory is accumulated in one instance of "java.lang.Object[]"
     * loaded by "<system class loader>" which occupies 425.3 MB (85.0%) of memory.
     * 
     * Keywords:
     * java.util.HashMap
     * java.lang.Object[]
     * 
     * Details »
     * 
     * This shows a HashMap consuming 85% of heap!
     */
    
    /**
     * DOMINATOR TREE:
     * 
     * Shows objects and their retained size
     * 
     * Retained size = object + all objects it keeps alive
     * 
     * Example:
     * 
     * Class Name                         | Shallow Heap | Retained Heap
     * ───────────────────────────────────┼──────────────┼──────────────
     * com.example.CacheManager           |       24 B   |   450 MB
     *   ├─ java.util.HashMap             |       48 B   |   450 MB
     *   │   └─ Object[] (size=1000000)   |     4 MB     |   446 MB
     *   │       ├─ Entry[0]               |       32 B   |   446 KB
     *   │       │   └─ byte[]             |      446 KB  |   446 KB
     *   │       ├─ Entry[1]               |       32 B   |   446 KB
     *   │       ...
     * 
     * Interpretation:
     * - CacheManager is keeping 450MB alive
     * - HashMap contains 1M entries
     * - Each entry holds 446KB byte array
     * - Likely memory leak in cache!
     */
    
    /**
     * HISTOGRAM:
     * 
     * Shows object counts and sizes by class
     * 
     * Example:
     * 
     * Class Name                    | Objects | Shallow Heap
     * ──────────────────────────────┼─────────┼─────────────
     * byte[]                        | 1000000 |    450 MB
     * java.lang.String              |  500000 |     12 MB
     * com.example.UserSession       |   10000 |    100 KB
     * java.util.HashMap$Node        | 1000000 |     32 MB
     * 
     * Interpretation:
     * - 1M byte arrays (cache entries?)
     * - 500K strings (user data?)
     * - 10K sessions (thread pool leak?)
     */
    
    /**
     * OQL QUERIES:
     * 
     * SQL-like queries for heap analysis
     */
    public void oqlExamples() {
        /*
        -- Find all instances of a class
        SELECT * FROM com.example.UserSession
        
        -- Find objects with specific property
        SELECT * FROM com.example.UserSession s 
        WHERE s.userId LIKE "admin.*"
        
        -- Count objects by class
        SELECT s.@class.name, count(s) 
        FROM java.lang.String s 
        GROUP BY s.@class.name
        
        -- Find large objects
        SELECT * FROM java.lang.Object o 
        WHERE o.@retainedHeapSize > 1000000
        
        -- Find objects with no references (memory leak!)
        SELECT * FROM com.example.CacheEntry e 
        WHERE e.@GCRootInfo != null
        
        -- Find ThreadLocal leaks
        SELECT * FROM java.lang.ThreadLocal tl
        */
    }
    
    /**
     * PATH TO GC ROOTS:
     * 
     * Shows why object can't be GC'd
     * 
     * Example:
     * 
     * com.example.UserSession @ 0x12345678
     *   ← ThreadLocalMap$Entry @ 0x23456789
     *     ← ThreadLocalMap @ 0x34567890
     *       ← Thread @ 0x45678901 "pool-1-thread-1"
     *         ← ThreadGroup @ 0x56789012
     *           ← GC Root: Thread
     * 
     * Interpretation:
     * - UserSession kept alive by ThreadLocal
     * - ThreadLocal owned by pool thread
     * - Thread is GC root (can't be collected)
     * - Must call ThreadLocal.remove() to fix!
     */
    
    /**
     * COMMON LEAK PATTERNS IN MAT:
     * 
     * 1. HashMap with many entries:
     *    Look for: Large HashMap in dominator tree
     *    Cause: Unbounded cache
     * 
     * 2. ArrayList growing indefinitely:
     *    Look for: Large Object[] backing ArrayList
     *    Cause: Listener leak
     * 
     * 3. ThreadLocal holding large objects:
     *    Look for: ThreadLocalMap with large entries
     *    Cause: ThreadLocal not cleaned up
     * 
     * 4. Class keeps old ClassLoader alive:
     *    Look for: Multiple versions of same class
     *    Cause: ClassLoader leak (application redeploy)
     * 
     * 5. Static field holds collection:
     *    Look for: Static field in path to GC roots
     *    Cause: Static collection never cleared
     */
}
```

### VisualVM Analysis

```java
/**
 * VISUALVM HEAP ANALYSIS:
 * 
 * VisualVM: Lightweight alternative to MAT
 * 
 * Features:
 * 1. Live monitoring
 * 2. Heap dumps
 * 3. Thread dumps
 * 4. CPU profiling
 * 5. Memory profiling
 * 
 * WORKFLOW:
 * 
 * 1. Launch VisualVM
 * 2. Connect to application
 * 3. Monitor → Heap Dump
 * 4. Analyze:
 *    - Classes (sorted by instance count)
 *    - Instances
 *    - References
 */

public class VisualVMGuide {
    
    /**
     * HEAP DUMP VIEW:
     * 
     * Summary Tab:
     * - Total size
     * - Number of classes
     * - Number of instances
     * - GC roots
     * 
     * Classes Tab:
     * Class Name                | Instances | Size
     * ──────────────────────────┼───────────┼──────────
     * byte[]                    | 1000000   | 450 MB
     * java.lang.String          |  500000   |  12 MB
     * com.example.UserSession   |   10000   | 100 KB
     * 
     * Instances Tab:
     * - Select class
     * - View all instances
     * - Inspect fields
     * - See references
     * 
     * OQL Console:
     * - Run queries
     * - Filter objects
     * - Export results
     */
    
    /**
     * LIVE MONITORING:
     * 
     * Advantages over heap dumps:
     * - Real-time data
     * - See trends over time
     * - Lighter weight
     * - No application pause
     * 
     * Monitor Tab shows:
     * - Heap usage over time
     * - GC activity
     * - Class loading
     * - Thread count
     * 
     * Used Memory graph:
     * 
     *  2GB ┤      ╱╲    ╱╲    ╱╲
     *      │     ╱  ╲  ╱  ╲  ╱  ╲
     *  1GB ┤    ╱    ╲╱    ╲╱    ╲
     *      │   ╱
     *    0 ┴───┬───┬───┬───┬───┬───→ time
     *          0  10  20  30  40  50 min
     * 
     * Pattern shows:
     * - Memory grows steadily (allocation)
     * - Sudden drops (GC)
     * - Rising baseline (leak!)
     */
    
    /**
     * PROFILING:
     * 
     * CPU Profiling:
     * - Find hot methods
     * - Identify bottlenecks
     * - Measure execution time
     * 
     * Memory Profiling:
     * - Track allocations
     * - Find allocation hot spots
     * - See object lifecycle
     * 
     * Method                          | Time (ms) | Calls
     * ────────────────────────────────┼───────────┼──────────
     * com.example.process()           |   5000    |   1000
     *   ├─ com.example.loadData()     |   4000    |   1000
     *   └─ com.example.saveData()     |   1000    |   1000
     * 
     * Shows: loadData() is bottleneck (80% of time)
     */
}
```

---

## 7. Preventing Memory Leaks

### Best Practices

```java
/**
 * MEMORY LEAK PREVENTION:
 * 
 * 1. ALWAYS CLEAN UP RESOURCES
 * 2. AVOID STATIC COLLECTIONS
 * 3. REMOVE LISTENERS
 * 4. CLEAN THREADLOCAL
 * 5. USE WEAK REFERENCES
 * 6. BOUNDED CACHES
 * 7. CLOSE STREAMS
 * 8. AVOID FINALIZERS
 */

public class LeakPrevention {
    
    // RULE 1: Use try-with-resources
    public void properResourceManagement() throws IOException {
        // GOOD
        try (FileInputStream fis = new FileInputStream("file.txt");
             BufferedReader reader = new BufferedReader(new InputStreamReader(fis))) {
            
            String line = reader.readLine();
            // ...
            
        } // Automatic cleanup!
        
        // BAD
        FileInputStream fis = new FileInputStream("file.txt");
        // ...
        // Forget to close() - LEAK!
    }
    
    // RULE 2: Avoid static collections
    // BAD
    private static List<Object> staticCache = new ArrayList<>();
    
    public void addToStaticCache(Object obj) {
        staticCache.add(obj); // Never GC'd!
    }
    
    // GOOD: Use instance field with proper lifecycle
    private List<Object> instanceCache = new ArrayList<>();
    
    public void addToInstanceCache(Object obj) {
        instanceCache.add(obj); // GC'd when instance is GC'd
    }
    
    // RULE 3: Remove listeners
    public void properListenerManagement() {
        EventSource source = new EventSource();
        EventListener listener = event -> {};
        
        // Register
        source.addListener(listener);
        
        // Use
        // ...
        
        // IMPORTANT: Unregister!
        source.removeListener(listener);
    }
    
    // RULE 4: Clean ThreadLocal
    public void properThreadLocalManagement() {
        ThreadLocal<UserSession> sessionLocal = ThreadLocal.withInitial(UserSession::new);
        
        try {
            // Use ThreadLocal
            UserSession session = sessionLocal.get();
            // ...
            
        } finally {
            // IMPORTANT: Clean up!
            sessionLocal.remove();
        }
    }
    
    // RULE 5: Use appropriate reference types
    public void properCacheImplementation() {
        // For metadata cache (should be GC'd when memory low)
        Map<String, SoftReference<Metadata>> cache = new HashMap<>();
        
        // For canonical mapping (should be GC'd when key goes away)
        WeakHashMap<Key, Value> mapping = new WeakHashMap<>();
        
        // For size-limited cache
        Map<String, String> boundedCache = new LinkedHashMap<String, String>(16, 0.75f, true) {
            protected boolean removeEldestEntry(Map.Entry<String, String> eldest) {
                return size() > 1000;
            }
        };
    }
    
    // RULE 6: Nullify references
    public void nullifyReferences() {
        Object[] stack = new Object[100];
        int size = 0;
        
        // Push
        stack[size++] = new Object();
        
        // Pop
        Object popped = stack[--size];
        stack[size] = null; // IMPORTANT: Clear reference!
        
        // Without nullification, array keeps references to popped objects!
    }
    
    // RULE 7: Avoid inner classes in long-lived objects
    // BAD
    class OuterClass {
        private byte[] largeData = new byte[1024 * 1024]; // 1MB
        
        public InnerClass createInner() {
            return new InnerClass(); // Holds reference to OuterClass!
        }
        
        class InnerClass {
            // Implicitly holds reference to OuterClass
            // If InnerClass is long-lived, OuterClass can't be GC'd!
        }
    }
    
    // GOOD: Use static inner class
    static class OuterClassFixed {
        private byte[] largeData = new byte[1024 * 1024];
        
        public StaticInnerClass createInner() {
            return new StaticInnerClass();
        }
        
        static class StaticInnerClass {
            // No implicit reference to outer class!
        }
    }
    
    /**
     * PREVENTION CHECKLIST:
     * 
     * ☐ Use try-with-resources for Closeable
     * ☐ Remove event listeners when done
     * ☐ Clean up ThreadLocal in finally block
     * ☐ Use bounded caches with eviction
     * ☐ Use WeakHashMap for canonical mappings
     * ☐ Avoid static collections
     * ☐ Nullify array elements after use
     * ☐ Use static inner classes when possible
     * ☐ Close database connections
     * ☐ Close file streams
     * ☐ Unregister MBeans
     * ☐ Cancel timers
     * ☐ Shutdown thread pools
     * ☐ Clear references in destroy/cleanup methods
     */
    
    /**
     * CODE REVIEW RED FLAGS:
     * 
     * 🚩 Static List/Map/Set without size limit
     * 🚩 ThreadLocal without remove()
     * 🚩 addListener() without removeListener()
     * 🚩 Unbounded cache
     * 🚩 InputStream/OutputStream without try-with-resources
     * 🚩 Inner class in long-lived object
     * 🚩 finalize() method
     * 🚩 Thread created but not stopped
     * 🚩 Timer scheduled but not cancelled
     */
}
```

---

## Summary

### Object Lifecycle

```java
/**
 * COMPLETE OBJECT LIFECYCLE:
 * 
 * 1. Creation:
 *    - new keyword
 *    - Reflection
 *    - Cloning
 *    - Deserialization
 * 
 * 2. Initialization:
 *    - Static initializers (class loading)
 *    - Instance initializers
 *    - Constructor chain (parent → child)
 * 
 * 3. Usage:
 *    - Strongly reachable
 *    - Accessed via references
 * 
 * 4. Reachability Change:
 *    - Softly reachable (memory-sensitive)
 *    - Weakly reachable (next GC)
 *    - Phantom reachable (post-finalization)
 * 
 * 5. Finalization (deprecated):
 *    - finalize() called
 *    - Can resurrect object
 * 
 * 6. Cleanup:
 *    - Cleaner runs (Java 9+)
 *    - Native resources released
 * 
 * 7. Reclamation:
 *    - Memory returned to heap
 *    - Available for new objects
 */
```

### Memory Leak Patterns Summary

|Pattern|Symptom|Heap Dump|Fix|
|---|---|---|---|
|**Listener Leak**|Growing ArrayList|Large ArrayList of listeners|Remove listeners or use WeakReference|
|**Cache Leak**|Growing HashMap|Large HashMap with many entries|Add size limit or TTL|
|**ThreadLocal Leak**|Memory per thread|ThreadLocalMap with large entries|Call ThreadLocal.remove()|
|**ClassLoader Leak**|Multiple class versions|Multiple ClassLoader instances|Clean up ThreadLocal and listeners|
|**Static Collection**|Constant memory growth|Static field with large collection|Use instance field or bound size|
|**Inner Class Leak**|Outer object not GC'd|Inner class holds outer reference|Use static inner class|
|**Stream Leak**|File handle exhaustion|Open streams in dominator tree|Use try-with-resources|

### Tools Comparison

|Tool|Best For|Learning Curve|Features|
|---|---|---|---|
|**Eclipse MAT**|Deep analysis|Medium|Leak suspects, OQL, dominator tree|
|**VisualVM**|Live monitoring|Low|Real-time charts, profiling|
|**JProfiler**|Professional use|High|Advanced profiling, comparison|
|**YourKit**|Production analysis|High|CPU/memory profiling, telemetry|
|**jmap/jhat**|Quick checks|Low|Command-line, basic analysis|

### Quick Reference

```bash
# Take heap dump
jcmd <pid> GC.heap_dump heap.hprof

# Analyze with jhat (built-in)
jhat heap.hprof
# Open http://localhost:7000

# Find memory leaks (Linux)
jmap -histo:live <pid> | head -20

# Monitor memory in real-time
jstat -gcutil <pid> 1000
```

---
