# Java Memory Model & Internals

## Overview

Understanding JVM memory architecture is crucial for writing efficient Java applications, troubleshooting memory issues, and optimizing performance. This guide covers the internal workings of Java memory management.

---

## 1. JVM Memory Architecture Deep Dive

### Complete Memory Layout

```java
/**
 * JVM MEMORY ARCHITECTURE:
 * 
 * ┌─────────────────────────────────────────┐
 * │           JVM PROCESS MEMORY            │
 * ├─────────────────────────────────────────┤
 * │                                         │
 * │  ┌───────────────────────────────────┐ │
 * │  │         HEAP MEMORY              │ │
 * │  │  ┌────────────────────────────┐  │ │
 * │  │  │    YOUNG GENERATION        │  │ │
 * │  │  │  ┌──────┐  ┌─────────────┐ │  │ │
 * │  │  │  │ Eden │  │  Survivor   │ │  │ │
 * │  │  │  │      │  │  S0  │  S1  │ │  │ │
 * │  │  │  └──────┘  └─────────────┘ │  │ │
 * │  │  └────────────────────────────┘  │ │
 * │  │  ┌────────────────────────────┐  │ │
 * │  │  │    OLD GENERATION          │  │ │
 * │  │  │  (Tenured Space)           │  │ │
 * │  │  └────────────────────────────┘  │ │
 * │  └───────────────────────────────────┘ │
 * │                                         │
 * │  ┌───────────────────────────────────┐ │
 * │  │       METASPACE (Java 8+)        │ │
 * │  │  - Class metadata                │ │
 * │  │  - Method metadata               │ │
 * │  │  - Static variables              │ │
 * │  │  - Runtime constant pool         │ │
 * │  └───────────────────────────────────┘ │
 * │                                         │
 * │  ┌───────────────────────────────────┐ │
 * │  │      THREAD STACKS (per thread)  │ │
 * │  │  - Local variables               │ │
 * │  │  - Method call frames            │ │
 * │  │  - Operand stacks                │ │
 * │  └───────────────────────────────────┘ │
 * │                                         │
 * │  ┌───────────────────────────────────┐ │
 * │  │      DIRECT MEMORY               │ │
 * │  │  (Off-heap / Native memory)      │ │
 * │  └───────────────────────────────────┘ │
 * │                                         │
 * │  ┌───────────────────────────────────┐ │
 * │  │      CODE CACHE                  │ │
 * │  │  (JIT compiled code)             │ │
 * │  └───────────────────────────────────┘ │
 * └─────────────────────────────────────────┘
 */
```

---

## 2. Heap Memory Detailed

### Young Generation (Eden + Survivor Spaces)

```java
public class YoungGenerationDemo {
    
    /**
     * YOUNG GENERATION STRUCTURE:
     * 
     * Purpose: Where new objects are allocated
     * 
     * Components:
     * 1. Eden Space (80% of Young Gen by default)
     *    - All new objects allocated here
     *    - Fast allocation using bump-the-pointer
     *    
     * 2. Survivor Spaces (S0 and S1, 10% each)
     *    - Objects that survive one GC
     *    - Only ONE survivor space active at a time
     *    - Objects copied between S0 <-> S1
     * 
     * Minor GC Process:
     * 1. Eden fills up
     * 2. Minor GC triggered
     * 3. Live objects copied to Survivor space
     * 4. Eden cleared
     * 5. Objects age (generation count++)
     * 6. After ~15 GCs, promoted to Old Gen
     */
    
    public static void main(String[] args) {
        // These objects allocated in Eden
        for (int i = 0; i < 1000; i++) {
            Object obj = new Object();
            // Most become garbage immediately
        }
        
        // Object that survives
        Object survivor = new Object();
        
        // Trigger GC
        System.gc();
        
        // survivor moved to S0
        // After multiple GCs, it will be promoted to Old Gen
    }
    
    /**
     * ALLOCATION EXAMPLE:
     * 
     * Time 0: Eden = [], S0 = [], S1 = []
     * 
     * After creating 3 objects:
     * Eden = [obj1, obj2, obj3], S0 = [], S1 = []
     * 
     * After Minor GC (obj2 is garbage):
     * Eden = [], S0 = [obj1(age=1), obj3(age=1)], S1 = []
     * 
     * After creating more objects:
     * Eden = [obj4, obj5], S0 = [obj1(age=1), obj3(age=1)], S1 = []
     * 
     * After another Minor GC (obj5 is garbage):
     * Eden = [], S0 = [], S1 = [obj1(age=2), obj3(age=2), obj4(age=1)]
     * 
     * After 15 GCs (age reaches threshold):
     * Old Gen = [obj1, obj3], S1 = [obj4(age=14)]
     */
}
```

### Old Generation (Tenured Space)

```java
public class OldGenerationDemo {
    
    /**
     * OLD GENERATION:
     * 
     * Purpose: Long-lived objects
     * 
     * Objects promoted when:
     * 1. Survived 15 Minor GCs (age threshold reached)
     * 2. Survivor space is full (premature promotion)
     * 3. Large object allocated directly
     * 
     * Major GC (Full GC):
     * - Triggered when Old Gen fills up
     * - Much slower than Minor GC
     * - Typically causes "Stop-The-World" pause
     * - Uses Mark-Sweep-Compact algorithm
     */
    
    // Long-lived object - will be promoted to Old Gen
    private static final List<byte[]> longLivedData = new ArrayList<>();
    
    public static void main(String[] args) {
        // Simulate long-lived objects
        for (int i = 0; i < 100; i++) {
            longLivedData.add(new byte[1024 * 1024]); // 1 MB each
            
            // These will survive multiple GCs
            // Eventually promoted to Old Gen
        }
        
        // Monitor with: jstat -gcutil <pid> 1000
        // Shows Young Gen vs Old Gen usage
    }
    
    /**
     * PROMOTION SCENARIOS:
     * 
     * 1. Age-based promotion:
     *    Object survives 15 Minor GCs → Old Gen
     * 
     * 2. Dynamic age calculation:
     *    If survivor space 50% full, threshold lowered
     * 
     * 3. Large object:
     *    Object size > half of Eden → Directly to Old Gen
     * 
     * 4. Premature promotion:
     *    Survivor space full → Promote even if young
     */
}
```

### Metaspace (Java 8+)

```java
public class MetaspaceDemo {
    
    /**
     * METASPACE (replaces PermGen in Java 8+):
     * 
     * Contents:
     * 1. Class metadata (structure of classes)
     * 2. Method metadata
     * 3. Static variables
     * 4. Runtime constant pool
     * 5. Interned Strings (moved to heap in Java 7+)
     * 
     * Key Differences from PermGen:
     * - Uses native memory (not heap)
     * - Grows automatically (no fixed size)
     * - Can be limited with -XX:MaxMetaspaceSize
     * - Garbage collected when classes unloaded
     * 
     * JVM Flags:
     * -XX:MetaspaceSize=128M          // Initial size
     * -XX:MaxMetaspaceSize=512M       // Maximum size
     * -XX:MinMetaspaceFreeRatio=40    // Min free %
     * -XX:MaxMetaspaceFreeRatio=70    // Max free %
     */
    
    public static void main(String[] args) {
        // Class metadata stored in Metaspace
        Class<?> clazz = MyClass.class;
        
        // Static variables stored in Metaspace
        MyClass.staticField = "value";
        
        // Method metadata stored in Metaspace
        java.lang.reflect.Method[] methods = clazz.getDeclaredMethods();
    }
    
    static class MyClass {
        static String staticField;
        
        void instanceMethod() {
            // Method code in Code Cache
            // Method metadata in Metaspace
        }
    }
    
    /**
     * METASPACE GROWTH EXAMPLE:
     * 
     * Scenario: Dynamic class loading (e.g., reflection, proxies)
     * 
     * Initial: Metaspace = 20 MB
     * After loading 100 classes: Metaspace = 25 MB
     * After loading 1000 classes: Metaspace = 40 MB
     * 
     * If MaxMetaspaceSize exceeded:
     * → OutOfMemoryError: Metaspace
     */
}
```

---

## 3. Stack Memory (Thread-Local)

### Stack Frame Structure

```java
public class StackMemoryDemo {
    
    /**
     * STACK MEMORY:
     * 
     * Characteristics:
     * - One stack per thread
     * - LIFO (Last In, First Out)
     * - Stores local variables and method calls
     * - Very fast allocation/deallocation
     * - Limited size (-Xss flag)
     * 
     * Each Stack Frame contains:
     * 1. Local Variable Array
     * 2. Operand Stack
     * 3. Frame Data (return address, exception handling)
     * 
     * Default Stack Size:
     * - Linux/Solaris: 1 MB
     * - Windows: depends on JVM
     * - Can set with: -Xss512k
     */
    
    public static void main(String[] args) {
        int x = 10;           // Stored in main's stack frame
        int result = add(x, 5); // New frame created for add()
        System.out.println(result);
    }
    
    public static int add(int a, int b) {
        int sum = a + b;      // Stored in add's stack frame
        return sum;           // Frame popped after return
    }
    
    /**
     * STACK FRAME VISUALIZATION:
     * 
     * Before add() call:
     * ┌────────────────────┐
     * │   main() frame     │
     * │   x = 10           │
     * │   result = ?       │
     * └────────────────────┘
     * 
     * During add() execution:
     * ┌────────────────────┐
     * │   add() frame      │ ← Top of stack
     * │   a = 10           │
     * │   b = 5            │
     * │   sum = 15         │
     * ├────────────────────┤
     * │   main() frame     │
     * │   x = 10           │
     * │   result = ?       │
     * └────────────────────┘
     * 
     * After add() returns:
     * ┌────────────────────┐
     * │   main() frame     │
     * │   x = 10           │
     * │   result = 15      │
     * └────────────────────┘
     */
}
```

### Primitive vs Reference Types on Stack

```java
public class StackVsHeapDemo {
    
    public static void main(String[] args) {
        // PRIMITIVES: Value stored on stack
        int age = 25;                    // Stack: age = 25
        double salary = 50000.0;         // Stack: salary = 50000.0
        
        // OBJECTS: Reference on stack, object on heap
        Person person = new Person("Alice", 30);
        
        /**
         * MEMORY LAYOUT:
         * 
         * STACK (main thread):
         * ┌──────────────────────────┐
         * │ age = 25                 │
         * │ salary = 50000.0         │
         * │ person = 0x7F2A1B3C      │ ──┐
         * └──────────────────────────┘   │
         *                                │
         * HEAP:                          │
         * ┌──────────────────────────┐   │
         * │ Person@0x7F2A1B3C        │ ←─┘
         * │  - name = "Alice"        │
         * │  - age = 30              │
         * └──────────────────────────┘
         */
        
        modifyPrimitive(age);      // Pass by value
        modifyObject(person);      // Pass by reference
        
        System.out.println(age);         // Still 25
        System.out.println(person.name); // Changed to "Bob"
    }
    
    static void modifyPrimitive(int value) {
        value = 100; // Only local copy changed
    }
    
    static void modifyObject(Person p) {
        p.name = "Bob"; // Modifies heap object
    }
    
    static class Person {
        String name;
        int age;
        
        Person(String name, int age) {
            this.name = name;
            this.age = age;
        }
    }
    
    /**
     * KEY POINTS:
     * 
     * Stack stores:
     * - Primitive values directly
     * - Object references (memory addresses)
     * - Method call frames
     * 
     * Heap stores:
     * - Object instances
     * - Instance variables
     * - Arrays
     */
}
```

### Stack Overflow

```java
public class StackOverflowDemo {
    
    /**
     * STACK OVERFLOW:
     * 
     * Occurs when:
     * 1. Too many recursive calls
     * 2. Infinite recursion
     * 3. Very deep call stack
     * 
     * Each method call adds a frame to stack
     * If stack size exceeded → StackOverflowError
     */
    
    // Infinite recursion causes StackOverflowError
    public static void infiniteRecursion(int depth) {
        System.out.println("Depth: " + depth);
        infiniteRecursion(depth + 1); // No base case!
    }
    
    // Proper recursion with base case
    public static int factorial(int n) {
        if (n <= 1) return 1;         // Base case
        return n * factorial(n - 1);  // Recursive case
    }
    
    // Tail recursion (can be optimized)
    public static int factorialTail(int n, int accumulator) {
        if (n <= 1) return accumulator;
        return factorialTail(n - 1, n * accumulator);
    }
    
    /**
     * STACK DEPTH EXAMPLE:
     * 
     * factorial(5):
     * 
     * Call Stack Growth:
     * factorial(5)         ← Frame 5
     * factorial(4)         ← Frame 4
     * factorial(3)         ← Frame 3
     * factorial(2)         ← Frame 2
     * factorial(1) → 1     ← Frame 1 (base case)
     * 
     * Call Stack Shrinkage:
     * factorial(2) → 2
     * factorial(3) → 6
     * factorial(4) → 24
     * factorial(5) → 120
     * 
     * Maximum stack depth for factorial(5) = 5 frames
     * 
     * With default 1MB stack:
     * - Each frame ~1KB
     * - Max depth ~1000 calls
     * - factorial(10000) would overflow
     */
    
    public static void main(String[] args) {
        // This will work
        System.out.println(factorial(5));
        
        // This will throw StackOverflowError
        // infiniteRecursion(0);
        
        // Measure max depth
        try {
            infiniteRecursion(0);
        } catch (StackOverflowError e) {
            System.out.println("Stack overflow occurred");
        }
    }
}
```

---

## 4. Method Area and Constant Pool

### Runtime Constant Pool

```java
public class ConstantPoolDemo {
    
    /**
     * RUNTIME CONSTANT POOL:
     * 
     * Located in: Metaspace (Java 8+)
     * 
     * Contains:
     * 1. Literal constants (numbers, strings)
     * 2. Symbolic references (class names, field names, method names)
     * 3. Class and interface names
     * 4. Field references
     * 5. Method references
     * 
     * Created per class at class loading time
     */
    
    public static void main(String[] args) {
        // Compile-time constants go to constant pool
        int x = 100;           // 100 in constant pool
        String s = "Hello";    // "Hello" in string pool
        
        // Class metadata in runtime constant pool
        Class<?> clazz = ConstantPoolDemo.class;
    }
    
    /**
     * CONSTANT POOL STRUCTURE:
     * 
     * For this class, constant pool contains:
     * 
     * #1 = Methodref          #6.#20  // java/lang/Object."<init>"
     * #2 = Class              #21     // ConstantPoolDemo
     * #3 = String             #22     // Hello
     * #4 = Integer            100
     * #5 = Fieldref           #2.#23  // ConstantPoolDemo.x
     * #6 = Class              #24     // java/lang/Object
     * ...
     * 
     * View with: javap -v ConstantPoolDemo.class
     */
}
```

### Method Metadata

```java
public class MethodMetadataDemo {
    
    /**
     * METHOD AREA (part of Metaspace):
     * 
     * Stores:
     * 1. Class structures (fields, methods, constructors)
     * 2. Method bytecode
     * 3. Runtime constant pool
     * 4. Static variables
     * 5. Class references
     * 
     * Shared among all threads
     * Garbage collected when classes unloaded
     */
    
    // Static variable stored in Method Area
    private static int staticCounter = 0;
    
    // Instance variable stored in Heap (with object)
    private int instanceCounter = 0;
    
    // Method metadata stored in Method Area
    public void incrementCounters() {
        staticCounter++;
        instanceCounter++;
    }
    
    /**
     * MEMORY LAYOUT:
     * 
     * METASPACE (Method Area):
     * ┌─────────────────────────────────────┐
     * │ MethodMetadataDemo.class            │
     * │  - Static: staticCounter = 5        │
     * │  - Method: incrementCounters()      │
     * │    - Bytecode                       │
     * │    - Parameter info                 │
     * │    - Exception table                │
     * │  - Constant Pool                    │
     * └─────────────────────────────────────┘
     * 
     * HEAP:
     * ┌─────────────────────────────────────┐
     * │ MethodMetadataDemo@0xABC (instance) │
     * │  - instanceCounter = 3              │
     * └─────────────────────────────────────┘
     */
    
    public static void main(String[] args) {
        MethodMetadataDemo obj1 = new MethodMetadataDemo();
        MethodMetadataDemo obj2 = new MethodMetadataDemo();
        
        obj1.incrementCounters(); // staticCounter = 1, obj1.instanceCounter = 1
        obj2.incrementCounters(); // staticCounter = 2, obj2.instanceCounter = 1
        
        // Static shared, instance separate
        System.out.println(staticCounter);      // 2
        System.out.println(obj1.instanceCounter); // 1
        System.out.println(obj2.instanceCounter); // 1
    }
}
```

---

## 5. Direct Memory and Off-Heap

### Direct ByteBuffer

```java
import java.nio.ByteBuffer;

public class DirectMemoryDemo {
    
    /**
     * DIRECT MEMORY:
     * 
     * Characteristics:
     * - Allocated outside JVM heap
     * - Native memory (OS managed)
     * - Not subject to GC
     * - Faster I/O operations
     * - Manual management needed
     * 
     * Use Cases:
     * 1. Network I/O (sockets)
     * 2. File I/O
     * 3. Large buffers
     * 4. Reducing GC pressure
     * 
     * Limitations:
     * - Limited by -XX:MaxDirectMemorySize
     * - Default = -Xmx (max heap size)
     * - OutOfMemoryError if exceeded
     */
    
    public static void main(String[] args) {
        // Heap-based buffer (subject to GC)
        ByteBuffer heapBuffer = ByteBuffer.allocate(1024);
        
        // Direct buffer (off-heap, not GC'd)
        ByteBuffer directBuffer = ByteBuffer.allocateDirect(1024);
        
        /**
         * MEMORY LAYOUT:
         * 
         * HEAP:
         * ┌─────────────────────────────────┐
         * │ heapBuffer (ByteBuffer object)  │
         * │  - byte[] array (1024 bytes)    │
         * └─────────────────────────────────┘
         * 
         * DIRECT MEMORY (Off-Heap):
         * ┌─────────────────────────────────┐
         * │ Native memory (1024 bytes)      │
         * └─────────────────────────────────┘
         *          ↑
         * HEAP:    │
         * ┌────────────────────────────┐
         * │ directBuffer (object)      │
         * │  - address pointer ────────┘
         * └────────────────────────────┘
         */
        
        // Performance comparison
        long start = System.nanoTime();
        for (int i = 0; i < 100000; i++) {
            heapBuffer.put((byte) i);
        }
        long heapTime = System.nanoTime() - start;
        
        start = System.nanoTime();
        for (int i = 0; i < 100000; i++) {
            directBuffer.put((byte) i);
        }
        long directTime = System.nanoTime() - start;
        
        System.out.println("Heap time: " + heapTime);
        System.out.println("Direct time: " + directTime);
        
        // Clean up (important!)
        // DirectBuffer cleaned by Cleaner (phantom reference)
        // But explicit cleanup is better
        if (directBuffer instanceof sun.nio.ch.DirectBuffer) {
            ((sun.nio.ch.DirectBuffer) directBuffer).cleaner().clean();
        }
    }
    
    /**
     * WHEN TO USE DIRECT MEMORY:
     * 
     * Use Direct Memory:
     * ✓ Large, long-lived buffers
     * ✓ Frequent I/O operations
     * ✓ Need to reduce GC pressure
     * ✓ Working with native code (JNI)
     * 
     * Use Heap Memory:
     * ✓ Short-lived buffers
     * ✓ Small buffers
     * ✓ Infrequent I/O
     * ✓ GC is not a concern
     * 
     * TRADE-OFFS:
     * 
     * Direct Memory Pros:
     * + Faster I/O (no copying)
     * + No GC overhead
     * + Shared with native code
     * 
     * Direct Memory Cons:
     * - Allocation/deallocation slower
     * - Not managed by GC
     * - Can cause OutOfMemoryError
     * - Harder to debug
     */
}
```

### Off-Heap Data Structures

```java
public class OffHeapCacheDemo {
    
    /**
     * OFF-HEAP USAGE SCENARIOS:
     * 
     * 1. Large Caches:
     *    - Reduce GC pressure
     *    - Cache millions of objects
     *    - Examples: Ehcache, Chronicle Map
     * 
     * 2. Memory-Mapped Files:
     *    - Direct file access
     *    - Shared memory between processes
     * 
     * 3. Native Libraries:
     *    - JNI allocations
     *    - Native C/C++ integration
     */
    
    // Example: Chronicle Map (off-heap map)
    public static void chronicleMapExample() {
        // Pseudocode (requires Chronicle Map library)
        /*
        ChronicleMap<Integer, String> offHeapMap = 
            ChronicleMap.of(Integer.class, String.class)
                .entries(1_000_000)
                .averageValueSize(100)
                .create();
        
        // Data stored off-heap
        offHeapMap.put(1, "value1");
        offHeapMap.put(2, "value2");
        
        // No GC pressure even with millions of entries
        */
    }
    
    /**
     * MONITORING OFF-HEAP MEMORY:
     * 
     * Tools:
     * 1. Native Memory Tracking (NMT):
     *    -XX:NativeMemoryTracking=summary
     *    jcmd <pid> VM.native_memory summary
     * 
     * 2. Process memory tools:
     *    - Linux: pmap, top, ps
     *    - Windows: Process Explorer
     * 
     * 3. JVM flags:
     *    -XX:MaxDirectMemorySize=1G
     *    -XX:+PrintNMTStatistics
     */
}
```

---

## 6. Memory Allocation Strategies

### TLAB (Thread-Local Allocation Buffer)

```java
public class TLABDemo {
    
    /**
     * TLAB (Thread-Local Allocation Buffer):
     * 
     * Purpose: Fast object allocation without synchronization
     * 
     * How it works:
     * 1. Each thread gets a portion of Eden
     * 2. Thread allocates objects in its TLAB
     * 3. No locking needed
     * 4. When TLAB full, request new TLAB
     * 
     * Benefits:
     * - Very fast allocation (bump-the-pointer)
     * - No thread contention
     * - Cache-friendly
     * 
     * Size:
     * - Dynamic, based on allocation rate
     * - Typically 1-5% of Eden
     * - Can tune with -XX:TLABSize
     */
    
    public static void main(String[] args) throws InterruptedException {
        // Demonstrate TLAB usage
        Runnable allocator = () -> {
            for (int i = 0; i < 1000; i++) {
                // Allocated in thread's TLAB (fast!)
                Object obj = new Object();
            }
        };
        
        // Each thread uses its own TLAB
        Thread t1 = new Thread(allocator);
        Thread t2 = new Thread(allocator);
        Thread t3 = new Thread(allocator);
        
        t1.start();
        t2.start();
        t3.start();
        
        t1.join();
        t2.join();
        t3.join();
        
        /**
         * MEMORY LAYOUT:
         * 
         * EDEN SPACE:
         * ┌────────────────────────────────────────┐
         * │ Thread-1 TLAB │ Thread-2 TLAB │ ...   │
         * │  [objects]    │  [objects]    │       │
         * └────────────────────────────────────────┘
         * 
         * Each thread allocates independently
         * No synchronization needed!
         */
    }
    
    /**
     * ALLOCATION STRATEGIES:
     * 
     * 1. TLAB allocation (fast path):
     *    - Check if fits in current TLAB
     *    - If yes: bump pointer, done
     *    - If no: request new TLAB
     * 
     * 2. Eden allocation (slow path):
     *    - TLAB exhausted
     *    - Synchronize on Eden
     *    - Allocate new TLAB
     * 
     * 3. Old Gen allocation (large objects):
     *    - Object > 50% of Eden
     *    - Allocate directly in Old Gen
     *    - Avoid copying costs
     * 
     * JVM FLAGS:
     * -XX:+UseTLAB (enabled by default)
     * -XX:TLABSize=256k
     * -XX:MinTLABSize=2k
     * -XX:TLABRefillWasteFraction=64
     */
}
```

### Allocation Benchmarks

```java
public class AllocationBenchmark {
    
    private static final int ITERATIONS = 1_000_000;
    
    public static void main(String[] args) {
        // Benchmark 1: Small object allocation
        long start = System.nanoTime();
        for (int i = 0; i < ITERATIONS; i++) {
            Object obj = new Object(); // 16 bytes (header + padding)
        }
        long smallObjTime = System.nanoTime() - start;
        
        // Benchmark 2: Medium object allocation
        start = System.nanoTime();
        for (int i = 0; i < ITERATIONS; i++) {
            int[] arr = new int[100]; // ~416 bytes
        }
        long mediumObjTime = System.nanoTime() - start;
        
        // Benchmark 3: Large object allocation
        start = System.nanoTime();
        for (int i = 0; i < 1000; i++) {
            int[] arr = new int[100_000]; // ~400 KB
        }
        long largeObjTime = System.nanoTime() - start;
        
        System.out.println("Small objects: " + smallObjTime / ITERATIONS + " ns/allocation");
        System.out.println("Medium objects: " + mediumObjTime / ITERATIONS + " ns/allocation");
        System.out.println("Large objects: " + largeObjTime / 1000 + " ns/allocation");
        
        /**
         * TYPICAL RESULTS:
         * 
         * Small objects: ~3-5 ns (TLAB bump pointer)
         * Medium objects: ~10-20 ns (still TLAB)
         * Large objects: ~10,000 ns (direct Old Gen allocation)
         * 
         * Allocation is VERY fast in Java!
         * - Faster than malloc in C
         * - Faster than new in C++
         * - Thanks to TLAB and generational GC
         */
    }
}
```

---

## 7. Escape Analysis and Stack Allocation

### Escape Analysis Basics

```java
public class EscapeAnalysisDemo {
    
    /**
     * ESCAPE ANALYSIS:
     * 
     * JVM optimization that determines if object escapes its scope
     * 
     * Object ESCAPES if:
     * 1. Returned from method
     * 2. Assigned to static field
     * 3. Assigned to field of escaping object
     * 4. Passed to unknown method
     * 
     * Object DOESN'T ESCAPE if:
     * - Only used within method
     * - Never leaves method scope
     * 
     * Optimizations when object doesn't escape:
     * 1. Stack allocation (instead of heap)
     * 2. Scalar replacement (remove object, keep fields)
     * 3. Lock elision (remove unnecessary locks)
     */
    
    // Example 1: Object ESCAPES (returned)
    public Point createPoint() {
        Point p = new Point(10, 20);
        return p; // ESCAPES - must allocate on heap
    }
    
    // Example 2: Object DOESN'T ESCAPE
    public int computeDistance() {
        Point p = new Point(10, 20); // Doesn't escape
        return p.x * p.x + p.y * p.y; // Can be stack-allocated or scalar replaced
    }
    
    // Example 3: Object ESCAPES (assigned to field)
    private Point globalPoint;
    
    public void setGlobalPoint() {
        Point p = new Point(10, 20);
        globalPoint = p; // ESCAPES - assigned to field
    }
    
    static class Point {
        int x, y;
        
        Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }
    
    /**
     * OPTIMIZATION EXAMPLE:
     * 
     * Original code:
     * public int compute() {
     *     Point p = new Point(10, 20);
     *     return p.x + p.y;
     * }
     * 
     * After escape analysis + scalar replacement:
     * public int compute() {
     *     int x = 10;  // No object created!
     *     int y = 20;
     *     return x + y;
     * }
     * 
     * Object completely eliminated!
     */
}
```

### Scalar Replacement

```java
public class ScalarReplacementDemo {
    
    /**
     * SCALAR REPLACEMENT:
     * 
     * When object doesn't escape:
     * 1. JVM replaces object with its fields
     * 2. Fields stored in registers or stack
     * 3. No heap allocation
     * 4. No GC overhead
     * 
     * Enabled by: -XX:+DoEscapeAnalysis -XX:+EliminateAllocations
     * (Both enabled by default in Java 8+)
     */
    
    public static void main(String[] args) {
        // Run with: -XX:+PrintCompilation -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining
        
        long start = System.nanoTime();
        long sum = 0;
        
        for (int i = 0; i < 10_000_000; i++) {
            sum += calculateArea(i, i + 1);
        }
        
        long time = System.nanoTime() - start;
        System.out.println("Time: " + time / 1_000_000 + " ms");
        System.out.println("Sum: " + sum);
    }
    
    // After JIT compilation with escape analysis:
    // Rectangle object eliminated via scalar replacement
    public static int calculateArea(int width, int height) {
        Rectangle rect = new Rectangle(width, height);
        return rect.getArea(); // Object doesn't escape
    }
    
    static class Rectangle {
        private final int width;
        private final int height;
        
        Rectangle(int width, int height) {
            this.width = width;
            this.height = height;
        }
        
        int getArea() {
            return width * height;
        }
    }
    
    /**
     * BYTECODE vs OPTIMIZED CODE:
     * 
     * Original bytecode:
     * 0: new Rectangle          // Allocate object
     * 3: dup
     * 4: iload_0                // Load width
     * 5: iload_1                // Load height
     * 6: invokespecial <init>   // Call constructor
     * 9: astore_2               // Store reference
     * 10: aload_2               // Load reference
     * 11: invokevirtual getArea // Call method
     * 14: ireturn
     * 
     * After optimization (scalar replacement):
     * 0: iload_0                // Load width
     * 1: iload_1                // Load height
     * 2: imul                   // Multiply
     * 3: ireturn
     * 
     * Object allocation completely removed!
     * Method calls inlined!
     */
}
```

### Lock Elision

```java
public class LockElisionDemo {
    
    /**
     * LOCK ELISION:
     * 
     * When object doesn't escape and is locked:
     * JVM can remove synchronization overhead
     * 
     * Conditions:
     * 1. Object doesn't escape
     * 2. Lock never contended
     * 3. Lock only used locally
     */
    
    public static void main(String[] args) {
        long start = System.nanoTime();
        
        for (int i = 0; i < 1_000_000; i++) {
            processWithLock();
        }
        
        long time = System.nanoTime() - start;
        System.out.println("Time: " + time / 1_000_000 + " ms");
    }
    
    // Lock can be eliminated by JVM
    public static void processWithLock() {
        // Local object - doesn't escape
        Object lock = new Object();
        
        synchronized (lock) {
            // No actual synchronization needed!
            // JVM can remove the lock
            int x = 10;
            int y = 20;
            int z = x + y;
        }
    }
    
    /**
     * OPTIMIZATION:
     * 
     * Original:
     * synchronized (lock) {
     *     // code
     * }
     * 
     * After lock elision:
     * // code (no synchronization)
     * 
     * Lock completely removed!
     */
    
    /**
     * WHEN LOCK CANNOT BE ELIMINATED:
     * 
     * 1. Object escapes:
     * private Object sharedLock = new Object();
     * synchronized (sharedLock) { ... } // Cannot elide
     * 
     * 2. Lock passed to another method:
     * Object lock = new Object();
     * someMethod(lock); // Lock escapes
     * synchronized (lock) { ... } // Cannot elide
     * 
     * 3. Lock used across threads:
     * // Lock is shared - cannot elide
     */
}
```

---

## 8. String Pool Internals

### String Pool Location and Behavior

```java
public class StringPoolDemo {
    
    /**
     * STRING POOL (String Intern Pool):
     * 
     * Location:
     * - Java 6: PermGen (fixed size, GC'd rarely)
     * - Java 7+: Heap (dynamic size, GC'd normally)
     * 
     * Purpose:
     * - Store unique string literals
     * - Reuse string objects
     * - Save memory
     * 
     * Size:
     * - Java 7: ~60,000 entries default
     * - Configurable: -XX:StringTableSize=100000
     * - Resizing: -XX:+PrintStringTableStatistics
     */
    
    public static void main(String[] args) {
        // String literals go to pool automatically
        String s1 = "Hello";
        String s2 = "Hello";
        
        System.out.println(s1 == s2); // true - same object in pool
        
        // new String() creates heap object
        String s3 = new String("Hello");
        
        System.out.println(s1 == s3); // false - different objects
        
        // intern() adds to pool if not present
        String s4 = s3.intern();
        
        System.out.println(s1 == s4); // true - intern returns pooled object
        
        /**
         * MEMORY LAYOUT:
         * 
         * STRING POOL (Heap):
         * ┌──────────────────────┐
         * │ "Hello" @ 0xAAA      │ ←─┐
         * │ "World" @ 0xBBB      │   │
         * └──────────────────────┘   │
         *                            │
         * STACK:                     │
         * ┌──────────────────────┐   │
         * │ s1 = 0xAAA ──────────┼───┘
         * │ s2 = 0xAAA ──────────┼───┐ (same reference)
         * └──────────────────────┘   │
         *                            │
         * HEAP (non-pooled):         │
         * ┌──────────────────────┐   │
         * │ String @ 0xCCC       │   │
         * │  value = 0xAAA ──────┼───┘ (points to pooled char array)
         * └──────────────────────┘
         *          ↑
         * STACK:   │
         * ┌────────────────┐
         * │ s3 = 0xCCC ────┘
         * └────────────────┘
         */
    }
    
    /**
     * STRING CONCATENATION:
     * 
     * Compile-time concatenation:
     */
    public void compileTimeConcatenation() {
        String s1 = "Hello" + "World"; // Compiled to "HelloWorld"
        String s2 = "HelloWorld";
        
        System.out.println(s1 == s2); // true - same pooled string
    }
    
    /**
     * Runtime concatenation:
     */
    public void runtimeConcatenation() {
        String s1 = "Hello";
        String s2 = "World";
        String s3 = s1 + s2; // StringBuilder used at runtime
        String s4 = "HelloWorld";
        
        System.out.println(s3 == s4); // false - s3 is heap object
        System.out.println(s3.equals(s4)); // true - content is same
    }
}
```

### String Pool Performance

```java
public class StringPoolPerformanceDemo {
    
    /**
     * PERFORMANCE CONSIDERATIONS:
     * 
     * String pool is implemented as HashMap
     * - Key: String hash
     * - Value: String reference
     * 
     * Performance:
     * - Lookup: O(1) average
     * - Insert: O(1) average
     * - But can degrade with collisions
     */
    
    public static void main(String[] args) {
        // Benchmark intern() performance
        long start = System.currentTimeMillis();
        
        for (int i = 0; i < 100_000; i++) {
            String s = ("String" + i).intern();
        }
        
        long internTime = System.currentTimeMillis() - start;
        System.out.println("Intern time: " + internTime + " ms");
        
        // Benchmark without intern
        start = System.currentTimeMillis();
        
        for (int i = 0; i < 100_000; i++) {
            String s = "String" + i;
        }
        
        long noInternTime = System.currentTimeMillis() - start;
        System.out.println("No intern time: " + noInternTime + " ms");
        
        /**
         * TYPICAL RESULTS:
         * 
         * With intern(): ~100-200 ms
         * Without intern(): ~50-100 ms
         * 
         * Intern is slower but saves memory!
         */
    }
    
    /**
     * WHEN TO USE intern():
     * 
     * Use intern():
     * ✓ Many duplicate strings
     * ✓ Strings from external sources (files, network)
     * ✓ Memory is concern
     * ✓ String comparison performance matters
     * 
     * Don't use intern():
     * ✗ Few duplicates
     * ✗ Short-lived strings
     * ✗ Already using string literals
     * ✗ Performance critical (intern has overhead)
     */
    
    /**
     * MEMORY SAVINGS EXAMPLE:
     */
    public void memorySavingsExample() {
        // Without intern: 1,000,000 string objects
        List<String> strings1 = new ArrayList<>();
        for (int i = 0; i < 1_000_000; i++) {
            strings1.add(new String("duplicate")); // 1M objects
        }
        
        // With intern: 1 string object (+ 1M references)
        List<String> strings2 = new ArrayList<>();
        for (int i = 0; i < 1_000_000; i++) {
            strings2.add(new String("duplicate").intern()); // 1 object!
        }
        
        /**
         * Memory usage:
         * Without intern: ~40 MB (40 bytes * 1M)
         * With intern: ~4 MB (4 bytes * 1M references)
         * 
         * Savings: 90%!
         */
    }
}
```

### String Deduplication

```java
public class StringDeduplicationDemo {
    
    /**
     * STRING DEDUPLICATION (Java 8u20+):
     * 
     * Background GC process that finds duplicate strings
     * and makes them share the same char array
     * 
     * Enable with:
     * -XX:+UseStringDeduplication
     * -XX:+UseG1GC (requires G1 GC)
     * 
     * How it works:
     * 1. G1 GC identifies duplicate strings
     * 2. Makes them point to same char array
     * 3. Happens during GC, not at allocation
     * 
     * Different from intern():
     * - Automatic (no code changes)
     * - Works on heap strings
     * - Doesn't use string pool
     */
    
    public static void main(String[] args) {
        // Run with: -XX:+UseG1GC -XX:+UseStringDeduplication
        
        List<String> strings = new ArrayList<>();
        
        // Create many duplicate strings (not interned)
        for (int i = 0; i < 1_000_000; i++) {
            strings.add(new String("duplicate value")); // Heap strings
        }
        
        // Force GC to trigger deduplication
        System.gc();
        
        /**
         * BEFORE DEDUPLICATION:
         * String 1: char[] @ 0x1000
         * String 2: char[] @ 0x2000
         * String 3: char[] @ 0x3000
         * ... (1M char arrays)
         * 
         * AFTER DEDUPLICATION:
         * String 1: char[] @ 0x1000
         * String 2: char[] @ 0x1000 (shared!)
         * String 3: char[] @ 0x1000 (shared!)
         * ... (1 char array)
         * 
         * Memory saved: ~99%!
         */
        
        // Monitor with: -XX:+PrintStringDeduplicationStatistics
    }
    
    /**
     * DEDUPLICATION STATISTICS:
     * 
     * Example output:
     * [String Deduplication: 
     *   Inspected: 1000000
     *   Deduplicated: 999999
     *   Savings: 39.99 MB
     * ]
     */
}
```

---

## Summary

### Key Takeaways

**Heap Memory:**

- Young Gen: Eden (new objects) + Survivor (survived GC)
- Old Gen: Long-lived objects
- Metaspace: Class metadata, static variables
- Minor GC fast, Major GC slow

**Stack Memory:**

- One per thread
- Stores primitives and references
- Method call frames
- LIFO structure

**Direct Memory:**

- Off-heap, native memory
- Faster I/O
- Manual management
- Not GC'd

**Optimizations:**

- TLAB: Fast thread-local allocation
- Escape Analysis: Stack allocation possible
- Scalar Replacement: Eliminate object creation
- Lock Elision: Remove unnecessary locks

**String Pool:**

- In heap (Java 7+)
- Reuses string literals
- intern() for manual pooling
- String deduplication with G1 GC

### Memory Tuning Flags

```bash
# Heap sizes
-Xms2g                    # Initial heap
-Xmx4g                    # Maximum heap
-Xmn1g                    # Young generation size

# Metaspace
-XX:MetaspaceSize=128m    # Initial metaspace
-XX:MaxMetaspaceSize=512m # Maximum metaspace

# Stack size
-Xss512k                  # Stack size per thread

# Direct memory
-XX:MaxDirectMemorySize=1g

# GC options
-XX:NewRatio=2            # Old/Young ratio
-XX:SurvivorRatio=8       # Eden/Survivor ratio
-XX:MaxTenuringThreshold=15 # GCs before promotion

# String pool
-XX:StringTableSize=100000

# TLAB
-XX:+UseTLAB
-XX:TLABSize=256k

# Escape analysis
-XX:+DoEscapeAnalysis
-XX:+EliminateAllocations

# String deduplication
-XX:+UseG1GC
-XX:+UseStringDeduplication
```

---
