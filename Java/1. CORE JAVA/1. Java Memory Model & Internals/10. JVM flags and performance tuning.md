# JVM Flags and Performance Tuning

## Overview

Mastering JVM performance tuning requires understanding flags, profiling tools, and systematic troubleshooting. This guide provides production-ready advice for optimizing Java applications, from development through production deployment.

---

## 1. Diagnostic Flags (-XX:+PrintFlagsFinal)

### Discovering JVM Flags

```bash
#!/bin/bash

# ============================================================================
# DISCOVERING JVM FLAGS
# ============================================================================

# 1. Print all JVM flags with their current values
java -XX:+PrintFlagsFinal -version

# Output format:
# [Global flags]
#     intx ActiveProcessorCount    = -1        {product}
#   size_t AdaptiveSizeDecrementScaleFactor = 4        {product}
#   size_t AdaptiveSizeMajorGCDecayTimeScale = 10       {product}
#     bool UseG1GC                 = true      {product}
# 
# Columns:
# - Type: intx, size_t, bool, uintx, etc.
# - Name: Flag name
# - = : Assignment
# - Value: Current value
# - Origin: {product}, {manageable}, {diagnostic}, {experimental}

# 2. Print only modified flags
java -XX:+PrintCommandLineFlags -version

# Output:
# -XX:InitialHeapSize=268435456 -XX:MaxHeapSize=4294967296 -XX:+UseG1GC
#
# Shows only flags different from defaults

# 3. Filter specific flags
java -XX:+PrintFlagsFinal -version | grep -i "heap"

# Examples:
#   size_t InitialHeapSize         = 268435456 {product}
#   size_t MaxHeapSize             = 4294967296 {product}
#   size_t MinHeapSize             = 8388608    {product}

# 4. Search for GC-related flags
java -XX:+PrintFlagsFinal -version | grep -E "GC|gc"

# 5. Show experimental flags (require -XX:+UnlockExperimentalVMOptions)
java -XX:+UnlockExperimentalVMOptions -XX:+PrintFlagsFinal -version | grep "experimental"

# 6. Show diagnostic flags (require -XX:+UnlockDiagnosticVMOptions)
java -XX:+UnlockDiagnosticVMOptions -XX:+PrintFlagsFinal -version | grep "diagnostic"
```

### Flag Categories

```bash
#!/bin/bash

# ============================================================================
# FLAG CATEGORIES
# ============================================================================

# STANDARD FLAGS (cross-platform, stable)
# -----------------------------------------
-Xms2g              # Initial heap size
-Xmx4g              # Maximum heap size
-Xss1m              # Thread stack size
-verbose:gc         # Basic GC logging
-Xlog:gc            # Modern GC logging (Java 9+)

# -XX FLAGS (platform-specific, may change)
# -----------------------------------------

# PRODUCT FLAGS (stable, production-ready)
-XX:+UseG1GC                    # Enable G1 collector
-XX:MaxGCPauseMillis=200        # GC pause goal
-XX:ParallelGCThreads=8         # Parallel GC threads

# MANAGEABLE FLAGS (can change at runtime via JMX)
-XX:+HeapDumpOnOutOfMemoryError # Dump heap on OOM
-XX:HeapDumpPath=/tmp/dumps     # Dump location

# DIAGNOSTIC FLAGS (require unlock)
-XX:+UnlockDiagnosticVMOptions
-XX:+PrintInlining              # Print inlining decisions
-XX:+LogCompilation             # Log JIT compilation

# EXPERIMENTAL FLAGS (require unlock, may change/remove)
-XX:+UnlockExperimentalVMOptions
-XX:+UseEpsilonGC               # No-op GC (experimental)
-XX:+UseShenandoahGC            # Shenandoah GC (experimental in Java 12-14)

# ============================================================================
# FLAG SYNTAX
# ============================================================================

# Boolean flags (enable/disable)
-XX:+UseG1GC                    # Enable (+ prefix)
-XX:-UseConcMarkSweepGC         # Disable (- prefix)

# Numeric flags
-XX:MaxGCPauseMillis=200        # Integer value
-XX:InitialHeapSize=2g          # Size (supports k, m, g suffixes)
-XX:GCTimeRatio=19              # Ratio (1:19 = 5% GC time)

# String flags
-XX:HeapDumpPath=/tmp/dumps     # Path or string value

# Multiple values
-Xlog:gc*:file=gc.log:time,level,tags
# Format: category:output:decorators

# ============================================================================
# COMMON FLAG PATTERNS
# ============================================================================

# Development (verbose output, debugging)
java -Xms512m -Xmx2g \
     -XX:+PrintCommandLineFlags \
     -XX:+PrintFlagsFinal \
     -XX:+UnlockDiagnosticVMOptions \
     -XX:+PrintInlining \
     -Xlog:gc*:file=gc.log:time,level,tags \
     -jar myapp.jar

# Production (optimized, monitoring)
java -Xms4g -Xmx4g \
     -XX:+UseG1GC \
     -XX:MaxGCPauseMillis=200 \
     -XX:+HeapDumpOnOutOfMemoryError \
     -XX:HeapDumpPath=/var/dumps \
     -XX:+ExitOnOutOfMemoryError \
     -Xlog:gc*:file=/var/log/gc.log:time,level,tags \
     -Dcom.sun.management.jmxremote \
     -Dcom.sun.management.jmxremote.port=9010 \
     -jar myapp.jar

# Performance testing (detailed metrics)
java -Xms8g -Xmx8g \
     -XX:+UseG1GC \
     -XX:+FlightRecorder \
     -XX:StartFlightRecording=duration=60s,filename=recording.jfr \
     -XX:+UnlockDiagnosticVMOptions \
     -XX:+PrintCompilation \
     -XX:+PrintInlining \
     -XX:+LogCompilation \
     -Xlog:gc*:file=gc.log:time,level,tags \
     -jar myapp.jar
```

### Verifying Applied Flags

```java
/**
 * PROGRAMMATIC FLAG ACCESS
 */

import java.lang.management.ManagementFactory;
import java.lang.management.RuntimeMXBean;
import java.util.List;

public class FlagVerification {
    
    /**
     * Get all JVM input arguments
     */
    public static void printVMArguments() {
        RuntimeMXBean runtimeMxBean = ManagementFactory.getRuntimeMXBean();
        List<String> arguments = runtimeMxBean.getInputArguments();
        
        System.out.println("=== JVM Arguments ===");
        for (String arg : arguments) {
            System.out.println(arg);
        }
        
        /**
         * Example output:
         * -Xms4g
         * -Xmx4g
         * -XX:+UseG1GC
         * -XX:MaxGCPauseMillis=200
         */
    }
    
    /**
     * Check specific settings
     */
    public static void checkMemorySettings() {
        Runtime runtime = Runtime.getRuntime();
        
        long maxMemory = runtime.maxMemory();
        long totalMemory = runtime.totalMemory();
        long freeMemory = runtime.freeMemory();
        
        System.out.println("=== Memory Settings ===");
        System.out.printf("Max heap (-Xmx):   %,d MB%n", maxMemory / (1024 * 1024));
        System.out.printf("Total heap:        %,d MB%n", totalMemory / (1024 * 1024));
        System.out.printf("Free heap:         %,d MB%n", freeMemory / (1024 * 1024));
        System.out.printf("Used heap:         %,d MB%n", 
            (totalMemory - freeMemory) / (1024 * 1024));
        
        /**
         * Example output:
         * Max heap (-Xmx):   4,096 MB
         * Total heap:        2,048 MB
         * Free heap:         1,500 MB
         * Used heap:         548 MB
         */
    }
    
    /**
     * Check GC configuration
     */
    public static void checkGCSettings() {
        List<java.lang.management.GarbageCollectorMXBean> gcBeans = 
            ManagementFactory.getGarbageCollectorMXBeans();
        
        System.out.println("=== Garbage Collectors ===");
        for (java.lang.management.GarbageCollectorMXBean gcBean : gcBeans) {
            System.out.printf("Name: %s%n", gcBean.getName());
            System.out.printf("  Collection count: %,d%n", gcBean.getCollectionCount());
            System.out.printf("  Collection time:  %,d ms%n", gcBean.getCollectionTime());
            System.out.printf("  Memory pools: %s%n", 
                String.join(", ", gcBean.getMemoryPoolNames()));
        }
        
        /**
         * Example output (G1GC):
         * Name: G1 Young Generation
         *   Collection count: 150
         *   Collection time:  1,250 ms
         *   Memory pools: G1 Eden Space, G1 Survivor Space
         * 
         * Name: G1 Old Generation
         *   Collection count: 5
         *   Collection time:  450 ms
         *   Memory pools: G1 Old Gen
         */
    }
    
    public static void main(String[] args) {
        printVMArguments();
        System.out.println();
        checkMemorySettings();
        System.out.println();
        checkGCSettings();
    }
}
```

---

## 2. Heap Sizing Recommendations

### Heap Sizing Guidelines

```bash
#!/bin/bash

# ============================================================================
# HEAP SIZING PRINCIPLES
# ============================================================================

# RULE 1: Set -Xms and -Xmx to same value
# -----------------------------------------
# Prevents heap resizing during runtime
# Reduces allocation overhead
# More predictable performance

-Xms4g -Xmx4g    # Good: Same value
-Xms1g -Xmx4g    # Bad: Will resize dynamically

# RULE 2: Leave room for non-heap memory
# -----------------------------------------
# Total memory = Heap + Metaspace + Native + OS
# Example: 8GB server
# - Heap: 4-5GB
# - Metaspace: 256-512MB
# - Native: 512MB-1GB (DirectByteBuffer, threads, code cache)
# - OS: 1-2GB
# - Buffer: 512MB-1GB (safety margin)

# RULE 3: Consider GC pause goals
# -----------------------------------------
# Larger heap = More data = Longer GC pauses
# Smaller heap = More frequent GC = More overhead

# For G1GC (default Java 9+):
-Xms4g -Xmx4g -XX:MaxGCPauseMillis=200

# For ZGC (low latency):
-Xms8g -Xmx8g -XX:+UseZGC

# ============================================================================
# SIZING BY WORKLOAD
# ============================================================================

# MICROSERVICE (container-based)
# -----------------------------------------
# Small footprint, fast startup
-Xms256m -Xmx512m
-XX:+UseSerialGC              # Smallest overhead
-XX:MaxRAMPercentage=75.0     # Container-aware

# WEB APPLICATION (medium traffic)
# -----------------------------------------
# Balanced performance
-Xms2g -Xmx2g
-XX:+UseG1GC
-XX:MaxGCPauseMillis=200
-XX:+UseStringDeduplication

# HIGH-THROUGHPUT BATCH PROCESSING
# -----------------------------------------
# Maximize throughput, pauses acceptable
-Xms8g -Xmx8g
-XX:+UseParallelGC
-XX:GCTimeRatio=19            # 5% GC time
-XX:ParallelGCThreads=8

# LOW-LATENCY TRADING SYSTEM
# -----------------------------------------
# Sub-millisecond pause requirement
-Xms16g -Xmx16g
-XX:+UseZGC
-XX:ZCollectionInterval=5     # Proactive GC every 5s
-XX:+UseLargePages

# LARGE DATA ANALYTICS
# -----------------------------------------
# Large heap, infrequent GC
-Xms32g -Xmx32g
-XX:+UseG1GC
-XX:G1HeapRegionSize=32m      # Larger regions for large heap
-XX:MaxGCPauseMillis=1000     # Can tolerate longer pauses

# ============================================================================
# CONTAINER SIZING (Docker/Kubernetes)
# ============================================================================

# PERCENTAGE-BASED (Java 10+)
# -----------------------------------------
# Recommended for containers
-XX:InitialRAMPercentage=75.0    # Initial heap as % of container memory
-XX:MaxRAMPercentage=75.0        # Max heap as % of container memory
-XX:MinRAMPercentage=50.0        # Min heap as % (when total < 200MB)

# Example: 4GB container
# -XX:MaxRAMPercentage=75.0 → 3GB heap (leaves 1GB for OS/native)

# ABSOLUTE VALUES
# -----------------------------------------
# More predictable, works on all Java versions
# Container: 4GB → Heap: 3GB
-Xms3g -Xmx3g

# Kubernetes deployment example:
# resources:
#   limits:
#     memory: "4Gi"
#   requests:
#     memory: "4Gi"
# env:
#   - name: JAVA_OPTS
#     value: "-Xms3g -Xmx3g -XX:+UseG1GC"

# ============================================================================
# GENERATION SIZING (for generational GCs)
# ============================================================================

# Young generation sizing
# -----------------------------------------
-XX:NewRatio=2                # Old:Young ratio (default: 2 = 1/3 young)
-XX:NewSize=1g                # Initial young gen size
-XX:MaxNewSize=1g             # Max young gen size

# Or use absolute young generation size:
-Xmn1g                        # Sets both NewSize and MaxNewSize

# Survivor space sizing
# -----------------------------------------
-XX:SurvivorRatio=8           # Eden:Survivor ratio (8 = Eden is 8x survivor)
# With SurvivorRatio=8:
# Eden = 80% of young gen
# Survivor1 = 10% of young gen
# Survivor2 = 10% of young gen

# ============================================================================
# HEAP SIZING CALCULATION
# ============================================================================

# Step 1: Measure actual usage
# Run application under load
# Check heap usage: jstat -gc <pid> 1000 100
# Or: JVisualVM, JConsole

# Step 2: Calculate minimums
# Peak heap usage: 2GB
# Safety margin: 1.5-2x → 3-4GB

# Step 3: Choose heap size
# Development: Peak × 1.5 = 3GB
# Production: Peak × 2 = 4GB

# Step 4: Test and validate
# Load test with chosen size
# Monitor GC behavior
# Adjust based on results

# ============================================================================
# MONITORING HEAP SIZE
# ============================================================================

# Runtime monitoring
jstat -gc <pid> 1000

# Output:
# S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     
# 10240  10240   0     8192    81920    40960    204800    102400   51200

# Columns:
# S0C/S1C: Survivor space capacity
# S0U/S1U: Survivor space used
# EC: Eden capacity
# EU: Eden used
# OC: Old generation capacity
# OU: Old generation used
# MC: Metaspace capacity

# Calculate percentages
# Young gen usage: (S0U + S1U + EU) / (S0C + S1C + EC) × 100
# Old gen usage: OU / OC × 100
```

### Heap Sizing Decision Tree

```
┌─────────────────────────────────────────┐
│   What's your primary constraint?      │
└─────────────────────────┬───────────────┘
                          │
          ┌───────────────┼───────────────┐
          │               │               │
    ┌─────▼─────┐   ┌────▼────┐   ┌─────▼─────┐
    │  Memory   │   │ Latency │   │Throughput │
    │  Limited  │   │  Goals  │   │   Goals   │
    └─────┬─────┘   └────┬────┘   └─────┬─────┘
          │              │              │
    ┌─────▼─────────────────────────────▼─────┐
    │                                          │
    │  < 1GB          → SerialGC + small heap │
    │  1-4GB          → G1GC + medium heap    │
    │  4-32GB         → G1GC + large heap     │
    │  > 32GB         → ZGC or G1GC           │
    │                                          │
    │  Sub-10ms pause → ZGC (16GB+)           │
    │  < 100ms pause  → G1GC (any size)       │
    │  Pause OK       → ParallelGC (any)      │
    │                                          │
    │  Max throughput → ParallelGC + large    │
    │  Balanced       → G1GC + medium         │
    │  Low latency    → ZGC + large           │
    └──────────────────────────────────────────┘
```

---

## 3. GC Tuning for Throughput vs Latency

### Throughput-Focused Tuning

```bash
#!/bin/bash

# ============================================================================
# THROUGHPUT OPTIMIZATION (Batch Processing, Analytics)
# ============================================================================

# Goal: Maximize work done, minimize time in GC
# Acceptable: Longer, less frequent pauses

# PARALLEL GC (best for throughput)
# -----------------------------------------
java -Xms8g -Xmx8g \
     -XX:+UseParallelGC \
     -XX:ParallelGCThreads=8 \
     -XX:GCTimeRatio=19 \
     -XX:MaxGCPauseMillis=1000 \
     -XX:+UseAdaptiveSizePolicy \
     -jar batch-processor.jar

# Flag explanations:
# -XX:GCTimeRatio=19
#   → Target: 1/(1+19) = 5% time in GC, 95% application
#   → Higher = less GC overhead
#   → Range: 1-99, default: 99 (1% GC time)

# -XX:MaxGCPauseMillis=1000
#   → Soft goal, not guarantee
#   → JVM will try to keep pauses under 1 second
#   → May sacrifice throughput to meet goal

# -XX:ParallelGCThreads=8
#   → Number of threads for parallel GC
#   → Default: min(CPUs, 8 + (CPUs-8)*5/8)
#   → 8 cores → 8 threads
#   → 16 cores → 13 threads

# -XX:+UseAdaptiveSizePolicy
#   → Auto-tune generation sizes
#   → Enabled by default
#   → Balances pause times vs throughput

# LARGE YOUNG GENERATION
# -----------------------------------------
# Longer time between collections
# More throughput, longer pauses

java -Xms8g -Xmx8g \
     -Xmn4g \
     -XX:+UseParallelGC \
     -XX:SurvivorRatio=6 \
     -jar batch-processor.jar

# -Xmn4g: 50% of heap for young gen (aggressive)
# -XX:SurvivorRatio=6: Larger Eden (75% of young gen)

# DISABLE CONCURRENT GC
# -----------------------------------------
# Use full stop-the-world collections for maximum throughput

java -Xms16g -Xmx16g \
     -XX:+UseParallelGC \
     -XX:ParallelGCThreads=16 \
     -XX:-UseParallelOldGC \
     -jar batch-processor.jar

# ============================================================================
# THROUGHPUT MONITORING
# ============================================================================

# Calculate throughput from GC logs
# Throughput = (Total time - GC time) / Total time × 100

# Example GC log analysis:
# Total runtime: 3600s (1 hour)
# Total GC time: 180s
# Throughput: (3600 - 180) / 3600 = 95%

# Monitor with jstat:
jstat -gcutil <pid> 1000

# Output shows percentages:
# S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT
# 0.00  95.53  67.38  45.23  96.84  92.36   342    2.156    5    1.234    3.390

# YGC: Young GC count
# YGCT: Young GC time (seconds)
# FGC: Full GC count
# FGCT: Full GC time (seconds)
# GCT: Total GC time (seconds)

# Calculate throughput:
# Runtime = <current time - start time>
# Throughput = (Runtime - GCT) / Runtime × 100
```

### Latency-Focused Tuning

```bash
#!/bin/bash

# ============================================================================
# LATENCY OPTIMIZATION (Web Apps, APIs, Trading)
# ============================================================================

# Goal: Minimize pause times, consistent performance
# Acceptable: Lower throughput, higher GC overhead

# G1GC (good balance)
# -----------------------------------------
java -Xms4g -Xmx4g \
     -XX:+UseG1GC \
     -XX:MaxGCPauseMillis=100 \
     -XX:G1ReservePercent=10 \
     -XX:InitiatingHeapOccupancyPercent=45 \
     -XX:G1HeapRegionSize=8m \
     -XX:ConcGCThreads=2 \
     -XX:+UseStringDeduplication \
     -jar web-app.jar

# Flag explanations:
# -XX:MaxGCPauseMillis=100
#   → Target: 100ms pause time
#   → G1 will adjust to meet target
#   → Lower = more concurrent work = higher overhead

# -XX:G1ReservePercent=10
#   → Reserve 10% of heap as buffer
#   → Prevents evacuation failures
#   → Increase if seeing "to-space exhausted"

# -XX:InitiatingHeapOccupancyPercent=45
#   → Start concurrent cycle at 45% occupancy
#   → Lower = earlier concurrent GC = less risk of Full GC
#   → Higher = less overhead but risk Full GC

# -XX:G1HeapRegionSize=8m
#   → Region size: 1-32MB
#   → Auto-calculated: heap / 2048 regions
#   → Tune for object size distribution
#   → Larger regions for large objects

# -XX:ConcGCThreads=2
#   → Concurrent marking threads
#   → Default: ParallelGCThreads / 4
#   → Increase if marking can't keep up

# ZGC (ultra-low latency)
# -----------------------------------------
java -Xms16g -Xmx16g \
     -XX:+UseZGC \
     -XX:ZCollectionInterval=10 \
     -XX:ZFragmentationLimit=10 \
     -XX:+UseLargePages \
     -XX:+UseTransparentHugePages \
     -jar trading-system.jar

# Flag explanations:
# -XX:+UseZGC
#   → Sub-10ms pauses regardless of heap size
#   → Concurrent, region-based
#   → Minimum 16GB heap recommended

# -XX:ZCollectionInterval=10
#   → Proactive GC every 10 seconds
#   → Prevents heap exhaustion
#   → 0 = disabled (reactive only)

# -XX:ZFragmentationLimit=10
#   → Trigger GC when fragmentation > 10%
#   → Lower = less fragmentation, more GC
#   → Default: 25%

# -XX:+UseLargePages
#   → Use OS large pages (2MB/1GB pages)
#   → Reduces TLB misses
#   → Requires OS configuration

# SHENANDOAH (alternative low-latency)
# -----------------------------------------
java -Xms8g -Xmx8g \
     -XX:+UseShenandoahGC \
     -XX:ShenandoahGCHeuristics=compact \
     -XX:ShenandoahGuaranteedGCInterval=30000 \
     -jar low-latency-app.jar

# Flag explanations:
# -XX:ShenandoahGCHeuristics=compact
#   → Heuristic mode: adaptive, static, compact, aggressive
#   → compact: Favor compaction
#   → adaptive: Default, balanced

# -XX:ShenandoahGuaranteedGCInterval=30000
#   → Force GC every 30 seconds minimum
#   → Prevents heap exhaustion
#   → Milliseconds

# ============================================================================
# LATENCY MONITORING
# ============================================================================

# Track pause times
jstat -gccause <pid> 1000

# Or analyze GC log:
# [0.123s][info][gc] GC(0) Pause Young (Normal) 45M->8M(256M) 12.345ms
#                                                            ^^^^^^^^
#                                                         Pause time

# Parse log for percentiles:
# P50: 50% of pauses below this
# P99: 99% of pauses below this
# P99.9: 99.9% of pauses below this

# Example analysis:
# Total pauses: 1000
# P50: 50ms
# P99: 150ms
# P99.9: 300ms
# Max: 500ms

# For SLA requirements:
# "99% of requests < 100ms" requires P99 pause < 100ms
```

### GC Tuning Strategies

```bash
#!/bin/bash

# ============================================================================
# PROGRESSIVE GC TUNING
# ============================================================================

# PHASE 1: BASELINE (Start here)
# -----------------------------------------
java -Xms4g -Xmx4g \
     -XX:+UseG1GC \
     -Xlog:gc*:file=gc.log:time,level,tags \
     -jar myapp.jar

# Run for 24+ hours
# Analyze: pause times, frequency, allocation rate

# PHASE 2: IF FREQUENT YOUNG GCs
# -----------------------------------------
# Symptom: Young GC every few seconds
# Solution: Increase young generation

java -Xms4g -Xmx4g \
     -XX:+UseG1GC \
     -XX:G1NewSizePercent=30 \
     -XX:G1MaxNewSizePercent=60 \
     -jar myapp.jar

# PHASE 3: IF LONG PAUSE TIMES
# -----------------------------------------
# Symptom: Pauses > 200ms
# Solution: Lower pause goal, increase concurrency

java -Xms4g -Xmx4g \
     -XX:+UseG1GC \
     -XX:MaxGCPauseMillis=100 \
     -XX:ConcGCThreads=4 \
     -XX:InitiatingHeapOccupancyPercent=40 \
     -jar myapp.jar

# PHASE 4: IF TO-SPACE EXHAUSTED
# -----------------------------------------
# Symptom: "to-space exhausted" in logs
# Solution: Reserve more buffer space

java -Xms4g -Xmx4g \
     -XX:+UseG1GC \
     -XX:G1ReservePercent=15 \
     -XX:InitiatingHeapOccupancyPercent=35 \
     -jar myapp.jar

# PHASE 5: IF HIGH ALLOCATION RATE
# -----------------------------------------
# Symptom: Frequent young GCs despite tuning
# Solution: Increase heap, optimize code

java -Xms8g -Xmx8g \
     -XX:+UseG1GC \
     -jar myapp.jar

# And optimize hot paths (reduce allocations)

# PHASE 6: IF NOTHING WORKS
# -----------------------------------------
# Consider different GC

# For latency-critical:
java -Xms16g -Xmx16g \
     -XX:+UseZGC \
     -jar myapp.jar

# For throughput-critical:
java -Xms8g -Xmx8g \
     -XX:+UseParallelGC \
     -jar myapp.jar

# ============================================================================
# GC TUNING CHECKLIST
# ============================================================================

# ✓ Measure first (don't guess)
# ✓ Change one parameter at a time
# ✓ Run load tests after each change
# ✓ Monitor for 24+ hours
# ✓ Document changes and results
# ✓ Keep GC logs enabled in production
# ✓ Set up alerting on GC metrics
# ✓ Review GC logs regularly
```

---

## 4. JIT Compiler Flags

### JIT Optimization Flags

```bash
#!/bin/bash

# ============================================================================
# JIT COMPILER CONFIGURATION
# ============================================================================

# COMPILER SELECTION
# -----------------------------------------
-XX:+TieredCompilation          # Enable tiered compilation (default)
-XX:TieredStopAtLevel=1         # Stop at C1 (fast compile, less optimization)
-XX:TieredStopAtLevel=4         # Full optimization (C2) - default

# Use cases:
# Level 1: Fast startup (microservices, CLIs)
# Level 4: Peak performance (long-running apps)

# CLIENT vs SERVER COMPILER
# -----------------------------------------
-client                          # C1 only (fast compile, lower peak perf)
-server                          # C2 (slow compile, higher peak perf) - default

# Note: -client/-server deprecated, use TieredStopAtLevel instead

# COMPILATION THRESHOLDS
# -----------------------------------------
-XX:CompileThreshold=10000       # C2 compilation threshold (default: 10000)
-XX:Tier3InvocationThreshold=200 # C1 full profile threshold (default: 200)
-XX:Tier4InvocationThreshold=5000 # C2 threshold (default: 5000)

# Lower thresholds = earlier compilation = faster warmup
# Higher thresholds = better profile data = better optimization

# ============================================================================
# OPTIMIZATION CONTROL
# ============================================================================

# INLINING
# -----------------------------------------
-XX:MaxInlineSize=35             # Max bytecode size to inline (default: 35)
-XX:FreqInlineSize=325           # Frequently called method size (default: 325)
-XX:MaxInlineLevel=9             # Max inlining depth (default: 9)
-XX:InlineSmallCode=2000         # Max compiled size (default: 2000)

# Increase for aggressive inlining:
-XX:MaxInlineSize=70 -XX:FreqInlineSize=500

# ESCAPE ANALYSIS
# -----------------------------------------
-XX:+DoEscapeAnalysis            # Enable escape analysis (default: true)
-XX:+EliminateAllocations        # Enable scalar replacement (default: true)
-XX:+EliminateLocks              # Enable lock elision (default: true)

# Disable for debugging:
-XX:-DoEscapeAnalysis

# LOOP OPTIMIZATIONS
# -----------------------------------------
-XX:LoopUnrollLimit=60           # Max loop unroll iterations (default: 60)
-XX:+UseLoopPredicate            # Loop predicate optimization (default: true)
-XX:+RangeCheckElimination       # Remove redundant bounds checks (default: true)

# SPECULATIVE OPTIMIZATIONS
# -----------------------------------------
-XX:+UseTypeSpeculation          # Speculate on types (default: true)
-XX:TypeProfileLevel=222         # Type profiling detail (default: 222)

# ============================================================================
# CODE CACHE
# ============================================================================

# Size configuration
-XX:InitialCodeCacheSize=256m    # Initial code cache size
-XX:ReservedCodeCacheSize=512m   # Max code cache size
-XX:CodeCacheExpansionSize=64k   # Expansion increment

# Default sizes:
# Client: 32MB reserved
# Server: 240MB reserved (Java 11+)

# Monitor code cache:
jstat -compiler <pid>

# If code cache full:
# - Increase ReservedCodeCacheSize
# - Or reduce compiled code with -XX:CompileThreshold

# ============================================================================
# COMPILATION LOGGING
# ============================================================================

# Basic compilation info
-XX:+PrintCompilation

# Output:
#    142   42       3       java.lang.String::charAt (29 bytes)
#    ^^^   ^^       ^       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#     |     |       |                    |
#     |     |       |              Method signature
#     |     |       Compilation level (0-4)
#     |     Compilation ID
#     Timestamp

# Detailed compilation log
-XX:+UnlockDiagnosticVMOptions \
-XX:+LogCompilation \
-XX:LogFile=hotspot.log

# Output: XML log with detailed compilation info
# Use JITWatch tool to analyze: https://github.com/AdoptOpenJDK/jitwatch

# Inlining decisions
-XX:+UnlockDiagnosticVMOptions \
-XX:+PrintInlining

# Output:
#   @ 5   java.lang.String::charAt (29 bytes)   inline (hot)
#   @ 12  java.lang.String::isLatin1 (19 bytes)   inline (hot)
#   @ 24  java.lang.StringUTF16::charAt (11 bytes)   inline (hot)

# ============================================================================
# PRODUCTION TUNING
# ============================================================================

# DEFAULT (good for most apps)
# -----------------------------------------
java -Xms4g -Xmx4g \
     -XX:+TieredCompilation \
     -XX:ReservedCodeCacheSize=512m \
     -jar myapp.jar

# FAST STARTUP (microservices)
# -----------------------------------------
java -Xms512m -Xmx512m \
     -XX:+TieredCompilation \
     -XX:TieredStopAtLevel=1 \
     -XX:ReservedCodeCacheSize=64m \
     -jar microservice.jar

# PEAK PERFORMANCE (long-running)
# -----------------------------------------
java -Xms8g -Xmx8g \
     -XX:+TieredCompilation \
     -XX:CompileThreshold=5000 \
     -XX:ReservedCodeCacheSize=1g \
     -XX:+UseTypeSpeculation \
     -XX:+UseLoopPredicate \
     -jar backend-service.jar

# DEBUGGING COMPILATION ISSUES
# -----------------------------------------
java -Xms4g -Xmx4g \
     -XX:+TieredCompilation \
     -XX:+UnlockDiagnosticVMOptions \
     -XX:+PrintCompilation \
     -XX:+PrintInlining \
     -XX:+LogCompilation \
     -XX:LogFile=compilation.log \
     -jar myapp.jar

# Then analyze with JITWatch
```

### JIT Compiler Monitoring

```java
/**
 * JIT COMPILER MONITORING
 */

import java.lang.management.ManagementFactory;
import java.lang.management.CompilationMXBean;

public class JITMonitoring {
    
    /**
     * Monitor JIT compilation
     */
    public static void monitorCompilation() {
        CompilationMXBean compilationBean = ManagementFactory.getCompilationMXBean();
        
        System.out.println("=== JIT Compiler ===");
        System.out.println("Name: " + compilationBean.getName());
        System.out.println("Total compilation time: " + 
            compilationBean.getTotalCompilationTime() + " ms");
        
        /**
         * Output:
         * Name: HotSpot 64-Bit Tiered Compilers
         * Total compilation time: 5234 ms
         */
    }
    
    /**
     * Track compilation over time
     */
    public static void trackCompilation() throws InterruptedException {
        CompilationMXBean compilationBean = ManagementFactory.getCompilationMXBean();
        
        long lastTime = 0;
        
        for (int i = 0; i < 10; i++) {
            long currentTime = compilationBean.getTotalCompilationTime();
            long delta = currentTime - lastTime;
            
            System.out.printf("Compilation time: %,d ms (+%d ms)%n", 
                currentTime, delta);
            
            lastTime = currentTime;
            Thread.sleep(5000);
        }
        
        /**
         * Shows compilation activity
         * High delta = active compilation (warmup)
         * Low delta = steady state
         */
    }
    
    public static void main(String[] args) throws InterruptedException {
        monitorCompilation();
        System.out.println();
        trackCompilation();
    }
}
```

---

## 5. Profiling with JFR (Java Flight Recorder)

### JFR Basics

```bash
#!/bin/bash

# ============================================================================
# JAVA FLIGHT RECORDER (JFR)
# ============================================================================

# JFR is built-in, low-overhead profiler (< 1% overhead)
# Records events: GC, compilation, threads, I/O, locks, etc.

# ENABLE JFR (Java 11+)
# -----------------------------------------
# JFR enabled by default, no flags needed

# RECORDING OPTIONS
# -----------------------------------------

# Option 1: Start with application
java -XX:StartFlightRecording=duration=60s,filename=recording.jfr \
     -jar myapp.jar

# Option 2: Start via jcmd (runtime)
jcmd <pid> JFR.start duration=60s filename=recording.jfr

# Option 3: Continuous recording (circular buffer)
jcmd <pid> JFR.start name=continuous maxage=1h maxsize=500M

# ============================================================================
# JFR COMMANDS
# ============================================================================

# Start recording
jcmd <pid> JFR.start name=myrecording settings=profile duration=60s filename=rec.jfr

# Parameters:
# - name: Recording identifier
# - settings: default (low overhead) or profile (more events)
# - duration: Recording duration (0 = until stopped)
# - filename: Output file
# - maxage: Max event age in circular buffer
# - maxsize: Max file size

# Check recordings
jcmd <pid> JFR.check

# Output:
# Recording 1: name=myrecording duration=60s (running)

# Dump recording
jcmd <pid> JFR.dump name=myrecording filename=dump.jfr

# Stop recording
jcmd <pid> JFR.stop name=myrecording

# ============================================================================
# JFR SETTINGS
# ============================================================================

# Default (low overhead, < 1%)
-XX:StartFlightRecording=settings=default,filename=rec.jfr

# Profile (more events, ~2% overhead)
-XX:StartFlightRecording=settings=profile,filename=rec.jfr

# Custom settings (create .jfc file)
# Use JDK Mission Control to create custom configuration

# ============================================================================
# ANALYZING JFR FILES
# ============================================================================

# Option 1: JDK Mission Control (GUI)
# Download from: https://jdk.java.net/jmc/
jmc

# Then: File → Open File → Select .jfr file

# Option 2: Command-line (jfr tool, Java 11+)
jfr print recording.jfr

# Summary
jfr summary recording.jfr

# Output:
#  Version: 2.0
#  Chunks: 1
#  Duration: 60 s
#  Start: 2025-01-15 10:00:00
#  GC: G1GC
#  Events: 123,456

# Print specific events
jfr print --events GarbageCollection recording.jfr
jfr print --events CPULoad recording.jfr
jfr print --events ThreadAllocationStatistics recording.jfr

# Export to JSON
jfr print --json recording.jfr > recording.json

# ============================================================================
# PRODUCTION JFR USAGE
# ============================================================================

# CONTINUOUS RECORDING (recommended)
# -----------------------------------------
java -XX:StartFlightRecording=name=continuous,maxage=6h,maxsize=500M,dumponexit=true,filename=/var/logs/jfr/app-%t.jfr \
     -jar myapp.jar

# Explanation:
# - maxage=6h: Keep last 6 hours of events
# - maxsize=500M: Max 500MB circular buffer
# - dumponexit=true: Save on JVM exit
# - filename with %t: Timestamp in filename

# ON-DEMAND RECORDING (troubleshooting)
# -----------------------------------------
# When issue occurs:
jcmd <pid> JFR.start duration=120s filename=/tmp/issue-$(date +%s).jfr

# SCHEDULED RECORDING (cron)
# -----------------------------------------
#!/bin/bash
# Daily JFR recording at 2 AM
0 2 * * * /usr/bin/jcmd $(pgrep -f myapp.jar) JFR.start duration=300s filename=/var/logs/jfr/daily-$(date +\%Y\%m\%d).jfr

# ============================================================================
# KEY EVENTS TO ANALYZE
# ============================================================================

# GC EVENTS
# -----------------------------------------
jfr print --events GarbageCollection,GCPhasePause recording.jfr

# Look for:
# - Pause times
# - Frequency
# - Heap before/after

# ALLOCATION EVENTS
# -----------------------------------------
jfr print --events ObjectAllocationInNewTLAB,ObjectAllocationOutsideTLAB recording.jfr

# Look for:
# - Top allocating classes
# - Allocation rate
# - Large objects

# CPU EVENTS
# -----------------------------------------
jfr print --events CPULoad,ExecutionSample recording.jfr

# Look for:
# - CPU usage patterns
# - Hot methods
# - Thread usage

# THREAD EVENTS
# -----------------------------------------
jfr print --events JavaMonitorEnter,JavaMonitorWait,ThreadPark recording.jfr

# Look for:
# - Lock contention
# - Wait times
# - Thread states

# I/O EVENTS
# -----------------------------------------
jfr print --events FileRead,FileWrite,SocketRead,SocketWrite recording.jfr

# Look for:
# - I/O bottlenecks
# - Slow operations
# - I/O patterns
```

### JFR Analysis Example

```java
/**
 * ANALYZING JFR PROGRAMMATICALLY
 */

import jdk.jfr.consumer.RecordingFile;
import jdk.jfr.consumer.RecordedEvent;
import java.nio.file.Path;
import java.util.*;

public class JFRAnalysis {
    
    /**
     * Analyze GC pauses
     */
    public static void analyzeGC(String jfrFile) throws Exception {
        List<Long> pauseTimes = new ArrayList<>();
        
        try (RecordingFile recording = new RecordingFile(Path.of(jfrFile))) {
            while (recording.hasMoreEvents()) {
                RecordedEvent event = recording.readEvent();
                
                if (event.getEventType().getName().equals("jdk.GarbageCollection")) {
                    long sumPause = event.getLong("sumOfPauses");
                    pauseTimes.add(sumPause);
                }
            }
        }
        
        // Calculate statistics
        Collections.sort(pauseTimes);
        long count = pauseTimes.size();
        long sum = pauseTimes.stream().mapToLong(Long::longValue).sum();
        long avg = sum / count;
        long p50 = pauseTimes.get((int)(count * 0.50));
        long p99 = pauseTimes.get((int)(count * 0.99));
        long max = pauseTimes.get(pauseTimes.size() - 1);
        
        System.out.println("=== GC Pause Analysis ===");
        System.out.printf("Count:   %,d pauses%n", count);
        System.out.printf("Average: %,d ms%n", avg / 1_000_000);
        System.out.printf("P50:     %,d ms%n", p50 / 1_000_000);
        System.out.printf("P99:     %,d ms%n", p99 / 1_000_000);
        System.out.printf("Max:     %,d ms%n", max / 1_000_000);
    }
    
    /**
     * Find top allocating classes
     */
    public static void analyzeAllocations(String jfrFile) throws Exception {
        Map<String, Long> allocations = new HashMap<>();
        
        try (RecordingFile recording = new RecordingFile(Path.of(jfrFile))) {
            while (recording.hasMoreEvents()) {
                RecordedEvent event = recording.readEvent();
                
                if (event.getEventType().getName().contains("ObjectAllocation")) {
                    String className = event.getClass("objectClass").getName();
                    long size = event.getLong("allocationSize");
                    
                    allocations.merge(className, size, Long::sum);
                }
            }
        }
        
        // Sort by size
        List<Map.Entry<String, Long>> sorted = new ArrayList<>(allocations.entrySet());
        sorted.sort((a, b) -> Long.compare(b.getValue(), a.getValue()));
        
        System.out.println("=== Top 10 Allocations ===");
        for (int i = 0; i < Math.min(10, sorted.size()); i++) {
            Map.Entry<String, Long> entry = sorted.get(i);
            System.out.printf("%s: %,d bytes%n", entry.getKey(), entry.getValue());
        }
    }
    
    public static void main(String[] args) throws Exception {
        if (args.length < 1) {
            System.out.println("Usage: java JFRAnalysis <jfr-file>");
            return;
        }
        
        String jfrFile = args[0];
        analyzeGC(jfrFile);
        System.out.println();
        analyzeAllocations(jfrFile);
    }
}
```

---

## 6. Monitoring with JMX

### JMX Configuration

```bash
#!/bin/bash

# ============================================================================
# JMX (Java Management Extensions)
# ============================================================================

# Enable JMX for remote monitoring

# BASIC JMX (no authentication)
# -----------------------------------------
java -Dcom.sun.management.jmxremote \
     -Dcom.sun.management.jmxremote.port=9010 \
     -Dcom.sun.management.jmxremote.authenticate=false \
     -Dcom.sun.management.jmxremote.ssl=false \
     -Dcom.sun.management.jmxremote.local.only=false \
     -jar myapp.jar

# WARNING: No authentication - use only in dev/test!

# SECURE JMX (with authentication)
# -----------------------------------------
# Create password file: jmxremote.password
# monitorRole  password1
# controlRole  password2

# Set permissions: chmod 600 jmxremote.password

# Create access file: jmxremote.access
# monitorRole  readonly
# controlRole  readwrite

java -Dcom.sun.management.jmxremote \
     -Dcom.sun.management.jmxremote.port=9010 \
     -Dcom.sun.management.jmxremote.authenticate=true \
     -Dcom.sun.management.jmxremote.password.file=/path/to/jmxremote.password \
     -Dcom.sun.management.jmxremote.access.file=/path/to/jmxremote.access \
     -Dcom.sun.management.jmxremote.ssl=true \
     -Dcom.sun.management.jmxremote.registry.ssl=true \
     -Djavax.net.ssl.keyStore=/path/to/keystore \
     -Djavax.net.ssl.keyStorePassword=password \
     -jar myapp.jar

# SSL JMX (recommended for production)
# -----------------------------------------
# Generate keystore:
keytool -genkeypair -alias jmx -keyalg RSA -keystore jmx.keystore

java -Dcom.sun.management.jmxremote \
     -Dcom.sun.management.jmxremote.port=9010 \
     -Dcom.sun.management.jmxremote.authenticate=true \
     -Dcom.sun.management.jmxremote.password.file=/etc/jmx/password \
     -Dcom.sun.management.jmxremote.access.file=/etc/jmx/access \
     -Dcom.sun.management.jmxremote.ssl=true \
     -Djavax.net.ssl.keyStore=/etc/jmx/jmx.keystore \
     -Djavax.net.ssl.keyStorePassword=changeit \
     -jar myapp.jar

# ============================================================================
# CONNECTING TO JMX
# ============================================================================

# Option 1: JConsole (GUI)
jconsole hostname:9010

# Option 2: VisualVM (GUI)
jvisualvm
# Then: File → Add JMX Connection → hostname:9010

# Option 3: jmxterm (CLI)
# Download from: https://github.com/jiaqi/jmxterm
java -jar jmxterm.jar
# > open hostname:9010
# > domains
# > domain java.lang
# > beans
# > bean java.lang:type=Memory
# > get HeapMemoryUsage

# Option 4: Programmatic (Java)
# See examples below
```

### JMX Monitoring Code

```java
/**
 * JMX MONITORING EXAMPLES
 */

import javax.management.*;
import javax.management.remote.*;
import java.lang.management.*;
import java.util.*;

public class JMXMonitoring {
    
    /**
     * Connect to remote JMX
     */
    public static MBeanServerConnection connect(String host, int port) 
            throws Exception {
        String url = String.format("service:jmx:rmi:///jndi/rmi://%s:%d/jmxrmi", 
            host, port);
        
        JMXServiceURL serviceURL = new JMXServiceURL(url);
        JMXConnector connector = JMXConnectorFactory.connect(serviceURL);
        
        return connector.getMBeanServerConnection();
    }
    
    /**
     * Monitor memory usage
     */
    public static void monitorMemory(MBeanServerConnection mbs) throws Exception {
        ObjectName memoryBean = new ObjectName("java.lang:type=Memory");
        
        // Heap memory
        CompositeData heapMemory = 
            (CompositeData) mbs.getAttribute(memoryBean, "HeapMemoryUsage");
        
        long used = (Long) heapMemory.get("used");
        long max = (Long) heapMemory.get("max");
        long committed = (Long) heapMemory.get("committed");
        
        System.out.println("=== Heap Memory ===");
        System.out.printf("Used:      %,d MB%n", used / (1024 * 1024));
        System.out.printf("Committed: %,d MB%n", committed / (1024 * 1024));
        System.out.printf("Max:       %,d MB%n", max / (1024 * 1024));
        System.out.printf("Usage:     %.1f%%%n", (double)used / max * 100);
        
        // Non-heap memory
        CompositeData nonHeapMemory = 
            (CompositeData) mbs.getAttribute(memoryBean, "NonHeapMemoryUsage");
        
        used = (Long) nonHeapMemory.get("used");
        committed = (Long) nonHeapMemory.get("committed");
        
        System.out.println("\n=== Non-Heap Memory ===");
        System.out.printf("Used:      %,d MB%n", used / (1024 * 1024));
        System.out.printf("Committed: %,d MB%n", committed / (1024 * 1024));
    }
    
    /**
     * Monitor GC statistics
     */
    public static void monitorGC(MBeanServerConnection mbs) throws Exception {
        ObjectName gcQuery = new ObjectName("java.lang:type=GarbageCollector,*");
        Set<ObjectName> gcBeans = mbs.queryNames(gcQuery, null);
        
        System.out.println("=== Garbage Collectors ===");
        for (ObjectName gcBean : gcBeans) {
            String name = (String) mbs.getAttribute(gcBean, "Name");
            Long count = (Long) mbs.getAttribute(gcBean, "CollectionCount");
            Long time = (Long) mbs.getAttribute(gcBean, "CollectionTime");
            
            System.out.printf("%s:%n", name);
            System.out.printf("  Collections: %,d%n", count);
            System.out.printf("  Time:        %,d ms%n", time);
            if (count > 0) {
                System.out.printf("  Avg time:    %.2f ms%n", 
                    (double)time / count);
            }
        }
    }
    
    /**
     * Monitor threads
     */
    public static void monitorThreads(MBeanServerConnection mbs) throws Exception {
        ObjectName threadBean = new ObjectName("java.lang:type=Threading");
        
        Integer threadCount = 
            (Integer) mbs.getAttribute(threadBean, "ThreadCount");
        Integer peakThreadCount = 
            (Integer) mbs.getAttribute(threadBean, "PeakThreadCount");
        Integer daemonThreadCount = 
            (Integer) mbs.getAttribute(threadBean, "DaemonThreadCount");
        Long totalStartedCount = 
            (Long) mbs.getAttribute(threadBean, "TotalStartedThreadCount");
        
        System.out.println("=== Threads ===");
        System.out.printf("Current:        %,d%n", threadCount);
        System.out.printf("Peak:           %,d%n", peakThreadCount);
        System.out.printf("Daemon:         %,d%n", daemonThreadCount);
        System.out.printf("Total started:  %,d%n", totalStartedCount);
    }
    
    /**
     * Monitor class loading
     */
    public static void monitorClassLoading(MBeanServerConnection mbs) 
            throws Exception {
        ObjectName classLoadingBean = 
            new ObjectName("java.lang:type=ClassLoading");
        
        Integer loadedCount = 
            (Integer) mbs.getAttribute(classLoadingBean, "LoadedClassCount");
        Long totalLoadedCount = 
            (Long) mbs.getAttribute(classLoadingBean, "TotalLoadedClassCount");
        Long unloadedCount = 
            (Long) mbs.getAttribute(classLoadingBean, "UnloadedClassCount");
        
        System.out.println("=== Class Loading ===");
        System.out.printf("Currently loaded: %,d%n", loadedCount);
        System.out.printf("Total loaded:     %,d%n", totalLoadedCount);
        System.out.printf("Unloaded:         %,d%n", unloadedCount);
    }
    
    /**
     * Continuous monitoring
     */
    public static void continuousMonitor(String host, int port, int intervalSeconds) 
            throws Exception {
        MBeanServerConnection mbs = connect(host, port);
        
        while (true) {
            System.out.println("\n" + "=".repeat(50));
            System.out.println(new Date());
            System.out.println("=".repeat(50));
            
            monitorMemory(mbs);
            System.out.println();
            monitorGC(mbs);
            System.out.println();
            monitorThreads(mbs);
            
            Thread.sleep(intervalSeconds * 1000);
        }
    }
    
    /**
     * Trigger actions
     */
    public static void triggerGC(MBeanServerConnection mbs) throws Exception {
        ObjectName memoryBean = new ObjectName("java.lang:type=Memory");
        mbs.invoke(memoryBean, "gc", new Object[0], new String[0]);
        System.out.println("GC triggered");
    }
    
    public static void dumpHeap(MBeanServerConnection mbs, String fileName) 
            throws Exception {
        ObjectName hotspotDiag = 
            new ObjectName("com.sun.management:type=HotSpotDiagnostic");
        
        mbs.invoke(hotspotDiag, "dumpHeap", 
            new Object[]{fileName, true}, 
            new String[]{String.class.getName(), boolean.class.getName()});
        
        System.out.println("Heap dumped to: " + fileName);
    }
    
    public static void main(String[] args) throws Exception {
        if (args.length < 2) {
            System.out.println("Usage: java JMXMonitoring <host> <port>");
            return;
        }
        
        String host = args[0];
        int port = Integer.parseInt(args[1]);
        
        // One-time monitoring
        MBeanServerConnection mbs = connect(host, port);
        monitorMemory(mbs);
        System.out.println();
        monitorGC(mbs);
        System.out.println();
        monitorThreads(mbs);
        System.out.println();
        monitorClassLoading(mbs);
        
        // Continuous monitoring (uncomment to enable)
        // continuousMonitor(host, port, 10);
    }
}
```

---

## 7. Production Troubleshooting Checklist

### Pre-Deployment Checklist

```bash
#!/bin/bash

# ============================================================================
# PRE-DEPLOYMENT CHECKLIST
# ============================================================================

# □ HEAP SIZING
# -----------------------------------------
☐ -Xms and -Xmx set to same value
☐ Heap size = 50-75% of container/server memory
☐ Tested under load with chosen heap size
☐ No OutOfMemoryError during load tests

# □ GC CONFIGURATION
# -----------------------------------------
☐ GC algorithm chosen based on requirements:
  - G1GC for general use
  - ZGC for low latency
  - ParallelGC for throughput
☐ GC pause goals set appropriately
☐ GC logs enabled and configured
☐ GC log rotation configured

# □ JFR CONFIGURATION
# -----------------------------------------
☐ Continuous JFR recording enabled
☐ JFR files saved with timestamps
☐ Max age/size configured
☐ dumponexit=true set

# □ JMX CONFIGURATION
# -----------------------------------------
☐ JMX enabled with authentication
☐ JMX port configured and documented
☐ Firewall rules allow JMX port
☐ Monitoring tools connected successfully

# □ ERROR HANDLING
# -----------------------------------------
☐ -XX:+HeapDumpOnOutOfMemoryError enabled
☐ -XX:HeapDumpPath configured and writable
☐ -XX:+ExitOnOutOfMemoryError or -XX:+CrashOnOutOfMemoryError set
☐ OOM kills handled by orchestrator (K8s)

# □ LOGGING
# -----------------------------------------
☐ GC logging: -Xlog:gc*:file=gc.log:time,level,tags
☐ GC log rotation: -Xlog:gc*:file=gc.log:time,level,tags:filecount=10,filesize=100M
☐ Application logging configured
☐ Log aggregation configured (ELK, Splunk)

# □ MONITORING
# -----------------------------------------
☐ Metrics exposed (JMX, Prometheus, etc.)
☐ Dashboards created (Grafana, etc.)
☐ Alerts configured:
  - High heap usage (>80%)
  - Long GC pauses (>1s)
  - Frequent GC (>1/sec)
  - OOM errors
  - High CPU usage
  - Thread deadlocks

# □ DOCUMENTATION
# -----------------------------------------
☐ All JVM flags documented
☐ Reasoning for choices documented
☐ Runbook created
☐ On-call procedures defined

# ============================================================================
# EXAMPLE PRODUCTION FLAGS
# ============================================================================

# General web application (4GB container)
java -Xms3g -Xmx3g \
     -XX:+UseG1GC \
     -XX:MaxGCPauseMillis=200 \
     -XX:+HeapDumpOnOutOfMemoryError \
     -XX:HeapDumpPath=/var/dumps/heap-%p-%t.hprof \
     -XX:+ExitOnOutOfMemoryError \
     -XX:StartFlightRecording=name=continuous,maxage=6h,maxsize=500M,dumponexit=true,filename=/var/logs/jfr/app-%t.jfr \
     -Xlog:gc*:file=/var/logs/gc/gc.log:time,level,tags:filecount=10,filesize=100M \
     -Dcom.sun.management.jmxremote \
     -Dcom.sun.management.jmxremote.port=9010 \
     -Dcom.sun.management.jmxremote.authenticate=true \
     -Dcom.sun.management.jmxremote.ssl=true \
     -Dcom.sun.management.jmxremote.password.file=/etc/jmx/password \
     -jar myapp.jar
```

### Runtime Troubleshooting

```bash
#!/bin/bash

# ============================================================================
# RUNTIME TROUBLESHOOTING
# ============================================================================

# Get process ID
PID=$(pgrep -f "myapp.jar")

# PROBLEM: High CPU usage
# -----------------------------------------

# 1. Check which threads are using CPU
top -H -p $PID

# 2. Get thread dump
jstack $PID > thread-dump-$(date +%s).txt

# 3. Find CPU-heavy threads
# Convert thread ID from top (decimal) to hex
# Example: Thread 12345 → 0x3039
# Search for "nid=0x3039" in thread dump

# 4. Start JFR recording
jcmd $PID JFR.start duration=60s filename=/tmp/cpu-issue-$(date +%s).jfr

# 5. Analyze JFR file for hot methods

# PROBLEM: High memory usage
# -----------------------------------------

# 1. Check heap usage
jstat -gcutil $PID 1000 10

# 2. If heap near maximum, get heap dump
jcmd $PID GC.heap_dump /tmp/heap-dump-$(date +%s).hprof

# 3. Analyze with Eclipse MAT or VisualVM

# 4. Check for memory leak
jcmd $PID GC.class_histogram > histogram-$(date +%s).txt
# Wait some time
jcmd $PID GC.class_histogram > histogram-later-$(date +%s).txt
# Compare: diff histogram-*.txt

# PROBLEM: Long GC pauses
# -----------------------------------------

# 1. Check GC statistics
jstat -gc $PID 1000 10

# 2. Analyze GC log
# Look for long pauses:
grep "Pause" /var/logs/gc/gc.log | awk '{print $NF}' | sort -n | tail -20

# 3. If using G1GC, check for "to-space exhausted"
grep "to-space exhausted" /var/logs/gc/gc.log

# 4. Possible fixes:
# - Increase -XX:G1ReservePercent
# - Lower -XX:InitiatingHeapOccupancyPercent
# - Increase heap size
# - Reduce allocation rate (optimize code)

# PROBLEM: OutOfMemoryError
# -----------------------------------------

# 1. Find heap dump (if -XX:+HeapDumpOnOutOfMemoryError enabled)
ls -lh /var/dumps/

# 2. Analyze heap dump with MAT
# Look for:
# - Largest objects
# - Leak suspects
# - Dominator tree

# 3. Check which type of OOM:
# - "Java heap space" → Increase heap or fix leak
# - "GC overhead limit exceeded" → GC spending >98% time
# - "unable to create new native thread" → Too many threads
# - "Metaspace" → Too many classes, increase metaspace

# PROBLEM: Thread deadlock
# -----------------------------------------

# 1. Get thread dump
jstack $PID > thread-dump.txt

# 2. Look for "Found one Java-level deadlock"

# 3. Analyze deadlock cycle:
# Thread A waiting for lock held by Thread B
# Thread B waiting for lock held by Thread A

# 4. Use jconsole or VisualVM "Threads" tab for visual representation

# PROBLEM: Slow performance
# -----------------------------------------

# 1. Start JFR recording
jcmd $PID JFR.start duration=120s filename=/tmp/perf-$(date +%s).jfr settings=profile

# 2. During recording, reproduce slow operation

# 3. Analyze JFR for:
# - Method profiling (hot methods)
# - Allocation profiling (high allocators)
# - Lock contention
# - I/O operations

# PROBLEM: Application hangs
# -----------------------------------------

# 1. Take multiple thread dumps (10 seconds apart)
for i in {1..3}; do
  jstack $PID > thread-dump-$i.txt
  sleep 10
done

# 2. Compare dumps:
# - Threads in same state → Deadlock or livelock
# - Threads making progress → Slow operation

# 3. Check for:
# - BLOCKED threads
# - WAITING threads
# - High number of threads in one state

# ============================================================================
# DIAGNOSTIC COMMAND REFERENCE
# ============================================================================

# List available commands
jcmd $PID help

# Common commands:
jcmd $PID VM.uptime                # JVM uptime
jcmd $PID VM.system_properties     # System properties
jcmd $PID VM.flags                 # JVM flags
jcmd $PID VM.command_line          # Command line
jcmd $PID GC.heap_info             # Heap info
jcmd $PID GC.class_histogram       # Class histogram
jcmd $PID GC.run                   # Trigger GC
jcmd $PID Thread.print             # Thread dump
jcmd $PID VM.native_memory summary # Native memory tracking

# ============================================================================
# LOG ANALYSIS TOOLS
# ============================================================================

# GCViewer (visualize GC logs)
# https://github.com/chewiebug/GCViewer
java -jar gcviewer.jar gc.log

# GCEasy (online GC log analyzer)
# https://gceasy.io
# Upload gc.log

# Eclipse MAT (heap dump analyzer)
# https://www.eclipse.org/mat/
# File → Open Heap Dump → heap-dump.hprof

# JITWatch (JIT compilation analyzer)
# https://github.com/AdoptOpenJDK/jitwatch
java -jar jitwatch.jar
```

### Performance Tuning Workflow

```
┌─────────────────────────────────────────────┐
│  1. MEASURE (Establish Baseline)           │
│  - Run load tests                           │
│  - Collect metrics (JFR, GC logs, JMX)      │
│  - Document current performance             │
└──────────────────┬──────────────────────────┘
                   │
┌──────────────────▼──────────────────────────┐
│  2. ANALYZE (Identify Bottlenecks)          │
│  - Analyze JFR recordings                   │
│  - Review GC logs                           │
│  - Profile CPU, memory, I/O                 │
│  - Identify top 3 issues                    │
└──────────────────┬──────────────────────────┘
                   │
┌──────────────────▼──────────────────────────┐
│  3. HYPOTHESIZE (Form Theories)             │
│  - High allocation rate → Reduce objects    │
│  - Long GC pauses → Tune GC                 │
│  - High CPU → Optimize hot methods          │
│  - Document expected improvements           │
└──────────────────┬──────────────────────────┘
                   │
┌──────────────────▼──────────────────────────┐
│  4. CHANGE (Implement Fix)                  │
│  - Change ONE parameter                     │
│  - Document change                          │
│  - Deploy to test environment               │
└──────────────────┬──────────────────────────┘
                   │
┌──────────────────▼──────────────────────────┐
│  5. VALIDATE (Measure Again)                │
│  - Run same load tests                      │
│  - Collect same metrics                     │
│  - Compare to baseline                      │
│  - Verify improvement                       │
└──────────────────┬──────────────────────────┘
                   │
        ┌──────────┴──────────┐
        │                     │
    ┌───▼────┐          ┌────▼────┐
    │ Better │          │  Worse  │
    └───┬────┘          └────┬────┘
        │                    │
        │              ┌─────▼─────┐
        │              │  Rollback │
        │              └─────┬─────┘
        │                    │
        └────────┬───────────┘
                 │
      ┌──────────▼──────────┐
      │  More issues?       │
      │  Yes → Go to step 2 │
      │  No → Done!         │
      └─────────────────────┘
```

---

## Summary

### Flag Categories Quick Reference

```bash
# HEAP SIZING
-Xms<size>                          # Initial heap
-Xmx<size>                          # Maximum heap
-Xmn<size>                          # Young generation size
-XX:MaxRAMPercentage=75.0           # Heap as % of RAM

# GC SELECTION
-XX:+UseSerialGC                    # Serial GC (single thread)
-XX:+UseParallelGC                  # Parallel GC (throughput)
-XX:+UseG1GC                        # G1 GC (balanced, default)
-XX:+UseZGC                         # ZGC (ultra-low latency)
-XX:+UseShenandoahGC                # Shenandoah (low latency)

# GC TUNING
-XX:MaxGCPauseMillis=200            # Pause time goal
-XX:GCTimeRatio=19                  # Throughput goal (5% GC)
-XX:ParallelGCThreads=8             # Parallel GC threads
-XX:ConcGCThreads=2                 # Concurrent GC threads

# JIT COMPILATION
-XX:+TieredCompilation              # Tiered compilation (default)
-XX:CompileThreshold=10000          # C2 compilation threshold
-XX:ReservedCodeCacheSize=512m      # Code cache size

# DIAGNOSTIC
-XX:+HeapDumpOnOutOfMemoryError     # Dump heap on OOM
-XX:HeapDumpPath=/var/dumps         # Dump location
-XX:+ExitOnOutOfMemoryError         # Exit on OOM
-XX:StartFlightRecording=...        # Enable JFR

# LOGGING
-Xlog:gc*:file=gc.log:time          # GC logging
-XX:+PrintFlagsFinal                # Print all flags
-XX:+PrintCommandLineFlags          # Print modified flags

# JMX
-Dcom.sun.management.jmxremote                  # Enable JMX
-Dcom.sun.management.jmxremote.port=9010        # JMX port
-Dcom.sun.management.jmxremote.authenticate=true # Auth required
```

### Performance Tuning Priorities

**Priority 1: Correctness**

1. No OutOfMemoryErrors under load
2. No deadlocks or livelocks
3. Stable under sustained traffic
4. Recovers from errors

**Priority 2: Meets SLAs**

1. Latency within targets (P50, P99, P99.9)
2. Throughput meets requirements
3. GC pauses acceptable
4. Resource usage reasonable

**Priority 3: Optimization**

1. Reduce allocation rate
2. Tune GC parameters
3. Optimize hot code paths
4. Improve cache hit rates

### Common Issues and Solutions

|Issue|Symptoms|Solution|
|---|---|---|
|High heap usage|Heap >80%, frequent GC|Increase heap or fix memory leak|
|Long GC pauses|Pauses >1s|Lower pause goal, increase heap, tune GC|
|Frequent GC|GC >1/sec|Increase young gen, reduce allocation|
|OOM|Application crashes|Analyze heap dump, fix leak, increase heap|
|High CPU|CPU >80%|Profile with JFR, optimize hot methods|
|Thread contention|Slow performance|Thread dump, reduce lock scope|
|Slow startup|Minutes to start|Reduce classpath, use AOT, CDS|

### Monitoring Metrics

**Critical Metrics (Alert):**

- Heap usage >80%
- GC pause >1 second
- GC frequency >1/second
- OOM errors
- Thread deadlocks

**Important Metrics (Track):**

- Average GC pause time
- GC throughput (% time in GC)
- Allocation rate
- Thread count
- CPU usage
- Response time (P50, P99, P99.9)

**Nice-to-Have Metrics:**

- Code cache usage
- Metaspace usage
- Compilation time
- Safepoint time
- Direct buffer usage

---
