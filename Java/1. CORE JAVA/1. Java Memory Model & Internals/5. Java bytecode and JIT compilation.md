# Java Bytecode and JIT Compilation

## Overview

Understanding Java bytecode and JIT (Just-In-Time) compilation is crucial for performance optimization and deep JVM knowledge. This guide covers bytecode structure, JIT compilation strategies, and optimization techniques.

---

## 1. Bytecode Structure and Instructions

### Bytecode Basics

```java
/**
 * JAVA BYTECODE:
 * 
 * Platform-independent instruction set for JVM
 * 
 * Characteristics:
 * - Stack-based (not register-based)
 * - Type-safe
 * - Compact representation
 * - One byte opcode + optional operands
 * 
 * File Structure:
 * .class file contains:
 * 1. Magic number (0xCAFEBABE)
 * 2. Version (major, minor)
 * 3. Constant pool
 * 4. Access flags
 * 5. This class, super class
 * 6. Interfaces
 * 7. Fields
 * 8. Methods
 * 9. Attributes
 */

public class BytecodeBasicsDemo {
    
    private int value;
    
    public int add(int a, int b) {
        return a + b;
    }
    
    public void setValue(int v) {
        this.value = v;
    }
    
    public int getValue() {
        return this.value;
    }
    
    /**
     * BYTECODE INSPECTION:
     * 
     * Command: javap -c BytecodeBasicsDemo
     * 
     * Output for add():
     * 
     * public int add(int, int);
     *   Code:
     *      0: iload_1        // Load parameter a
     *      1: iload_2        // Load parameter b
     *      2: iadd           // Add two integers
     *      3: ireturn        // Return integer
     * 
     * STACK TRACE:
     * 
     * Initial:     Stack: []
     * After iload_1: Stack: [a]
     * After iload_2: Stack: [a, b]
     * After iadd:    Stack: [a+b]
     * After ireturn: Stack: []
     * 
     * Output for setValue():
     * 
     * public void setValue(int);
     *   Code:
     *      0: aload_0        // Load 'this'
     *      1: iload_1        // Load parameter v
     *      2: putfield #2    // Set field value
     *      5: return         // Return void
     * 
     * Output for getValue():
     * 
     * public int getValue();
     *   Code:
     *      0: aload_0        // Load 'this'
     *      1: getfield #2    // Get field value
     *      4: ireturn        // Return integer
     */
}
```

### Common Bytecode Instructions

```java
/**
 * BYTECODE INSTRUCTION CATEGORIES:
 * 
 * 1. LOAD/STORE: Move values between locals and stack
 * 2. ARITHMETIC: Perform calculations
 * 3. TYPE CONVERSION: Convert between types
 * 4. OBJECT CREATION: Create objects, arrays
 * 5. FIELD ACCESS: Get/set fields
 * 6. METHOD INVOCATION: Call methods
 * 7. CONTROL FLOW: Branches, returns
 * 8. COMPARISON: Compare values
 */

public class BytecodeInstructionsDemo {
    
    /**
     * LOAD INSTRUCTIONS:
     * 
     * Load from local variables to stack
     */
    public void loadInstructions() {
        int i = 10;
        long l = 100L;
        float f = 1.5f;
        double d = 2.5;
        Object obj = new Object();
        
        /**
         * BYTECODE:
         * 
         * 0: bipush 10        // Push byte 10 to stack
         * 2: istore_1         // Store to local variable 1 (i)
         * 
         * 3: ldc2_w #2        // Load constant 100L
         * 6: lstore_2         // Store to locals 2,3 (l is 64-bit)
         * 
         * 7: ldc #4           // Load constant 1.5
         * 9: fstore 4         // Store to local 4 (f)
         * 
         * 11: ldc2_w #5       // Load constant 2.5
         * 14: dstore 5        // Store to locals 5,6 (d is 64-bit)
         * 
         * 16: new #7          // Create new Object
         * 19: dup             // Duplicate reference
         * 20: invokespecial #8 // Call Object.<init>
         * 23: astore 7        // Store reference to local 7
         * 
         * INSTRUCTION PATTERN:
         * iload_<n>  - load int from local n
         * lload_<n>  - load long from local n
         * fload_<n>  - load float from local n
         * dload_<n>  - load double from local n
         * aload_<n>  - load reference from local n
         * 
         * _0, _1, _2, _3 are optimized forms (1 byte)
         * General form takes 2 bytes (opcode + index)
         */
    }
    
    /**
     * ARITHMETIC INSTRUCTIONS:
     */
    public int arithmetic(int a, int b) {
        int sum = a + b;
        int diff = a - b;
        int prod = a * b;
        int quot = a / b;
        int rem = a % b;
        int neg = -a;
        
        return sum;
        
        /**
         * BYTECODE:
         * 
         * // sum = a + b
         * 0: iload_1          // Load a
         * 1: iload_2          // Load b
         * 2: iadd             // Add
         * 3: istore_3         // Store sum
         * 
         * // diff = a - b
         * 4: iload_1          // Load a
         * 5: iload_2          // Load b
         * 6: isub             // Subtract
         * 7: istore 4         // Store diff
         * 
         * // prod = a * b
         * 9: iload_1          // Load a
         * 10: iload_2         // Load b
         * 11: imul            // Multiply
         * 12: istore 5        // Store prod
         * 
         * // quot = a / b
         * 14: iload_1         // Load a
         * 15: iload_2         // Load b
         * 16: idiv            // Divide
         * 17: istore 6        // Store quot
         * 
         * // rem = a % b
         * 19: iload_1         // Load a
         * 20: iload_2         // Load b
         * 21: irem            // Remainder
         * 22: istore 7        // Store rem
         * 
         * // neg = -a
         * 24: iload_1         // Load a
         * 25: ineg            // Negate
         * 26: istore 8        // Store neg
         * 
         * 28: iload_3         // Load sum
         * 29: ireturn         // Return sum
         * 
         * ARITHMETIC INSTRUCTIONS:
         * iadd, ladd, fadd, dadd  - Addition
         * isub, lsub, fsub, dsub  - Subtraction
         * imul, lmul, fmul, dmul  - Multiplication
         * idiv, ldiv, fdiv, ddiv  - Division
         * irem, lrem, frem, drem  - Remainder
         * ineg, lneg, fneg, dneg  - Negation
         */
    }
    
    /**
     * CONTROL FLOW:
     */
    public int controlFlow(int x) {
        if (x > 0) {
            return 1;
        } else if (x < 0) {
            return -1;
        } else {
            return 0;
        }
        
        /**
         * BYTECODE:
         * 
         * 0: iload_1          // Load x
         * 1: ifle 7           // If x <= 0, jump to 7
         * 4: iconst_1         // Push 1
         * 5: ireturn          // Return 1
         * 
         * 6: iload_1          // Load x (never executed, dead code)
         * 7: ifge 13          // If x >= 0, jump to 13
         * 10: iconst_m1       // Push -1
         * 11: ireturn         // Return -1
         * 
         * 12: iconst_0        // Push 0 (never executed)
         * 13: ireturn         // Return 0
         * 
         * COMPARISON INSTRUCTIONS:
         * ifeq - if == 0
         * ifne - if != 0
         * iflt - if < 0
         * ifle - if <= 0
         * ifgt - if > 0
         * ifge - if >= 0
         * if_icmpeq - if int1 == int2
         * if_icmpne - if int1 != int2
         * if_icmplt - if int1 < int2
         * if_icmple - if int1 <= int2
         * if_icmpgt - if int1 > int2
         * if_icmpge - if int1 >= int2
         * if_acmpeq - if ref1 == ref2
         * if_acmpne - if ref1 != ref2
         * ifnull - if == null
         * ifnonnull - if != null
         */
    }
    
    /**
     * METHOD INVOCATION:
     */
    public void methodInvocation() {
        String s = "Hello";
        int len = s.length();            // invokevirtual
        String upper = String.valueOf(10); // invokestatic
        
        /**
         * BYTECODE:
         * 
         * 0: ldc #2           // Load constant "Hello"
         * 2: astore_1         // Store to s
         * 
         * 3: aload_1          // Load s
         * 4: invokevirtual #3 // String.length()
         * 7: istore_2         // Store to len
         * 
         * 8: bipush 10        // Push 10
         * 10: invokestatic #4 // String.valueOf(int)
         * 13: astore_3        // Store to upper
         * 
         * INVOCATION INSTRUCTIONS:
         * 
         * invokevirtual - Instance method (normal dispatch)
         * invokespecial - Constructor, private, super methods
         * invokestatic  - Static method
         * invokeinterface - Interface method
         * invokedynamic - Dynamic language support (lambdas)
         */
    }
    
    /**
     * OBJECT CREATION:
     */
    public void objectCreation() {
        Object obj = new Object();
        int[] arr = new int[10];
        
        /**
         * BYTECODE:
         * 
         * // new Object()
         * 0: new #2           // Allocate Object
         * 3: dup              // Duplicate reference
         * 4: invokespecial #1 // Call Object.<init>
         * 7: astore_1         // Store to obj
         * 
         * // new int[10]
         * 8: bipush 10        // Push size 10
         * 10: newarray int    // Create int array
         * 12: astore_2        // Store to arr
         * 
         * OBJECT INSTRUCTIONS:
         * new - Create new object
         * newarray - Create primitive array
         * anewarray - Create object array
         * multianewarray - Create multi-dimensional array
         * arraylength - Get array length
         * instanceof - Check instance type
         * checkcast - Cast reference
         */
    }
}
```

### Stack and Local Variables

```java
/**
 * JVM STACK MACHINE:
 * 
 * Each method has:
 * 1. Local Variables (array)
 * 2. Operand Stack
 * 3. Frame Data (metadata)
 * 
 * Local Variables:
 * - Index 0: 'this' (for instance methods)
 * - Index 1+: Method parameters
 * - Remaining: Local variables
 * 
 * Operand Stack:
 * - Temporary storage for calculations
 * - LIFO (Last In First Out)
 * - Max depth known at compile time
 */

public class StackMachineDemo {
    
    public int calculate(int a, int b, int c) {
        int x = a + b;
        int y = x * c;
        return y;
    }
    
    /**
     * LOCAL VARIABLES TABLE:
     * 
     * Index | Variable | Type
     * ------+----------+------
     *   0   | this     | ref
     *   1   | a        | int
     *   2   | b        | int
     *   3   | c        | int
     *   4   | x        | int
     *   5   | y        | int
     * 
     * BYTECODE WITH STACK TRACE:
     * 
     * Instruction      | Stack          | Locals
     * -----------------+----------------+------------------
     * 0: iload_1       | [a]            | [this,a,b,c]
     * 1: iload_2       | [a,b]          | [this,a,b,c]
     * 2: iadd          | [a+b]          | [this,a,b,c]
     * 3: istore 4      | []             | [this,a,b,c,x]
     * 5: iload 4       | [x]            | [this,a,b,c,x]
     * 7: iload_3       | [x,c]          | [this,a,b,c,x]
     * 8: imul          | [x*c]          | [this,a,b,c,x]
     * 9: istore 5      | []             | [this,a,b,c,x,y]
     * 11: iload 5      | [y]            | [this,a,b,c,x,y]
     * 13: ireturn      | []             | []
     * 
     * MAX STACK: 2 (at most 2 values on stack)
     * MAX LOCALS: 6 (this + 3 params + 2 locals)
     */
    
    /**
     * COMPLEX EXPRESSION:
     */
    public int complexExpression() {
        return (1 + 2) * (3 + 4);
    }
    
    /**
     * BYTECODE:
     * 
     * 0: iconst_1         // Push 1
     * 1: iconst_2         // Push 2
     * 2: iadd             // 1 + 2 = 3
     * 3: iconst_3         // Push 3
     * 4: iconst_4         // Push 4
     * 5: iadd             // 3 + 4 = 7
     * 6: imul             // 3 * 7 = 21
     * 7: ireturn          // Return 21
     * 
     * STACK EVOLUTION:
     * 
     * Step | Instruction  | Stack
     * -----+--------------+---------
     *  0   | iconst_1     | [1]
     *  1   | iconst_2     | [1,2]
     *  2   | iadd         | [3]
     *  3   | iconst_3     | [3,3]
     *  4   | iconst_4     | [3,3,4]
     *  5   | iadd         | [3,7]
     *  6   | imul         | [21]
     *  7   | ireturn      | []
     */
}
```

---

## 2. javap for Bytecode Inspection

### Basic javap Usage

```bash
# Compile Java file
javac BytecodeDemo.java

# Basic disassembly
javap BytecodeDemo

# Show methods
javap -public BytecodeDemo
javap -private BytecodeDemo

# Show bytecode
javap -c BytecodeDemo

# Verbose output (constant pool, fields, etc.)
javap -v BytecodeDemo

# Line numbers and local variables
javap -c -l BytecodeDemo

# Show internal method signatures
javap -s BytecodeDemo
```

### Detailed javap Analysis

```java
public class JavapDemo {
    
    private int value;
    private static final String CONSTANT = "Hello";
    
    public JavapDemo(int value) {
        this.value = value;
    }
    
    public int getValue() {
        return value;
    }
    
    public void setValue(int value) {
        this.value = value;
    }
    
    public static void main(String[] args) {
        JavapDemo demo = new JavapDemo(42);
        System.out.println(demo.getValue());
    }
}

/**
 * COMMAND: javap -v -p JavapDemo
 * 
 * OUTPUT:
 * 
 * Classfile JavapDemo.class
 *   Last modified Dec 10, 2024; size 629 bytes
 *   MD5 checksum a1b2c3d4e5f6...
 *   Compiled from "JavapDemo.java"
 * public class JavapDemo
 *   minor version: 0
 *   major version: 61      // Java 17
 *   flags: (0x0021) ACC_PUBLIC, ACC_SUPER
 *   this_class: #7          // JavapDemo
 *   super_class: #2         // java/lang/Object
 *   interfaces: 0, fields: 2, methods: 4, attributes: 1
 * 
 * Constant pool:
 *    #1 = Methodref          #2.#3          // java/lang/Object."<init>":()V
 *    #2 = Class              #4             // java/lang/Object
 *    #3 = NameAndType        #5:#6          // "<init>":()V
 *    #4 = Utf8               java/lang/Object
 *    #5 = Utf8               <init>
 *    #6 = Utf8               ()V
 *    #7 = Class              #8             // JavapDemo
 *    #8 = Utf8               JavapDemo
 *    #9 = Fieldref           #7.#10         // JavapDemo.value:I
 *   #10 = NameAndType        #11:#12        // value:I
 *   #11 = Utf8               value
 *   #12 = Utf8               I
 *   #13 = String             #14            // "Hello"
 *   #14 = Utf8               Hello
 *   #15 = Fieldref           #7.#16         // JavapDemo.CONSTANT:Ljava/lang/String;
 *   #16 = NameAndType        #17:#18        // CONSTANT:Ljava/lang/String;
 *   ... (more entries)
 * 
 * {
 *   private int value;
 *     descriptor: I
 *     flags: (0x0002) ACC_PRIVATE
 * 
 *   private static final java.lang.String CONSTANT;
 *     descriptor: Ljava/lang/String;
 *     flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
 *     ConstantValue: String "Hello"
 * 
 *   public JavapDemo(int);
 *     descriptor: (I)V
 *     flags: (0x0001) ACC_PUBLIC
 *     Code:
 *       stack=2, locals=2, args_size=2
 *          0: aload_0
 *          1: invokespecial #1  // Method java/lang/Object."<init>":()V
 *          4: aload_0
 *          5: iload_1
 *          6: putfield      #9  // Field value:I
 *          9: return
 *       LineNumberTable:
 *         line 5: 0
 *         line 6: 4
 *         line 7: 9
 *       LocalVariableTable:
 *         Start  Length  Slot  Name   Signature
 *             0      10     0  this   LJavapDemo;
 *             0      10     1 value   I
 * 
 *   public int getValue();
 *     descriptor: ()I
 *     flags: (0x0001) ACC_PUBLIC
 *     Code:
 *       stack=1, locals=1, args_size=1
 *          0: aload_0
 *          1: getfield      #9  // Field value:I
 *          4: ireturn
 *       LineNumberTable:
 *         line 10: 0
 *       LocalVariableTable:
 *         Start  Length  Slot  Name   Signature
 *             0       5     0  this   LJavapDemo;
 * 
 *   public static void main(java.lang.String[]);
 *     descriptor: ([Ljava/lang/String;)V
 *     flags: (0x0009) ACC_PUBLIC, ACC_STATIC
 *     Code:
 *       stack=3, locals=2, args_size=1
 *          0: new           #7  // class JavapDemo
 *          3: dup
 *          4: bipush        42
 *          6: invokespecial #20 // Method "<init>":(I)V
 *          9: astore_1
 *         10: getstatic     #21 // Field java/lang/System.out
 *         13: aload_1
 *         14: invokevirtual #22 // Method getValue:()I
 *         17: invokevirtual #23 // Method java/io/PrintStream.println:(I)V
 *         20: return
 *       LineNumberTable:
 *         line 18: 0
 *         line 19: 10
 *         line 20: 20
 *       LocalVariableTable:
 *         Start  Length  Slot  Name   Signature
 *             0      21     0  args   [Ljava/lang/String;
 *            10      11     1  demo   LJavapDemo;
 * }
 * 
 * KEY INFORMATION:
 * 
 * - Class version: Java 17 (major version 61)
 * - Constant pool: String/class/method references
 * - Fields: value (private), CONSTANT (static final)
 * - Methods: Constructor, getter, setter, main
 * - Stack depth: Maximum operand stack size
 * - Locals: Maximum local variable slots
 * - LineNumberTable: Maps bytecode to source lines
 * - LocalVariableTable: Maps slots to variable names
 */
```

### Advanced javap Techniques

```java
/**
 * ANALYZING LAMBDA EXPRESSIONS:
 */
public class LambdaAnalysis {
    
    public void useLambda() {
        Runnable r = () -> System.out.println("Hello");
        r.run();
    }
    
    /**
     * COMMAND: javap -c -p LambdaAnalysis
     * 
     * OUTPUT:
     * 
     * public void useLambda();
     *   Code:
     *      0: invokedynamic #2,  0  // InvokeDynamic #0:run:()Ljava/lang/Runnable;
     *      5: astore_1
     *      6: aload_1
     *      7: invokeinterface #3,  1  // InterfaceMethod Runnable.run:()V
     *     12: return
     * 
     * private static void lambda$useLambda$0();
     *   Code:
     *      0: getstatic     #4  // Field java/lang/System.out
     *      3: ldc           #5  // String "Hello"
     *      5: invokevirtual #6  // Method java/io/PrintStream.println
     *      8: return
     * 
     * EXPLANATION:
     * 
     * 1. Lambda compiled to private static method: lambda$useLambda$0()
     * 2. invokedynamic creates Runnable implementation
     * 3. Lambda body in synthetic method
     * 4. Bootstrap method links at runtime
     * 
     * Bootstrap Methods:
     *   0: #23 REF_invokeStatic java/lang/invoke/LambdaMetafactory.metafactory
     *     Method arguments:
     *       #24 ()V
     *       #25 REF_invokeStatic LambdaAnalysis.lambda$useLambda$0:()V
     *       #24 ()V
     */
}

/**
 * ANALYZING SWITCH STATEMENTS:
 */
public class SwitchAnalysis {
    
    public String switchInt(int x) {
        switch (x) {
            case 1: return "one";
            case 2: return "two";
            case 3: return "three";
            default: return "other";
        }
    }
    
    /**
     * BYTECODE (Java 7+):
     * 
     * 0: iload_1
     * 1: tableswitch   { // 1 to 3
     *         1: 28    // case 1
     *         2: 33    // case 2
     *         3: 38    // case 3
     *   default: 43    // default
     * }
     * 28: ldc #2       // String "one"
     * 30: areturn
     * 33: ldc #3       // String "two"
     * 35: areturn
     * 38: ldc #4       // String "three"
     * 40: areturn
     * 43: ldc #5       // String "other"
     * 45: areturn
     * 
     * TABLESWITCH: Dense case values (1,2,3)
     * LOOKUPSWITCH: Sparse case values (1,10,100)
     */
    
    public String switchString(String s) {
        switch (s) {
            case "hello": return "hi";
            case "bye": return "goodbye";
            default: return "unknown";
        }
    }
    
    /**
     * STRING SWITCH (Java 7+):
     * 
     * Compiles to:
     * 1. Switch on hashCode
     * 2. equals() check for hash collisions
     * 3. Second switch on index
     * 
     * Very complex bytecode!
     */
}
```

---

## 3. JIT Compilation (C1, C2 Compilers)

### JIT Compilation Overview

```java
/**
 * JIT (JUST-IN-TIME) COMPILATION:
 * 
 * JVM executes bytecode in two ways:
 * 1. Interpreter: Line-by-line execution (slow but fast startup)
 * 2. JIT Compiler: Compile to native code (fast but slow startup)
 * 
 * TWO JIT COMPILERS:
 * 
 * C1 (Client Compiler):
 * - Fast compilation
 * - Basic optimizations
 * - Lower code quality
 * - Used for startup-sensitive code
 * 
 * C2 (Server Compiler):
 * - Slow compilation
 * - Aggressive optimizations
 * - High code quality
 * - Used for hot methods
 * 
 * COMPILATION TRIGGERS:
 * 
 * Method compiled when:
 * - Invocation count exceeds threshold
 * - Back-edge count exceeds threshold (loops)
 * 
 * Default thresholds:
 * - C1: 1500 invocations or 13995 back-edges
 * - C2: 10000 invocations or 10700 back-edges
 */

public class JITCompilationDemo {
    
    public static void main(String[] args) {
        
        // Method starts in interpreter
        for (int i = 0; i < 20000; i++) {
            compute(i);
            
            /**
             * COMPILATION LIFECYCLE:
             * 
             * Invocations 0-1500:
             * - Interpreted mode
             * - Profiling data collected
             * 
             * Invocation 1500:
             * - C1 compilation triggered
             * - Method compiled with basic optimizations
             * 
             * Invocations 1500-10000:
             * - Runs as C1 compiled code
             * - More profiling data collected
             * 
             * Invocation 10000:
             * - C2 compilation triggered
             * - Method recompiled with aggressive optimizations
             * 
             * Invocations 10000+:
             * - Runs as C2 compiled code
             * - Highest performance
             */
        }
    }
    
    private static int compute(int x) {
        return x * x + 2 * x + 1;
    }
    
    /**
     * MONITORING JIT COMPILATION:
     * 
     * JVM Flags:
     * 
     * -XX:+PrintCompilation
     * Shows when methods are compiled
     * 
     * Output:
     *     74    1       3       java.lang.String::hashCode (55 bytes)
     *     75    2       3       java.lang.String::charAt (25 bytes)
     *     76    3       3       JITCompilationDemo::compute (10 bytes)
     *     
     *     Column 1: Timestamp (ms)
     *     Column 2: Compile ID
     *     Column 3: Compilation level (1=C1, 3=C1 full, 4=C2)
     *     Column 4: Method name
     *     Column 5: Bytecode size
     * 
     * -XX:+UnlockDiagnosticVMOptions -XX:+LogCompilation
     * Detailed compilation log (XML format)
     * 
     * -XX:+PrintInlining
     * Shows inlining decisions
     * 
     * -XX:CompileThreshold=N
     * Set invocation threshold for C2
     * Default: 10000
     */
}
```

### C1 Compiler (Client)

```java
/**
 * C1 COMPILER:
 * 
 * Goals:
 * - Fast compilation time
 * - Quick startup
 * - Decent performance
 * 
 * Optimizations:
 * - Value numbering
 * - Method inlining (limited)
 * - Dead code elimination
 * - Constant folding
 * - Copy propagation
 * 
 * Use cases:
 * - Client applications
 * - Short-running programs
 * - Startup-sensitive code
 */

public class C1CompilerDemo {
    
    public int simpleMethod(int x, int y) {
        int a = x + 1;
        int b = y + 1;
        return a + b;
    }
    
    /**
     * BYTECODE:
     * 
     * 0: iload_1        // x
     * 1: iconst_1       // 1
     * 2: iadd           // x + 1
     * 3: istore_3       // a = x + 1
     * 4: iload_2        // y
     * 5: iconst_1       // 1
     * 6: iadd           // y + 1
     * 7: istore 4       // b = y + 1
     * 9: iload_3        // a
     * 10: iload 4       // b
     * 12: iadd          // a + b
     * 13: ireturn
     * 
     * C1 OPTIMIZATIONS:
     * 
     * 1. Register allocation:
     *    - Locals to CPU registers
     *    - x → register r1
     *    - y → register r2
     * 
     * 2. Constant folding:
     *    - Compile-time evaluation
     *    - Already done by javac here
     * 
     * 3. Dead code elimination:
     *    - Remove unused code
     * 
     * NATIVE CODE (simplified):
     * 
     * mov eax, [r1]     # Load x
     * add eax, 1        # x + 1
     * mov ecx, [r2]     # Load y
     * add ecx, 1        # y + 1
     * add eax, ecx      # (x+1) + (y+1)
     * ret               # Return
     */
    
    public int deadCodeExample() {
        int x = 10;
        int y = 20;   // Dead code (y never used)
        return x * 2;
    }
    
    /**
     * BYTECODE:
     * 
     * 0: bipush 10
     * 2: istore_1       // x = 10
     * 3: bipush 20
     * 5: istore_2       // y = 20 (dead!)
     * 6: iload_1
     * 7: iconst_2
     * 8: imul
     * 9: ireturn
     * 
     * C1 COMPILED CODE:
     * 
     * mov eax, 10       # x = 10
     * # y = 20 eliminated (dead code)
     * imul eax, 2       # x * 2
     * ret
     */
}
```

### C2 Compiler (Server)

```java
/**
 * C2 COMPILER:
 * 
 * Goals:
 * - Maximum performance
 * - Aggressive optimizations
 * - Long-running methods
 * 
 * Optimizations:
 * - Escape analysis
 * - Loop unrolling
 * - Loop invariant hoisting
 * - Range check elimination
 * - Scalar replacement
 * - Aggressive inlining
 * - Speculative optimizations
 * - Intrinsics
 * 
 * Use cases:
 * - Server applications
 * - Long-running processes
 * - Hot code paths
 */

public class C2CompilerDemo {
    
    /**
     * LOOP UNROLLING:
     */
    public int sumArray(int[] arr) {
        int sum = 0;
        for (int i = 0; i < arr.length; i++) {
            sum += arr[i];
        }
        return sum;
    }
    
    /**
     * ORIGINAL LOOP:
     * 
     * for (int i = 0; i < arr.length; i++) {
     *     sum += arr[i];
     * }
     * 
     * C2 UNROLLED (simplified):
     * 
     * int limit = arr.length - 3;
     * for (int i = 0; i < limit; i += 4) {
     *     sum += arr[i];
     *     sum += arr[i+1];
     *     sum += arr[i+2];
     *     sum += arr[i+3];
     * }
     * // Handle remaining elements
     * for (; i < arr.length; i++) {
     *     sum += arr[i];
     * }
     * 
     * Benefits:
     * - Fewer iterations
     * - Fewer branch predictions
     * - Better CPU pipeline utilization
     * - SIMD vectorization possible
     */
    
    /**
     * RANGE CHECK ELIMINATION:
     */
    public void fillArray(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            arr[i] = i * 2;
        }
    }
    
    /**
     * NORMAL BYTECODE:
     * 
     * Each arr[i] access includes:
     * 1. Check i >= 0
     * 2. Check i < arr.length
     * 3. Throw ArrayIndexOutOfBoundsException if fails
     * 
     * C2 OPTIMIZATION:
     * 
     * Proves i is always in bounds:
     * - Loop condition: i < arr.length
     * - i starts at 0
     * - i increments by 1
     * - Therefore: 0 <= i < arr.length (always)
     * 
     * ELIMINATES bounds checks!
     * 
     * Result: 30-50% speedup for array-heavy code
     */
    
    /**
     * ESCAPE ANALYSIS:
     */
    public int noEscape() {
        Point p = new Point(1, 2);  // Doesn't escape method
        return p.x + p.y;
    }
    
    static class Point {
        int x, y;
        Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }
    
    /**
     * NORMAL EXECUTION:
     * 
     * 1. Allocate Point on heap
     * 2. Initialize fields
     * 3. Read fields
     * 4. Eventually GC
     * 
     * C2 WITH ESCAPE ANALYSIS:
     * 
     * Point doesn't escape → Scalar replacement
     * 
     * Optimized to:
     * int x = 1;
     * int y = 2;
     * return x + y;
     * 
     * Result:
     * return 3;  // Constant folded!
     * 
     * NO heap allocation!
     * NO GC pressure!
     */
}
```

---

## 4. Tiered Compilation

### Tiered Compilation Levels

```java
/**
 * TIERED COMPILATION:
 * 
 * Combines interpreter and both compilers for optimal performance
 * 
 * LEVELS:
 * 
 * Level 0: Interpreter
 * - No compilation
 * - Profiling data collected
 * 
 * Level 1: C1 (Simple)
 * - Fast compilation
 * - No profiling
 * - Basic optimizations
 * 
 * Level 2: C1 (Limited Profile)
 * - Fast compilation
 * - Limited profiling
 * - Basic optimizations
 * 
 * Level 3: C1 (Full Profile)
 * - Fast compilation
 * - Full profiling
 * - Basic optimizations
 * 
 * Level 4: C2
 * - Slow compilation
 * - No profiling (uses data from Level 3)
 * - Aggressive optimizations
 * 
 * TYPICAL PATH:
 * 
 * Level 0 (Interpreter)
 *   ↓ 1500 invocations
 * Level 3 (C1 with profiling)
 *   ↓ 10000 invocations + good profile
 * Level 4 (C2)
 */

public class TieredCompilationDemo {
    
    public static void main(String[] args) {
        
        // Enable tiered compilation (default in Java 8+)
        // -XX:+TieredCompilation
        
        for (int i = 0; i < 50000; i++) {
            compute(i);
        }
    }
    
    private static int compute(int x) {
        return x * x;
    }
    
    /**
     * COMPILATION PROGRESSION:
     * 
     * Invocation 0-1500:
     * Level 0 (Interpreter)
     * - Slow execution
     * - Collecting profiling data:
     *   * Branch frequencies
     *   * Type profiles
     *   * Call site profiles
     * 
     * Invocation 1500:
     * Trigger: Invocation counter threshold
     * Level 0 → Level 3 (C1 Full Profile)
     * 
     * Invocations 1500-10000:
     * Level 3 (C1 Full Profile)
     * - Moderate performance
     * - Still collecting profile data
     * - Profiling overhead minimal
     * 
     * Invocation 10000:
     * Trigger: Invocation counter + good profile
     * Level 3 → Level 4 (C2)
     * 
     * Invocations 10000+:
     * Level 4 (C2)
     * - Maximum performance
     * - Uses profiling data from Level 3
     * - No more profiling
     * 
     * PrintCompilation output:
     * 
     *     74    1       3       compute (5 bytes)
     *            ↑       ↑       ↑
     *            |       |       Method
     *            |       Level (3 = C1 full)
     *            Compile ID
     * 
     *     124   1       4       compute (5 bytes)
     *            ↑       ↑
     *            |       Level (4 = C2)
     *            Same ID (recompilation)
     */
    
    /**
     * WHY TIERED COMPILATION?
     * 
     * Problem with C2 only:
     * - Slow compilation (100ms+ for complex methods)
     * - Poor startup performance
     * - Wasted time compiling rarely-used methods
     * 
     * Problem with C1 only:
     * - Lower peak performance
     * - Missing aggressive optimizations
     * - No escape analysis, etc.
     * 
     * Tiered compilation combines best of both:
     * - Fast startup (C1)
     * - Peak performance (C2)
     * - Smart compilation decisions (profiling)
     */
}
```

### Profiling Data

```java
/**
 * PROFILING DATA:
 * 
 * JVM collects data to guide C2 optimizations:
 * 
 * 1. Branch frequency
 * 2. Type profiles
 * 3. Call site profiles
 * 4. Null check profiles
 */

public class ProfilingDemo {
    
    /**
     * BRANCH PROFILING:
     */
    public int branchExample(int x) {
        if (x > 0) {
            return x * 2;     // Taken 90% of time
        } else {
            return x * 3;     // Taken 10% of time
        }
    }
    
    /**
     * PROFILE DATA:
     * 
     * if (x > 0):
     * - Taken: 90%
     * - Not taken: 10%
     * 
     * C2 OPTIMIZATION:
     * 
     * Optimize for common path:
     * - Inline x * 2 path
     * - x * 3 path as rare branch
     * 
     * CPU branch predictor also benefits!
     */
    
    /**
     * TYPE PROFILING:
     */
    public int polymorphicCall(Animal animal) {
        return animal.makeSound();
    }
    
    interface Animal {
        int makeSound();
    }
    
    static class Dog implements Animal {
        public int makeSound() { return 1; }
    }
    
    static class Cat implements Animal {
        public int makeSound() { return 2; }
    }
    
    /**
     * PROFILE DATA:
     * 
     * animal types seen:
     * - Dog: 95%
     * - Cat: 5%
     * 
     * C2 OPTIMIZATION (Speculative):
     * 
     * // Fast path (inlined)
     * if (animal.getClass() == Dog.class) {
     *     return 1;  // Dog.makeSound() inlined
     * } else {
     *     // Slow path (virtual call)
     *     return animal.makeSound();
     * }
     * 
     * Result: 95% of calls are fast!
     * 
     * If profile changes (Cat becomes common):
     * → Deoptimization
     * → Recompile with new profile
     */
    
    /**
     * CALL SITE PROFILING:
     */
    public void callSiteExample() {
        for (int i = 0; i < 1000; i++) {
            process(new Dog());     // Call site 1: always Dog
        }
        for (int i = 0; i < 10; i++) {
            process(new Cat());     // Call site 2: always Cat
        }
    }
    
    private void process(Animal animal) {
        animal.makeSound();
    }
    
    /**
     * PROFILE DATA:
     * 
     * Call site 1:
     * - Dog: 100%
     * 
     * Call site 2:
     * - Cat: 100%
     * 
     * C2 OPTIMIZATION:
     * 
     * Inline different implementations at each site!
     * 
     * Call site 1:
     * // Directly call Dog.makeSound()
     * 
     * Call site 2:
     * // Directly call Cat.makeSound()
     * 
     * NO virtual dispatch overhead!
     */
}
```

### Controlling Tiered Compilation

```bash
# Enable/disable tiered compilation
-XX:+TieredCompilation      # Enable (default)
-XX:-TieredCompilation      # Disable (C2 only)

# Set compilation thresholds
-XX:Tier3InvocationThreshold=2000    # C1 threshold (default: 1500)
-XX:Tier4InvocationThreshold=15000   # C2 threshold (default: 10000)

# Limit compilation levels
-XX:TieredStopAtLevel=1     # Only use C1
-XX:TieredStopAtLevel=3     # Use C1 with profiling (no C2)
-XX:TieredStopAtLevel=4     # Use all levels (default)

# Compiler threads
-XX:CICompilerCount=4       # Total compiler threads
-XX:CICompilerCountPerCPU=1 # Threads per CPU

# Monitoring
-XX:+PrintCompilation       # Show compilations
-XX:+PrintInlining          # Show inlining
-XX:+UnlockDiagnosticVMOptions
-XX:+LogCompilation         # Detailed log
```

---

## 5. Inlining and Method Compilation

### Method Inlining

```java
/**
 * METHOD INLINING:
 * 
 * Replace method call with method body
 * 
 * Benefits:
 * - Eliminate call overhead
 * - Enable further optimizations
 * - Better CPU cache utilization
 * 
 * Heuristics:
 * - Hot methods (called frequently)
 * - Small methods (< 35 bytecode bytes)
 * - Max inlining depth: 9 levels
 * - Max bytecode size after inlining: 8000 bytes
 */

public class InliningDemo {
    
    public int calculate(int x) {
        int a = square(x);
        int b = double(x);
        return a + b;
    }
    
    private int square(int x) {
        return x * x;
    }
    
    private int double(int x) {
        return x * 2;
    }
    
    /**
     * BEFORE INLINING:
     * 
     * calculate():
     * 0: aload_0
     * 1: iload_1
     * 2: invokevirtual square    // Method call
     * 5: istore_2
     * 6: aload_0
     * 7: iload_1
     * 8: invokevirtual double    // Method call
     * 11: istore_3
     * 12: iload_2
     * 13: iload_3
     * 14: iadd
     * 15: ireturn
     * 
     * AFTER INLINING (C2):
     * 
     * calculate():
     * int a = x * x;       // square() inlined
     * int b = x * 2;       // double() inlined
     * return a + b;
     * 
     * Further optimization:
     * return x * x + x * 2;
     * 
     * Final optimization:
     * return x * (x + 2);  // Common subexpression elimination
     * 
     * Result: NO method calls, optimal native code!
     */
    
    /**
     * INLINING DECISIONS:
     */
    private int smallMethod(int x) {
        return x + 1;  // 3 bytes → Always inlined
    }
    
    private int mediumMethod(int x) {
        int a = x * 2;
        int b = x * 3;
        int c = a + b;
        return c;      // 15 bytes → Usually inlined
    }
    
    private int largeMethod(int x) {
        // 100 lines of code
        // 500 bytes of bytecode
        return x;      // Too large → Not inlined
    }
    
    /**
     * MONITORING INLINING:
     * 
     * -XX:+PrintInlining
     * 
     * Output:
     *   @ 2   InliningDemo::square (5 bytes)   inline (hot)
     *   @ 8   InliningDemo::double (5 bytes)   inline (hot)
     *   @ 45  InliningDemo::largeMethod (500 bytes)   too big
     */
    
    /**
     * INLINING THRESHOLDS:
     */
    public static void main(String[] args) {
        /**
         * -XX:MaxInlineSize=35
         * Maximum bytecode size to inline (default: 35)
         * 
         * -XX:FreqInlineSize=325
         * Maximum size for hot methods (default: 325)
         * 
         * -XX:MaxInlineLevel=9
         * Maximum inlining depth (default: 9)
         * 
         * -XX:InlineSmallCode=2000
         * Maximum compiled size (default: 2000)
         */
    }
}
```

### Polymorphic Inlining

```java
/**
 * POLYMORPHIC INLINING:
 * 
 * Inline virtual/interface method calls
 * Uses type profiling
 */

public class PolymorphicInliningDemo {
    
    interface Shape {
        int area();
    }
    
    static class Square implements Shape {
        int side;
        
        public int area() {
            return side * side;
        }
    }
    
    static class Circle implements Shape {
        int radius;
        
        public int area() {
            return 3 * radius * radius;  // Simplified
        }
    }
    
    public int calculateArea(Shape shape) {
        return shape.area();
    }
    
    /**
     * MONOMORPHIC CALL SITE:
     * 
     * if (always called with Square) {
     *     Profile: Square 100%
     *     
     *     Optimized to:
     *     if (shape.getClass() == Square.class) {
     *         return ((Square)shape).side * ((Square)shape).side;
     *     } else {
     *         return shape.area();  // Rare path
     *     }
     *     
     *     Further optimized:
     *     int side = ((Square)shape).side;
     *     return side * side;
     * }
     * 
     * BIMORPHIC CALL SITE:
     * 
     * if (called with Square 60%, Circle 40%) {
     *     Profile: Square 60%, Circle 40%
     *     
     *     Optimized to:
     *     if (shape.getClass() == Square.class) {
     *         return ((Square)shape).side * ((Square)shape).side;
     *     } else if (shape.getClass() == Circle.class) {
     *         int r = ((Circle)shape).radius;
     *         return 3 * r * r;
     *     } else {
     *         return shape.area();  // Very rare
     *     }
     * }
     * 
     * MEGAMORPHIC CALL SITE:
     * 
     * if (called with many types) {
     *     Profile: Square 30%, Circle 30%, Triangle 30%, ...
     *     
     *     Cannot inline effectively!
     *     Uses normal virtual dispatch.
     *     
     *     Performance impact: 2-5x slower than monomorphic
     * }
     */
    
    public static void main(String[] args) {
        PolymorphicInliningDemo demo = new PolymorphicInliningDemo();
        
        // Monomorphic usage
        Square square = new Square();
        for (int i = 0; i < 100000; i++) {
            demo.calculateArea(square);  // Always Square
        }
        // Result: Fully inlined, no virtual call!
        
        // Megamorphic usage
        Shape[] shapes = {
            new Square(), new Circle(), 
            new Triangle(), new Rectangle()
        };
        for (int i = 0; i < 100000; i++) {
            demo.calculateArea(shapes[i % 4]);  // Many types
        }
        // Result: Cannot inline, virtual call remains
    }
    
    static class Triangle implements Shape {
        public int area() { return 0; }
    }
    
    static class Rectangle implements Shape {
        public int area() { return 0; }
    }
}
```

### Inlining Best Practices

```java
/**
 * INLINING OPTIMIZATION TIPS:
 */

public class InliningBestPractices {
    
    // ✅ GOOD: Small helper methods
    private int add(int a, int b) {
        return a + b;  // Will be inlined
    }
    
    // ✅ GOOD: Getter methods
    public int getValue() {
        return value;  // Will be inlined
    }
    
    // ✅ GOOD: Final methods (easier to inline)
    public final int compute(int x) {
        return x * 2;
    }
    
    // ❌ BAD: Large methods
    public int processLarge(int x) {
        // 100 lines of code
        // Won't be inlined
        return x;
    }
    
    // ⚠️ CAREFUL: Virtual calls with many implementations
    public void polymorphic(Animal animal) {
        animal.makeSound();  // Megamorphic → slow
    }
    
    private int value;
    
    interface Animal {
        void makeSound();
    }
    
    /**
     * OPTIMIZATION STRATEGIES:
     * 
     * 1. Keep methods small:
     *    - < 35 bytes for automatic inlining
     *    - Extract complex logic to separate methods
     * 
     * 2. Use final where possible:
     *    - final methods easier to inline
     *    - final classes eliminate virtual dispatch
     * 
     * 3. Avoid megamorphic call sites:
     *    - Keep call sites monomorphic or bimorphic
     *    - Use instanceof checks if needed
     * 
     * 4. Profile your code:
     *    - -XX:+PrintInlining
     *    - Check what's NOT being inlined
     *    - Refactor if needed
     * 
     * 5. Trust the JIT:
     *    - Don't manually inline everything
     *    - JIT makes smart decisions
     *    - Focus on algorithm, not micro-optimization
     */
    
    /**
     * EXAMPLE: Fixing megamorphic call site
     */
    
    // Before (megamorphic)
    public int processBefore(Shape shape) {
        return shape.area();  // Many Shape implementations
    }
    
    // After (monomorphic paths)
    public int processAfter(Shape shape) {
        if (shape instanceof Square) {
            return processSquare((Square) shape);
        } else if (shape instanceof Circle) {
            return processCircle((Circle) shape);
        } else {
            return shape.area();
        }
    }
    
    private int processSquare(Square s) {
        return s.side * s.side;  // Monomorphic, inlined
    }
    
    private int processCircle(Circle c) {
        return 3 * c.radius * c.radius;  // Monomorphic, inlined
    }
    
    interface Shape {
        int area();
    }
    
    static class Square implements Shape {
        int side;
        public int area() { return side * side; }
    }
    
    static class Circle implements Shape {
        int radius;
        public int area() { return 3 * radius * radius; }
    }
}
```

---

## 6. Deoptimization Scenarios

### Understanding Deoptimization

```java
/**
 * DEOPTIMIZATION:
 * 
 * JIT makes speculative optimizations based on profiling.
 * If assumptions become invalid, must deoptimize.
 * 
 * Process:
 * 1. Detect invalid assumption
 * 2. Transfer execution back to interpreter
 * 3. Continue execution (slower)
 * 4. Optionally recompile with new profile
 * 
 * Common causes:
 * 1. Type profile changed
 * 2. Class loading (new subclass)
 * 3. Uncommon trap hit
 * 4. Unreached code executed
 */

public class DeoptimizationDemo {
    
    interface Animal {
        String speak();
    }
    
    static class Dog implements Animal {
        public String speak() { return "Woof"; }
    }
    
    static class Cat implements Animal {
        public String speak() { return "Meow"; }
    }
    
    /**
     * SCENARIO 1: TYPE PROFILE CHANGE
     */
    public String process(Animal animal) {
        return animal.speak();
    }
    
    public static void scenario1() {
        DeoptimizationDemo demo = new DeoptimizationDemo();
        
        // Phase 1: Train with Dog only
        Dog dog = new Dog();
        for (int i = 0; i < 20000; i++) {
            demo.process(dog);
        }
        
        /**
         * JIT OPTIMIZATION:
         * 
         * Profile: Dog 100%
         * 
         * Optimized code:
         * if (animal.getClass() == Dog.class) {
         *     return "Woof";  // Inlined Dog.speak()
         * } else {
         *     return animal.speak();  // Uncommon trap
         * }
         */
        
        // Phase 2: Introduce Cat
        Cat cat = new Cat();
        demo.process(cat);  // DEOPTIMIZATION!
        
        /**
         * WHAT HAPPENS:
         * 
         * 1. Uncommon trap hit (not Dog)
         * 2. Deoptimize to interpreter
         * 3. Update profile: Dog 99%, Cat 1%
         * 4. Continue in interpreter
         * 5. After more calls, recompile with new profile
         * 
         * NEW OPTIMIZED CODE:
         * if (animal.getClass() == Dog.class) {
         *     return "Woof";
         * } else if (animal.getClass() == Cat.class) {
         *     return "Meow";
         * } else {
         *     return animal.speak();
         * }
         */
    }
    
    /**
     * SCENARIO 2: CLASS LOADING
     */
    static class Bird implements Animal {
        public String speak() { return "Chirp"; }
    }
    
    public static void scenario2() throws Exception {
        DeoptimizationDemo demo = new DeoptimizationDemo();
        
        // Compile with only Dog known
        for (int i = 0; i < 20000; i++) {
            demo.process(new Dog());
        }
        
        // Load new class
        Class<?> birdClass = Class.forName("DeoptimizationDemo$Bird");
        Animal bird = (Animal) birdClass.getDeclaredConstructor().newInstance();
        
        demo.process(bird);  // DEOPTIMIZATION!
        
        /**
         * REASON:
         * 
         * JIT assumed only Dog exists
         * New subclass Bird loaded
         * Invalidates optimization
         * Must deoptimize
         */
    }
    
    /**
     * SCENARIO 3: UNREACHED CODE
     */
    public int divide(int a, int b) {
        return a / b;
    }
    
    public static void scenario3() {
        DeoptimizationDemo demo = new DeoptimizationDemo();
        
        // Train with b != 0
        for (int i = 0; i < 20000; i++) {
            demo.divide(100, 10);
        }
        
        /**
         * JIT OPTIMIZATION:
         * 
         * Profile: b never 0
         * Optimization: Assume b != 0
         * Remove division-by-zero check!
         * 
         * Optimized code:
         * return a / b;  // No check
         */
        
        // Trigger division by zero
        try {
            demo.divide(100, 0);  // DEOPTIMIZATION!
        } catch (ArithmeticException e) {
            // Exception thrown
        }
        
        /**
         * WHAT HAPPENS:
         * 
         * 1. Division by zero attempted
         * 2. Hardware exception
         * 3. JVM catches, deoptimizes
         * 4. Re-executes in interpreter with checks
         * 5. Throws ArithmeticException properly
         */
    }
    
    /**
     * SCENARIO 4: NULL CHECK ELIMINATION
     */
    public int useObject(String s) {
        return s.length();
    }
    
    public static void scenario4() {
        DeoptimizationDemo demo = new DeoptimizationDemo();
        
        // Train with non-null
        for (int i = 0; i < 20000; i++) {
            demo.useObject("Hello");
        }
        
        /**
         * JIT OPTIMIZATION:
         * 
         * Profile: s never null
         * Optimization: Remove null check
         * 
         * Optimized code:
         * return s.length();  // No null check
         */
        
        // Pass null
        try {
            demo.useObject(null);  // DEOPTIMIZATION!
        } catch (NullPointerException e) {
            // Exception thrown after deoptimization
        }
    }
}
```

### Deoptimization Performance Impact

```java
/**
 * DEOPTIMIZATION COSTS:
 * 
 * 1. Transfer to interpreter (slow)
 * 2. Lost optimized code
 * 3. Recompilation time
 * 4. Performance cliff
 */

public class DeoptimizationPerformanceDemo {
    
    interface Processor {
        int process(int x);
    }
    
    static class FastProcessor implements Processor {
        public int process(int x) { return x * 2; }
    }
    
    static class SlowProcessor implements Processor {
        public int process(int x) { return x * 3; }
    }
    
    public int calculate(Processor p, int x) {
        return p.process(x);
    }
    
    public static void main(String[] args) {
        DeoptimizationPerformanceDemo demo = 
            new DeoptimizationPerformanceDemo();
        
        FastProcessor fast = new FastProcessor();
        SlowProcessor slow = new SlowProcessor();
        
        // Warmup with FastProcessor
        for (int i = 0; i < 20000; i++) {
            demo.calculate(fast, i);
        }
        
        System.out.println("Warmed up with FastProcessor");
        
        // Benchmark stable state
        long start = System.nanoTime();
        for (int i = 0; i < 1000000; i++) {
            demo.calculate(fast, i);
        }
        long stableTime = System.nanoTime() - start;
        System.out.println("Stable time: " + stableTime / 1_000_000 + "ms");
        
        // Introduce SlowProcessor (deoptimization!)
        demo.calculate(slow, 1);
        
        System.out.println("Deoptimized!");
        
        // Benchmark after deoptimization
        start = System.nanoTime();
        for (int i = 0; i < 1000000; i++) {
            demo.calculate(fast, i);
        }
        long deoptTime = System.nanoTime() - start;
        System.out.println("Deopt time: " + deoptTime / 1_000_000 + "ms");
        
        System.out.println("Slowdown: " + 
            (double) deoptTime / stableTime + "x");
        
        /**
         * TYPICAL RESULTS:
         * 
         * Stable time: 5ms
         * Deopt time: 50ms
         * Slowdown: 10x
         * 
         * Eventually recompiles to bimorphic:
         * After 20000 more iterations: back to ~10ms
         */
    }
    
    /**
     * AVOIDING DEOPTIMIZATION:
     * 
     * 1. Consistent types:
     *    - Keep call sites monomorphic
     *    - Avoid type mixing
     * 
     * 2. Handle edge cases early:
     *    - Check nulls before hot loop
     *    - Validate inputs upfront
     * 
     * 3. Stable code paths:
     *    - Avoid loading classes mid-execution
     *    - Initialize all types early
     * 
     * 4. Profile-guided optimization:
     *    - Run representative workload
     *    - Let JIT learn real patterns
     */
}
```

### Monitoring Deoptimization

```bash
# Show deoptimization events
-XX:+UnlockDiagnosticVMOptions
-XX:+PrintCompilation
-XX:+PrintDeoptimization

# Sample output:
#     123    1       4       MyClass::method (10 bytes)   made not entrant
#                                                          ^^^^^^^^^^^^^^
#                                                          Deoptimized
#
# "made not entrant" = deoptimized
# "made zombie" = code can be freed

# Detailed deoptimization info
-XX:+TraceDeoptimization

# Count uncommon traps
-XX:+LogCompilation
# Then analyze with JITWatch or similar tool
```

---

## 7. JVM Intrinsics

### What are Intrinsics?

```java
/**
 * JVM INTRINSICS:
 * 
 * Special methods with hand-written native implementations
 * 
 * Characteristics:
 * - Implemented in JVM (not JIT compiled)
 * - Highly optimized assembly code
 * - Sometimes use special CPU instructions
 * - Much faster than Java implementation
 * 
 * Common intrinsics:
 * - Math.sqrt, Math.sin, Math.cos
 * - System.arraycopy
 * - String.indexOf, String.equals
 * - Arrays.equals, Arrays.copyOf
 * - Unsafe operations
 * - Object.hashCode
 * - Integer.bitCount
 */

public class IntrinsicsDemo {
    
    /**
     * MATH INTRINSICS:
     */
    public void mathIntrinsics() {
        double x = 2.0;
        
        double sqrt = Math.sqrt(x);    // Intrinsic: fsqrt instruction
        double sin = Math.sin(x);       // Intrinsic: fsin instruction
        double cos = Math.cos(x);       // Intrinsic: fcos instruction
        double abs = Math.abs(x);       // Intrinsic: fabs instruction
        
        /**
         * PERFORMANCE:
         * 
         * Java implementation (polynomial approximation):
         * Math.sqrt: ~20-30 CPU cycles
         * 
         * Intrinsic (native CPU instruction):
         * Math.sqrt: ~5-10 CPU cycles
         * 
         * 3-5x faster!
         */
    }
    
    /**
     * ARRAY INTRINSICS:
     */
    public void arrayIntrinsics() {
        int[] src = new int[1000];
        int[] dest = new int[1000];
        
        // Intrinsic: optimized memory copy
        System.arraycopy(src, 0, dest, 0, 1000);
        
        /**
         * IMPLEMENTATION:
         * 
         * Java loop:
         * for (int i = 0; i < length; i++) {
         *     dest[i] = src[i];
         * }
         * 
         * Intrinsic uses:
         * - memcpy on x86
         * - SIMD instructions (AVX, SSE)
         * - Aligned memory access
         * - Prefetching
         * 
         * Result: 10-50x faster than Java loop!
         */
        
        // Arrays.equals also intrinsic
        boolean equal = Arrays.equals(src, dest);
        
        /**
         * Intrinsic implementation:
         * - Compare 64 bits at a time (SIMD)
         * - Early exit on difference
         * - No bounds checks in loop
         */
    }
    
    /**
     * STRING INTRINSICS:
     */
    public void stringIntrinsics() {
        String s1 = "Hello World";
        String s2 = "Hello World";
        String s3 = "Hello";
        
        // Intrinsic: optimized comparison
        boolean eq = s1.equals(s2);
        
        /**
         * Intrinsic optimization:
         * 1. Reference check: s1 == s2
         * 2. Length check: s1.length() == s2.length()
         * 3. SIMD comparison of characters
         * 
         * Much faster than char-by-char loop
         */
        
        // Intrinsic: Boyer-Moore-Horspool algorithm
        int index = s1.indexOf(s3);
        
        /**
         * Intrinsic uses advanced string search:
         * - Boyer-Moore-Horspool
         * - SIMD instructions
         * - Pattern preprocessing
         * 
         * 5-10x faster than naive search
         */
    }
    
    /**
     * BIT MANIPULATION INTRINSICS:
     */
    public void bitIntrinsics() {
        int x = 0b10101100;
        
        // Intrinsic: popcnt instruction
        int count = Integer.bitCount(x);
        
        /**
         * Java implementation:
         * int count = 0;
         * while (x != 0) {
         *     count += x & 1;
         *     x >>>= 1;
         * }
         * 
         * Intrinsic: single popcnt instruction
         * 
         * Result: 30x faster!
         */
        
        // Other bit intrinsics:
        int leading = Integer.numberOfLeadingZeros(x);   // lzcnt
        int trailing = Integer.numberOfTrailingZeros(x); // tzcnt
    }
    
    /**
     * UNSAFE INTRINSICS:
     */
    public void unsafeIntrinsics() {
        sun.misc.Unsafe unsafe = getUnsafe();
        
        long address = unsafe.allocateMemory(1024);
        
        // Direct memory access (intrinsic)
        unsafe.putLong(address, 12345L);
        long value = unsafe.getLong(address);
        
        // Compare and swap (intrinsic: CMPXCHG instruction)
        boolean success = unsafe.compareAndSwapLong(
            null, address, 12345L, 67890L);
        
        /**
         * CAS is fundamental for:
         * - AtomicInteger, AtomicLong
         * - Lock-free data structures
         * - Concurrent algorithms
         * 
         * Single CPU instruction (atomic)!
         */
        
        unsafe.freeMemory(address);
    }
    
    private static sun.misc.Unsafe getUnsafe() {
        try {
            java.lang.reflect.Field f = 
                sun.misc.Unsafe.class.getDeclaredField("theUnsafe");
            f.setAccessible(true);
            return (sun.misc.Unsafe) f.get(null);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
    
    /**
     * CRYPTO INTRINSICS:
     */
    public void cryptoIntrinsics() {
        /**
         * AES encryption/decryption:
         * - Uses AES-NI instructions (x86)
         * - Hardware-accelerated
         * - 10-20x faster than software
         * 
         * SHA hashing:
         * - Uses SHA extensions
         * - Hardware-accelerated
         * - 3-5x faster
         * 
         * Available in:
         * - javax.crypto.Cipher (AES)
         * - java.security.MessageDigest (SHA)
         */
    }
}
```

### Custom Intrinsics (Advanced)

```java
/**
 * CREATING CUSTOM INTRINSICS:
 * 
 * For OpenJDK developers only!
 * 
 * Steps:
 * 1. Identify hot method
 * 2. Write Java declaration
 * 3. Write C++ implementation in JVM
 * 4. Register intrinsic
 * 5. Recompile JVM
 * 
 * Example: String.indexOf intrinsic
 */

// vmSymbols.hpp
/*
template(indexOf_name, "indexOf")

// library_call.cpp
bool LibraryCallKit::inline_string_indexOf() {
    Node* source = argument(0);
    Node* target = argument(1);
    Node* from_index = argument(2);
    
    // Use optimized assembly implementation
    Node* result = make_string_indexOf(source, target, from_index);
    
    set_result(result);
    return true;
}
*/

/**
 * WHY CREATE INTRINSICS:
 * 
 * - Critical performance path
 * - CPU-specific optimization available
 * - Complex algorithm benefits from hand-tuning
 * - Used by many applications
 * 
 * Examples:
 * - Base64 encoding/decoding
 * - Vector operations
 * - Specialized math functions
 */
```

---

## Summary

### Bytecode Quick Reference

```
LOAD:     iload, lload, fload, dload, aload
STORE:    istore, lstore, fstore, dstore, astore
ARITHMETIC: iadd, isub, imul, idiv, irem, ineg
COMPARISON: ifeq, ifne, iflt, ifle, ifgt, ifge
INVOKE:   invokevirtual, invokespecial, invokestatic, invokeinterface
OBJECTS:  new, newarray, anewarray, getfield, putfield
CONTROL:  goto, if_icmp*, return, ireturn
STACK:    dup, pop, swap
```

### JIT Compilation Levels

|Level|Name|Compiler|Profiling|Optimizations|Use Case|
|---|---|---|---|---|---|
|0|Interpreter|None|Yes|None|Startup|
|1|C1 Simple|C1|No|Basic|Quick compile|
|2|C1 Limited|C1|Limited|Basic|Rarely used|
|3|C1 Full|C1|Full|Basic|Collect profile|
|4|C2|C2|No|Aggressive|Peak performance|

### Key Performance Concepts

1. **Tiered Compilation**: Combines fast startup (C1) with peak performance (C2)
2. **Inlining**: Eliminates method call overhead, enables further optimizations
3. **Escape Analysis**: Scalar replacement, lock elision, stack allocation
4. **Deoptimization**: Falls back to interpreter when assumptions invalid
5. **Intrinsics**: Hand-optimized native implementations of critical methods

### Optimization Checklist

- ✅ Keep hot methods small (< 35 bytes)
- ✅ Use final methods/classes when possible
- ✅ Avoid megamorphic call sites
- ✅ Profile before optimizing
- ✅ Let JIT do its job (don't micro-optimize)
- ✅ Use intrinsic methods (Math, System.arraycopy, etc.)
- ✅ Maintain type stability (avoid deoptimization)

### JVM Flags Reference

```bash
# Compilation monitoring
-XX:+PrintCompilation          # Show compilations
-XX:+PrintInlining              # Show inlining decisions
-XX:+LogCompilation             # Detailed XML log

# Compilation control
-XX:+TieredCompilation          # Enable tiered (default)
-XX:TieredStopAtLevel=N         # Stop at level N
-XX:CompileThreshold=N          # C2 threshold (default: 10000)

# Inlining control
-XX:MaxInlineSize=N             # Max inline size (default: 35)
-XX:FreqInlineSize=N            # Hot method size (default: 325)

# Deoptimization monitoring
-XX:+PrintDeoptimization        # Show deoptimization
-XX:+TraceDeoptimization        # Detailed deopt info
```

---

