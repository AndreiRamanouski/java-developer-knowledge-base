# Java Stack vs Heap Allocation

## Overview

Understanding stack and heap allocation is crucial for Java performance optimization. This guide explores when and how objects are allocated, escape analysis, stack internals, and optimization techniques.

---

## 1. When Objects Go to Stack (Escape Analysis)

### Escape Analysis Fundamentals

```java
/**
 * ESCAPE ANALYSIS:
 * 
 * JVM optimization that determines if an object's lifetime
 * is confined to a method or thread.
 * 
 * OBJECT ESCAPES IF:
 * 1. Returned from method
 * 2. Stored in static field
 * 3. Stored in heap object field
 * 4. Passed to unknown code
 * 5. Captured by lambda/inner class (may escape)
 * 
 * IF OBJECT DOESN'T ESCAPE:
 * - Can be allocated on stack
 * - Can be scalar replaced (eliminated entirely)
 * - Locks can be elided
 * 
 * ENABLED BY DEFAULT:
 * -XX:+DoEscapeAnalysis (default: true)
 */

public class EscapeAnalysisDemo {
    
    /**
     * EXAMPLE 1: DOES NOT ESCAPE (Stack allocation possible)
     */
    public int noEscape() {
        Point p = new Point(1, 2);
        return p.x + p.y;
        
        /**
         * ANALYSIS:
         * 
         * Point p created inside method
         * Not returned
         * Not stored anywhere
         * Not passed to other methods
         * 
         * RESULT: Point can be stack-allocated or scalar replaced
         * 
         * BYTECODE (before optimization):
         * new Point
         * dup
         * iconst_1
         * iconst_2
         * invokespecial Point.<init>
         * astore_1
         * aload_1
         * getfield Point.x
         * aload_1
         * getfield Point.y
         * iadd
         * ireturn
         * 
         * OPTIMIZED (after scalar replacement):
         * iconst_1  // x
         * iconst_2  // y
         * iadd
         * ireturn
         * 
         * Point object eliminated entirely!
         */
    }
    
    /**
     * EXAMPLE 2: ESCAPES BY RETURN (Heap allocation required)
     */
    public Point escapesReturn() {
        Point p = new Point(1, 2);
        return p;  // ESCAPES: Returned to caller
        
        /**
         * ANALYSIS:
         * 
         * Point p returned from method
         * Lifetime extends beyond method
         * Caller can store it anywhere
         * 
         * RESULT: Must allocate on heap
         */
    }
    
    /**
     * EXAMPLE 3: ESCAPES BY FIELD ASSIGNMENT (Heap allocation required)
     */
    private Point globalPoint;
    
    public void escapesField() {
        Point p = new Point(1, 2);
        this.globalPoint = p;  // ESCAPES: Stored in field
        
        /**
         * ANALYSIS:
         * 
         * Point stored in instance field
         * Can be accessed by other methods
         * Lifetime tied to enclosing object
         * 
         * RESULT: Must allocate on heap
         */
    }
    
    /**
     * EXAMPLE 4: ESCAPES BY STATIC FIELD (Heap allocation required)
     */
    private static Point staticPoint;
    
    public void escapesStatic() {
        Point p = new Point(1, 2);
        staticPoint = p;  // ESCAPES: Stored in static field
        
        /**
         * ANALYSIS:
         * 
         * Point stored in static field
         * Accessible by all threads
         * Lifetime until class unload
         * 
         * RESULT: Must allocate on heap
         */
    }
    
    /**
     * EXAMPLE 5: MAY ESCAPE BY METHOD CALL
     */
    public void mayEscape() {
        Point p = new Point(1, 2);
        process(p);  // May escape depending on process() implementation
    }
    
    private void process(Point p) {
        // If this method doesn't let p escape, then p can be optimized
        int sum = p.x + p.y;
        System.out.println(sum);
    }
    
    /**
     * ANALYSIS:
     * 
     * If JIT can see process() implementation:
     * - Inlines process() into mayEscape()
     * - Determines p doesn't escape
     * - Optimizes as if it's local
     * 
     * If JIT cannot see implementation:
     * - Must assume p might escape
     * - Allocates on heap
     */
    
    /**
     * EXAMPLE 6: ESCAPES VIA EXCEPTION
     */
    public void escapesException() {
        try {
            Point p = new Point(1, 2);
            riskyOperation();
            // p doesn't escape here
        } catch (Exception e) {
            // But exception can capture p in stack trace
        }
        
        /**
         * ANALYSIS:
         * 
         * Stack trace might reference local variables
         * JIT must be conservative
         * Usually allocates on heap
         */
    }
    
    /**
     * EXAMPLE 7: ESCAPES VIA LAMBDA
     */
    public Runnable escapesLambda() {
        Point p = new Point(1, 2);
        
        return () -> {
            System.out.println(p.x + p.y);  // ESCAPES: Captured by lambda
        };
        
        /**
         * ANALYSIS:
         * 
         * Lambda captures p
         * Lambda returned from method
         * p must outlive method invocation
         * 
         * RESULT: Must allocate on heap
         */
    }
    
    /**
     * EXAMPLE 8: DOES NOT ESCAPE VIA LOCAL LAMBDA
     */
    public void notEscapeLambda() {
        Point p = new Point(1, 2);
        
        Runnable r = () -> {
            System.out.println(p.x + p.y);
        };
        
        r.run();  // Lambda used locally only
        
        /**
         * ANALYSIS:
         * 
         * Lambda created and used locally
         * Not returned or stored
         * JIT can inline lambda
         * p might be optimized (if JIT is smart enough)
         */
    }
    
    static class Point {
        int x, y;
        
        Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }
}
```

### Escape Analysis Limitations

```java
/**
 * WHEN ESCAPE ANALYSIS FAILS:
 */

public class EscapeAnalysisLimitations {
    
    /**
     * LIMITATION 1: POLYMORPHISM
     */
    interface Shape {
        int area();
    }
    
    static class Square implements Shape {
        int side;
        
        Square(int side) {
            this.side = side;
        }
        
        public int area() {
            return side * side;
        }
    }
    
    public int polymorphicCall(boolean flag) {
        Shape s = flag ? new Square(5) : new Circle(3);
        return s.area();
        
        /**
         * PROBLEM:
         * 
         * Shape type unknown at compile time
         * Might be Square or Circle
         * JIT can't prove it doesn't escape
         * 
         * RESULT: Allocates on heap
         * 
         * SOLUTION:
         * If JIT can prove only one type ever used (monomorphic),
         * it can optimize
         */
    }
    
    static class Circle implements Shape {
        int radius;
        
        Circle(int radius) {
            this.radius = radius;
        }
        
        public int area() {
            return (int) (Math.PI * radius * radius);
        }
    }
    
    /**
     * LIMITATION 2: LARGE OBJECTS
     */
    public void largeObject() {
        int[] large = new int[10000];  // 40KB
        process(large);
        
        /**
         * PROBLEM:
         * 
         * Even if doesn't escape, too large for stack
         * Stack typically 256KB - 1MB
         * Large arrays would overflow stack
         * 
         * RESULT: Allocates on heap
         * 
         * JVM FLAG:
         * -XX:EliminateAllocationArraySizeLimit=64
         * Max array size for stack allocation (default 64)
         */
    }
    
    private void process(int[] arr) {
        // Use array
    }
    
    /**
     * LIMITATION 3: RECURSIVE CALLS
     */
    public int recursive(int n) {
        if (n <= 0) return 0;
        
        Point p = new Point(n, n);  // Created in each recursion
        return p.x + recursive(n - 1);
        
        /**
         * PROBLEM:
         * 
         * Each recursive call creates new Point
         * Deep recursion could overflow stack
         * JIT must be conservative
         * 
         * RESULT: Usually allocates on heap
         */
    }
    
    /**
     * LIMITATION 4: UNKNOWN CALLEES
     */
    public void unknownCallee() {
        Point p = new Point(1, 2);
        someLibraryMethod(p);  // Don't know what this does
        
        /**
         * PROBLEM:
         * 
         * someLibraryMethod() from external library
         * JIT can't see implementation
         * Must assume p might escape
         * 
         * RESULT: Allocates on heap
         * 
         * EXCEPTION:
         * If method is final or class is final,
         * JIT might have more confidence
         */
    }
    
    private void someLibraryMethod(Point p) {
        // Unknown implementation
    }
    
    /**
     * LIMITATION 5: REFLECTION
     */
    public void reflection() throws Exception {
        Point p = new Point(1, 2);
        
        Class<?> clazz = p.getClass();
        java.lang.reflect.Method m = clazz.getMethod("toString");
        m.invoke(p);
        
        /**
         * PROBLEM:
         * 
         * Reflection can do anything
         * Can store object anywhere
         * JIT cannot analyze
         * 
         * RESULT: Always allocates on heap
         */
    }
    
    static class Point {
        int x, y;
        Point(int x, int y) { this.x = x; this.y = y; }
    }
}
```

---

## 2. Scalar Replacement

### Understanding Scalar Replacement

```java
/**
 * SCALAR REPLACEMENT:
 * 
 * JIT optimization that replaces object allocation with
 * individual variables (scalars) for each field.
 * 
 * REQUIREMENTS:
 * 1. Object doesn't escape
 * 2. Object has known type
 * 3. All fields accessed individually
 * 
 * RESULT:
 * - No object allocation
 * - No memory overhead
 * - Better register allocation
 * - Enables further optimizations
 * 
 * ENABLED BY DEFAULT:
 * -XX:+EliminateAllocations (default: true)
 */

public class ScalarReplacementDemo {
    
    /**
     * EXAMPLE 1: BASIC SCALAR REPLACEMENT
     */
    public int basicScalarReplacement() {
        Point p = new Point(1, 2);
        return p.x + p.y;
        
        /**
         * ORIGINAL CODE:
         * - Allocate Point object (24 bytes)
         * - Initialize fields
         * - Read fields
         * - Add values
         * 
         * AFTER SCALAR REPLACEMENT:
         * - int x = 1;  // Scalar variable
         * - int y = 2;  // Scalar variable
         * - return x + y;
         * 
         * OPTIMIZED FURTHER:
         * - return 3;  // Constant folded
         * 
         * RESULT:
         * - No allocation
         * - No memory access
         * - Single instruction
         */
    }
    
    /**
     * EXAMPLE 2: COMPLEX OBJECT
     */
    static class Rectangle {
        int x, y, width, height;
        
        Rectangle(int x, int y, int width, int height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }
        
        int area() {
            return width * height;
        }
    }
    
    public int rectangleArea() {
        Rectangle r = new Rectangle(10, 20, 30, 40);
        return r.area();
        
        /**
         * AFTER SCALAR REPLACEMENT:
         * 
         * int x = 10;
         * int y = 20;
         * int width = 30;
         * int height = 40;
         * return width * height;
         * 
         * OPTIMIZED:
         * return 1200;
         * 
         * Rectangle object completely eliminated!
         */
    }
    
    /**
     * EXAMPLE 3: NESTED OBJECTS
     */
    static class Line {
        Point start, end;
        
        Line(Point start, Point end) {
            this.start = start;
            this.end = end;
        }
        
        int length() {
            int dx = end.x - start.x;
            int dy = end.y - start.y;
            return (int) Math.sqrt(dx * dx + dy * dy);
        }
    }
    
    public int lineLength() {
        Point p1 = new Point(0, 0);
        Point p2 = new Point(3, 4);
        Line line = new Line(p1, p2);
        return line.length();
        
        /**
         * AFTER SCALAR REPLACEMENT:
         * 
         * // Line object
         * int start_x = 0;
         * int start_y = 0;
         * int end_x = 3;
         * int end_y = 4;
         * 
         * // Inlined length()
         * int dx = end_x - start_x;  // 3
         * int dy = end_y - start_y;  // 4
         * return (int) Math.sqrt(dx * dx + dy * dy);  // 5
         * 
         * OPTIMIZED:
         * return 5;
         * 
         * THREE objects eliminated: p1, p2, line
         */
    }
    
    /**
     * EXAMPLE 4: LOOP WITH OBJECTS
     */
    public int sumAreas() {
        int sum = 0;
        for (int i = 0; i < 1000; i++) {
            Rectangle r = new Rectangle(i, i, 10, 20);
            sum += r.area();
        }
        return sum;
        
        /**
         * WITHOUT SCALAR REPLACEMENT:
         * - 1000 Rectangle allocations
         * - 1000 × 32 bytes = 32KB allocated
         * - GC pressure
         * 
         * WITH SCALAR REPLACEMENT:
         * int sum = 0;
         * for (int i = 0; i < 1000; i++) {
         *     int width = 10;
         *     int height = 20;
         *     sum += width * height;
         * }
         * 
         * OPTIMIZED (loop invariant):
         * int area = 200;
         * int sum = 0;
         * for (int i = 0; i < 1000; i++) {
         *     sum += area;
         * }
         * 
         * FULLY OPTIMIZED:
         * return 200000;
         * 
         * Zero allocations, constant result!
         */
    }
    
    /**
     * EXAMPLE 5: WHEN SCALAR REPLACEMENT FAILS
     */
    public Point cannotScalarReplace() {
        Point p = new Point(1, 2);
        return p;  // ESCAPES
        
        /**
         * Point escapes (returned)
         * Cannot replace with scalars
         * Must allocate actual object
         */
    }
    
    private Point[] points = new Point[100];
    
    public void cannotScalarReplace2() {
        Point p = new Point(1, 2);
        points[0] = p;  // ESCAPES to array
        
        /**
         * Point stored in array (heap)
         * Cannot replace with scalars
         * Must allocate actual object
         */
    }
    
    static class Point {
        int x, y;
        Point(int x, int y) { this.x = x; this.y = y; }
    }
}
```

### Scalar Replacement Performance

```java
/**
 * MEASURING SCALAR REPLACEMENT IMPACT:
 */

public class ScalarReplacementPerformance {
    
    /**
     * BENCHMARK: With and without scalar replacement
     */
    static class Point {
        double x, y;
        
        Point(double x, double y) {
            this.x = x;
            this.y = y;
        }
        
        double distance() {
            return Math.sqrt(x * x + y * y);
        }
    }
    
    /**
     * TEST 1: Local object (scalar replacement possible)
     */
    public double testLocal() {
        double sum = 0;
        for (int i = 0; i < 1_000_000; i++) {
            Point p = new Point(i, i);
            sum += p.distance();
        }
        return sum;
        
        /**
         * WITH SCALAR REPLACEMENT:
         * - Time: ~5ms
         * - Allocations: 0
         * - GC: No pressure
         * 
         * WITHOUT SCALAR REPLACEMENT (-XX:-EliminateAllocations):
         * - Time: ~50ms
         * - Allocations: 1M × 32 bytes = 32MB
         * - GC: Frequent young gen collections
         * 
         * SPEEDUP: 10x faster with scalar replacement!
         */
    }
    
    /**
     * TEST 2: Escaped object (no scalar replacement)
     */
    private Point lastPoint;
    
    public double testEscaped() {
        double sum = 0;
        for (int i = 0; i < 1_000_000; i++) {
            Point p = new Point(i, i);
            lastPoint = p;  // ESCAPES
            sum += p.distance();
        }
        return sum;
        
        /**
         * WITH AND WITHOUT -XX:-EliminateAllocations:
         * - Time: ~50ms (same)
         * - Allocations: 32MB (same)
         * - GC: Same pressure
         * 
         * Object escapes, so no scalar replacement possible
         * Flag makes no difference
         */
    }
    
    /**
     * FULL BENCHMARK:
     */
    public static void main(String[] args) {
        ScalarReplacementPerformance demo = new ScalarReplacementPerformance();
        
        // Warmup
        for (int i = 0; i < 10; i++) {
            demo.testLocal();
        }
        
        // Measure
        long start = System.nanoTime();
        for (int i = 0; i < 100; i++) {
            demo.testLocal();
        }
        long elapsed = System.nanoTime() - start;
        
        System.out.println("Average: " + elapsed / 100 / 1_000_000 + "ms");
        
        /**
         * TYPICAL RESULTS:
         * 
         * With -XX:+EliminateAllocations (default):
         * Average: 5ms
         * 
         * With -XX:-EliminateAllocations:
         * Average: 50ms
         * 
         * Scalar replacement provides 10x speedup!
         */
    }
    
    /**
     * MONITORING SCALAR REPLACEMENT:
     * 
     * JVM FLAGS:
     * -XX:+PrintEliminateAllocations
     * Shows which allocations are eliminated
     * 
     * -XX:+PrintCompilation
     * Shows when methods are compiled
     * 
     * -XX:+UnlockDiagnosticVMOptions
     * -XX:+LogCompilation
     * Detailed XML log
     */
}
```

---

## 3. Stack Frame Structure

### Stack Frame Anatomy

```java
/**
 * STACK FRAME STRUCTURE:
 * 
 * Each method invocation creates a stack frame containing:
 * 1. Local Variables Array
 * 2. Operand Stack
 * 3. Frame Data (return address, exception handlers)
 * 
 * STACK FRAME LAYOUT:
 * 
 * ┌─────────────────────────────────────┐  ← Stack pointer (SP)
 * │         Operand Stack               │
 * │  (Working storage for computation)  │
 * ├─────────────────────────────────────┤
 * │      Local Variables Array          │
 * │  Index 0: 'this' (instance methods) │
 * │  Index 1+: Parameters                │
 * │  Index N+: Local variables           │
 * ├─────────────────────────────────────┤
 * │          Frame Data                 │
 * │  - Return address                   │
 * │  - Exception handler table          │
 * │  - Constant pool reference          │
 * │  - Previous frame pointer           │
 * └─────────────────────────────────────┘  ← Frame pointer (FP)
 * 
 * THREAD STACK:
 * 
 * ┌─────────────────────────────────────┐  ← Stack top
 * │      Current Method Frame           │
 * ├─────────────────────────────────────┤
 * │      Caller Method Frame            │
 * ├─────────────────────────────────────┤
 * │      Caller's Caller Frame          │
 * ├─────────────────────────────────────┤
 * │            ...                      │
 * ├─────────────────────────────────────┤
 * │          main() Frame               │
 * └─────────────────────────────────────┘  ← Stack base
 */

public class StackFrameDemo {
    
    /**
     * EXAMPLE METHOD:
     */
    public int calculate(int a, int b) {
        int result = a + b;
        int doubled = result * 2;
        return doubled;
    }
    
    /**
     * STACK FRAME FOR calculate(5, 3):
     * 
     * ┌─────────────────────────────────────┐
     * │      OPERAND STACK                  │
     * │  (max depth: 2 values)              │
     * │  Initially empty                    │
     * │  During execution:                  │
     * │    [5, 3] → [8] → [8, 2] → [16]    │
     * ├─────────────────────────────────────┤
     * │    LOCAL VARIABLES ARRAY            │
     * │  Index 0: this (reference)          │
     * │  Index 1: a = 5                     │
     * │  Index 2: b = 3                     │
     * │  Index 3: result = 8                │
     * │  Index 4: doubled = 16              │
     * ├─────────────────────────────────────┤
     * │       FRAME DATA                    │
     * │  Return address                     │
     * │  Exception handlers                 │
     * └─────────────────────────────────────┘
     * 
     * BYTECODE EXECUTION:
     * 
     * 0: iload_1        // Load a (5) → Stack: [5]
     * 1: iload_2        // Load b (3) → Stack: [5, 3]
     * 2: iadd           // Add         → Stack: [8]
     * 3: istore_3       // Store result → Local[3] = 8
     * 4: iload_3        // Load result → Stack: [8]
     * 5: iconst_2       // Push 2      → Stack: [8, 2]
     * 6: imul           // Multiply    → Stack: [16]
     * 7: istore 4       // Store doubled → Local[4] = 16
     * 9: iload 4        // Load doubled → Stack: [16]
     * 11: ireturn       // Return 16
     */
    
    /**
     * FRAME SIZE CALCULATION:
     */
    public void frameSizeExample() {
        /**
         * For calculate(int, int):
         * 
         * Local Variables:
         * - this: 8 bytes (reference, or 4 with compressed oops)
         * - a: 4 bytes
         * - b: 4 bytes
         * - result: 4 bytes
         * - doubled: 4 bytes
         * Total: 24 bytes (or 20 with compressed oops)
         * 
         * Operand Stack:
         * - Max depth: 2 int values
         * - Size: 2 × 4 = 8 bytes
         * 
         * Frame Data:
         * - Return address: 8 bytes
         * - Other metadata: ~16 bytes
         * 
         * Total Frame Size: ~48-56 bytes
         * 
         * For typical thread stack (1MB):
         * Max frames: ~20,000 frames (if all methods similar size)
         */
    }
    
    /**
     * RECURSIVE METHOD EXAMPLE:
     */
    public int factorial(int n) {
        if (n <= 1) return 1;
        return n * factorial(n - 1);
    }
    
    /**
     * STACK GROWTH FOR factorial(5):
     * 
     * Call: factorial(5)
     * ┌─────────────────────────────────────┐
     * │ factorial(5) frame                  │
     * │   Local: n=5                        │
     * │   Return address → caller           │
     * ├─────────────────────────────────────┤
     * │ factorial(4) frame                  │
     * │   Local: n=4                        │
     * │   Return address → factorial(5)     │
     * ├─────────────────────────────────────┤
     * │ factorial(3) frame                  │
     * │   Local: n=3                        │
     * │   Return address → factorial(4)     │
     * ├─────────────────────────────────────┤
     * │ factorial(2) frame                  │
     * │   Local: n=2                        │
     * │   Return address → factorial(3)     │
     * ├─────────────────────────────────────┤
     * │ factorial(1) frame                  │
     * │   Local: n=1                        │
     * │   Return address → factorial(2)     │
     * │   Returns 1                         │
     * └─────────────────────────────────────┘
     * 
     * Each frame: ~40 bytes
     * 5 frames: ~200 bytes
     * 
     * For factorial(10000):
     * 10000 frames × 40 bytes = 400KB
     * Might exceed stack limit!
     */
    
    /**
     * VIEWING STACK FRAMES:
     */
    public void viewStackFrames() {
        method1();
    }
    
    private void method1() {
        method2();
    }
    
    private void method2() {
        method3();
    }
    
    private void method3() {
        // Get current stack trace
        StackTraceElement[] frames = Thread.currentThread().getStackTrace();
        
        for (StackTraceElement frame : frames) {
            System.out.println(frame);
        }
        
        /**
         * OUTPUT:
         * 
         * java.lang.Thread.getStackTrace(Thread.java:xxx)
         * StackFrameDemo.method3(StackFrameDemo.java:xxx)
         * StackFrameDemo.method2(StackFrameDemo.java:xxx)
         * StackFrameDemo.method1(StackFrameDemo.java:xxx)
         * StackFrameDemo.viewStackFrames(StackFrameDemo.java:xxx)
         * 
         * Each line represents one stack frame
         */
    }
}
```

### Native vs Java Frames

```java
/**
 * TYPES OF STACK FRAMES:
 */

public class FrameTypes {
    
    /**
     * JAVA FRAME:
     * 
     * Standard Java method invocation
     * Contains local variables, operand stack, frame data
     */
    public void javaFrame() {
        int x = 1;
        int y = 2;
        int z = x + y;
    }
    
    /**
     * NATIVE FRAME:
     * 
     * JNI or native method call
     * Different structure, depends on platform
     */
    public native void nativeFrame();
    
    /**
     * STACK TRACE WITH MIXED FRAMES:
     */
    public void mixedFrames() {
        try {
            // Java frame
            String s = null;
            // Native frame (from String.hashCode)
            s.hashCode();
        } catch (Exception e) {
            e.printStackTrace();
            
            /**
             * OUTPUT:
             * 
             * java.lang.NullPointerException
             *   at FrameTypes.mixedFrames(FrameTypes.java:xxx)  ← Java frame
             *   ... (more Java frames)
             * 
             * Native frames not shown in stack trace
             * But are on the call stack
             */
        }
    }
    
    /**
     * INLINED FRAMES:
     * 
     * JIT compiler inlines methods
     * Frames eliminated, merged into caller
     */
    public int inlinedFrames() {
        return helper1() + helper2();
    }
    
    private int helper1() {
        return 1;  // Will be inlined
    }
    
    private int helper2() {
        return 2;  // Will be inlined
    }
    
    /**
     * AFTER INLINING:
     * 
     * public int inlinedFrames() {
     *     return 1 + 2;  // No method calls
     * }
     * 
     * OPTIMIZED FURTHER:
     * 
     * public int inlinedFrames() {
     *     return 3;  // Constant folded
     * }
     * 
     * Zero stack frames for helpers!
     */
    
    /**
     * DEOPTIMIZATION FRAMES:
     * 
     * When deoptimization occurs, JIT must reconstruct frames
     */
    public int deoptimization(Object obj) {
        // Compiled with assumption obj is Integer
        return ((Integer) obj).intValue();
        
        /**
         * If obj is actually String:
         * 1. ClassCastException
         * 2. Deoptimization triggered
         * 3. JIT reconstructs interpreter frames
         * 4. Returns to interpreter
         * 5. Throws exception from correct location
         */
    }
}
```

---

## 4. StackOverflowError Causes and Prevention

### Common Causes

```java
/**
 * STACKOVERFLOWERROR CAUSES:
 */

public class StackOverflowCauses {
    
    /**
     * CAUSE 1: INFINITE RECURSION (Most common)
     */
    public void infiniteRecursion() {
        infiniteRecursion();  // No base case!
        
        /**
         * Each call creates new stack frame
         * Stack grows until limit reached
         * Throws StackOverflowError
         * 
         * STACK DEPTH:
         * With -Xss1m: ~5,000-10,000 frames (depends on frame size)
         * With -Xss256k: ~1,000-2,000 frames
         */
    }
    
    /**
     * CAUSE 2: INCORRECT BASE CASE
     */
    public int factorial(int n) {
        if (n < 1) return 1;  // BUG: Should be n <= 1
        return n * factorial(n - 1);
    }
    
    /**
     * factorial(0) never terminates:
     * factorial(0) → factorial(-1) → factorial(-2) → ...
     * Stack overflow!
     */
    
    /**
     * CAUSE 3: MUTUAL RECURSION
     */
    public void method1() {
        method2();
    }
    
    public void method2() {
        method1();  // Calls back to method1
    }
    
    /**
     * method1() → method2() → method1() → method2() → ...
     * Infinite mutual recursion
     * Stack overflow!
     */
    
    /**
     * CAUSE 4: DEEP RECURSION ON LARGE INPUT
     */
    public int sum(int n) {
        if (n <= 0) return 0;
        return n + sum(n - 1);
    }
    
    /**
     * sum(10000) creates 10,000 frames
     * Might exceed stack limit
     * 
     * SOLUTION: Use iteration instead
     * 
     * public int sumIterative(int n) {
     *     int result = 0;
     *     for (int i = 1; i <= n; i++) {
     *         result += i;
     *     }
     *     return result;
     * }
     */
    
    /**
     * CAUSE 5: LARGE LOCAL VARIABLES
     */
    public void largeLocals() {
        int[] huge1 = new int[1000000];  // 4MB on stack? NO!
        largeLocals();  // Recursive call
        
        /**
         * CLARIFICATION:
         * Array OBJECT is on heap
         * Only REFERENCE is on stack (4-8 bytes)
         * 
         * But large primitive arrays or many locals
         * can increase frame size
         */
    }
    
    /**
     * CAUSE 6: DEEP INHERITANCE/DELEGATION
     */
    static class A {
        B b = new B();
        void process() { b.process(); }
    }
    
    static class B {
        C c = new C();
        void process() { c.process(); }
    }
    
    static class C {
        A a = new A();  // Circular reference
        void process() { a.process(); }
    }
    
    /**
     * A.process() → B.process() → C.process() → A.process() → ...
     * Infinite delegation loop
     * Stack overflow!
     */
    
    /**
     * CAUSE 7: EXCESSIVE METHOD CHAINING
     */
    public Object chain() {
        return new Object() {
            Object next() {
                return new Object() {
                    Object next() {
                        return new Object() {
                            // ... hundreds more
                        };
                    }
                };
            }
        };
    }
    
    /**
     * Deep nesting of method calls
     * Each creates stack frame
     * Can cause stack overflow
     */
}
```

### Prevention and Solutions

```java
/**
 * PREVENTING STACKOVERFLOWERROR:
 */

public class StackOverflowPrevention {
    
    /**
     * SOLUTION 1: ADD DEPTH LIMIT
     */
    public int factorialSafe(int n) {
        return factorialHelper(n, 0, 1000);
    }
    
    private int factorialHelper(int n, int depth, int maxDepth) {
        if (depth > maxDepth) {
            throw new IllegalArgumentException("Recursion too deep");
        }
        if (n <= 1) return 1;
        return n * factorialHelper(n - 1, depth + 1, maxDepth);
    }
    
    /**
     * SOLUTION 2: CONVERT TO ITERATION
     */
    public int factorialIterative(int n) {
        int result = 1;
        for (int i = 2; i <= n; i++) {
            result *= i;
        }
        return result;
        
        /**
         * BENEFITS:
         * - No stack frames per iteration
         * - Constant stack space
         * - No risk of stack overflow
         * - Often faster
         */
    }
    
    /**
     * SOLUTION 3: TAIL RECURSION (Java doesn't optimize, but pattern is useful)
     */
    public int factorialTail(int n) {
        return factorialTailHelper(n, 1);
    }
    
    private int factorialTailHelper(int n, int accumulator) {
        if (n <= 1) return accumulator;
        return factorialTailHelper(n - 1, n * accumulator);
        
        /**
         * NOTE: Java doesn't optimize tail calls
         * Still creates stack frames
         * But easier to convert to iteration:
         * 
         * public int factorialTailIterative(int n) {
         *     int accumulator = 1;
         *     while (n > 1) {
         *         accumulator *= n;
         *         n--;
         *     }
         *     return accumulator;
         * }
         */
    }
    
    /**
     * SOLUTION 4: USE EXPLICIT STACK (ITERATION WITH STACK)
     */
    static class TreeNode {
        int value;
        TreeNode left, right;
        
        TreeNode(int value) { this.value = value; }
    }
    
    // Recursive (can overflow)
    public int sumRecursive(TreeNode node) {
        if (node == null) return 0;
        return node.value + sumRecursive(node.left) + sumRecursive(node.right);
    }
    
    // Iterative with explicit stack (safe)
    public int sumIterative(TreeNode root) {
        if (root == null) return 0;
        
        int sum = 0;
        java.util.Stack<TreeNode> stack = new java.util.Stack<>();
        stack.push(root);
        
        while (!stack.isEmpty()) {
            TreeNode node = stack.pop();
            sum += node.value;
            
            if (node.right != null) stack.push(node.right);
            if (node.left != null) stack.push(node.left);
        }
        
        return sum;
        
        /**
         * BENEFITS:
         * - Uses heap instead of stack
         * - No depth limit (until heap full)
         * - Explicit control over traversal
         */
    }
    
    /**
     * SOLUTION 5: INCREASE STACK SIZE
     */
    public void demonstrateStackSize() {
        /**
         * JVM FLAG: -Xss<size>
         * 
         * -Xss256k   → 256KB stack (small, ~1,000 frames)
         * -Xss512k   → 512KB stack (medium, ~3,000 frames)
         * -Xss1m     → 1MB stack (default, ~5,000-10,000 frames)
         * -Xss2m     → 2MB stack (large, ~10,000-20,000 frames)
         * 
         * TRADE-OFFS:
         * 
         * Smaller stack:
         * + More threads possible
         * + Less memory per thread
         * - Higher overflow risk
         * 
         * Larger stack:
         * + Deeper recursion possible
         * - More memory per thread
         * - Fewer threads possible
         * 
         * Example:
         * With 4GB memory and 1MB stacks: Max ~4,000 threads
         * With 4GB memory and 2MB stacks: Max ~2,000 threads
         */
    }
    
    /**
     * SOLUTION 6: MEMOIZATION (DYNAMIC PROGRAMMING)
     */
    private java.util.Map<Integer, Integer> memo = new java.util.HashMap<>();
    
    public int fibonacci(int n) {
        if (n <= 1) return n;
        
        if (memo.containsKey(n)) {
            return memo.get(n);  // Return cached result
        }
        
        int result = fibonacci(n - 1) + fibonacci(n - 2);
        memo.put(n, result);
        return result;
        
        /**
         * Reduces recursion depth
         * Avoids redundant calculations
         * Much faster
         * 
         * fibonacci(100) without memo: Stack overflow
         * fibonacci(100) with memo: Completes instantly
         */
    }
    
    /**
     * SOLUTION 7: TRAMPOLINING (FUNCTIONAL PROGRAMMING)
     */
    interface Trampoline<T> {
        boolean isDone();
        T getValue();
        Trampoline<T> next();
    }
    
    static class Done<T> implements Trampoline<T> {
        private final T value;
        
        Done(T value) { this.value = value; }
        
        public boolean isDone() { return true; }
        public T getValue() { return value; }
        public Trampoline<T> next() { throw new UnsupportedOperationException(); }
    }
    
    static class Call<T> implements Trampoline<T> {
        private final java.util.function.Supplier<Trampoline<T>> next;
        
        Call(java.util.function.Supplier<Trampoline<T>> next) { this.next = next; }
        
        public boolean isDone() { return false; }
        public T getValue() { throw new UnsupportedOperationException(); }
        public Trampoline<T> next() { return next.get(); }
    }
    
    public int factorialTrampoline(int n) {
        Trampoline<Integer> trampoline = factorialTrampolineHelper(n, 1);
        while (!trampoline.isDone()) {
            trampoline = trampoline.next();
        }
        return trampoline.getValue();
    }
    
    private Trampoline<Integer> factorialTrampolineHelper(int n, int acc) {
        if (n <= 1) {
            return new Done<>(acc);
        }
        return new Call<>(() -> factorialTrampolineHelper(n - 1, n * acc));
        
        /**
         * Converts recursion to iteration
         * No stack growth
         * Can handle any depth
         * 
         * But complex and harder to read
         * Not common in Java code
         */
    }
}
```

---

## 5. Thread Stack Sizing (-Xss)

### Understanding Stack Size

```java
/**
 * THREAD STACK SIZE:
 * 
 * Each Java thread has its own stack
 * Configurable via -Xss flag
 * 
 * DEFAULT SIZES (platform-dependent):
 * - Linux x64: 1MB
 * - Windows x64: 1MB
 * - macOS x64: 1MB
 * - 32-bit systems: 320KB - 512KB
 * 
 * SYNTAX:
 * -Xss<size>[g|m|k]
 * 
 * Examples:
 * -Xss256k  → 256 kilobytes
 * -Xss1m    → 1 megabyte
 * -Xss2m    → 2 megabytes
 */

public class ThreadStackSizing {
    
    /**
     * MEASURING STACK DEPTH:
     */
    private static int maxDepth = 0;
    
    public static int measureStackDepth() {
        try {
            return measureStackDepthHelper(0);
        } catch (StackOverflowError e) {
            return maxDepth;
        }
    }
    
    private static int measureStackDepthHelper(int depth) {
        maxDepth = Math.max(maxDepth, depth);
        return measureStackDepthHelper(depth + 1);
    }
    
    /**
     * RESULTS WITH DIFFERENT STACK SIZES:
     * 
     * -Xss256k: ~3,000-5,000 frames
     * -Xss512k: ~6,000-10,000 frames
     * -Xss1m:   ~12,000-20,000 frames
     * -Xss2m:   ~25,000-40,000 frames
     * 
     * Actual numbers depend on:
     * - Frame size (method complexity)
     * - JIT compilation
     * - Platform
     */
    
    /**
     * CALCULATING STACK NEEDS:
     */
    public static void calculateStackNeeds() {
        /**
         * FORMULA:
         * 
         * Required Stack Size = 
         *   (Max Recursion Depth) × (Average Frame Size)
         * 
         * EXAMPLE 1: Simple recursion
         * 
         * Max depth: 1,000 frames
         * Frame size: 50 bytes
         * Required: 1,000 × 50 = 50KB
         * 
         * EXAMPLE 2: Complex recursion
         * 
         * Max depth: 10,000 frames
         * Frame size: 200 bytes (many locals)
         * Required: 10,000 × 200 = 2MB
         * 
         * EXAMPLE 3: With large locals
         * 
         * Max depth: 5,000 frames
         * Frame size: 500 bytes (large arrays)
         * Required: 5,000 × 500 = 2.5MB
         */
    }
    
    /**
     * THREAD COUNT VS STACK SIZE:
     */
    public static void threadCountVsStackSize() {
        /**
         * TRADE-OFF:
         * 
         * Total Thread Stack Memory = 
         *   (Number of Threads) × (Stack Size per Thread)
         * 
         * EXAMPLE: 4GB available memory
         * 
         * With -Xss1m:
         * - Max threads: 4,096 (4GB / 1MB)
         * - Minus heap, metaspace, etc.
         * - Realistic: ~3,000 threads
         * 
         * With -Xss2m:
         * - Max threads: 2,048 (4GB / 2MB)
         * - Realistic: ~1,500 threads
         * 
         * With -Xss256k:
         * - Max threads: 16,384 (4GB / 256KB)
         * - Realistic: ~15,000 threads
         * 
         * SERVER WITH MANY THREADS:
         * Use smaller stacks (-Xss256k or -Xss512k)
         * 
         * APPLICATION WITH DEEP RECURSION:
         * Use larger stacks (-Xss2m or -Xss4m)
         */
    }
    
    /**
     * DETERMINING OPTIMAL STACK SIZE:
     */
    public static void determineOptimalStackSize() {
        /**
         * APPROACH 1: Profile your application
         * 
         * 1. Run with default (-Xss1m)
         * 2. Monitor for StackOverflowError
         * 3. If errors: Increase stack size
         * 4. If no errors and many threads: Try reducing
         * 
         * APPROACH 2: Calculate from requirements
         * 
         * 1. Identify deepest recursion
         * 2. Measure frame size (use JOL or profiler)
         * 3. Calculate: depth × frame_size
         * 4. Add 50% safety margin
         * 
         * APPROACH 3: Test different sizes
         * 
         * java -Xss256k MyApp
         * java -Xss512k MyApp
         * java -Xss1m MyApp
         * 
         * Monitor:
         * - StackOverflowError occurrences
         * - Thread creation success
         * - Memory usage
         */
    }
    
    /**
     * MONITORING STACK USAGE:
     */
    public static void monitorStackUsage() {
        ThreadMXBean threadMXBean = 
            java.lang.management.ManagementFactory.getThreadMXBean();
        
        long[] threadIds = threadMXBean.getAllThreadIds();
        
        for (long threadId : threadIds) {
            ThreadInfo info = threadMXBean.getThreadInfo(threadId);
            if (info != null) {
                StackTraceElement[] stack = info.getStackTrace();
                System.out.printf("Thread: %s, Stack depth: %d%n",
                    info.getThreadName(), stack.length);
            }
        }
        
        /**
         * OUTPUT:
         * 
         * Thread: main, Stack depth: 15
         * Thread: Finalizer, Stack depth: 3
         * Thread: Reference Handler, Stack depth: 2
         * Thread: Signal Dispatcher, Stack depth: 0
         * 
         * Use this to identify threads with deep stacks
         */
    }
    
    /**
     * STACK SIZE RECOMMENDATIONS:
     */
    public static void recommendations() {
        /**
         * WEB SERVER (many threads, shallow stacks):
         * -Xss256k or -Xss512k
         * 
         * Benefits:
         * - More threads possible
         * - Less memory per thread
         * - Good for I/O-bound workloads
         * 
         * RECURSIVE ALGORITHMS (deep stacks):
         * -Xss2m or -Xss4m
         * 
         * Benefits:
         * - Handles deep recursion
         * - Fewer stack overflows
         * - Good for complex algorithms
         * 
         * GENERAL PURPOSE APPLICATION:
         * -Xss1m (default)
         * 
         * Benefits:
         * - Balanced
         * - Works for most cases
         * - Start here and adjust
         * 
         * MICROSERVICES:
         * -Xss256k
         * 
         * Benefits:
         * - Small memory footprint
         * - Fast startup
         * - Many instances possible
         */
    }
}
```

---

## 6. Stack Unwinding and Exception Handling

### Exception Handling Mechanics

```java
/**
 * STACK UNWINDING:
 * 
 * When exception thrown, JVM:
 * 1. Searches current frame for matching catch block
 * 2. If not found, unwinds to caller frame
 * 3. Repeats until catch block found or main() reached
 * 4. Each unwound frame is removed from stack
 * 5. Finally blocks executed during unwinding
 */

public class StackUnwindingDemo {
    
    /**
     * EXAMPLE 1: BASIC UNWINDING
     */
    public void example1() {
        System.out.println("example1: start");
        try {
            method1();
        } catch (Exception e) {
            System.out.println("example1: caught exception");
            e.printStackTrace();
        }
        System.out.println("example1: end");
    }
    
    private void method1() {
        System.out.println("method1: start");
        method2();
        System.out.println("method1: end");  // Never executed
    }
    
    private void method2() {
        System.out.println("method2: start");
        method3();
        System.out.println("method2: end");  // Never executed
    }
    
    private void method3() {
        System.out.println("method3: throwing exception");
        throw new RuntimeException("Error in method3");
    }
    
    /**
     * OUTPUT:
     * 
     * example1: start
     * method1: start
     * method2: start
     * method3: throwing exception
     * example1: caught exception
     * java.lang.RuntimeException: Error in method3
     *     at StackUnwindingDemo.method3(...)
     *     at StackUnwindingDemo.method2(...)
     *     at StackUnwindingDemo.method1(...)
     *     at StackUnwindingDemo.example1(...)
     * example1: end
     * 
     * UNWINDING PROCESS:
     * 
     * 1. Exception thrown in method3()
     * 2. No catch in method3() → Unwind to method2()
     * 3. No catch in method2() → Unwind to method1()
     * 4. No catch in method1() → Unwind to example1()
     * 5. Catch found in example1() → Handle exception
     * 6. Continue after catch block
     * 
     * Frames removed: method3, method2, method1
     */
    
    /**
     * EXAMPLE 2: FINALLY BLOCKS DURING UNWINDING
     */
    public void example2() {
        try {
            methodA();
        } catch (Exception e) {
            System.out.println("Caught: " + e.getMessage());
        }
    }
    
    private void methodA() {
        System.out.println("methodA: enter");
        try {
            methodB();
        } finally {
            System.out.println("methodA: finally");
        }
        System.out.println("methodA: exit");  // Never executed
    }
    
    private void methodB() {
        System.out.println("methodB: enter");
        try {
            methodC();
        } finally {
            System.out.println("methodB: finally");
        }
        System.out.println("methodB: exit");  // Never executed
    }
    
    private void methodC() {
        System.out.println("methodC: throwing");
        throw new RuntimeException("Error");
    }
    
    /**
     * OUTPUT:
     * 
     * methodA: enter
     * methodB: enter
     * methodC: throwing
     * methodB: finally  ← Executed during unwinding
     * methodA: finally  ← Executed during unwinding
     * Caught: Error
     * 
     * UNWINDING PROCESS:
     * 
     * 1. Exception in methodC()
     * 2. Unwind to methodB() → Execute finally block
     * 3. Unwind to methodA() → Execute finally block
     * 4. Unwind to example2() → Catch exception
     * 
     * Finally blocks always executed!
     */
    
    /**
     * EXAMPLE 3: EXCEPTION TABLE
     */
    public int exceptionTable(int x) {
        try {
            return 10 / x;
        } catch (ArithmeticException e) {
            return -1;
        } finally {
            System.out.println("Finally");
        }
    }
    
    /**
     * BYTECODE (simplified):
     * 
     * public int exceptionTable(int);
     *   Code:
     *     0: bipush 10
     *     2: iload_1
     *     3: idiv              // May throw ArithmeticException
     *     4: istore_2
     *     5: getstatic System.out
     *     8: ldc "Finally"
     *    10: invokevirtual println
     *    13: iload_2
     *    14: ireturn
     *    15: astore_2         // Catch ArithmeticException
     *    16: iconst_m1
     *    17: istore_3
     *    18: getstatic System.out
     *    21: ldc "Finally"
     *    23: invokevirtual println
     *    26: iload_3
     *    27: ireturn
     *    28: astore 4         // Catch any (for finally)
     *    30: getstatic System.out
     *    33: ldc "Finally"
     *    35: invokevirtual println
     *    38: aload 4
     *    40: athrow
     * 
     * Exception table:
     *   from    to  target  type
     *     0     5    15     Class java/lang/ArithmeticException
     *     0     5    28     any
     *    15    18    28     any
     * 
     * EXPLANATION:
     * 
     * PC range 0-5:
     * - If ArithmeticException → Jump to 15
     * - If any other exception → Jump to 28
     * 
     * PC range 15-18:
     * - If any exception → Jump to 28 (for finally)
     * 
     * The finally block at PC 28 ensures cleanup
     */
    
    /**
     * EXAMPLE 4: NESTED EXCEPTIONS
     */
    public void nestedExceptions() {
        try {
            try {
                throw new IllegalArgumentException("Inner");
            } catch (IllegalArgumentException e) {
                System.out.println("Caught inner: " + e.getMessage());
                throw new RuntimeException("Outer", e);
            }
        } catch (RuntimeException e) {
            System.out.println("Caught outer: " + e.getMessage());
            System.out.println("Caused by: " + e.getCause().getMessage());
        }
    }
    
    /**
     * OUTPUT:
     * 
     * Caught inner: Inner
     * Caught outer: Outer
     * Caused by: Inner
     * 
     * Stack trace shows nested exceptions:
     * java.lang.RuntimeException: Outer
     *   at StackUnwindingDemo.nestedExceptions(...)
     * Caused by: java.lang.IllegalArgumentException: Inner
     *   at StackUnwindingDemo.nestedExceptions(...)
     */
}
```

### Performance Impact

```java
/**
 * EXCEPTION PERFORMANCE:
 */

public class ExceptionPerformance {
    
    /**
     * COST OF EXCEPTIONS:
     * 
     * 1. Creating exception object: ~1-5 microseconds
     * 2. Filling stack trace: ~10-50 microseconds (expensive!)
     * 3. Throwing and catching: ~0.1-1 microseconds
     * 4. Unwinding stack: Depends on depth
     * 
     * Total: ~10-100 microseconds per exception
     * 
     * Compare to normal return: ~1 nanosecond
     * Exceptions are 10,000x slower!
     */
    
    /**
     * BENCHMARK 1: Normal return vs exception
     */
    public int normalReturn() {
        return 42;
    }
    
    public int exceptionReturn() {
        try {
            throw new Exception();
        } catch (Exception e) {
            return 42;
        }
    }
    
    public void benchmarkReturnVsException() {
        final int ITERATIONS = 1_000_000;
        
        // Warmup
        for (int i = 0; i < 10000; i++) {
            normalReturn();
            exceptionReturn();
        }
        
        // Benchmark normal return
        long start = System.nanoTime();
        for (int i = 0; i < ITERATIONS; i++) {
            normalReturn();
        }
        long normalTime = System.nanoTime() - start;
        
        // Benchmark exception return
        start = System.nanoTime();
        for (int i = 0; i < ITERATIONS; i++) {
            exceptionReturn();
        }
        long exceptionTime = System.nanoTime() - start;
        
        System.out.printf("Normal return:    %,d ns total, %.2f ns/op%n",
            normalTime, (double)normalTime / ITERATIONS);
        System.out.printf("Exception return: %,d ns total, %.2f ns/op%n",
            exceptionTime, (double)exceptionTime / ITERATIONS);
        System.out.printf("Exception is %.0fx slower%n",
            (double)exceptionTime / normalTime);
        
        /**
         * TYPICAL RESULTS:
         * 
         * Normal return:    1,000,000 ns total, 1.00 ns/op
         * Exception return: 50,000,000,000 ns total, 50,000.00 ns/op
         * Exception is 50,000x slower
         * 
         * Filling stack trace is very expensive!
         */
    }
    
    /**
     * OPTIMIZATION: Exceptions without stack traces
     */
    static class FastException extends Exception {
        @Override
        public synchronized Throwable fillInStackTrace() {
            return this;  // Don't fill stack trace
        }
    }
    
    public int fastExceptionReturn() {
        try {
            throw new FastException();
        } catch (FastException e) {
            return 42;
        }
    }
    
    /**
     * With FastException:
     * Exception is only ~100x slower
     * Still slower, but much better!
     * 
     * Use case: Flow control in performance-critical code
     * (But generally avoid exceptions for flow control)
     */
    
    /**
     * BENCHMARK 2: Stack depth impact
     */
    public void deepStack(int depth) {
        if (depth > 0) {
            deepStack(depth - 1);
        } else {
            throw new RuntimeException("Error");
        }
    }
    
    public void benchmarkStackDepth() {
        // Shallow stack
        long start = System.nanoTime();
        try {
            deepStack(10);
        } catch (RuntimeException e) {
            // Caught
        }
        long shallowTime = System.nanoTime() - start;
        
        // Deep stack
        start = System.nanoTime();
        try {
            deepStack(1000);
        } catch (RuntimeException e) {
            // Caught
        }
        long deepTime = System.nanoTime() - start;
        
        System.out.printf("Shallow stack (10):   %,d ns%n", shallowTime);
        System.out.printf("Deep stack (1000):    %,d ns%n", deepTime);
        
        /**
         * RESULTS:
         * 
         * Shallow stack (10):   15,000 ns
         * Deep stack (1000):    150,000 ns
         * 
         * Stack trace cost scales with depth!
         * Each frame adds ~100-200 ns
         */
    }
    
    /**
     * BEST PRACTICES:
     */
    public void bestPractices() {
        /**
         * 1. DON'T USE EXCEPTIONS FOR FLOW CONTROL
         * 
         * Bad:
         * try {
         *     return map.get(key);
         * } catch (NullPointerException e) {
         *     return defaultValue;
         * }
         * 
         * Good:
         * Object value = map.get(key);
         * return (value != null) ? value : defaultValue;
         * 
         * 2. CATCH SPECIFIC EXCEPTIONS
         * 
         * Bad:
         * try {
         *     riskyOperation();
         * } catch (Exception e) {  // Too broad
         *     handle(e);
         * }
         * 
         * Good:
         * try {
         *     riskyOperation();
         * } catch (IOException e) {  // Specific
         *     handle(e);
         * }
         * 
         * 3. AVOID THROWING IN HOT PATHS
         * 
         * If exception happens frequently:
         * - Use return codes
         * - Use Optional
         * - Use error objects
         * 
         * 4. REUSE EXCEPTION INSTANCES (CAREFULLY)
         * 
         * private static final Exception CACHED = 
         *     new Exception("Common error") {
         *         @Override
         *         public synchronized Throwable fillInStackTrace() {
         *             return this;
         *         }
         *     };
         * 
         * But: Stack trace won't be accurate!
         * Only for truly common, low-priority errors
         */
    }
}
```

---

## 7. Performance Comparison

### Stack vs Heap Allocation Performance

```java
/**
 * PERFORMANCE COMPARISON:
 * Stack Allocation vs Heap Allocation
 */

public class AllocationPerformance {
    
    /**
     * TEST OBJECT:
     */
    static class Point {
        double x, y;
        
        Point(double x, double y) {
            this.x = x;
            this.y = y;
        }
        
        double distance() {
            return Math.sqrt(x * x + y * y);
        }
    }
    
    /**
     * BENCHMARK 1: Local object (can be stack-allocated)
     */
    public double localAllocation() {
        Point p = new Point(3.0, 4.0);
        return p.distance();
        
        /**
         * WITH ESCAPE ANALYSIS:
         * - Object allocated on stack (or scalar replaced)
         * - ~5 nanoseconds per iteration
         * - No GC pressure
         * 
         * WITHOUT ESCAPE ANALYSIS:
         * - Object allocated on heap
         * - ~50 nanoseconds per iteration
         * - GC pressure
         */
    }
    
    /**
     * BENCHMARK 2: Escaped object (must be heap-allocated)
     */
    private Point lastPoint;
    
    public double escapedAllocation() {
        Point p = new Point(3.0, 4.0);
        lastPoint = p;  // ESCAPES
        return p.distance();
        
        /**
         * WITH OR WITHOUT ESCAPE ANALYSIS:
         * - Object allocated on heap
         * - ~50 nanoseconds per iteration
         * - GC pressure
         * 
         * No optimization possible
         */
    }
    
    /**
     * BENCHMARK 3: Primitive values (no allocation)
     */
    public double primitiveOnly() {
        double x = 3.0;
        double y = 4.0;
        return Math.sqrt(x * x + y * y);
        
        /**
         * NO ALLOCATION:
         * - Values in registers or stack slots
         * - ~2 nanoseconds per iteration
         * - Zero GC pressure
         * 
         * Fastest option!
         */
    }
    
    /**
     * FULL BENCHMARK:
     */
    public static void main(String[] args) {
        AllocationPerformance demo = new AllocationPerformance();
        final int ITERATIONS = 10_000_000;
        
        // Warmup (let JIT compile)
        for (int i = 0; i < 100000; i++) {
            demo.localAllocation();
            demo.escapedAllocation();
            demo.primitiveOnly();
        }
        
        // Benchmark local allocation
        long start = System.nanoTime();
        double sum1 = 0;
        for (int i = 0; i < ITERATIONS; i++) {
            sum1 += demo.localAllocation();
        }
        long time1 = System.nanoTime() - start;
        
        // Benchmark escaped allocation
        start = System.nanoTime();
        double sum2 = 0;
        for (int i = 0; i < ITERATIONS; i++) {
            sum2 += demo.escapedAllocation();
        }
        long time2 = System.nanoTime() - start;
        
        // Benchmark primitive only
        start = System.nanoTime();
        double sum3 = 0;
        for (int i = 0; i < ITERATIONS; i++) {
            sum3 += demo.primitiveOnly();
        }
        long time3 = System.nanoTime() - start;
        
        System.out.printf("Local allocation:   %,d ms, %.2f ns/op%n",
            time1 / 1_000_000, (double)time1 / ITERATIONS);
        System.out.printf("Escaped allocation: %,d ms, %.2f ns/op%n",
            time2 / 1_000_000, (double)time2 / ITERATIONS);
        System.out.printf("Primitive only:     %,d ms, %.2f ns/op%n",
            time3 / 1_000_000, (double)time3 / ITERATIONS);
        
        // Prevent dead code elimination
        System.out.println("Sums: " + sum1 + ", " + sum2 + ", " + sum3);
        
        /**
         * TYPICAL RESULTS:
         * 
         * Local allocation:   50 ms, 5.00 ns/op
         * Escaped allocation: 500 ms, 50.00 ns/op
         * Primitive only:     20 ms, 2.00 ns/op
         * 
         * ANALYSIS:
         * 
         * Primitive only (2 ns):
         * - No allocation
         * - Values in registers
         * - Fastest
         * 
         * Local allocation (5 ns):
         * - Scalar replacement or stack allocation
         * - 2.5x slower than primitives
         * - Still very fast
         * 
         * Escaped allocation (50 ns):
         * - Heap allocation required
         * - 10x slower than stack allocation
         * - 25x slower than primitives
         * - Causes GC pressure
         */
    }
    
    /**
     * MEMORY ALLOCATION RATES:
     */
    public void measureAllocationRate() {
        final int ITERATIONS = 10_000_000;
        
        // Measure heap allocations
        long heapBefore = getHeapUsed();
        
        for (int i = 0; i < ITERATIONS; i++) {
            escapedAllocation();
        }
        
        long heapAfter = getHeapUsed();
        long allocated = heapAfter - heapBefore;
        
        System.out.printf("Allocated: %,d bytes%n", allocated);
        System.out.printf("Per object: %.1f bytes%n",
            (double)allocated / ITERATIONS);
        
        /**
         * RESULTS:
         * 
         * Allocated: 320,000,000 bytes (320 MB)
         * Per object: 32.0 bytes
         * 
         * Each Point object:
         * - Header: 12 bytes
         * - Fields: 16 bytes (2 doubles)
         * - Padding: 4 bytes
         * Total: 32 bytes
         * 
         * 10M allocations × 32 bytes = 320 MB
         * 
         * With stack allocation: 0 bytes!
         */
    }
    
    private long getHeapUsed() {
        System.gc();
        return Runtime.getRuntime().totalMemory() - 
               Runtime.getRuntime().freeMemory();
    }
}
```

### Real-World Optimization Example

```java
/**
 * REAL-WORLD OPTIMIZATION:
 */

public class RealWorldOptimization {
    
    /**
     * SCENARIO: High-frequency trading system
     * Processing millions of price updates per second
     */
    
    /**
     * VERSION 1: Object-oriented (slow)
     */
    static class PriceUpdate {
        String symbol;
        double price;
        long timestamp;
        
        PriceUpdate(String symbol, double price, long timestamp) {
            this.symbol = symbol;
            this.price = price;
            this.timestamp = timestamp;
        }
        
        double calculateSpread(PriceUpdate other) {
            return Math.abs(this.price - other.price);
        }
    }
    
    public void processUpdatesOO() {
        for (int i = 0; i < 1_000_000; i++) {
            PriceUpdate buy = new PriceUpdate("AAPL", 150.0, System.nanoTime());
            PriceUpdate sell = new PriceUpdate("AAPL", 150.5, System.nanoTime());
            double spread = buy.calculateSpread(sell);
            // Process spread
        }
        
        /**
         * PERFORMANCE:
         * - Time: ~100ms
         * - Allocations: 2M objects × 32 bytes = 64 MB
         * - GC: Frequent collections
         * 
         * TOO SLOW for HFT!
         */
    }
    
    /**
     * VERSION 2: Primitive arrays (fast)
     */
    public void processUpdatesPrimitive() {
        double[] buyPrices = new double[1_000_000];
        double[] sellPrices = new double[1_000_000];
        long[] timestamps = new long[1_000_000];
        
        for (int i = 0; i < 1_000_000; i++) {
            buyPrices[i] = 150.0;
            sellPrices[i] = 150.5;
            timestamps[i] = System.nanoTime();
            double spread = Math.abs(buyPrices[i] - sellPrices[i]);
            // Process spread
        }
        
        /**
         * PERFORMANCE:
         * - Time: ~10ms (10x faster)
         * - Allocations: 3 arrays = ~24 MB (one-time)
         * - GC: Minimal pressure
         * 
         * Much better!
         */
    }
    
    /**
     * VERSION 3: Stack-local processing (fastest)
     */
    public void processUpdatesLocal() {
        for (int i = 0; i < 1_000_000; i++) {
            // All variables on stack or in registers
            double buyPrice = 150.0;
            double sellPrice = 150.5;
            long timestamp = System.nanoTime();
            double spread = Math.abs(buyPrice - sellPrice);
            // Process spread
        }
        
        /**
         * PERFORMANCE:
         * - Time: ~5ms (20x faster than OO)
         * - Allocations: 0 bytes
         * - GC: No pressure
         * 
         * Optimal for this use case!
         */
    }
    
    /**
     * BENCHMARK RESULTS:
     * 
     * Object-oriented:      100ms, 64 MB allocated
     * Primitive arrays:      10ms, 24 MB allocated
     * Stack-local:            5ms,  0 MB allocated
     * 
     * Stack-local is 20x faster!
     */
}
```

---

## Summary

### Key Concepts

**Escape Analysis:**

- Determines if object lifetime is confined to method
- Enables stack allocation and scalar replacement
- Triggered by: returning, storing in fields, passing to unknown code

**Scalar Replacement:**

- Replaces object with individual variables for each field
- Eliminates allocation entirely
- 10x faster than heap allocation
- Enabled by default: `-XX:+EliminateAllocations`

**Stack Frame:**

- Contains: Local variables, operand stack, frame data
- Size: ~40-100 bytes per frame
- Typical depth: 5,000-20,000 frames (1MB stack)

**StackOverflowError:**

- Caused by: Infinite recursion, deep call chains
- Prevention: Iteration, depth limits, increase stack size
- Stack size: `-Xss256k` to `-Xss4m`

**Exception Performance:**

- Creating exception: ~10-50 microseconds
- 10,000x slower than normal return
- Cost scales with stack depth
- Avoid in hot paths

### Performance Characteristics

|Allocation Type|Speed (ns/op)|GC Pressure|Use Case|
|---|---|---|---|
|Primitive values|2|None|Best performance|
|Stack-allocated object|5|None|Local temporary objects|
|Heap-allocated object|50|High|Escaped objects|
|Exception throw/catch|50,000|Medium|Error handling|

### Stack Size Guidelines

|Application Type|Recommended -Xss|Thread Count|Rationale|
|---|---|---|---|
|Web server|256k-512k|High (1000+)|Shallow stacks, many threads|
|Microservice|256k|Very high|Minimal memory footprint|
|General app|1m (default)|Medium (100-1000)|Balanced|
|Recursive algorithms|2m-4m|Low (<100)|Deep call stacks|
|Desktop app|1m-2m|Low|User responsiveness|

### JVM Flags Reference

```bash
# Escape analysis
-XX:+DoEscapeAnalysis               # Enable (default: true)
-XX:-DoEscapeAnalysis               # Disable
-XX:+PrintEscapeAnalysis            # Print analysis results

# Scalar replacement
-XX:+EliminateAllocations           # Enable (default: true)
-XX:-EliminateAllocations           # Disable
-XX:+PrintEliminateAllocations      # Print eliminated allocations

# Stack size
-Xss256k                            # 256 KB stack
-Xss512k                            # 512 KB stack
-Xss1m                              # 1 MB stack (typical default)
-Xss2m                              # 2 MB stack

# Monitoring
-XX:+PrintCompilation               # Show JIT compilation
-XX:+UnlockDiagnosticVMOptions      # Unlock diagnostic options
-XX:+LogCompilation                 # Detailed compilation log
-XX:+TraceDeoptimization            # Show deoptimizations

# Debugging
-XX:+PrintFlagsFinal                # Print all JVM flags
-XX:+TraceClassLoading              # Trace class loading
-XX:+PrintGCDetails                 # GC details
```

### Best Practices

**Optimization:**

1. ✅ Keep objects local when possible (enable escape analysis)
2. ✅ Use primitives instead of objects in hot paths
3. ✅ Avoid unnecessary object creation in loops
4. ✅ Let JIT do its job (avoid premature manual optimization)
5. ✅ Profile before optimizing

**Stack Management:**

1. ✅ Prefer iteration over recursion
2. ✅ Add depth limits to recursive algorithms
3. ✅ Size stacks based on application needs
4. ✅ Monitor thread count vs stack size trade-off
5. ✅ Test with realistic workloads

**Exception Handling:**

1. ✅ Never use exceptions for flow control
2. ✅ Catch specific exceptions, not `Exception`
3. ✅ Avoid throwing in hot paths
4. ✅ Keep stack traces shallow when possible
5. ✅ Consider error codes or Optional for frequent errors

### Common Pitfalls

**❌ Assuming all objects are heap-allocated:**

```java
// This might be stack-allocated or scalar replaced:
Point p = new Point(1, 2);
return p.x + p.y;
```

**❌ Disabling escape analysis:**

```java
// Don't do this unless you have a very good reason:
-XX:-DoEscapeAnalysis
```

**❌ Infinite recursion:**

```java
public void recurse() {
    recurse();  // StackOverflowError!
}
```

**❌ Using exceptions for flow control:**

```java
// Bad: 10,000x slower than if-check
try {
    return map.get(key);
} catch (NullPointerException e) {
    return defaultValue;
}
```

---
