# Java ClassLoader Hierarchy and Mechanism

## Overview

ClassLoaders are fundamental to Java's runtime system, responsible for loading classes dynamically at runtime. Understanding ClassLoader hierarchy is essential for plugin systems, application servers, and modular applications.


---

## 1. ClassLoader Hierarchy

### The Three Core ClassLoaders

```java
/**
 * CLASSLOADER HIERARCHY:
 * 
 *                    null (Bootstrap ClassLoader)
 *                      ↑ parent
 *                      |
 *              Platform/Extension ClassLoader
 *                      ↑ parent
 *                      |
 *              Application ClassLoader
 *                      ↑ parent
 *                      |
 *              Custom ClassLoaders
 * 
 * Loading order (Parent Delegation):
 * 1. Check Bootstrap ClassLoader
 * 2. Check Platform/Extension ClassLoader
 * 3. Check Application ClassLoader
 * 4. Check Custom ClassLoader
 */

public class ClassLoaderHierarchyDemo {
    
    public static void main(String[] args) {
        
        // Get current class's ClassLoader
        ClassLoader appClassLoader = ClassLoaderHierarchyDemo.class.getClassLoader();
        System.out.println("Application ClassLoader: " + appClassLoader);
        
        // Get parent (Platform/Extension ClassLoader)
        ClassLoader platformClassLoader = appClassLoader.getParent();
        System.out.println("Platform ClassLoader: " + platformClassLoader);
        
        // Get parent (Bootstrap ClassLoader)
        ClassLoader bootstrapClassLoader = platformClassLoader.getParent();
        System.out.println("Bootstrap ClassLoader: " + bootstrapClassLoader); // null
        
        /**
         * OUTPUT (Java 11+):
         * Application ClassLoader: jdk.internal.loader.ClassLoaders$AppClassLoader@...
         * Platform ClassLoader: jdk.internal.loader.ClassLoaders$PlatformClassLoader@...
         * Bootstrap ClassLoader: null
         * 
         * OUTPUT (Java 8):
         * Application ClassLoader: sun.misc.Launcher$AppClassLoader@...
         * Extension ClassLoader: sun.misc.Launcher$ExtClassLoader@...
         * Bootstrap ClassLoader: null
         * 
         * Note: Bootstrap ClassLoader is implemented in native code (C++),
         * so it returns null in Java
         */
    }
    
    /**
     * WHICH CLASSLOADER LOADED WHICH CLASS?
     */
    public static void examineClassLoaders() {
        
        // 1. Bootstrap ClassLoader (null)
        // Loads core Java classes from rt.jar or jrt-fs.jar (Java 9+)
        ClassLoader cl1 = String.class.getClassLoader();
        System.out.println("String loaded by: " + cl1); // null
        
        ClassLoader cl2 = ArrayList.class.getClassLoader();
        System.out.println("ArrayList loaded by: " + cl2); // null
        
        // 2. Platform/Extension ClassLoader
        // Loads classes from jre/lib/ext or platform modules (Java 9+)
        ClassLoader cl3 = java.sql.Driver.class.getClassLoader();
        System.out.println("java.sql.Driver loaded by: " + cl3); // Platform
        
        // 3. Application ClassLoader
        // Loads classes from CLASSPATH
        ClassLoader cl4 = ClassLoaderHierarchyDemo.class.getClassLoader();
        System.out.println("Current class loaded by: " + cl4); // Application
        
        /**
         * CLASSPATH LOCATIONS:
         * 
         * Bootstrap ClassLoader:
         * - Java 8: jre/lib/rt.jar
         * - Java 9+: JAVA_HOME/lib/modules (jrt-fs.jar)
         * 
         * Extension/Platform ClassLoader:
         * - Java 8: jre/lib/ext/*.jar
         * - Java 9+: Platform modules (java.sql, java.xml, etc.)
         * 
         * Application ClassLoader:
         * - CLASSPATH environment variable
         * - -cp or -classpath command line
         * - Current directory (.)
         * - JAR manifest Class-Path
         */
    }
}
```

### Bootstrap ClassLoader

```java
/**
 * BOOTSTRAP CLASSLOADER:
 * 
 * Characteristics:
 * - Implemented in native code (C/C++)
 * - No Java object representation (returns null)
 * - Parent of all ClassLoaders
 * - Loads core Java classes
 * - Cannot be extended or replaced
 * 
 * Loaded Classes:
 * - java.lang.* (Object, String, Class, etc.)
 * - java.util.* (ArrayList, HashMap, etc.)
 * - java.io.* (InputStream, OutputStream, etc.)
 * - Other java.* core packages
 * 
 * Location (Java 8):
 * $JAVA_HOME/jre/lib/rt.jar
 * 
 * Location (Java 9+):
 * $JAVA_HOME/lib/modules (module system)
 */

public class BootstrapClassLoaderDemo {
    
    public static void main(String[] args) {
        
        // All core Java classes loaded by Bootstrap
        System.out.println("Object: " + Object.class.getClassLoader());           // null
        System.out.println("String: " + String.class.getClassLoader());           // null
        System.out.println("ArrayList: " + ArrayList.class.getClassLoader());     // null
        System.out.println("HashMap: " + HashMap.class.getClassLoader());         // null
        System.out.println("Thread: " + Thread.class.getClassLoader());           // null
        System.out.println("ClassLoader: " + ClassLoader.class.getClassLoader()); // null
        
        /**
         * WHY NULL?
         * 
         * Bootstrap ClassLoader is implemented in native code (C++).
         * It doesn't exist as a Java object, so getClassLoader() returns null.
         * 
         * This is by design - core classes need to be loaded before
         * the Java ClassLoader class itself exists!
         * 
         * SECURITY:
         * 
         * Bootstrap ClassLoader is trusted.
         * Classes loaded by it have full system privileges.
         * Cannot be overridden or replaced for security reasons.
         */
        
        // Get Bootstrap ClassLoader's search paths
        String bootClassPath = System.getProperty("sun.boot.class.path");
        if (bootClassPath != null) {
            System.out.println("\nBootstrap ClassPath (Java 8):");
            for (String path : bootClassPath.split(System.getProperty("path.separator"))) {
                System.out.println("  " + path);
            }
        }
        
        // Java 9+ uses module system
        String javaHome = System.getProperty("java.home");
        System.out.println("\nJava Home: " + javaHome);
        System.out.println("Modules location (Java 9+): " + javaHome + "/lib/modules");
    }
    
    /**
     * CUSTOMIZING BOOTSTRAP CLASSPATH:
     * 
     * Command line options:
     * 
     * -Xbootclasspath:<path>        Replace default bootstrap classpath
     * -Xbootclasspath/a:<path>      Append to bootstrap classpath
     * -Xbootclasspath/p:<path>      Prepend to bootstrap classpath
     * 
     * Example:
     * java -Xbootclasspath/a:custom.jar MyApp
     * 
     * WARNING: Dangerous! Can break JVM functionality.
     * Only use for testing or very specific scenarios.
     */
}
```

### Platform/Extension ClassLoader

```java
/**
 * PLATFORM CLASSLOADER (Java 9+):
 * EXTENSION CLASSLOADER (Java 8):
 * 
 * Java 8 (Extension ClassLoader):
 * - Loads JARs from jre/lib/ext
 * - User can add JARs to ext directory
 * - Parent: Bootstrap ClassLoader
 * 
 * Java 9+ (Platform ClassLoader):
 * - Loads platform modules (java.sql, java.xml, etc.)
 * - Cannot add arbitrary JARs
 * - Parent: Bootstrap ClassLoader
 * 
 * Key Difference:
 * Java 8: Extension mechanism (put JARs in ext folder)
 * Java 9+: Module system (no extension mechanism)
 */

public class PlatformClassLoaderDemo {
    
    public static void main(String[] args) throws ClassNotFoundException {
        
        // Classes loaded by Platform ClassLoader
        ClassLoader platformCL;
        
        // Java 9+ platform modules
        try {
            Class<?> sqlDriver = Class.forName("java.sql.Driver");
            platformCL = sqlDriver.getClassLoader();
            System.out.println("java.sql.Driver loaded by: " + platformCL);
            
            Class<?> xmlParser = Class.forName("javax.xml.parsers.DocumentBuilder");
            System.out.println("javax.xml.parsers loaded by: " + 
                xmlParser.getClassLoader());
            
        } catch (ClassNotFoundException e) {
            System.out.println("Platform modules not available");
        }
        
        /**
         * JAVA 8 EXTENSION MECHANISM:
         * 
         * Location: $JAVA_HOME/jre/lib/ext/
         * 
         * Common extensions:
         * - localedata.jar (locale data)
         * - sunjce_provider.jar (cryptography)
         * - sunpkcs11.jar (PKCS#11)
         * - zipfs.jar (ZIP filesystem provider)
         * 
         * Custom extensions:
         * 1. Create JAR: myextension.jar
         * 2. Copy to: $JAVA_HOME/jre/lib/ext/
         * 3. Classes automatically available to all applications
         * 
         * WARNING: Deprecated in Java 8, removed in Java 9+
         */
        
        // Java 8: List extension JARs
        String extDirs = System.getProperty("java.ext.dirs");
        if (extDirs != null) {
            System.out.println("\nExtension directories (Java 8):");
            for (String dir : extDirs.split(System.getProperty("path.separator"))) {
                System.out.println("  " + dir);
            }
        }
        
        /**
         * JAVA 9+ MODULE SYSTEM:
         * 
         * Platform modules include:
         * - java.sql (JDBC)
         * - java.xml (XML processing)
         * - java.logging (Java Logging)
         * - java.management (JMX)
         * - java.naming (JNDI)
         * - java.prefs (Preferences)
         * - java.rmi (RMI)
         * - java.security.jgss (JGSS)
         * - java.security.sasl (SASL)
         * - java.transaction.xa (XA transactions)
         * 
         * To use platform module:
         * 
         * module-info.java:
         * module myapp {
         *     requires java.sql;
         * }
         */
    }
}
```

### Application ClassLoader

```java
/**
 * APPLICATION CLASSLOADER:
 * 
 * Characteristics:
 * - Loads application classes
 * - Reads from CLASSPATH
 * - Parent: Platform/Extension ClassLoader
 * - Default ClassLoader for application
 * 
 * Classpath sources:
 * 1. CLASSPATH environment variable
 * 2. -cp or -classpath command line
 * 3. JAR manifest Class-Path attribute
 * 4. Current directory (if not specified)
 */

public class ApplicationClassLoaderDemo {
    
    public static void main(String[] args) {
        
        // Get Application ClassLoader
        ClassLoader appCL = ClassLoader.getSystemClassLoader();
        System.out.println("Application ClassLoader: " + appCL);
        
        // Current class loaded by Application ClassLoader
        ClassLoader currentCL = ApplicationClassLoaderDemo.class.getClassLoader();
        System.out.println("Current class loaded by: " + currentCL);
        
        System.out.println("Are they same? " + (appCL == currentCL)); // true
        
        // Get classpath
        String classpath = System.getProperty("java.class.path");
        System.out.println("\nClasspath:");
        for (String path : classpath.split(System.getProperty("path.separator"))) {
            System.out.println("  " + path);
        }
        
        /**
         * CLASSPATH FORMATS:
         * 
         * 1. Directories:
         *    java -cp /path/to/classes MyApp
         * 
         * 2. JAR files:
         *    java -cp myapp.jar MyApp
         * 
         * 3. Multiple paths:
         *    java -cp dir1:jar1.jar:jar2.jar MyApp  (Unix)
         *    java -cp dir1;jar1.jar;jar2.jar MyApp  (Windows)
         * 
         * 4. Wildcards (Java 6+):
         *    java -cp "libs/*" MyApp  (all JARs in libs/)
         * 
         * 5. Current directory:
         *    java -cp . MyApp
         */
    }
    
    /**
     * LOADING CLASSES FROM APPLICATION CLASSPATH:
     */
    public static void loadClassExample() throws ClassNotFoundException {
        
        ClassLoader appCL = ClassLoader.getSystemClassLoader();
        
        // Load class by name
        Class<?> clazz = appCL.loadClass("com.example.MyClass");
        System.out.println("Loaded class: " + clazz.getName());
        System.out.println("Loaded by: " + clazz.getClassLoader());
        
        /**
         * CLASS LOADING PROCESS:
         * 
         * 1. Check if class already loaded
         *    - Classes are loaded only once
         *    - Cached in ClassLoader
         * 
         * 2. Delegate to parent (Parent Delegation)
         *    - Platform ClassLoader checks
         *    - Bootstrap ClassLoader checks
         * 
         * 3. If not found, load from classpath
         *    - Read .class file
         *    - Convert to Class object
         *    - Link and initialize
         * 
         * 4. Return Class object
         */
    }
    
    /**
     * JAR MANIFEST CLASS-PATH:
     * 
     * In JAR's META-INF/MANIFEST.MF:
     * 
     * Manifest-Version: 1.0
     * Main-Class: com.example.Main
     * Class-Path: lib/dependency1.jar lib/dependency2.jar
     * 
     * When executing:
     * java -jar myapp.jar
     * 
     * Application ClassLoader automatically includes:
     * - myapp.jar
     * - lib/dependency1.jar (relative to myapp.jar)
     * - lib/dependency2.jar (relative to myapp.jar)
     */
}
```

---

## 2. Parent Delegation Model

### How Parent Delegation Works

```java
/**
 * PARENT DELEGATION MODEL:
 * 
 * Process:
 * 1. ClassLoader asked to load class
 * 2. Check if already loaded (findLoadedClass)
 * 3. Delegate to parent ClassLoader
 * 4. If parent can't load, try loading itself
 * 5. If still fails, throw ClassNotFoundException
 * 
 * Benefits:
 * - Prevents duplicate class loading
 * - Ensures core classes loaded by Bootstrap
 * - Provides class loading priority
 * - Security (prevents overriding core classes)
 */

public class ParentDelegationDemo {
    
    /**
     * PARENT DELEGATION FLOW:
     * 
     * Request: Load "com.example.MyClass"
     * 
     * Custom ClassLoader:
     *   ↓ delegate to parent
     * Application ClassLoader:
     *   ↓ delegate to parent
     * Platform ClassLoader:
     *   ↓ delegate to parent
     * Bootstrap ClassLoader:
     *   ✗ Not found (not a core class)
     *   ↓ return to child
     * Platform ClassLoader:
     *   ✗ Not found (not a platform class)
     *   ↓ return to child
     * Application ClassLoader:
     *   ✓ Found in classpath!
     *   ↓ return Class object
     * Custom ClassLoader:
     *   ↓ return to caller
     * 
     * Result: Class loaded by Application ClassLoader
     */
    
    public static void main(String[] args) throws Exception {
        
        // Demonstrate parent delegation
        ClassLoader custom = new CustomClassLoader();
        
        // Load String class
        Class<?> stringClass = custom.loadClass("java.lang.String");
        System.out.println("String loaded by: " + stringClass.getClassLoader()); // null (Bootstrap)
        
        // Load ArrayList class
        Class<?> listClass = custom.loadClass("java.util.ArrayList");
        System.out.println("ArrayList loaded by: " + listClass.getClassLoader()); // null (Bootstrap)
        
        // Load JDBC Driver (platform class)
        try {
            Class<?> driverClass = custom.loadClass("java.sql.Driver");
            System.out.println("Driver loaded by: " + driverClass.getClassLoader()); // Platform
        } catch (ClassNotFoundException e) {
            System.out.println("Driver not available");
        }
        
        // Load application class
        Class<?> currentClass = custom.loadClass(ParentDelegationDemo.class.getName());
        System.out.println("Current class loaded by: " + currentClass.getClassLoader()); // Application
        
        /**
         * KEY INSIGHT:
         * 
         * Even though we used custom ClassLoader,
         * classes were loaded by their "natural" ClassLoader:
         * - Core classes by Bootstrap
         * - Platform classes by Platform
         * - Application classes by Application
         * 
         * Custom ClassLoader only loads classes not found by parents.
         */
    }
    
    /**
     * SIMPLIFIED CLASSLOADER.LOADCLASS() IMPLEMENTATION:
     */
    static class CustomClassLoader extends ClassLoader {
        
        @Override
        public Class<?> loadClass(String name) throws ClassNotFoundException {
            System.out.println("CustomClassLoader: Loading " + name);
            
            // Step 1: Check if already loaded
            Class<?> c = findLoadedClass(name);
            if (c != null) {
                System.out.println("  Already loaded");
                return c;
            }
            
            // Step 2: Delegate to parent
            try {
                System.out.println("  Delegating to parent: " + getParent());
                c = getParent().loadClass(name);
                System.out.println("  Parent loaded successfully");
                return c;
            } catch (ClassNotFoundException e) {
                // Parent couldn't load
                System.out.println("  Parent couldn't load");
            }
            
            // Step 3: Load ourselves
            System.out.println("  Loading ourselves");
            return findClass(name);
        }
        
        @Override
        protected Class<?> findClass(String name) throws ClassNotFoundException {
            // Custom loading logic here
            throw new ClassNotFoundException(name);
        }
    }
}
```

### Why Parent Delegation?

```java
/**
 * BENEFITS OF PARENT DELEGATION:
 * 
 * 1. PREVENTS DUPLICATE LOADING:
 * 2. ENSURES CORE CLASS INTEGRITY:
 * 3. PROVIDES LOADING PRIORITY:
 * 4. SECURITY:
 */

public class ParentDelegationBenefits {
    
    /**
     * BENEFIT 1: PREVENTS DUPLICATE LOADING
     * 
     * Without parent delegation:
     * - Same class could be loaded multiple times
     * - Each ClassLoader loads its own copy
     * - Classes are NOT compatible (different ClassLoaders)
     */
    public static void demonstrateDuplicateLoading() throws Exception {
        
        // Load class with Application ClassLoader
        Class<?> class1 = Class.forName("com.example.Person");
        
        // Load same class with custom ClassLoader (hypothetically)
        // Class<?> class2 = customLoader.loadClass("com.example.Person");
        
        // class1 != class2 (different Class objects!)
        // class1.cast(class2Instance) throws ClassCastException!
        
        /**
         * PROBLEM SCENARIO:
         * 
         * Person person1 = new Person(); // Loaded by CL1
         * Person person2 = new Person(); // Loaded by CL2
         * 
         * person1.getClass() != person2.getClass()
         * person1.getClass().getName().equals(person2.getClass().getName()) // true
         * person1.equals(person2) // ClassCastException!
         * 
         * Parent delegation prevents this by ensuring
         * class loaded once by highest available ClassLoader.
         */
    }
    
    /**
     * BENEFIT 2: ENSURES CORE CLASS INTEGRITY
     * 
     * Without parent delegation:
     * - Malicious code could replace java.lang.String
     * - Override system behavior
     * - Security vulnerability
     */
    public static void demonstrateCoreClassProtection() {
        
        /**
         * ATTACK SCENARIO (prevented by parent delegation):
         * 
         * 1. Attacker creates malicious java.lang.String:
         * 
         * package java.lang;
         * public class String {
         *     // Malicious implementation
         *     public String(String s) {
         *         // Steal passwords, log data, etc.
         *     }
         * }
         * 
         * 2. Put on classpath before real String
         * 3. Application uses malicious String
         * 
         * PREVENTION:
         * Parent delegation ensures java.lang.String
         * always loaded by Bootstrap ClassLoader,
         * which has highest priority.
         * 
         * Custom ClassLoader cannot override core classes!
         */
    }
    
    /**
     * BENEFIT 3: PROVIDES LOADING PRIORITY
     * 
     * Classes loaded in order:
     * 1. Core Java classes (Bootstrap)
     * 2. Platform classes (Platform)
     * 3. Application classes (Application)
     * 4. Custom classes (Custom ClassLoader)
     * 
     * This ensures system classes take precedence.
     */
    
    /**
     * BENEFIT 4: SECURITY
     * 
     * Parent delegation is a security mechanism:
     * - Prevents class spoofing
     * - Protects core classes
     * - Maintains class loading hierarchy
     * - Enforces class visibility rules
     */
}
```

### Breaking Parent Delegation

```java
/**
 * BREAKING PARENT DELEGATION:
 * 
 * Some scenarios require breaking parent delegation:
 * - Application servers (isolate applications)
 * - Plugin systems (load different versions)
 * - Hot reloading (reload changed classes)
 * - OSGi bundles (complex dependencies)
 * 
 * How to break:
 * - Override loadClass() instead of findClass()
 * - Don't delegate to parent
 * - Load class directly
 * 
 * WARNING: Use carefully! Can cause issues.
 */

public class BreakingParentDelegation {
    
    /**
     * CHILD-FIRST CLASSLOADER:
     * 
     * Reverses delegation: checks self before parent
     */
    static class ChildFirstClassLoader extends ClassLoader {
        
        private String classPath;
        
        public ChildFirstClassLoader(String classPath, ClassLoader parent) {
            super(parent);
            this.classPath = classPath;
        }
        
        @Override
        public Class<?> loadClass(String name) throws ClassNotFoundException {
            
            // Load core classes from parent (always!)
            if (name.startsWith("java.")) {
                return super.loadClass(name);
            }
            
            // Check if already loaded
            Class<?> c = findLoadedClass(name);
            if (c != null) {
                return c;
            }
            
            // BREAK DELEGATION: Try loading ourselves first
            try {
                c = findClass(name);
                if (c != null) {
                    System.out.println("Loaded by child: " + name);
                    return c;
                }
            } catch (ClassNotFoundException e) {
                // Not found, try parent
            }
            
            // Fall back to parent
            System.out.println("Delegating to parent: " + name);
            return super.loadClass(name);
        }
        
        @Override
        protected Class<?> findClass(String name) throws ClassNotFoundException {
            // Load class from custom classpath
            byte[] classData = loadClassData(name);
            if (classData != null) {
                return defineClass(name, classData, 0, classData.length);
            }
            throw new ClassNotFoundException(name);
        }
        
        private byte[] loadClassData(String name) {
            // Read .class file from classPath
            String path = classPath + "/" + name.replace('.', '/') + ".class";
            try {
                // Read file bytes
                return java.nio.file.Files.readAllBytes(java.nio.file.Paths.get(path));
            } catch (Exception e) {
                return null;
            }
        }
    }
    
    /**
     * USE CASE: APPLICATION SERVER
     * 
     * Tomcat uses child-first ClassLoader for web applications:
     * 
     * 1. Application classes loaded first
     * 2. Allows application to override libraries
     * 3. Isolates applications from each other
     * 
     * Example:
     * 
     * App1 uses log4j 1.2
     * App2 uses log4j 2.0
     * 
     * Each app has own ClassLoader:
     * - App1 ClassLoader loads log4j 1.2
     * - App2 ClassLoader loads log4j 2.0
     * - No conflict!
     */
    
    public static void main(String[] args) throws Exception {
        
        // Create child-first ClassLoader
        ChildFirstClassLoader loader = 
            new ChildFirstClassLoader("/path/to/classes", 
                ClassLoader.getSystemClassLoader());
        
        // Load class (child first)
        Class<?> clazz = loader.loadClass("com.example.MyClass");
        System.out.println("Loaded by: " + clazz.getClassLoader());
        
        /**
         * CAVEATS:
         * 
         * 1. Core classes must use parent delegation
         *    - Never override java.*, javax.*
         *    - JVM won't work correctly
         * 
         * 2. Can cause ClassCastException
         *    - Same class loaded by different ClassLoaders
         *    - Objects not compatible
         * 
         * 3. Can cause LinkageError
         *    - Class already loaded by parent
         *    - Trying to load again with different ClassLoader
         * 
         * 4. Memory leaks
         *    - ClassLoader holds references
         *    - Classes can't be unloaded
         *    - See memory leak section
         */
    }
}
```

---

## 3. Custom ClassLoaders

### Creating Custom ClassLoader

```java
import java.io.*;
import java.nio.file.*;

/**
 * CUSTOM CLASSLOADER:
 * 
 * Use cases:
 * - Load classes from non-standard locations
 * - Load encrypted/obfuscated classes
 * - Implement hot reloading
 * - Create plugin systems
 * - Isolate class versions
 * 
 * Implementation steps:
 * 1. Extend ClassLoader
 * 2. Override findClass() method
 * 3. Load class bytes
 * 4. Call defineClass()
 * 5. Return Class object
 */

public class CustomClassLoaderDemo extends ClassLoader {
    
    private String classPath;
    
    public CustomClassLoaderDemo(String classPath) {
        super(CustomClassLoaderDemo.class.getClassLoader());
        this.classPath = classPath;
    }
    
    public CustomClassLoaderDemo(String classPath, ClassLoader parent) {
        super(parent);
        this.classPath = classPath;
    }
    
    /**
     * CORE METHOD: findClass()
     * 
     * Called by loadClass() when parent can't find class
     * Must return Class object or throw ClassNotFoundException
     */
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        
        System.out.println("CustomClassLoader: Finding " + name);
        
        try {
            // Convert class name to file path
            // com.example.Person -> com/example/Person.class
            String fileName = name.replace('.', '/') + ".class";
            String filePath = classPath + "/" + fileName;
            
            // Read class file bytes
            byte[] classData = loadClassFile(filePath);
            
            if (classData == null) {
                throw new ClassNotFoundException(name);
            }
            
            // Define class from bytes
            Class<?> clazz = defineClass(name, classData, 0, classData.length);
            
            System.out.println("  Successfully loaded: " + name);
            return clazz;
            
        } catch (IOException e) {
            throw new ClassNotFoundException(name, e);
        }
    }
    
    /**
     * HELPER: Load class file bytes
     */
    private byte[] loadClassFile(String filePath) throws IOException {
        
        Path path = Paths.get(filePath);
        
        if (!Files.exists(path)) {
            return null;
        }
        
        return Files.readAllBytes(path);
    }
    
    /**
     * EXAMPLE USAGE:
     */
    public static void main(String[] args) throws Exception {
        
        // Create custom ClassLoader
        CustomClassLoaderDemo loader = 
            new CustomClassLoaderDemo("/path/to/classes");
        
        // Load class
        Class<?> personClass = loader.loadClass("com.example.Person");
        
        System.out.println("Class name: " + personClass.getName());
        System.out.println("Loaded by: " + personClass.getClassLoader());
        System.out.println("Parent: " + personClass.getClassLoader().getParent());
        
        // Create instance
        Object person = personClass.getDeclaredConstructor().newInstance();
        
        // Invoke methods using reflection
        var method = personClass.getMethod("getName");
        String name = (String) method.invoke(person);
        System.out.println("Name: " + name);
        
        /**
         * OUTPUT:
         * CustomClassLoader: Finding com.example.Person
         *   Successfully loaded: com.example.Person
         * Class name: com.example.Person
         * Loaded by: CustomClassLoaderDemo@...
         * Parent: jdk.internal.loader.ClassLoaders$AppClassLoader@...
         */
    }
    
    /**
     * IMPORTANT METHODS:
     * 
     * defineClass():
     * - Converts byte[] to Class object
     * - Links the class
     * - Returns Class object
     * - Called by findClass()
     * 
     * resolveClass():
     * - Links the class
     * - Resolves symbolic references
     * - Called automatically by JVM
     * 
     * findLoadedClass():
     * - Checks if class already loaded
     * - Returns cached Class or null
     * 
     * getResourceAsStream():
     * - Load non-class resources
     * - Properties files, images, etc.
     */
}
```

### Advanced Custom ClassLoader

```java
import java.security.*;
import java.util.concurrent.*;

/**
 * ADVANCED CUSTOM CLASSLOADER:
 * 
 * Features:
 * - Caching
 * - Encryption/decryption
 * - Resource loading
 * - Package sealing
 * - Code source and permissions
 */

public class AdvancedClassLoader extends ClassLoader {
    
    private String classPath;
    private ConcurrentHashMap<String, Class<?>> classCache;
    private byte[] encryptionKey;
    
    public AdvancedClassLoader(String classPath, byte[] encryptionKey) {
        super(AdvancedClassLoader.class.getClassLoader());
        this.classPath = classPath;
        this.encryptionKey = encryptionKey;
        this.classCache = new ConcurrentHashMap<>();
    }
    
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        
        // Check cache first
        Class<?> cached = classCache.get(name);
        if (cached != null) {
            System.out.println("  Cache hit: " + name);
            return cached;
        }
        
        try {
            // Load and decrypt class bytes
            byte[] classData = loadAndDecryptClass(name);
            
            if (classData == null) {
                throw new ClassNotFoundException(name);
            }
            
            // Define package if needed
            definePackageIfNeeded(name);
            
            // Create CodeSource for security
            CodeSource codeSource = new CodeSource(
                new java.net.URL("file", "", classPath),
                (java.security.cert.Certificate[]) null
            );
            
            // Define class with protection domain
            ProtectionDomain protectionDomain = new ProtectionDomain(
                codeSource,
                null, // permissions
                this,
                null
            );
            
            Class<?> clazz = defineClass(
                name,
                classData,
                0,
                classData.length,
                protectionDomain
            );
            
            // Cache the class
            classCache.put(name, clazz);
            
            return clazz;
            
        } catch (Exception e) {
            throw new ClassNotFoundException(name, e);
        }
    }
    
    /**
     * LOAD AND DECRYPT CLASS:
     * 
     * Useful for:
     * - Protecting intellectual property
     * - Preventing decompilation
     * - Licensing enforcement
     */
    private byte[] loadAndDecryptClass(String name) throws Exception {
        
        // Load encrypted class file
        String fileName = name.replace('.', '/') + ".class";
        String filePath = classPath + "/" + fileName;
        
        byte[] encryptedData = Files.readAllBytes(Paths.get(filePath));
        
        // Decrypt (simple XOR for demonstration)
        byte[] decryptedData = decrypt(encryptedData);
        
        return decryptedData;
    }
    
    private byte[] decrypt(byte[] encrypted) {
        byte[] decrypted = new byte[encrypted.length];
        for (int i = 0; i < encrypted.length; i++) {
            decrypted[i] = (byte) (encrypted[i] ^ encryptionKey[i % encryptionKey.length]);
        }
        return decrypted;
    }
    
    /**
     * DEFINE PACKAGE:
     * 
     * Required for package-level features:
     * - Package sealing
     * - Package versioning
     * - Package metadata
     */
    private void definePackageIfNeeded(String className) {
        
        int lastDot = className.lastIndexOf('.');
        if (lastDot == -1) {
            return; // Default package
        }
        
        String packageName = className.substring(0, lastDot);
        
        if (getPackage(packageName) == null) {
            definePackage(
                packageName,
                null, // Specification title
                null, // Specification version
                null, // Specification vendor
                null, // Implementation title
                null, // Implementation version
                null, // Implementation vendor
                null  // Seal base (URL for sealing)
            );
        }
    }
    
    /**
     * LOAD RESOURCES:
     * 
     * Custom ClassLoader should also handle resources
     */
    @Override
    public InputStream getResourceAsStream(String name) {
        
        // Try parent first
        InputStream is = super.getResourceAsStream(name);
        if (is != null) {
            return is;
        }
        
        // Load from custom location
        try {
            Path path = Paths.get(classPath, name);
            if (Files.exists(path)) {
                return Files.newInputStream(path);
            }
        } catch (IOException e) {
            // Ignore
        }
        
        return null;
    }
    
    /**
     * USAGE EXAMPLE:
     */
    public static void main(String[] args) throws Exception {
        
        byte[] key = "secret".getBytes();
        AdvancedClassLoader loader = new AdvancedClassLoader("/path/to/encrypted", key);
        
        // Load encrypted class
        Class<?> clazz = loader.loadClass("com.example.SecureClass");
        
        // Create instance
        Object instance = clazz.getDeclaredConstructor().newInstance();
        
        // Load resource
        InputStream stream = loader.getResourceAsStream("config.properties");
        // ...
    }
}
```

### Plugin System with ClassLoader

```java
import java.net.*;
import java.util.*;

/**
 * PLUGIN SYSTEM:
 * 
 * Use case:
 * - Load plugins dynamically
 * - Isolate plugin dependencies
 * - Unload plugins
 * - Reload plugins
 * 
 * Architecture:
 * 
 * Application
 *   ├─ Plugin API (interface)
 *   ├─ Plugin Manager
 *   └─ Plugin ClassLoaders
 *        ├─ Plugin A ClassLoader → Plugin A classes
 *        ├─ Plugin B ClassLoader → Plugin B classes
 *        └─ Plugin C ClassLoader → Plugin C classes
 */

public class PluginSystemDemo {
    
    /**
     * PLUGIN INTERFACE:
     * 
     * Defined by application, implemented by plugins
     */
    public interface Plugin {
        String getName();
        void initialize();
        void execute();
        void shutdown();
    }
    
    /**
     * PLUGIN MANAGER:
     * 
     * Manages plugin lifecycle
     */
    static class PluginManager {
        
        private Map<String, PluginInfo> plugins = new HashMap<>();
        
        static class PluginInfo {
            Plugin plugin;
            URLClassLoader classLoader;
            
            PluginInfo(Plugin plugin, URLClassLoader classLoader) {
                this.plugin = plugin;
                this.classLoader = classLoader;
            }
        }
        
        /**
         * LOAD PLUGIN:
         * 
         * Each plugin gets own ClassLoader for isolation
         */
        public void loadPlugin(String pluginJar, String mainClass) throws Exception {
            
            System.out.println("Loading plugin: " + pluginJar);
            
            // Create URL for plugin JAR
            URL pluginUrl = new File(pluginJar).toURI().toURL();
            
            // Create isolated ClassLoader for plugin
            URLClassLoader pluginClassLoader = new URLClassLoader(
                new URL[] { pluginUrl },
                this.getClass().getClassLoader() // Parent
            );
            
            // Load plugin main class
            Class<?> pluginClass = pluginClassLoader.loadClass(mainClass);
            
            // Verify implements Plugin interface
            if (!Plugin.class.isAssignableFrom(pluginClass)) {
                throw new IllegalArgumentException(
                    "Plugin must implement Plugin interface");
            }
            
            // Create plugin instance
            Plugin plugin = (Plugin) pluginClass.getDeclaredConstructor().newInstance();
            
            // Initialize plugin
            plugin.initialize();
            
            // Store plugin info
            plugins.put(plugin.getName(), new PluginInfo(plugin, pluginClassLoader));
            
            System.out.println("  Loaded: " + plugin.getName());
        }
        
        /**
         * EXECUTE PLUGIN:
         */
        public void executePlugin(String name) {
            PluginInfo info = plugins.get(name);
            if (info != null) {
                info.plugin.execute();
            }
        }
        
        /**
         * UNLOAD PLUGIN:
         * 
         * Close ClassLoader to allow GC
         */
        public void unloadPlugin(String name) throws IOException {
            
            PluginInfo info = plugins.remove(name);
            
            if (info != null) {
                // Shutdown plugin
                info.plugin.shutdown();
                
                // Close ClassLoader
                info.classLoader.close();
                
                // Clear references
                info.plugin = null;
                info.classLoader = null;
                
                // Suggest GC
                System.gc();
                
                System.out.println("Unloaded: " + name);
            }
        }
        
        /**
         * LIST PLUGINS:
         */
        public void listPlugins() {
            System.out.println("Loaded plugins:");
            for (String name : plugins.keySet()) {
                System.out.println("  - " + name);
            }
        }
    }
    
    /**
     * EXAMPLE PLUGIN IMPLEMENTATION:
     */
    static class ExamplePlugin implements Plugin {
        
        @Override
        public String getName() {
            return "ExamplePlugin";
        }
        
        @Override
        public void initialize() {
            System.out.println("ExamplePlugin: Initializing");
        }
        
        @Override
        public void execute() {
            System.out.println("ExamplePlugin: Executing");
        }
        
        @Override
        public void shutdown() {
            System.out.println("ExamplePlugin: Shutting down");
        }
    }
    
    /**
     * USAGE:
     */
    public static void main(String[] args) throws Exception {
        
        PluginManager manager = new PluginManager();
        
        // Load plugins
        manager.loadPlugin("plugins/plugin1.jar", "com.example.Plugin1");
        manager.loadPlugin("plugins/plugin2.jar", "com.example.Plugin2");
        
        // List plugins
        manager.listPlugins();
        
        // Execute plugins
        manager.executePlugin("Plugin1");
        manager.executePlugin("Plugin2");
        
        // Unload plugin
        manager.unloadPlugin("Plugin1");
        
        /**
         * BENEFITS:
         * 
         * 1. Isolation:
         *    - Each plugin has own ClassLoader
         *    - Different versions of same library
         *    - No conflicts
         * 
         * 2. Dynamic loading:
         *    - Load plugins at runtime
         *    - No restart required
         * 
         * 3. Unloading:
         *    - Can unload plugins
         *    - Free memory
         * 
         * 4. Security:
         *    - Can set security permissions per plugin
         *    - Sandbox untrusted plugins
         */
    }
}
```

---

## 4. Class Loading Phases

### Loading Phase

```java
/**
 * CLASS LOADING PHASES:
 * 
 * 1. LOADING:
 *    - Locate .class file
 *    - Read bytecode
 *    - Create Class object
 * 
 * 2. LINKING:
 *    a. Verification: Verify bytecode validity
 *    b. Preparation: Allocate memory for static fields
 *    c. Resolution: Resolve symbolic references
 * 
 * 3. INITIALIZATION:
 *    - Execute static initializers
 *    - Initialize static fields
 */

public class ClassLoadingPhasesDemo {
    
    /**
     * PHASE 1: LOADING
     * 
     * Steps:
     * 1. Find class file by name
     * 2. Read bytecode into byte[]
     * 3. Call defineClass()
     * 4. Create Class object
     * 5. Store in method area
     * 
     * Triggers:
     * - new ClassName()
     * - Class.forName()
     * - ClassLoader.loadClass()
     * - First access to static field
     * - First invocation of static method
     */
    public static void demonstrateLoading() throws Exception {
        
        System.out.println("Before Class.forName()");
        
        // Trigger loading
        Class<?> clazz = Class.forName("com.example.LoadDemo");
        
        System.out.println("After Class.forName()");
        System.out.println("Class loaded: " + clazz.getName());
        
        /**
         * WHAT HAPPENS:
         * 
         * 1. ClassLoader.loadClass("com.example.LoadDemo")
         * 2. Check if already loaded (findLoadedClass)
         * 3. Delegate to parent (parent delegation)
         * 4. Parent not found, call findClass()
         * 5. Read LoadDemo.class file
         * 6. defineClass(bytes) → creates Class object
         * 7. Return Class object
         * 
         * MEMORY:
         * 
         * Method Area (Metaspace):
         * ┌─────────────────────────────┐
         * │ Class com.example.LoadDemo  │
         * │  - Methods metadata         │
         * │  - Fields metadata          │
         * │  - Constant pool            │
         * │  - Bytecode                 │
         * └─────────────────────────────┘
         * 
         * Heap:
         * ┌─────────────────────────────┐
         * │ java.lang.Class object      │
         * │  - name: "LoadDemo"         │
         * │  - classLoader: ref         │
         * │  - methods: Method[]        │
         * │  - fields: Field[]          │
         * └─────────────────────────────┘
         */
    }
    
    static class LoadDemo {
        static {
            System.out.println("LoadDemo: Static initializer");
        }
    }
}
```

### Linking Phase

```java
/**
 * PHASE 2: LINKING
 * 
 * Substeps:
 * a. Verification
 * b. Preparation
 * c. Resolution
 */

public class LinkingPhaseDemo {
    
    /**
     * 2a. VERIFICATION:
     * 
     * Verifies class file format and bytecode validity
     * 
     * Checks:
     * 1. Magic number (0xCAFEBABE)
     * 2. Version number compatibility
     * 3. Constant pool validity
     * 4. Bytecode structural correctness
     * 5. Type safety
     * 6. Control flow correctness
     * 7. Final class not extended
     * 8. Final method not overridden
     * 
     * Can skip with: -Xverify:none (NOT RECOMMENDED!)
     */
    public static void demonstrateVerification() {
        
        /**
         * VERIFICATION CHECKS:
         * 
         * 1. Format Check:
         *    - Magic number: 0xCAFEBABE
         *    - Major/minor version valid
         *    - Constant pool well-formed
         * 
         * 2. Semantic Check:
         *    - No stack overflow/underflow
         *    - Types used correctly
         *    - Method signatures valid
         * 
         * 3. Symbolic Reference Check:
         *    - Referenced classes exist
         *    - Referenced methods exist
         *    - Access rights respected
         * 
         * If verification fails:
         * - VerifyError thrown
         * - Class loading aborts
         * 
         * Example verification failure:
         * 
         * class Bad {
         *     public void method() {
         *         int x;
         *         return x; // ERROR: Uninitialized variable
         *     }
         * }
         * 
         * Throws: VerifyError
         */
    }
    
    /**
     * 2b. PREPARATION:
     * 
     * Allocates memory for static fields
     * Initializes to default values (NOT explicit initializers)
     * 
     * Default values:
     * - int: 0
     * - long: 0L
     * - float: 0.0f
     * - double: 0.0d
     * - boolean: false
     * - reference: null
     */
    public static void demonstratePreparation() {
        
        /**
         * EXAMPLE:
         * 
         * class Example {
         *     static int x = 100;    // Explicit initializer
         *     static String s = "test";
         * }
         * 
         * PREPARATION PHASE:
         * x = 0 (not 100 yet!)
         * s = null (not "test" yet!)
         * 
         * INITIALIZATION PHASE (later):
         * x = 100 (explicit initializer runs)
         * s = "test"
         * 
         * MEMORY AFTER PREPARATION:
         * 
         * Method Area:
         * ┌─────────────────────────────┐
         * │ Class Example               │
         * │  Static fields:             │
         * │    int x = 0                │ ← Default
         * │    String s = null          │ ← Default
         * └─────────────────────────────┘
         */
    }
    
    /**
     * 2c. RESOLUTION:
     * 
     * Resolves symbolic references to direct references
     * 
     * Symbolic reference:
     * - String representation
     * - "com/example/Person.getName()Ljava/lang/String;"
     * 
     * Direct reference:
     * - Memory address
     * - Method pointer
     * - Field offset
     * 
     * Resolution timing:
     * - Lazy (on first use) - default
     * - Eager (at load time) - with -Xverify:eager
     */
    public static void demonstrateResolution() {
        
        /**
         * EXAMPLE:
         * 
         * class A {
         *     void method() {
         *         B b = new B();  // Symbolic reference to B
         *         b.doSomething(); // Symbolic reference to B.doSomething()
         *     }
         * }
         * 
         * BEFORE RESOLUTION (symbolic):
         * CONSTANT_Class_info: "com/example/B"
         * CONSTANT_Methodref_info: "com/example/B.doSomething()V"
         * 
         * AFTER RESOLUTION (direct):
         * Class pointer: 0x12345678 (memory address of B)
         * Method pointer: 0x23456789 (address of doSomething bytecode)
         * 
         * RESOLUTION ERRORS:
         * 
         * - NoClassDefFoundError: Referenced class not found
         * - NoSuchFieldError: Referenced field not found
         * - NoSuchMethodError: Referenced method not found
         * - IllegalAccessError: Access violation
         * - IncompatibleClassChangeError: Class changed incompatibly
         */
    }
}
```

### Initialization Phase

```java
/**
 * PHASE 3: INITIALIZATION
 * 
 * Executes:
 * 1. Static field initializers
 * 2. Static initializer blocks
 * 
 * Order:
 * - Parent class initialized first
 * - Then child class
 * - Within class: textual order
 * 
 * Triggered by:
 * 1. new ClassName()
 * 2. Access to non-final static field
 * 3. Invocation of static method
 * 4. Reflection: Class.forName()
 * 5. Subclass initialization
 * 6. Designated as startup class (main)
 * 
 * NOT triggered by:
 * 1. Access to static final constant
 * 2. Array creation: new ClassName[10]
 * 3. Class.forName() with initialize=false
 * 4. ClassLoader.loadClass()
 */

public class InitializationPhaseDemo {
    
    static class Parent {
        static int parentValue = initParent();
        
        static {
            System.out.println("Parent: Static block");
        }
        
        static int initParent() {
            System.out.println("Parent: Initializing parentValue");
            return 100;
        }
    }
    
    static class Child extends Parent {
        static int childValue = initChild();
        
        static {
            System.out.println("Child: Static block");
        }
        
        static int initChild() {
            System.out.println("Child: Initializing childValue");
            return 200;
        }
    }
    
    public static void main(String[] args) throws Exception {
        
        System.out.println("=== Test 1: First use ===");
        Child child = new Child();
        
        /**
         * OUTPUT:
         * Parent: Initializing parentValue
         * Parent: Static block
         * Child: Initializing childValue
         * Child: Static block
         * 
         * Explanation:
         * 1. new Child() triggers Child initialization
         * 2. Child initialization requires Parent initialization first
         * 3. Parent initializers run in order
         * 4. Then Child initializers run in order
         */
        
        System.out.println("\n=== Test 2: Static field access ===");
        System.out.println("childValue = " + Child.childValue);
        // No output! Already initialized.
        
        System.out.println("\n=== Test 3: Final constant ===");
        System.out.println("CONSTANT = " + Constants.CONSTANT);
        // No initialization! Constant folded at compile time.
    }
    
    static class Constants {
        static final int CONSTANT = 42; // Compile-time constant
        
        static {
            System.out.println("Constants: Static block (NOT executed)");
        }
    }
    
    /**
     * INITIALIZATION LOCK:
     * 
     * Thread-safe initialization guaranteed by JVM
     * 
     * Process:
     * 1. Thread A starts initializing class
     * 2. Acquires initialization lock
     * 3. Runs static initializers
     * 4. Releases lock
     * 5. Thread B waits if tries to initialize
     * 
     * Only one thread can initialize a class!
     */
    public static void demonstrateConcurrentInitialization() throws Exception {
        
        Thread t1 = new Thread(() -> {
            new SlowInit();
        });
        
        Thread t2 = new Thread(() -> {
            new SlowInit();
        });
        
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        
        /**
         * OUTPUT:
         * Thread-0: Starting initialization
         * Thread-0: Finished initialization
         * 
         * Only one thread initializes!
         * Other thread waits.
         */
    }
    
    static class SlowInit {
        static {
            System.out.println(Thread.currentThread().getName() + ": Starting initialization");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {}
            System.out.println(Thread.currentThread().getName() + ": Finished initialization");
        }
    }
    
    /**
     * INITIALIZATION ERRORS:
     * 
     * If exception thrown during initialization:
     * - ExceptionInInitializerError wraps it
     * - Class marked as initialization failed
     * - Subsequent uses throw NoClassDefFoundError
     */
    public static void demonstrateInitializationError() {
        
        try {
            new FailedInit();
        } catch (ExceptionInInitializerError e) {
            System.out.println("First attempt: " + e);
        }
        
        try {
            new FailedInit();
        } catch (NoClassDefFoundError e) {
            System.out.println("Second attempt: " + e);
        }
        
        /**
         * OUTPUT:
         * First attempt: ExceptionInInitializerError (caused by NPE)
         * Second attempt: NoClassDefFoundError (initialization failed)
         * 
         * Once initialization fails, class is permanently unusable!
         */
    }
    
    static class FailedInit {
        static String s = null;
        static int len = s.length(); // NullPointerException!
    }
}
```

---

## 5. ClassNotFoundException vs NoClassDefFoundError

### Understanding the Difference

```java
/**
 * CLASSNOTFOUNDEXCEPTION vs NOCLASSDEFFOUNDERROR:
 * 
 * ClassNotFoundException (Checked Exception):
 * - Thrown when class not found at runtime
 * - Explicit class loading attempt
 * - Class.forName(), ClassLoader.loadClass()
 * - Can be caught and handled
 * 
 * NoClassDefFoundError (Error):
 * - Thrown when class was present at compile time
 * - But not found at runtime
 * - Or initialization failed
 * - Should not be caught (indicates serious problem)
 */

public class ClassNotFoundDemo {
    
    /**
     * CLASSNOTFOUNDEXCEPTION:
     * 
     * Scenarios:
     * 1. Class name typo
     * 2. Class not in classpath
     * 3. Wrong ClassLoader
     */
    public static void demonstrateClassNotFoundException() {
        
        // Scenario 1: Class doesn't exist
        try {
            Class.forName("com.example.NonExistentClass");
        } catch (ClassNotFoundException e) {
            System.out.println("ClassNotFoundException: " + e.getMessage());
            // Can handle: provide default, fallback, etc.
        }
        
        // Scenario 2: Using ClassLoader
        try {
            ClassLoader.getSystemClassLoader()
                .loadClass("com.example.MissingClass");
        } catch (ClassNotFoundException e) {
            System.out.println("Class not in classpath: " + e.getMessage());
        }
        
        // Scenario 3: JDBC driver not in classpath
        try {
            Class.forName("com.mysql.jdbc.Driver");
        } catch (ClassNotFoundException e) {
            System.out.println("MySQL driver not found: " + e.getMessage());
            // Can handle: use different driver, show error to user
        }
        
        /**
         * HANDLING:
         * 
         * try {
         *     Class.forName(driverClass);
         * } catch (ClassNotFoundException e) {
         *     log.error("Driver not found: " + driverClass);
         *     // Try fallback driver
         *     Class.forName("org.h2.Driver");
         * }
         */
    }
    
    /**
     * NOCLASSDEFFOUNDERROR:
     * 
     * Scenarios:
     * 1. Class present at compile time, missing at runtime
     * 2. Static initializer threw exception
     * 3. Dependent class missing
     */
    public static void demonstrateNoClassDefFoundError() {
        
        // Scenario 1: Dependent class missing at runtime
        /**
         * Compile time: A.class depends on B.class (both present)
         * Runtime: B.class removed or not in classpath
         * Result: NoClassDefFoundError when using A
         * 
         * Example:
         * 
         * // A.java
         * public class A {
         *     public void method() {
         *         B b = new B(); // Depends on B
         *     }
         * }
         * 
         * // Compile: javac A.java B.java → Success
         * // Delete B.class
         * // Run: java A → NoClassDefFoundError: B
         */
        
        // Scenario 2: Static initializer exception
        try {
            new BadInit();
        } catch (ExceptionInInitializerError e) {
            System.out.println("Initialization failed: " + e.getCause());
        }
        
        try {
            new BadInit(); // Second attempt
        } catch (NoClassDefFoundError e) {
            System.out.println("NoClassDefFoundError: " + e.getMessage());
            // This is serious! Class permanently broken.
            // Cannot recover.
        }
    }
    
    static class BadInit {
        static {
            throw new RuntimeException("Initialization failure");
        }
    }
    
    /**
     * COMPARISON TABLE:
     * 
     * ┌────────────────────┬─────────────────────┬──────────────────────┐
     * │                    │ ClassNotFoundException │ NoClassDefFoundError│
     * ├────────────────────┼─────────────────────┼──────────────────────┤
     * │ Type               │ Exception           │ Error                │
     * │ Checked/Unchecked  │ Checked             │ Unchecked            │
     * │ When               │ Explicit loading    │ Implicit loading     │
     * │ Cause              │ Class not found     │ Was found, now gone  │
     * │                    │                     │ or init failed       │
     * │ Triggered by       │ Class.forName()     │ new, static access   │
     * │ Can catch          │ Yes (should)        │ No (shouldn't)       │
     * │ Recovery           │ Possible            │ Difficult/impossible │
     * │ Common cause       │ Typo, classpath     │ Missing dependency,  │
     * │                    │                     │ init exception       │
     * └────────────────────┴─────────────────────┴──────────────────────┘
     */
    
    /**
     * DEBUGGING:
     * 
     * ClassNotFoundException:
     * 1. Check class name spelling
     * 2. Verify class in classpath
     * 3. Check ClassLoader hierarchy
     * 4. Use -verbose:class to see loading
     * 
     * NoClassDefFoundError:
     * 1. Check for missing dependencies
     * 2. Look for static initializer exceptions
     * 3. Verify all required classes present
     * 4. Check for circular dependencies
     * 5. Review classpath conflicts
     * 
     * Command line:
     * java -verbose:class MyApp
     * 
     * Shows:
     * [Loaded java.lang.Object from ...]
     * [Loaded java.lang.String from ...]
     * [Loaded com.example.MyClass from ...]
     */
}
```

---

## 6. OSGi and Modular ClassLoading

### OSGi Basics

```java
/**
 * OSGI (Open Services Gateway initiative):
 * 
 * Dynamic modular system for Java
 * 
 * Key concepts:
 * - Bundle: Module with its own ClassLoader
 * - Service: Shared component between bundles
 * - Lifecycle: Install, start, stop, uninstall
 * - Versioning: Multiple versions can coexist
 * 
 * Benefits:
 * - True modularity
 * - Dynamic loading/unloading
 * - Version isolation
 * - Service registry
 * 
 * Popular implementations:
 * - Apache Felix
 * - Eclipse Equinox
 * - Apache Karaf
 */

public class OSGiConceptsDemo {
    
    /**
     * OSGI BUNDLE:
     * 
     * Structure:
     * mybundle.jar
     * ├── META-INF/
     * │   └── MANIFEST.MF    ← Bundle metadata
     * ├── com/
     * │   └── example/
     * │       ├── Activator.java
     * │       └── MyService.java
     * └── resources/
     * 
     * MANIFEST.MF:
     * 
     * Manifest-Version: 1.0
     * Bundle-ManifestVersion: 2
     * Bundle-Name: My Bundle
     * Bundle-SymbolicName: com.example.mybundle
     * Bundle-Version: 1.0.0
     * Bundle-Activator: com.example.Activator
     * Import-Package: org.osgi.framework;version="1.8"
     * Export-Package: com.example.api;version="1.0"
     * 
     * Key directives:
     * - Bundle-SymbolicName: Unique identifier
     * - Bundle-Version: Bundle version
     * - Bundle-Activator: Entry point class
     * - Import-Package: Dependencies
     * - Export-Package: Public API
     */
    
    /**
     * BUNDLE ACTIVATOR:
     * 
     * Lifecycle callbacks
     */
    /*
    import org.osgi.framework.*;
    
    public class Activator implements BundleActivator {
        
        @Override
        public void start(BundleContext context) throws Exception {
            System.out.println("Bundle starting");
            
            // Register service
            MyService service = new MyServiceImpl();
            context.registerService(MyService.class.getName(), service, null);
        }
        
        @Override
        public void stop(BundleContext context) throws Exception {
            System.out.println("Bundle stopping");
            // Cleanup
        }
    }
    */
    
    /**
     * OSGI CLASSLOADER HIERARCHY:
     * 
     * Bootstrap ClassLoader
     *       ↑
     * Framework ClassLoader (OSGi framework)
     *       ↑
     *   ┌───┴───┬───────┬───────┐
     *   │       │       │       │
     * Bundle  Bundle  Bundle  Bundle
     *   CL1     CL2     CL3     CL4
     * 
     * Each bundle has own ClassLoader!
     * 
     * Class resolution:
     * 1. Check bundle ClassLoader cache
     * 2. Check parent (framework) ClassLoader
     * 3. Check Import-Package declarations
     * 4. Check bundle's own classes
     * 5. Check Require-Bundle dependencies
     * 6. Fail if not found
     */
    
    /**
     * VERSION ISOLATION:
     * 
     * Bundle A uses library 1.0:
     * - Bundle-SymbolicName: com.example.bundleA
     * - Import-Package: com.library;version="1.0"
     * 
     * Bundle B uses library 2.0:
     * - Bundle-SymbolicName: com.example.bundleB
     * - Import-Package: com.library;version="2.0"
     * 
     * Both run simultaneously without conflict!
     * 
     * OSGi resolves:
     * Bundle A ClassLoader → library 1.0
     * Bundle B ClassLoader → library 2.0
     */
}
```

### Java 9+ Module System (JPMS)

```java
/**
 * JAVA PLATFORM MODULE SYSTEM (JPMS):
 * 
 * Introduced in Java 9
 * Replaces extension mechanism
 * 
 * Key concepts:
 * - Module: Named collection of packages
 * - module-info.java: Module descriptor
 * - Automatic modules: JARs without module-info
 * - Unnamed module: Classpath classes
 * 
 * Benefits:
 * - Strong encapsulation
 * - Reliable configuration
 * - Improved security
 * - Better performance
 */

public class JPMSDemo {
    
    /**
     * MODULE DESCRIPTOR:
     * 
     * module-info.java:
     * 
     * module com.example.myapp {
     *     // Require other modules
     *     requires java.sql;
     *     requires java.xml;
     *     requires transitive com.example.api;
     *     
     *     // Export packages (public API)
     *     exports com.example.myapp.api;
     *     exports com.example.myapp.util to com.example.other;
     *     
     *     // Open for reflection
     *     opens com.example.myapp.model;
     *     
     *     // Provide service
     *     provides com.example.api.Service 
     *         with com.example.myapp.ServiceImpl;
     *     
     *     // Use service
     *     uses com.example.api.Plugin;
     * }
     * 
     * Directives:
     * - requires: Dependency
     * - requires transitive: Transitive dependency
     * - exports: Make package public
     * - exports...to: Make package public to specific modules
     * - opens: Allow reflection
     * - provides...with: Service provider
     * - uses: Service consumer
     */
    
    /**
     * MODULE PATH vs CLASSPATH:
     * 
     * Classpath (old):
     * java -cp lib/*:app.jar com.example.Main
     * 
     * Module path (new):
     * java --module-path lib:app.jar --module com.example.myapp/com.example.Main
     * 
     * Or short form:
     * java -p lib:app.jar -m com.example.myapp/com.example.Main
     * 
     * Benefits:
     * - Strong encapsulation (internal packages hidden)
     * - Explicit dependencies (no hidden dependencies)
     * - Compile-time checking (missing dependencies found early)
     */
    
    /**
     * MODULE GRAPH:
     * 
     * com.example.app
     *   ├─ requires java.base (implicit)
     *   ├─ requires java.sql
     *   │    └─ requires transitive java.logging
     *   └─ requires com.example.api
     *        └─ requires transitive java.xml
     * 
     * Transitive dependencies:
     * - com.example.app can use java.logging (via java.sql)
     * - com.example.app can use java.xml (via com.example.api)
     */
    
    /**
     * AUTOMATIC MODULES:
     * 
     * Legacy JAR without module-info.java
     * 
     * When placed on module path:
     * - Becomes automatic module
     * - Module name derived from JAR filename
     *   gson-2.8.jar → gson
     *   commons-lang3-3.12.jar → commons.lang3
     * - Exports all packages
     * - Reads all other modules
     * 
     * Usage:
     * module com.example.app {
     *     requires gson; // Automatic module
     * }
     */
    
    /**
     * UNNAMED MODULE:
     * 
     * Classpath classes (no module-info.java)
     * 
     * Properties:
     * - Reads all named modules
     * - Exports all packages to other unnamed modules
     * - Cannot be required by named modules
     * 
     * Migration path:
     * 1. Run on classpath (unnamed module)
     * 2. Convert dependencies to automatic modules
     * 3. Add module-info.java (named module)
     */
}
```

---

## 7. Hot Reloading and Class Unloading

### Hot Reloading Implementation

```java
import java.nio.file.*;
import java.util.*;
import java.util.concurrent.*;

/**
 * HOT RELOADING:
 * 
 * Reload classes without restarting JVM
 * 
 * Use cases:
 * - Development (faster iteration)
 * - Plugin systems (update plugins)
 * - Configuration changes
 * 
 * Limitations:
 * - Cannot change method signatures
 * - Cannot add/remove fields
 * - Cannot change class hierarchy
 * - Works best with new ClassLoader instance
 */

public class HotReloadDemo {
    
    /**
     * HOT RELOAD CLASS LOADER:
     * 
     * Creates new ClassLoader for each reload
     */
    static class ReloadableClassLoader extends ClassLoader {
        
        private String classPath;
        
        public ReloadableClassLoader(String classPath, ClassLoader parent) {
            super(parent);
            this.classPath = classPath;
        }
        
        @Override
        protected Class<?> findClass(String name) throws ClassNotFoundException {
            
            // Always load fresh (don't check cache)
            try {
                String fileName = name.replace('.', '/') + ".class";
                String filePath = classPath + "/" + fileName;
                
                byte[] classData = Files.readAllBytes(Paths.get(filePath));
                
                return defineClass(name, classData, 0, classData.length);
                
            } catch (Exception e) {
                throw new ClassNotFoundException(name, e);
            }
        }
    }
    
    /**
     * PLUGIN RELOADER:
     * 
     * Monitors plugin file and reloads on change
     */
    static class PluginReloader {
        
        private String pluginPath;
        private String pluginClass;
        private Object pluginInstance;
        private ClassLoader classLoader;
        private long lastModified;
        
        public PluginReloader(String pluginPath, String pluginClass) {
            this.pluginPath = pluginPath;
            this.pluginClass = pluginClass;
            reload();
        }
        
        /**
         * RELOAD PLUGIN:
         * 
         * Creates new ClassLoader and loads fresh class
         */
        public synchronized void reload() {
            try {
                System.out.println("Reloading plugin: " + pluginClass);
                
                // Create NEW ClassLoader
                // Old ClassLoader will be GC'd with old classes
                classLoader = new ReloadableClassLoader(
                    pluginPath,
                    getClass().getClassLoader()
                );
                
                // Load fresh class
                Class<?> clazz = classLoader.loadClass(pluginClass);
                
                // Create new instance
                pluginInstance = clazz.getDeclaredConstructor().newInstance();
                
                // Update last modified
                Path path = Paths.get(pluginPath + "/" + 
                    pluginClass.replace('.', '/') + ".class");
                lastModified = Files.getLastModifiedTime(path).toMillis();
                
                System.out.println("  Plugin reloaded successfully");
                
            } catch (Exception e) {
                System.err.println("  Failed to reload: " + e.getMessage());
            }
        }
        
        /**
         * CHECK AND RELOAD:
         * 
         * Reload if file modified
         */
        public void checkAndReload() {
            try {
                Path path = Paths.get(pluginPath + "/" + 
                    pluginClass.replace('.', '/') + ".class");
                long modified = Files.getLastModifiedTime(path).toMillis();
                
                if (modified > lastModified) {
                    reload();
                }
                
            } catch (Exception e) {
                // File might be temporarily unavailable during compilation
            }
        }
        
        /**
         * EXECUTE PLUGIN:
         */
        public synchronized void execute(String method) {
            try {
                var m = pluginInstance.getClass().getMethod(method);
                m.invoke(pluginInstance);
            } catch (Exception e) {
                System.err.println("Execution failed: " + e.getMessage());
            }
        }
        
        /**
         * START MONITORING:
         * 
         * Watch file system for changes
         */
        public void startMonitoring() {
            
            Thread monitor = new Thread(() -> {
                System.out.println("Starting file monitor");
                
                try (WatchService watcher = FileSystems.getDefault().newWatchService()) {
                    
                    Path dir = Paths.get(pluginPath);
                    dir.register(watcher, 
                        StandardWatchEventKinds.ENTRY_MODIFY);
                    
                    while (true) {
                        WatchKey key = watcher.take();
                        
                        for (WatchEvent<?> event : key.pollEvents()) {
                            if (event.kind() == StandardWatchEventKinds.ENTRY_MODIFY) {
                                System.out.println("File modified: " + event.context());
                                checkAndReload();
                            }
                        }
                        
                        key.reset();
                    }
                    
                } catch (Exception e) {
                    System.err.println("Monitor error: " + e.getMessage());
                }
            });
            
            monitor.setDaemon(true);
            monitor.start();
        }
    }
    
    /**
     * USAGE EXAMPLE:
     */
    public static void main(String[] args) throws Exception {
        
        // Create reloader
        PluginReloader reloader = new PluginReloader(
            "plugins/classes",
            "com.example.MyPlugin"
        );
        
        // Start monitoring
        reloader.startMonitoring();
        
        // Execute plugin periodically
        while (true) {
            System.out.println("\n=== Executing plugin ===");
            reloader.execute("run");
            
            Thread.sleep(5000);
            
            /**
             * WORKFLOW:
             * 
             * 1. Modify MyPlugin.java
             * 2. Compile: javac MyPlugin.java
             * 3. File monitor detects change
             * 4. Reloader creates new ClassLoader
             * 5. Loads fresh MyPlugin class
             * 6. Next execution uses new version
             * 
             * No restart required!
             */
        }
    }
    
    /**
     * CAVEATS:
     * 
     * 1. Static state lost:
     *    - Static fields reset
     *    - Static initializers re-run
     *    - Can't preserve state across reloads
     * 
     * 2. Old instances still exist:
     *    - Old ClassLoader not GC'd if references exist
     *    - Memory leak if not careful
     *    - Must clear all references to old instances
     * 
     * 3. Type incompatibility:
     *    - Old and new classes are different types
     *    - Can't cast between versions
     *    - Must use reflection or interfaces
     * 
     * 4. Dependencies:
     *    - Dependent classes also need reloading
     *    - Complex dependency graphs tricky
     */
}
```

### Class Unloading

```java
/**
 * CLASS UNLOADING:
 * 
 * Classes can be garbage collected when:
 * 1. ClassLoader that loaded them is unreachable
 * 2. All instances of class are unreachable
 * 3. Class object is unreachable
 * 
 * Conditions for unloading:
 * - No references to ClassLoader
 * - No references to any Class loaded by ClassLoader
 * - No instances of any class
 * - No references from Method area
 * 
 * Bootstrap/Platform/Application ClassLoaders never unloaded
 * Only custom ClassLoaders can be unloaded
 */

public class ClassUnloadingDemo {
    
    /**
     * DEMONSTRATING CLASS UNLOADING:
     */
    public static void main(String[] args) throws Exception {
        
        System.out.println("=== Loading class ===");
        
        // Create custom ClassLoader
        ClassLoader loader = new URLClassLoader(
            new URL[] { new File("plugins/").toURI().toURL() }
        );
        
        // Load class
        Class<?> clazz = loader.loadClass("com.example.Plugin");
        
        // Create instance
        Object instance = clazz.getDeclaredConstructor().newInstance();
        
        // Use instance
        clazz.getMethod("execute").invoke(instance);
        
        System.out.println("Class loaded by: " + clazz.getClassLoader());
        
        System.out.println("\n=== Unloading class ===");
        
        // Clear all references
        instance = null;
        clazz = null;
        loader = null;
        
        // Suggest GC
        System.gc();
        System.runFinalization();
        
        Thread.sleep(1000);
        
        System.out.println("Class potentially unloaded");
        
        /**
         * VERIFICATION:
         * 
         * Run with: -verbose:class
         * 
         * Output:
         * [Loaded com.example.Plugin from file:...]
         * ...
         * [Unloading class com.example.Plugin]
         * 
         * Class unloaded!
         */
    }
    
    /**
     * WHY CLASSES NOT UNLOADED:
     * 
     * Common issues preventing unloading:
     */
    public static void demonstrateLeaks() {
        
        // LEAK 1: Static reference
        class Holder {
            static Object leaked; // Holds reference!
        }
        
        ClassLoader loader = new URLClassLoader(new URL[0]);
        Holder.leaked = loader; // Leak!
        loader = null; // Not unloadable - Holder.leaked still references it
        
        // LEAK 2: Thread reference
        Thread thread = new Thread(() -> {
            // ClassLoader stored in thread context
        });
        thread.start();
        // Thread keeps ClassLoader alive!
        
        // LEAK 3: ThreadLocal
        ThreadLocal<Object> threadLocal = new ThreadLocal<>();
        threadLocal.set(loader);
        // ThreadLocal in thread keeps ClassLoader alive!
        
        // LEAK 4: Listener
        EventSource source = new EventSource();
        source.addListener(event -> {
            // Lambda captures ClassLoader!
        });
        // EventSource keeps listener keeps ClassLoader alive!
        
        /**
         * FIXES:
         * 
         * 1. Clear static references:
         *    Holder.leaked = null;
         * 
         * 2. Stop threads:
         *    thread.interrupt();
         *    thread.join();
         * 
         * 3. Clear ThreadLocal:
         *    threadLocal.remove();
         * 
         * 4. Remove listeners:
         *    source.removeListener(...);
         */
    }
    
    static class EventSource {
        void addListener(Object listener) {}
        void removeListener(Object listener) {}
    }
    
    /**
     * MONITORING CLASS UNLOADING:
     */
    public static void monitorUnloading() {
        
        /**
         * JVM FLAGS:
         * 
         * -verbose:class
         * Show class loading and unloading
         * 
         * -XX:+TraceClassUnloading
         * Detailed unloading information
         * 
         * -XX:+PrintClassHistogram
         * Print class histogram on Ctrl+Break
         * 
         * Example output:
         * [Loaded java.lang.String from ...]
         * [Loaded com.example.MyClass from file:...]
         * [Unloading class com.example.MyClass]
         */
        
        /**
         * PROGRAMMATIC MONITORING:
         */
        /*
        NotificationListener listener = (notification, handback) -> {
            if (notification.getType().equals(
                MemoryNotificationInfo.MEMORY_THRESHOLD_EXCEEDED)) {
                
                System.out.println("Memory threshold exceeded");
                System.gc(); // Trigger class unloading
            }
        };
        
        MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
        NotificationEmitter emitter = (NotificationEmitter) memoryBean;
        emitter.addNotificationListener(listener, null, null);
        */
    }
    
    /**
     * BEST PRACTICES:
     * 
     * 1. Use finite ClassLoader lifecycle:
     *    - Create ClassLoader
     *    - Load and use classes
     *    - Clear all references
     *    - Allow GC
     * 
     * 2. Avoid leaks:
     *    - No static references
     *    - Clean up ThreadLocal
     *    - Stop threads
     *    - Remove listeners
     * 
     * 3. Monitor:
     *    - Use -verbose:class
     *    - Watch memory usage
     *    - Heap dumps
     * 
     * 4. Test:
     *    - Load/unload repeatedly
     *    - Check for memory leaks
     *    - Profile with VisualVM
     */
}
```

---

## Summary

### ClassLoader Hierarchy

```
Bootstrap ClassLoader (null)
    ↓ parent
Platform/Extension ClassLoader
    ↓ parent
Application ClassLoader
    ↓ parent
Custom ClassLoaders
```

### Parent Delegation Flow

```
1. Check if already loaded (cache)
2. Delegate to parent ClassLoader
3. If parent can't load, try self
4. If still can't load, throw ClassNotFoundException
```

### Class Loading Phases

```
1. LOADING
   - Locate .class file
   - Read bytes
   - defineClass()
   
2. LINKING
   a. Verification: Verify bytecode
   b. Preparation: Allocate statics (default values)
   c. Resolution: Resolve symbolic references
   
3. INITIALIZATION
   - Execute static initializers
   - Set explicit values
```

### Key Differences

|Aspect|ClassNotFoundException|NoClassDefFoundError|
|---|---|---|
|Type|Exception (checked)|Error (unchecked)|
|When|Explicit loading|Implicit loading|
|Cause|Class not found|Was found, now missing or init failed|
|Can catch|Yes|No (shouldn't)|
|Recovery|Possible|Difficult|

### Common Issues

|Issue|Cause|Solution|
|---|---|---|
|ClassNotFoundException|Wrong classpath|Add to classpath|
|NoClassDefFoundError|Missing dependency|Include all dependencies|
|ClassCastException|Same class, different ClassLoaders|Use single ClassLoader|
|LinkageError|Class loaded twice|Check ClassLoader hierarchy|
|Memory leak|ClassLoader not GC'd|Clear all references|

### Best Practices

1. **Use parent delegation** (don't break unless necessary)
2. **Override findClass()** (not loadClass())
3. **Clean up resources** (close ClassLoaders)
4. **Avoid static references** (prevent leaks)
5. **Monitor with -verbose:class**
6. **Use try-with-resources** (URLClassLoader implements Closeable)
7. **Test hot reloading** (watch for memory leaks)

---

