# Error Handling in Async and Functional Code

## Overview

Functional and asynchronous programming in Java introduces unique challenges for exception handling. Traditional try-catch doesn't work well with lambdas and streams. Checked exceptions clash with functional interfaces. This guide covers modern patterns for handling errors in CompletableFutures, Streams, Optional, and functional code using both standard Java and Vavr.

---

## 1. CompletableFuture Exception Handling

### Async Exception Management

```java
/**
 * COMPLETABLEFUTURE EXCEPTION HANDLING
 * 
 * Managing errors in asynchronous code
 */

import java.util.concurrent.*;
import java.io.*;

public class CompletableFutureExceptionHandling {
    
    /**
     * The async exception problem
     */
    public static void asyncExceptionProblem() {
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            // This runs in a different thread
            if (Math.random() > 0.5) {
                throw new RuntimeException("Random failure");
            }
            return "Success";
        });
        
        // How to handle the exception?
        // Can't use try-catch here
        // Exception thrown in different thread
        
        /**
         * PROBLEM:
         * 
         * Traditional try-catch doesn't work
         * Exception in different thread
         * Need async exception handling
         */
    }
    
    /**
     * Method 1: exceptionally() - recover from exception
     */
    public static void exceptionallyMethod() {
        CompletableFuture<String> future = CompletableFuture
            .supplyAsync(() -> {
                System.out.println("Computing...");
                if (true) {
                    throw new RuntimeException("Computation failed");
                }
                return "Success";
            })
            .exceptionally(ex -> {
                // Called only if exception occurred
                System.err.println("Error: " + ex.getMessage());
                return "Fallback value";
            });
        
        String result = future.join();
        System.out.println("Result: " + result);
        
        /**
         * OUTPUT:
         * Computing...
         * Error: java.lang.RuntimeException: Computation failed
         * Result: Fallback value
         * 
         * 
         * EXCEPTIONALLY:
         * 
         * - Called only on exception
         * - Receives Throwable
         * - Returns fallback value
         * - Converts failure to success
         * 
         * Similar to catch block
         */
    }
    
    /**
     * Method 2: handle() - handle both success and failure
     */
    public static void handleMethod() {
        CompletableFuture<String> future = CompletableFuture
            .supplyAsync(() -> {
                if (Math.random() > 0.5) {
                    throw new RuntimeException("Failed");
                }
                return "Success";
            })
            .handle((result, ex) -> {
                // Called for both success and failure
                if (ex != null) {
                    System.err.println("Error: " + ex.getMessage());
                    return "Recovered: " + ex.getMessage();
                } else {
                    System.out.println("Success: " + result);
                    return "Processed: " + result;
                }
            });
        
        System.out.println("Final: " + future.join());
        
        /**
         * HANDLE:
         * 
         * - Called for both success and failure
         * - Receives (result, exception)
         * - If success: result != null, ex == null
         * - If failure: result == null, ex != null
         * - Must handle both cases
         * 
         * Similar to try-catch-finally
         */
    }
    
    /**
     * Method 3: whenComplete() - observe without changing result
     */
    public static void whenCompleteMethod() {
        CompletableFuture<String> future = CompletableFuture
            .supplyAsync(() -> {
                if (Math.random() > 0.5) {
                    throw new RuntimeException("Failed");
                }
                return "Success";
            })
            .whenComplete((result, ex) -> {
                // Called for both success and failure
                // But cannot change result
                if (ex != null) {
                    System.err.println("Logging error: " + ex.getMessage());
                } else {
                    System.out.println("Logging success: " + result);
                }
            });
        
        try {
            System.out.println("Result: " + future.join());
        } catch (CompletionException e) {
            System.err.println("Exception propagated: " + e.getCause());
        }
        
        /**
         * WHENCOMPLETE:
         * 
         * - Called for both success and failure
         * - Receives (result, exception)
         * - CANNOT change result
         * - Used for side effects (logging, cleanup)
         * - Exception propagates if not handled
         * 
         * Similar to finally block
         */
    }
    
    /**
     * Comparing exception handling methods
     */
    public static void comparingMethods() {
        /**
         * EXCEPTIONALLY:
         * 
         * exceptionally(ex -> fallback)
         * 
         * - Called only on exception
         * - Returns fallback value
         * - Converts failure to success
         * - Like: catch (Exception e) { return fallback; }
         * 
         * 
         * HANDLE:
         * 
         * handle((result, ex) -> {
         *     if (ex != null) return fallback;
         *     else return process(result);
         * })
         * 
         * - Called for both success and failure
         * - Can transform both cases
         * - Must handle both paths
         * - Like: try { } catch { } with return
         * 
         * 
         * WHENCOMPLETE:
         * 
         * whenComplete((result, ex) -> {
         *     if (ex != null) log(ex);
         *     else log(result);
         * })
         * 
         * - Called for both success and failure
         * - Cannot change result
         * - Side effects only
         * - Exception propagates
         * - Like: finally block
         */
    }
    
    /**
     * Chaining with exception handling
     */
    public static void chainingWithExceptions() {
        CompletableFuture<String> future = CompletableFuture
            .supplyAsync(() -> {
                System.out.println("Step 1: Fetch data");
                return "data";
            })
            .thenApply(data -> {
                System.out.println("Step 2: Process " + data);
                if (data.equals("data")) {
                    throw new RuntimeException("Processing failed");
                }
                return data.toUpperCase();
            })
            .thenApply(processed -> {
                // This won't execute if previous step failed
                System.out.println("Step 3: Transform " + processed);
                return "Result: " + processed;
            })
            .exceptionally(ex -> {
                // Handles exception from any step
                System.err.println("Recovery: " + ex.getMessage());
                return "Default result";
            });
        
        System.out.println("Final: " + future.join());
        
        /**
         * EXCEPTION IN CHAIN:
         * 
         * Step 1 succeeds → Step 2 fails
         * Step 2 throws → Step 3 skipped
         * exceptionally() called → Recovery
         * 
         * Chain short-circuits on exception
         * Skips remaining steps
         * Goes to exception handler
         */
    }
    
    /**
     * Multiple exception handlers
     */
    public static void multipleExceptionHandlers() {
        CompletableFuture<String> future = CompletableFuture
            .supplyAsync(() -> {
                throw new IllegalArgumentException("Invalid input");
            })
            .exceptionally(ex -> {
                // First handler
                System.out.println("Handler 1: " + ex.getMessage());
                
                // Can rethrow
                if (ex.getCause() instanceof IllegalArgumentException) {
                    throw new RuntimeException("Cannot recover", ex);
                }
                return "Recovered";
            })
            .exceptionally(ex -> {
                // Second handler (catches rethrow from first)
                System.out.println("Handler 2: " + ex.getMessage());
                return "Final fallback";
            });
        
        System.out.println("Result: " + future.join());
        
        /**
         * MULTIPLE HANDLERS:
         * 
         * - Can chain multiple exceptionally()
         * - Each can rethrow
         * - Next handler catches rethrow
         * - Like multiple catch blocks
         */
    }
    
    /**
     * Combining multiple futures
     */
    public static void combiningFutures() {
        CompletableFuture<String> future1 = CompletableFuture
            .supplyAsync(() -> "Result1");
        
        CompletableFuture<String> future2 = CompletableFuture
            .supplyAsync(() -> {
                throw new RuntimeException("Failed");
            });
        
        CompletableFuture<String> combined = future1
            .thenCombine(future2, (r1, r2) -> r1 + " + " + r2)
            .exceptionally(ex -> {
                System.err.println("Combined failed: " + ex.getMessage());
                return "Partial result";
            });
        
        System.out.println("Result: " + combined.join());
        
        /**
         * COMBINING WITH EXCEPTIONS:
         * 
         * If any future fails:
         * - Combination fails
         * - Exception propagates
         * - exceptionally() handles it
         */
    }
    
    /**
     * Custom exception types
     */
    static class DataNotFoundException extends RuntimeException {
        public DataNotFoundException(String message) {
            super(message);
        }
    }
    
    public static void customExceptionTypes() {
        CompletableFuture<String> future = CompletableFuture
            .supplyAsync(() -> {
                throw new DataNotFoundException("User not found");
            })
            .handle((result, ex) -> {
                if (ex != null) {
                    // Check exception type
                    Throwable cause = ex.getCause();
                    
                    if (cause instanceof DataNotFoundException) {
                        System.out.println("Not found, using default");
                        return "Default user";
                    } else {
                        System.err.println("Unexpected error");
                        throw new RuntimeException(ex);
                    }
                }
                return result;
            });
        
        System.out.println("Result: " + future.join());
        
        /**
         * EXCEPTION TYPE CHECKING:
         * 
         * - CompletionException wraps original
         * - Use getCause() to get original
         * - Check instanceof
         * - Handle different types differently
         */
    }
    
    /**
     * Timeout with exception handling
     */
    public static void timeoutHandling() {
        CompletableFuture<String> future = CompletableFuture
            .supplyAsync(() -> {
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                return "Result";
            })
            .orTimeout(1, TimeUnit.SECONDS)  // Java 9+
            .exceptionally(ex -> {
                if (ex instanceof TimeoutException) {
                    System.err.println("Operation timed out");
                    return "Timeout fallback";
                }
                throw new RuntimeException(ex);
            });
        
        System.out.println("Result: " + future.join());
        
        /**
         * TIMEOUT EXCEPTION:
         * 
         * - orTimeout() throws TimeoutException
         * - exceptionally() catches it
         * - Provide timeout fallback
         */
    }
    
    /**
     * Best practices
     */
    public static void bestPractices() {
        /**
         * COMPLETABLEFUTURE EXCEPTION BEST PRACTICES:
         * 
         * 1. ALWAYS HANDLE EXCEPTIONS:
         *    Use exceptionally() or handle()
         *    Don't let exceptions go unhandled
         * 
         * 2. LOG BEFORE RECOVERY:
         *    .whenComplete((r, ex) -> {
         *        if (ex != null) logger.error("Failed", ex);
         *    })
         *    .exceptionally(ex -> fallback)
         * 
         * 3. ADD CONTEXT:
         *    .exceptionally(ex -> {
         *        throw new RuntimeException("User processing failed: " + userId, ex);
         *    })
         * 
         * 4. CHOOSE RIGHT METHOD:
         *    - exceptionally(): Recovery only
         *    - handle(): Transform both cases
         *    - whenComplete(): Side effects only
         * 
         * 5. USE GETCAUSE():
         *    CompletionException wraps original
         *    ex.getCause() for original exception
         * 
         * 6. TIMEOUT HANDLING:
         *    Always use orTimeout() or completeOnTimeout()
         *    Prevent hanging futures
         * 
         * 7. AVOID BLOCKING:
         *    Don't use get() in async code
         *    Use join() or thenCompose()
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== exceptionally() ===");
        exceptionallyMethod();
        
        System.out.println("\n=== handle() ===");
        handleMethod();
        
        System.out.println("\n=== whenComplete() ===");
        whenCompleteMethod();
        
        System.out.println("\n=== Chaining ===");
        chainingWithExceptions();
    }
}
```

---

## 2. Stream Exception Handling

### Checked Exceptions in Streams

```java
/**
 * STREAM EXCEPTION HANDLING
 * 
 * Dealing with checked exceptions in streams
 */

import java.io.*;
import java.util.*;
import java.util.stream.*;

public class StreamExceptionHandling {
    
    /**
     * The checked exception problem
     */
    public static void checkedExceptionProblem() {
        List<String> files = Arrays.asList("file1.txt", "file2.txt");
        
        // ❌ This doesn't compile
        // files.stream()
        //     .map(file -> new FileReader(file))  // FileReader throws IOException
        //     .forEach(reader -> processReader(reader));
        
        /**
         * PROBLEM:
         * 
         * FileReader constructor throws IOException
         * But map() expects Function<T, R>
         * Function.apply() doesn't throw checked exceptions
         * 
         * Stream API doesn't support checked exceptions
         */
    }
    
    /**
     * Solution 1: Wrap in unchecked exception
     */
    public static void wrapInUnchecked() {
        List<String> files = Arrays.asList("file1.txt", "file2.txt");
        
        List<FileReader> readers = files.stream()
            .map(file -> {
                try {
                    return new FileReader(file);
                } catch (IOException e) {
                    // Wrap checked exception
                    throw new UncheckedIOException(e);
                }
            })
            .collect(Collectors.toList());
        
        /**
         * BENEFITS:
         * 
         * ✓ Compiles
         * ✓ Stream continues
         * ✓ Exception preserved
         * 
         * DRAWBACKS:
         * 
         * ❌ Converts to unchecked
         * ❌ Caller must catch UncheckedIOException
         * ❌ Lost compile-time checking
         */
    }
    
    /**
     * Solution 2: Wrapper functional interfaces
     */
    @FunctionalInterface
    interface ThrowingFunction<T, R, E extends Exception> {
        R apply(T t) throws E;
    }
    
    public static <T, R, E extends Exception> Function<T, R> unchecked(
            ThrowingFunction<T, R, E> function) {
        return t -> {
            try {
                return function.apply(t);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        };
    }
    
    public static void wrapperFunctions() {
        List<String> files = Arrays.asList("file1.txt", "file2.txt");
        
        // Use wrapper
        List<FileReader> readers = files.stream()
            .map(unchecked(file -> new FileReader(file)))
            .collect(Collectors.toList());
        
        /**
         * BENEFITS:
         * 
         * ✓ Reusable wrapper
         * ✓ Clean stream code
         * ✓ Type-safe
         * 
         * USAGE:
         * 
         * .map(unchecked(file -> new FileReader(file)))
         * .map(unchecked(reader -> reader.read()))
         */
    }
    
    /**
     * Solution 3: Try-catch in forEach
     */
    public static void tryCatchInForEach() {
        List<String> files = Arrays.asList("file1.txt", "file2.txt");
        
        files.forEach(file -> {
            try {
                FileReader reader = new FileReader(file);
                processReader(reader);
                reader.close();
            } catch (IOException e) {
                System.err.println("Error processing " + file + ": " + e.getMessage());
            }
        });
        
        /**
         * BENEFITS:
         * 
         * ✓ Handle exceptions per element
         * ✓ Continue processing on error
         * 
         * DRAWBACKS:
         * 
         * ❌ Verbose
         * ❌ Can't use with map/filter
         * ❌ Only works with forEach
         */
    }
    
    private static void processReader(FileReader reader) {}
    
    /**
     * Solution 4: Collect to Optional or Either
     */
    public static void collectToOptional() {
        List<String> files = Arrays.asList("file1.txt", "file2.txt", "file3.txt");
        
        List<Optional<FileReader>> readers = files.stream()
            .map(file -> {
                try {
                    return Optional.of(new FileReader(file));
                } catch (IOException e) {
                    System.err.println("Failed: " + file);
                    return Optional.<FileReader>empty();
                }
            })
            .collect(Collectors.toList());
        
        // Filter out failures
        List<FileReader> successful = readers.stream()
            .filter(Optional::isPresent)
            .map(Optional::get)
            .collect(Collectors.toList());
        
        System.out.println("Successful: " + successful.size());
        System.out.println("Failed: " + (readers.size() - successful.size()));
        
        /**
         * BENEFITS:
         * 
         * ✓ Distinguishes success/failure
         * ✓ Can collect both
         * ✓ Continue on errors
         * 
         * PATTERN:
         * 
         * - Map to Optional
         * - Empty on exception
         * - Filter present later
         */
    }
    
    /**
     * Solution 5: Partition successes and failures
     */
    static class Result<T> {
        private final T value;
        private final Exception error;
        
        private Result(T value, Exception error) {
            this.value = value;
            this.error = error;
        }
        
        public static <T> Result<T> success(T value) {
            return new Result<>(value, null);
        }
        
        public static <T> Result<T> failure(Exception error) {
            return new Result<>(null, error);
        }
        
        public boolean isSuccess() {
            return error == null;
        }
        
        public T getValue() {
            return value;
        }
        
        public Exception getError() {
            return error;
        }
    }
    
    public static void partitionResults() {
        List<String> files = Arrays.asList("file1.txt", "file2.txt", "file3.txt");
        
        List<Result<FileReader>> results = files.stream()
            .map(file -> {
                try {
                    return Result.success(new FileReader(file));
                } catch (IOException e) {
                    return Result.failure(e);
                }
            })
            .collect(Collectors.toList());
        
        // Partition
        Map<Boolean, List<Result<FileReader>>> partitioned = results.stream()
            .collect(Collectors.partitioningBy(Result::isSuccess));
        
        List<FileReader> successful = partitioned.get(true).stream()
            .map(Result::getValue)
            .collect(Collectors.toList());
        
        List<Exception> failures = partitioned.get(false).stream()
            .map(Result::getError)
            .collect(Collectors.toList());
        
        System.out.println("Successes: " + successful.size());
        System.out.println("Failures: " + failures.size());
        
        failures.forEach(e -> System.err.println("  " + e.getMessage()));
        
        /**
         * BENEFITS:
         * 
         * ✓ Track both successes and failures
         * ✓ Access error details
         * ✓ Report all errors
         * ✓ Continue processing
         */
    }
    
    /**
     * Solution 6: flatMap with Stream.empty()
     */
    public static void flatMapWithEmpty() {
        List<String> files = Arrays.asList("file1.txt", "file2.txt", "file3.txt");
        
        List<String> lines = files.stream()
            .flatMap(file -> {
                try {
                    return Files.lines(java.nio.file.Paths.get(file));
                } catch (IOException e) {
                    System.err.println("Skipping " + file + ": " + e.getMessage());
                    return Stream.empty();  // Skip this file
                }
            })
            .collect(Collectors.toList());
        
        /**
         * PATTERN:
         * 
         * - flatMap expects Stream<T>
         * - On error: return Stream.empty()
         * - Empty stream contributes nothing
         * - Effectively skips failed element
         * 
         * BENEFITS:
         * 
         * ✓ Continue on errors
         * ✓ Clean syntax
         * ✓ Works with flatMap
         */
    }
    
    /**
     * Parallel stream exception handling
     */
    public static void parallelStreamExceptions() {
        List<String> files = Arrays.asList("file1.txt", "file2.txt", "file3.txt");
        
        try {
            files.parallelStream()
                .map(file -> {
                    try {
                        return new FileReader(file);
                    } catch (IOException e) {
                        throw new UncheckedIOException(e);
                    }
                })
                .forEach(reader -> {});
                
        } catch (UncheckedIOException e) {
            System.err.println("At least one file failed: " + e.getMessage());
        }
        
        /**
         * PARALLEL STREAMS:
         * 
         * - Exception in any thread stops stream
         * - Only first exception thrown
         * - Other exceptions lost
         * 
         * RECOMMENDATION:
         * 
         * - Collect to Result/Optional
         * - Don't throw in parallel streams
         * - Or use sequential stream
         */
    }
    
    /**
     * Best practices
     */
    public static void bestPractices() {
        /**
         * STREAM EXCEPTION BEST PRACTICES:
         * 
         * 1. CHOOSE STRATEGY:
         *    - Fail fast → Wrap in unchecked
         *    - Continue on error → Optional/Result
         *    - Need error details → Result/Either
         * 
         * 2. WRAPPER FUNCTIONS:
         *    Create reusable unchecked() wrappers
         *    .map(unchecked(x -> throwingMethod(x)))
         * 
         * 3. OPTIONAL FOR NULLABILITY:
         *    .map(x -> tryParse(x).orElse(default))
         *    Treat errors as empty
         * 
         * 4. RESULT FOR ERROR TRACKING:
         *    .map(x -> Result.of(() -> risky(x)))
         *    Collect and report all errors
         * 
         * 5. PARALLEL STREAMS:
         *    Don't throw exceptions
         *    Use Optional/Result pattern
         * 
         * 6. LOGGING:
         *    .peek(x -> logger.debug("Processing: " + x))
         *    Log before risky operations
         * 
         * 7. TRY-CATCH PLACEMENT:
         *    Inside lambda: per-element handling
         *    Outside stream: fail-fast
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Wrap in Unchecked ===");
        try {
            wrapInUnchecked();
        } catch (UncheckedIOException e) {
            System.out.println("Caught: " + e.getCause());
        }
        
        System.out.println("\n=== Collect to Optional ===");
        collectToOptional();
        
        System.out.println("\n=== Partition Results ===");
        partitionResults();
    }
}
```

---

## 3. Optional Instead of Exceptions

### Using Optional for Error Handling

```java
/**
 * OPTIONAL INSTEAD OF EXCEPTIONS
 * 
 * Using Optional for nullable/missing values
 */

import java.util.*;

public class OptionalInsteadOfExceptions {
    
    /**
     * Traditional exception-based approach
     */
    static class UserRepository {
        private Map<String, String> users = new HashMap<>();
        
        public String findById(String id) throws UserNotFoundException {
            String user = users.get(id);
            if (user == null) {
                throw new UserNotFoundException("User not found: " + id);
            }
            return user;
        }
    }
    
    static class UserNotFoundException extends Exception {
        public UserNotFoundException(String message) {
            super(message);
        }
    }
    
    public static void traditionalExceptionApproach() {
        UserRepository repo = new UserRepository();
        
        try {
            String user = repo.findById("123");
            System.out.println("Found: " + user);
        } catch (UserNotFoundException e) {
            System.out.println("Not found, using guest");
            String user = "Guest";
        }
        
        /**
         * ISSUES:
         * 
         * - Exception for expected case (not found)
         * - Performance overhead
         * - Verbose try-catch
         * - Checked exception forces handling
         */
    }
    
    /**
     * Optional-based approach
     */
    static class UserRepositoryOptional {
        private Map<String, String> users = new HashMap<>();
        
        public Optional<String> findById(String id) {
            return Optional.ofNullable(users.get(id));
        }
    }
    
    public static void optionalApproach() {
        UserRepositoryOptional repo = new UserRepositoryOptional();
        
        // Option 1: orElse
        String user1 = repo.findById("123").orElse("Guest");
        
        // Option 2: orElseGet
        String user2 = repo.findById("123").orElseGet(() -> {
            System.out.println("User not found, creating guest");
            return "Guest";
        });
        
        // Option 3: ifPresentOrElse (Java 9+)
        repo.findById("123").ifPresentOrElse(
            user -> System.out.println("Found: " + user),
            () -> System.out.println("Not found")
        );
        
        // Option 4: map and orElse
        String email = repo.findById("123")
            .map(user -> user + "@example.com")
            .orElse("guest@example.com");
        
        /**
         * BENEFITS:
         * 
         * ✓ No exceptions
         * ✓ Cleaner code
         * ✓ Functional style
         * ✓ Explicit optionality
         */
    }
    
    /**
     * When to use Optional vs Exception
     */
    public static void whenToUseOptionalVsException() {
        /**
         * USE OPTIONAL WHEN:
         * 
         * ✓ Value might legitimately not exist
         * ✓ Not finding is expected/normal
         * ✓ Caller has reasonable default
         * 
         * Examples:
         * - findById() → might not exist
         * - getConfig() → might not be set
         * - findFirst() → list might be empty
         * 
         * 
         * USE EXCEPTION WHEN:
         * 
         * ✓ Absence is an error condition
         * ✓ Caller must handle it
         * ✓ Need to provide error context
         * 
         * Examples:
         * - loadRequiredConfig() → must exist
         * - getCurrentUser() → must be logged in
         * - getById() → ID should be valid
         * 
         * 
         * RULE OF THUMB:
         * 
         * Optional → "might not have"
         * Exception → "should have but doesn't"
         */
    }
    
    /**
     * Chaining Optionals
     */
    public static void chainingOptionals() {
        UserRepositoryOptional repo = new UserRepositoryOptional();
        
        Optional<String> result = repo.findById("123")
            .filter(user -> user.startsWith("A"))
            .map(String::toUpperCase)
            .or(() -> repo.findById("456"))  // Java 9+
            .map(user -> "User: " + user);
        
        result.ifPresent(System.out::println);
        
        /**
         * CHAINING:
         * 
         * - filter(): Narrow down
         * - map(): Transform
         * - or(): Alternative source
         * - flatMap(): Chain Optionals
         * 
         * Clean functional composition
         */
    }
    
    /**
     * Optional with validation
     */
    public static Optional<String> validateEmail(String email) {
        if (email == null || !email.contains("@")) {
            return Optional.empty();
        }
        return Optional.of(email);
    }
    
    public static void optionalValidation() {
        String input = "invalid";
        
        String email = validateEmail(input)
            .orElseThrow(() -> new IllegalArgumentException("Invalid email"));
        
        /**
         * OPTIONAL + EXCEPTION:
         * 
         * Optional for "might not be valid"
         * orElseThrow() when caller must handle
         * 
         * Best of both worlds
         */
    }
    
    /**
     * Optional in streams
     */
    public static void optionalInStreams() {
        List<String> ids = Arrays.asList("1", "2", "3", "4");
        UserRepositoryOptional repo = new UserRepositoryOptional();
        
        // Get all found users
        List<String> users = ids.stream()
            .map(repo::findById)
            .filter(Optional::isPresent)
            .map(Optional::get)
            .collect(java.util.stream.Collectors.toList());
        
        // Or with flatMap (Java 9+)
        List<String> users2 = ids.stream()
            .map(repo::findById)
            .flatMap(Optional::stream)  // Java 9+
            .collect(java.util.stream.Collectors.toList());
        
        /**
         * OPTIONAL IN STREAMS:
         * 
         * - Map returns Optional
         * - Filter present
         * - Map get (or flatMap stream)
         * - Collect successes
         * 
         * Clean handling of partial results
         */
    }
    
    /**
     * Anti-patterns with Optional
     */
    public static void optionalAntiPatterns() {
        /**
         * ❌ DON'T:
         */
        
        // 1. Optional.get() without isPresent()
        Optional<String> opt = Optional.empty();
        // String value = opt.get();  // NoSuchElementException
        
        // 2. isPresent() + get()
        if (opt.isPresent()) {
            String value = opt.get();  // Use ifPresent() instead
        }
        
        // 3. Optional as field
        // class User {
        //     private Optional<String> email;  // ❌ Wrong
        // }
        
        // 4. Optional parameter
        // public void setEmail(Optional<String> email) {  // ❌ Wrong
        // }
        
        // 5. orElse() with expensive operation
        // String value = opt.orElse(expensiveComputation());  // Always called
        // Use orElseGet(() -> expensiveComputation())
        
        /**
         * ✓ DO:
         */
        
        // 1. orElse() for default
        String value1 = opt.orElse("default");
        
        // 2. orElseGet() for lazy default
        String value2 = opt.orElseGet(() -> "default");
        
        // 3. ifPresent() for side effects
        opt.ifPresent(v -> System.out.println(v));
        
        // 4. map() for transformation
        Optional<Integer> length = opt.map(String::length);
        
        // 5. Return Optional, not use as field
        // public Optional<String> getEmail() { ... }
    }
    
    /**
     * Best practices
     */
    public static void bestPractices() {
        /**
         * OPTIONAL BEST PRACTICES:
         * 
         * 1. RETURN OPTIONAL:
         *    Use as return type
         *    Not as parameter or field
         * 
         * 2. NEVER NULL:
         *    Never return null instead of Optional
         *    Use Optional.empty()
         * 
         * 3. AVOID GET():
         *    Use orElse/orElseGet/ifPresent
         *    get() can throw
         * 
         * 4. LAZY DEFAULTS:
         *    orElseGet() for expensive defaults
         *    orElse() for simple values
         * 
         * 5. FUNCTIONAL STYLE:
         *    Use map/filter/flatMap
         *    Not isPresent() + get()
         * 
         * 6. DON'T OVERUSE:
         *    For truly optional values only
         *    Not for every nullable
         * 
         * 7. COMBINE WITH EXCEPTIONS:
         *    Optional for "might not exist"
         *    orElseThrow() when must exist
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Traditional Exception ===");
        traditionalExceptionApproach();
        
        System.out.println("\n=== Optional Approach ===");
        optionalApproach();
        
        System.out.println("\n=== Chaining ===");
        chainingOptionals();
    }
}
```

---

## 4. Either/Try Monads (Vavr)

### Functional Error Handling with Vavr

```java
/**
 * EITHER/TRY MONADS (VAVR)
 * 
 * Using Vavr for functional error handling
 * 
 * Add dependency:
 * <dependency>
 *     <groupId>io.vavr</groupId>
 *     <artifactId>vavr</artifactId>
 *     <version>0.10.4</version>
 * </dependency>
 */

import io.vavr.control.*;
import java.io.*;

public class EitherTryMonads {
    
    /**
     * Try monad - wraps exceptions
     */
    public static void tryMonad() {
        // Traditional try-catch
        String content1;
        try {
            content1 = readFile("data.txt");
        } catch (IOException e) {
            content1 = "default";
        }
        
        // Vavr Try
        String content2 = Try.of(() -> readFile("data.txt"))
            .getOrElse("default");
        
        /**
         * TRY MONAD:
         * 
         * Wraps operation that might throw
         * Returns Try<T>
         * Success or Failure
         * Functional exception handling
         */
    }
    
    private static String readFile(String path) throws IOException {
        throw new FileNotFoundException(path);
    }
    
    /**
     * Try methods
     */
    public static void tryMethods() {
        Try<String> result = Try.of(() -> readFile("data.txt"));
        
        // Check success/failure
        if (result.isSuccess()) {
            System.out.println("Success: " + result.get());
        } else {
            System.out.println("Failure: " + result.getCause());
        }
        
        // Get with default
        String value1 = result.getOrElse("default");
        
        // Get with supplier
        String value2 = result.getOrElse(() -> "computed default");
        
        // Recover from failure
        String value3 = result.recover(ex -> "recovered").get();
        
        // Map on success
        Try<Integer> length = result.map(String::length);
        
        // FlatMap for chaining
        Try<String> upper = result.flatMap(s -> 
            Try.of(() -> s.toUpperCase()));
        
        // Filter
        Try<String> filtered = result.filter(s -> s.length() > 0);
        
        // OrElse
        Try<String> alternative = result.orElse(() -> 
            Try.of(() -> readFile("backup.txt")));
        
        /**
         * TRY IS A MONAD:
         * 
         * - map: Transform success value
         * - flatMap: Chain Try operations
         * - filter: Add validation
         * - recover: Handle failure
         * - getOrElse: Extract with default
         */
    }
    
    /**
     * Try in streams
     */
    public static void tryInStreams() {
        java.util.List<String> files = java.util.Arrays.asList(
            "file1.txt", "file2.txt", "file3.txt");
        
        // Map to Try
        java.util.List<Try<String>> results = files.stream()
            .map(file -> Try.of(() -> readFile(file)))
            .collect(java.util.stream.Collectors.toList());
        
        // Separate successes and failures
        java.util.List<String> successes = results.stream()
            .filter(Try::isSuccess)
            .map(Try::get)
            .collect(java.util.stream.Collectors.toList());
        
        java.util.List<Throwable> failures = results.stream()
            .filter(Try::isFailure)
            .map(Try::getCause)
            .collect(java.util.stream.Collectors.toList());
        
        System.out.println("Successes: " + successes.size());
        System.out.println("Failures: " + failures.size());
        
        /**
         * TRY IN STREAMS:
         * 
         * - Map operations to Try
         * - Filter successes/failures
         * - Extract values or errors
         * - Continue processing
         */
    }
    
    /**
     * Either monad - success or failure with values
     */
    public static void eitherMonad() {
        // Either<Left, Right>
        // Left = error type
        // Right = success type
        
        Either<String, Integer> result1 = parseNumber("42");
        // Right(42)
        
        Either<String, Integer> result2 = parseNumber("abc");
        // Left("Invalid number: abc")
        
        /**
         * EITHER:
         * 
         * Left: Error value (not Throwable)
         * Right: Success value
         * 
         * More general than Try
         * Error can be any type
         */
    }
    
    private static Either<String, Integer> parseNumber(String str) {
        try {
            return Either.right(Integer.parseInt(str));
        } catch (NumberFormatException e) {
            return Either.left("Invalid number: " + str);
        }
    }
    
    /**
     * Either methods
     */
    public static void eitherMethods() {
        Either<String, Integer> result = parseNumber("42");
        
        // Check left/right
        if (result.isRight()) {
            System.out.println("Success: " + result.get());
        } else {
            System.out.println("Error: " + result.getLeft());
        }
        
        // Get with default
        Integer value1 = result.getOrElse(0);
        
        // Map right side
        Either<String, Integer> doubled = result.map(n -> n * 2);
        
        // Map left side
        Either<Integer, Integer> errorCode = result.mapLeft(String::length);
        
        // FlatMap
        Either<String, Integer> incremented = result.flatMap(n ->
            Either.right(n + 1));
        
        // Fold: handle both cases
        String message = result.fold(
            error -> "Error: " + error,
            value -> "Success: " + value
        );
        
        /**
         * EITHER METHODS:
         * 
         * - map: Transform right value
         * - mapLeft: Transform left value
         * - flatMap: Chain Either operations
         * - fold: Handle both cases
         * - getOrElse: Extract with default
         */
    }
    
    /**
     * Either for validation
     */
    static class ValidationError {
        private final String field;
        private final String message;
        
        ValidationError(String field, String message) {
            this.field = field;
            this.message = message;
        }
        
        @Override
        public String toString() {
            return field + ": " + message;
        }
    }
    
    private static Either<ValidationError, String> validateEmail(String email) {
        if (email == null || email.isEmpty()) {
            return Either.left(new ValidationError("email", "Email is required"));
        }
        if (!email.contains("@")) {
            return Either.left(new ValidationError("email", "Invalid email format"));
        }
        return Either.right(email);
    }
    
    public static void eitherValidation() {
        Either<ValidationError, String> result = validateEmail("invalid");
        
        String message = result.fold(
            error -> "Validation failed: " + error,
            email -> "Valid email: " + email
        );
        
        System.out.println(message);
        
        /**
         * EITHER FOR VALIDATION:
         * 
         * Left: Validation error
         * Right: Valid value
         * 
         * Type-safe error handling
         * Error value carries context
         */
    }
    
    /**
     * Accumulating validation errors
     */
    public static void accumulatingValidation() {
        // Vavr Validation allows accumulating errors
        
        io.vavr.collection.Seq<String> errors = 
            io.vavr.collection.List.empty();
        
        String email = "invalid";
        if (email == null || email.isEmpty()) {
            errors = errors.append("Email is required");
        }
        if (email != null && !email.contains("@")) {
            errors = errors.append("Email must contain @");
        }
        
        if (!errors.isEmpty()) {
            System.out.println("Validation errors: " + errors);
        }
        
        /**
         * VALIDATION:
         * 
         * Collect all errors
         * Not just first error
         * Better UX
         */
    }
    
    /**
     * Try vs Either comparison
     */
    public static void tryVsEither() {
        /**
         * TRY:
         * 
         * Try<T>
         * Success(value) or Failure(throwable)
         * Wraps exceptions
         * Use when: operation throws exceptions
         * 
         * Example:
         * Try.of(() -> readFile("data.txt"))
         * 
         * 
         * EITHER:
         * 
         * Either<L, R>
         * Left(error) or Right(value)
         * Error can be any type
         * Use when: want typed errors
         * 
         * Example:
         * Either<String, User> result = findUser(id);
         * 
         * 
         * CHOOSE:
         * 
         * Try: Wrapping exception-throwing code
         * Either: Domain errors, validation, typed errors
         */
    }
    
    /**
     * Best practices
     */
    public static void bestPractices() {
        /**
         * VAVR BEST PRACTICES:
         * 
         * 1. USE TRY FOR EXCEPTIONS:
         *    Try.of(() -> throwingOperation())
         *    Cleaner than try-catch
         * 
         * 2. USE EITHER FOR DOMAIN ERRORS:
         *    Either<ValidationError, User>
         *    Type-safe error handling
         * 
         * 3. CHAIN WITH FLATMAP:
         *    Try.of(() -> step1())
         *       .flatMap(r1 -> step2(r1))
         *       .flatMap(r2 -> step3(r2))
         * 
         * 4. FOLD FOR HANDLING:
         *    result.fold(
         *        error -> handleError(error),
         *        value -> handleSuccess(value)
         *    )
         * 
         * 5. COLLECT ERRORS:
         *    Use Validation for accumulating
         *    Better than Either for forms
         * 
         * 6. DON'T MIX:
         *    Don't throw in Try/Either code
         *    Stay in functional world
         * 
         * 7. CONVERT AT BOUNDARIES:
         *    External APIs → Try
         *    Internal domain → Either
         *    Presentation → exceptions/status codes
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Try Monad ===");
        tryMonad();
        
        System.out.println("\n=== Either Monad ===");
        eitherMonad();
        
        System.out.println("\n=== Either Validation ===");
        eitherValidation();
    }
}
```

---

## 5. Checked Exceptions in Lambdas

### The Lambda Exception Problem

```java
/**
 * CHECKED EXCEPTIONS IN LAMBDAS
 * 
 * Dealing with checked exceptions in lambda expressions
 */

import java.io.*;
import java.util.*;
import java.util.function.*;

public class CheckedExceptionsInLambdas {
    
    /**
     * The problem
     */
    public static void theProblem() {
        List<String> files = Arrays.asList("file1.txt", "file2.txt");
        
        // ❌ Doesn't compile
        // files.forEach(file -> {
        //     FileReader reader = new FileReader(file);  // Checked exception
        // });
        
        /**
         * PROBLEM:
         * 
         * Consumer.accept() doesn't throw checked exceptions
         * 
         * @FunctionalInterface
         * public interface Consumer<T> {
         *     void accept(T t);  // No throws clause
         * }
         * 
         * But FileReader() throws IOException
         * Lambda can't throw checked exception
         */
    }
    
    /**
     * Solution 1: Try-catch inside lambda
     */
    public static void tryCatchInsideLambda() {
        List<String> files = Arrays.asList("file1.txt", "file2.txt");
        
        files.forEach(file -> {
            try {
                FileReader reader = new FileReader(file);
                // Process reader
                reader.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        });
        
        /**
         * BENEFITS:
         * 
         * ✓ Compiles
         * ✓ Exception converted to unchecked
         * 
         * DRAWBACKS:
         * 
         * ❌ Verbose
         * ❌ Repeated for each lambda
         * ❌ Lost checked exception
         */
    }
    
    /**
     * Solution 2: Wrapper function
     */
    @FunctionalInterface
    interface ThrowingConsumer<T, E extends Exception> {
        void accept(T t) throws E;
    }
    
    public static <T> Consumer<T> unchecked(ThrowingConsumer<T, Exception> consumer) {
        return t -> {
            try {
                consumer.accept(t);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        };
    }
    
    public static void wrapperFunction() {
        List<String> files = Arrays.asList("file1.txt", "file2.txt");
        
        files.forEach(unchecked(file -> {
            FileReader reader = new FileReader(file);
            reader.close();
        }));
        
        /**
         * BENEFITS:
         * 
         * ✓ Clean lambda code
         * ✓ Reusable wrapper
         * ✓ Type-safe
         * 
         * USAGE:
         * 
         * .forEach(unchecked(x -> throwingMethod(x)))
         * .map(unchecked(x -> throwingFunction(x)))
         */
    }
    
    /**
     * Generic wrapper functions
     */
    @FunctionalInterface
    interface ThrowingFunction<T, R, E extends Exception> {
        R apply(T t) throws E;
    }
    
    @FunctionalInterface
    interface ThrowingSupplier<T, E extends Exception> {
        T get() throws E;
    }
    
    public static <T, R> Function<T, R> uncheckedFunction(
            ThrowingFunction<T, R, Exception> function) {
        return t -> {
            try {
                return function.apply(t);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        };
    }
    
    public static <T> Supplier<T> uncheckedSupplier(
            ThrowingSupplier<T, Exception> supplier) {
        return () -> {
            try {
                return supplier.get();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        };
    }
    
    public static void genericWrappers() {
        List<String> files = Arrays.asList("file1.txt", "file2.txt");
        
        // Consumer wrapper
        files.forEach(unchecked(file -> 
            new FileReader(file).close()));
        
        // Function wrapper
        List<FileReader> readers = files.stream()
            .map(uncheckedFunction(file -> new FileReader(file)))
            .collect(java.util.stream.Collectors.toList());
        
        // Supplier wrapper
        Supplier<FileReader> supplier = uncheckedSupplier(() ->
            new FileReader("data.txt"));
        
        /**
         * COMPLETE WRAPPER SET:
         * 
         * - unchecked(ThrowingConsumer)
         * - uncheckedFunction(ThrowingFunction)
         * - uncheckedSupplier(ThrowingSupplier)
         * - uncheckedPredicate(ThrowingPredicate)
         * 
         * Covers all functional interfaces
         */
    }
    
    /**
     * Solution 3: Extract method
     */
    public static void extractMethod() {
        List<String> files = Arrays.asList("file1.txt", "file2.txt");
        
        files.forEach(CheckedExceptionsInLambdas::processFile);
    }
    
    private static void processFile(String file) {
        try {
            FileReader reader = new FileReader(file);
            reader.close();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }
    
    /**
     * Solution 4: Vavr Try
     */
    public static void vavrTry() {
        List<String> files = Arrays.asList("file1.txt", "file2.txt");
        
        files.forEach(file -> {
            io.vavr.control.Try.of(() -> new FileReader(file))
                .onSuccess(reader -> System.out.println("Opened: " + file))
                .onFailure(ex -> System.err.println("Failed: " + file));
        });
        
        /**
         * VAVR TRY:
         * 
         * Wraps checked exception
         * Functional error handling
         * No try-catch needed
         */
    }
    
    /**
     * Rethrowing with context
     */
    public static <T> Consumer<T> uncheckedWithContext(
            ThrowingConsumer<T, Exception> consumer,
            Function<T, String> contextProvider) {
        return t -> {
            try {
                consumer.accept(t);
            } catch (Exception e) {
                String context = contextProvider.apply(t);
                throw new RuntimeException("Error processing: " + context, e);
            }
        };
    }
    
    public static void rethrowingWithContext() {
        List<String> files = Arrays.asList("file1.txt", "file2.txt");
        
        files.forEach(uncheckedWithContext(
            file -> new FileReader(file).close(),
            file -> "file: " + file
        ));
        
        /**
         * ENHANCED WRAPPER:
         * 
         * Adds context to exception
         * Shows what was being processed
         * Better error messages
         */
    }
    
    /**
     * Logging exceptions
     */
    public static <T> Consumer<T> uncheckedWithLogging(
            ThrowingConsumer<T, Exception> consumer) {
        return t -> {
            try {
                consumer.accept(t);
            } catch (Exception e) {
                System.err.println("Error processing " + t + ": " + e.getMessage());
                throw new RuntimeException(e);
            }
        };
    }
    
    /**
     * CompletableFuture with checked exceptions
     */
    public static void completableFutureWithChecked() {
        java.util.concurrent.CompletableFuture<String> future = 
            java.util.concurrent.CompletableFuture.supplyAsync(
                uncheckedSupplier(() -> readFile("data.txt"))
            );
        
        future.thenAccept(content -> System.out.println("Content: " + content))
              .exceptionally(ex -> {
                  System.err.println("Failed: " + ex.getMessage());
                  return null;
              });
    }
    
    private static String readFile(String path) throws IOException {
        throw new FileNotFoundException(path);
    }
    
    /**
     * Best practices
     */
    public static void bestPractices() {
        /**
         * CHECKED EXCEPTIONS IN LAMBDAS BEST PRACTICES:
         * 
         * 1. CREATE WRAPPER FUNCTIONS:
         *    Define once, use everywhere
         *    unchecked(), uncheckedFunction(), etc.
         * 
         * 2. ADD CONTEXT:
         *    Enhance wrappers with context
         *    Include what was being processed
         * 
         * 3. LOG BEFORE RETHROWING:
         *    Wrapper can log exception
         *    Then rethrow as unchecked
         * 
         * 4. CHOOSE STRATEGY:
         *    Simple: Try-catch in lambda
         *    Reusable: Wrapper functions
         *    Functional: Vavr Try
         *    Clean: Extract method
         * 
         * 5. TYPE SAFETY:
         *    Use generic wrappers
         *    Preserve type information
         * 
         * 6. DOCUMENT WRAPPER:
         *    Explain what exceptions become
         *    Document as @throws RuntimeException
         * 
         * 7. CONSISTENT APPROACH:
         *    Pick one strategy
         *    Use throughout codebase
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Try-Catch Inside Lambda ===");
        tryCatchInsideLambda();
        
        System.out.println("\n=== Wrapper Function ===");
        wrapperFunction();
        
        System.out.println("\n=== Extract Method ===");
        extractMethod();
    }
}
```

---

## 6. Sneaky Throws Pattern

### Type Erasure Exception Trick

```java
/**
 * SNEAKY THROWS PATTERN
 * 
 * Using generics to throw checked exceptions as unchecked
 */

public class SneakyThrowsPattern {
    
    /**
     * The sneaky throw technique
     */
    @SuppressWarnings("unchecked")
    private static <E extends Throwable> void sneakyThrow(Throwable e) throws E {
        throw (E) e;
    }
    
    public static void sneakyThrowExample() {
        // This method doesn't declare throws IOException
        // But it actually throws it!
        
        sneakyThrow(new java.io.IOException("Sneaky!"));
        
        /**
         * HOW IT WORKS:
         * 
         * 1. Generic method <E extends Throwable>
         * 2. Type erasure removes generic at runtime
         * 3. Cast to E (erased to Throwable)
         * 4. Compiler thinks it's unchecked
         * 5. Runtime actually throws checked exception
         * 
         * TRICK:
         * 
         * Compiler sees: throws E (RuntimeException)
         * Runtime sees: throws Throwable (IOException)
         * Type erasure makes it work
         */
    }
    
    /**
     * Wrapper using sneaky throw
     */
    @FunctionalInterface
    interface ThrowingRunnable<E extends Exception> {
        void run() throws E;
    }
    
    @FunctionalInterface
    interface ThrowingFunction<T, R, E extends Exception> {
        R apply(T t) throws E;
    }
    
    public static void sneakyRun(ThrowingRunnable<?> runnable) {
        try {
            runnable.run();
        } catch (Exception e) {
            sneakyThrow(e);
        }
    }
    
    public static <T, R> java.util.function.Function<T, R> sneaky(
            ThrowingFunction<T, R, ?> function) {
        return t -> {
            try {
                return function.apply(t);
            } catch (Exception e) {
                sneakyThrow(e);
                return null;  // Never reached
            }
        };
    }
    
    public static void sneakyWrappers() {
        // Use in lambda without try-catch
        java.util.Arrays.asList("file1.txt", "file2.txt")
            .forEach(file -> sneakyRun(() -> 
                new java.io.FileReader(file).close()));
        
        // Use in stream
        java.util.List<java.io.FileReader> readers = 
            java.util.Arrays.asList("file1.txt", "file2.txt")
            .stream()
            .map(sneaky(file -> new java.io.FileReader(file)))
            .collect(java.util.stream.Collectors.toList());
        
        /**
         * SNEAKY WRAPPERS:
         * 
         * Lambda doesn't declare throws
         * But checked exception thrown
         * Bypasses compiler check
         */
    }
    
    /**
     * Lombok @SneakyThrows
     */
    public static void lombokSneakyThrows() {
        /**
         * LOMBOK PROVIDES:
         * 
         * @SneakyThrows
         * public void readFile(String path) {
         *     FileReader reader = new FileReader(path);
         *     // No try-catch needed
         * }
         * 
         * 
         * GENERATES:
         * 
         * public void readFile(String path) {
         *     try {
         *         FileReader reader = new FileReader(path);
         *     } catch (Throwable $ex) {
         *         throw Lombok.sneakyThrow($ex);
         *     }
         * }
         * 
         * 
         * Same technique
         * Annotation-based
         */
    }
    
    /**
     * Dangers of sneaky throws
     */
    public static void dangersOfSneakyThrows() {
        /**
         * DANGERS:
         * 
         * 1. LOST COMPILE-TIME CHECKING:
         *    Checked exceptions exist for a reason
         *    Compiler no longer enforces handling
         *    Easy to miss errors
         * 
         * 2. SURPRISING BEHAVIOR:
         *    Method signature says no throws
         *    But actually throws checked exception
         *    Violates principle of least surprise
         * 
         * 3. CALLER CONFUSION:
         *    public void process() {  // No throws
         *        sneakyThrow(new IOException());
         *    }
         *    
         *    Caller sees:
         *    void process();  // Looks safe
         *    
         *    But actually throws IOException
         *    Caller not prepared
         * 
         * 4. DEBUGGING HARDER:
         *    Stack trace shows unchecked throw
         *    But exception is checked
         *    Confusing
         * 
         * 5. BREAKS CONTRACTS:
         *    Interface says: void method();
         *    Implementation throws: IOException
         *    Violates interface contract
         */
    }
    
    /**
     * When sneaky throws might be acceptable
     */
    public static void whenAcceptable() {
        /**
         * ACCEPTABLE CASES:
         * 
         * 1. LAMBDA WRAPPERS:
         *    Internal implementation detail
         *    Not exposed to callers
         *    Exception documented
         * 
         * 2. IMPOSSIBLE EXCEPTIONS:
         *    Checked exception that can't happen
         *    ByteArrayOutputStream never throws
         *    But signature requires handling
         * 
         * 3. FRAMEWORK CODE:
         *    Constraint by interface
         *    Must handle checked exception
         *    No way to declare throws
         * 
         * 
         * RULES:
         * 
         * ✓ Document thoroughly
         * ✓ Use sparingly
         * ✓ Consider alternatives first
         * ✓ Understand implications
         */
    }
    
    /**
     * Alternatives to sneaky throws
     */
    public static void alternatives() {
        /**
         * INSTEAD OF SNEAKY THROWS:
         * 
         * 1. UNCHECKED WRAPPER:
         *    throw new UncheckedIOException(ioException);
         *    Explicit conversion
         *    Clear intent
         * 
         * 2. TRY MONAD (VAVR):
         *    Try.of(() -> throwingOperation())
         *    Functional error handling
         *    Type-safe
         * 
         * 3. OPTIONAL:
         *    return Optional.empty();
         *    For "might not exist" cases
         *    No exception
         * 
         * 4. EXTRACT METHOD:
         *    Move try-catch to separate method
         *    Clear exception handling
         *    Testable
         * 
         * 5. CUSTOM FUNCTIONAL INTERFACE:
         *    @FunctionalInterface
         *    interface ThrowingConsumer<T> {
         *        void accept(T t) throws Exception;
         *    }
         *    
         *    Explicit about exceptions
         */
    }
    
    /**
     * Best practices
     */
    public static void bestPractices() {
        /**
         * SNEAKY THROWS BEST PRACTICES:
         * 
         * ❌ DON'T USE:
         * - In public APIs
         * - When callers need to handle
         * - Just to avoid try-catch
         * - Without documentation
         * 
         * ✓ CONSIDER:
         * - For internal utilities
         * - When exception truly impossible
         * - Framework constraints
         * - Lambda wrappers (private)
         * 
         * ✓ PREFER:
         * - UncheckedIOException
         * - Try monad (Vavr)
         * - Optional
         * - Proper exception handling
         * 
         * 
         * RECOMMENDATION:
         * 
         * Avoid sneaky throws
         * Use proper exception handling
         * Explicit is better than implicit
         * 
         * If you must use:
         * - Document extensively
         * - Keep private
         * - Consider alternatives first
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Sneaky Throw Example ===");
        try {
            sneakyThrowExample();
        } catch (Exception e) {
            System.out.println("Caught checked exception without declaration: " + 
                e.getClass().getSimpleName());
        }
    }
}
```

---

## 7. Best Practices for Async Errors

### Complete Async Error Handling Guide

```java
/**
 * BEST PRACTICES FOR ASYNC ERRORS
 * 
 * Comprehensive async error handling patterns
 */

import java.util.concurrent.*;
import java.util.*;

public class AsyncErrorBestPractices {
    
    /**
     * 1. Always handle CompletableFuture exceptions
     */
    public static void alwaysHandleExceptions() {
        // ❌ BAD: Unhandled exception
        CompletableFuture<String> bad = CompletableFuture.supplyAsync(() -> {
            if (true) throw new RuntimeException("Error");
            return "Result";
        });
        // Exception silently swallowed!
        
        // ✓ GOOD: Handle exceptions
        CompletableFuture<String> good = CompletableFuture
            .supplyAsync(() -> {
                if (true) throw new RuntimeException("Error");
                return "Result";
            })
            .exceptionally(ex -> {
                System.err.println("Error: " + ex.getMessage());
                return "Fallback";
            });
        
        /**
         * RULE:
         * 
         * Always add exception handler
         * exceptionally() or handle()
         * Never leave futures unhandled
         */
    }
    
    /**
     * 2. Log before recovering
     */
    public static void logBeforeRecovering() {
        CompletableFuture<String> future = CompletableFuture
            .supplyAsync(() -> {
                throw new RuntimeException("Operation failed");
            })
            .whenComplete((result, ex) -> {
                // Log (doesn't change result)
                if (ex != null) {
                    System.err.println("Operation failed:");
                    ex.printStackTrace();
                }
            })
            .exceptionally(ex -> {
                // Recover
                return "Fallback";
            });
        
        /**
         * PATTERN:
         * 
         * 1. whenComplete: Log exception
         * 2. exceptionally: Provide fallback
         * 
         * Ensures errors logged
         * Even if recovered
         */
    }
    
    /**
     * 3. Add context to async exceptions
     */
    public static void addContextToAsyncExceptions() {
        String userId = "USER123";
        
        CompletableFuture<String> future = CompletableFuture
            .supplyAsync(() -> {
                throw new RuntimeException("Database error");
            })
            .handle((result, ex) -> {
                if (ex != null) {
                    // Add context
                    throw new CompletionException(
                        "Failed to process user: " + userId, ex);
                }
                return result;
            });
        
        /**
         * CONTEXT IN ASYNC:
         * 
         * Capture variables before async
         * Include in exception message
         * Aids debugging
         */
    }
    
    /**
     * 4. Timeout handling
     */
    public static void timeoutHandling() {
        CompletableFuture<String> future = CompletableFuture
            .supplyAsync(() -> {
                try {
                    Thread.sleep(10000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                return "Result";
            })
            .orTimeout(1, TimeUnit.SECONDS)  // Java 9+
            .exceptionally(ex -> {
                if (ex instanceof TimeoutException) {
                    System.err.println("Operation timed out");
                    return "Timeout fallback";
                }
                throw new CompletionException(ex);
            });
        
        /**
         * TIMEOUT PATTERN:
         * 
         * 1. orTimeout() for deadline
         * 2. exceptionally() to handle timeout
         * 3. Provide timeout-specific fallback
         * 
         * Prevents hanging operations
         */
    }
    
    /**
     * 5. Combine multiple futures safely
     */
    public static void combineSafely() {
        CompletableFuture<String> future1 = fetchUser();
        CompletableFuture<String> future2 = fetchOrders();
        CompletableFuture<String> future3 = fetchPreferences();
        
        CompletableFuture<String> combined = CompletableFuture
            .allOf(future1, future2, future3)
            .thenApply(v -> {
                try {
                    String user = future1.join();
                    String orders = future2.join();
                    String prefs = future3.join();
                    return user + ", " + orders + ", " + prefs;
                } catch (CompletionException e) {
                    throw new RuntimeException("Failed to fetch data", e);
                }
            })
            .exceptionally(ex -> {
                System.err.println("Combined operation failed: " + ex.getMessage());
                return "Partial data available";
            });
        
        /**
         * COMBINING PATTERN:
         * 
         * 1. allOf() waits for all
         * 2. Handle individual exceptions
         * 3. Overall exception handler
         * 
         * If any fails, overall fails
         */
    }
    
    private static CompletableFuture<String> fetchUser() {
        return CompletableFuture.completedFuture("User");
    }
    
    private static CompletableFuture<String> fetchOrders() {
        return CompletableFuture.completedFuture("Orders");
    }
    
    private static CompletableFuture<String> fetchPreferences() {
        return CompletableFuture.completedFuture("Prefs");
    }
    
    /**
     * 6. Graceful degradation
     */
    public static void gracefulDegradation() {
        CompletableFuture<String> primary = CompletableFuture
            .supplyAsync(() -> {
                throw new RuntimeException("Primary failed");
            });
        
        CompletableFuture<String> fallback = primary
            .exceptionally(ex -> {
                System.out.println("Primary failed, trying fallback");
                return loadFromCache();
            })
            .exceptionally(ex -> {
                System.out.println("Fallback failed, using default");
                return "Default value";
            });
        
        /**
         * GRACEFUL DEGRADATION:
         * 
         * 1. Try primary source
         * 2. Fall back to cache
         * 3. Fall back to default
         * 
         * Multiple levels of fallback
         * System remains available
         */
    }
    
    private static String loadFromCache() {
        return "Cached value";
    }
    
    /**
     * 7. Stream exception patterns
     */
    public static void streamExceptionPatterns() {
        List<String> items = Arrays.asList("1", "2", "abc", "4");
        
        // Pattern: Collect successes, report failures
        List<Integer> results = new ArrayList<>();
        List<String> failures = new ArrayList<>();
        
        items.forEach(item -> {
            try {
                results.add(Integer.parseInt(item));
            } catch (NumberFormatException e) {
                failures.add(item);
            }
        });
        
        if (!failures.isEmpty()) {
            System.err.println("Failed to parse: " + failures);
        }
        
        System.out.println("Parsed: " + results);
        
        /**
         * STREAM PATTERN:
         * 
         * Don't throw in stream
         * Collect successes and failures
         * Report after stream completes
         */
    }
    
    /**
     * 8. Parallel stream safety
     */
    public static void parallelStreamSafety() {
        List<String> items = Arrays.asList("1", "2", "3", "4");
        
        // ❌ BAD: Exception in parallel stream
        // items.parallelStream()
        //     .map(item -> {
        //         if (item.equals("2")) {
        //             throw new RuntimeException("Error");
        //         }
        //         return Integer.parseInt(item);
        //     })
        //     .collect(Collectors.toList());
        
        // ✓ GOOD: Collect to Optional
        List<Optional<Integer>> results = items.parallelStream()
            .map(item -> {
                try {
                    return Optional.of(Integer.parseInt(item));
                } catch (Exception e) {
                    System.err.println("Failed: " + item);
                    return Optional.<Integer>empty();
                }
            })
            .collect(java.util.stream.Collectors.toList());
        
        /**
         * PARALLEL STREAM SAFETY:
         * 
         * Don't throw exceptions
         * Collect to Optional/Result
         * All threads complete
         * All errors reported
         */
    }
    
    /**
     * 9. ExecutorService exception handling
     */
    public static void executorServiceExceptions() {
        ExecutorService executor = Executors.newFixedThreadPool(2);
        
        try {
            Future<String> future = executor.submit(() -> {
                throw new RuntimeException("Task failed");
                // return "Result";
            });
            
            try {
                String result = future.get();
                System.out.println("Result: " + result);
            } catch (ExecutionException e) {
                // Wrapped exception
                Throwable cause = e.getCause();
                System.err.println("Task failed: " + cause.getMessage());
            }
            
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            System.err.println("Interrupted");
        } finally {
            executor.shutdown();
        }
        
        /**
         * EXECUTOR PATTERN:
         * 
         * 1. ExecutionException wraps task exception
         * 2. Get cause for original exception
         * 3. Handle InterruptedException
         * 4. Always shutdown executor
         */
    }
    
    /**
     * Complete example
     */
    public static void completeExample() {
        String orderId = "ORDER123";
        
        CompletableFuture<String> result = CompletableFuture
            // Step 1: Validate
            .supplyAsync(() -> {
                System.out.println("Validating order: " + orderId);
                if (orderId == null) {
                    throw new IllegalArgumentException("Order ID required");
                }
                return orderId;
            })
            // Step 2: Process
            .thenApplyAsync(id -> {
                System.out.println("Processing order: " + id);
                // Simulate processing
                return "Processed: " + id;
            })
            // Step 3: Log completion
            .whenComplete((res, ex) -> {
                if (ex != null) {
                    System.err.println("Order processing failed: " + orderId);
                    ex.printStackTrace();
                } else {
                    System.out.println("Order completed: " + res);
                }
            })
            // Step 4: Handle errors
            .exceptionally(ex -> {
                System.err.println("Providing fallback for order: " + orderId);
                return "Fallback for: " + orderId;
            })
            // Step 5: Timeout
            .orTimeout(5, TimeUnit.SECONDS)
            .exceptionally(ex -> {
                if (ex instanceof TimeoutException) {
                    System.err.println("Order processing timed out: " + orderId);
                    return "Timeout for: " + orderId;
                }
                throw new CompletionException(ex);
            });
        
        /**
         * COMPLETE ASYNC PATTERN:
         * 
         * ✓ Validation
         * ✓ Processing
         * ✓ Logging
         * ✓ Error handling
         * ✓ Timeout
         * ✓ Fallback
         * 
         * Production-ready async error handling
         */
    }
    
    /**
     * Best practices summary
     */
    public static void bestPracticesSummary() {
        /**
         * ASYNC ERROR HANDLING BEST PRACTICES:
         * 
         * 1. COMPLETABLEFUTURE:
         *    ✓ Always use exceptionally() or handle()
         *    ✓ Log with whenComplete()
         *    ✓ Add context to exceptions
         *    ✓ Use orTimeout()
         *    ✓ Combine safely with allOf()
         * 
         * 2. STREAMS:
         *    ✓ Don't throw in stream operations
         *    ✓ Collect to Optional/Result
         *    ✓ Report failures after completion
         *    ✓ Wrapper functions for checked exceptions
         * 
         * 3. PARALLEL:
         *    ✓ Never throw in parallel streams
         *    ✓ Use Optional/Result pattern
         *    ✓ All threads must complete
         * 
         * 4. EXECUTOR:
         *    ✓ Handle ExecutionException
         *    ✓ Get cause for original
         *    ✓ Handle InterruptedException
         *    ✓ Always shutdown
         * 
         * 5. GENERAL:
         *    ✓ Timeout all async operations
         *    ✓ Provide fallbacks
         *    ✓ Log all errors
         *    ✓ Add business context
         *    ✓ Graceful degradation
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Always Handle ===");
        alwaysHandleExceptions();
        
        System.out.println("\n=== Log Before Recovering ===");
        logBeforeRecovering();
        
        System.out.println("\n=== Complete Example ===");
        completeExample();
    }
}
```

---

## Summary

### Quick Reference

**CompletableFuture Exception Handling:**

```java
// Recovery
future.exceptionally(ex -> fallback)

// Transform both cases
future.handle((result, ex) -> {
    if (ex != null) return handleError(ex);
    return handleSuccess(result);
})

// Side effects only
future.whenComplete((result, ex) -> log(result, ex))

// Timeout
future.orTimeout(1, TimeUnit.SECONDS)
```

**Stream Exception Handling:**

```java
// Wrapper function
public static <T, R> Function<T, R> unchecked(
        ThrowingFunction<T, R, Exception> f) {
    return t -> {
        try { return f.apply(t); }
        catch (Exception e) { throw new RuntimeException(e); }
    };
}

// Usage
.map(unchecked(file -> new FileReader(file)))

// Optional pattern
.map(item -> {
    try { return Optional.of(parse(item)); }
    catch (Exception e) { return Optional.empty(); }
})
.filter(Optional::isPresent)
.map(Optional::get)
```

**Optional vs Exception:**

```java
// Use Optional for "might not exist"
Optional<User> findById(String id)

// Use Exception for "should exist"
User getById(String id) throws NotFoundException

// Combine
findById(id).orElseThrow(() -> new NotFoundException())
```

**Vavr Try/Either:**

```java
// Try monad
Try<String> result = Try.of(() -> readFile("data.txt"))
    .recover(ex -> "fallback")
    .map(String::toUpperCase);

// Either monad
Either<String, Integer> result = parseNumber("42")
    .mapLeft(error -> "Error: " + error)
    .map(num -> num * 2);
```

### Comparison Table

```
┌──────────────────┬───────────────────┬─────────────────┬──────────────────┐
│ Pattern          │ Use Case          │ Benefits        │ Drawbacks        │
├──────────────────┼───────────────────┼─────────────────┼──────────────────┤
│ exceptionally()  │ Async recovery    │ Clean syntax    │ Changes type     │
│ handle()         │ Both cases        │ Flexible        │ Must handle both │
│ whenComplete()   │ Side effects      │ No change       │ Can't recover    │
│ Try monad        │ Wrap exceptions   │ Functional      │ New dependency   │
│ Either           │ Typed errors      │ Type-safe       │ More complex     │
│ Optional         │ Nullable values   │ Standard Java   │ Limited errors   │
│ Unchecked wrap   │ Lambda exceptions │ Reusable        │ Lost checking    │
│ Sneaky throws    │ Bypass compiler   │ No wrapper      │ Dangerous        │
└──────────────────┴───────────────────┴─────────────────┴──────────────────┘
```

### Decision Trees

**Async Error Handling:**

```
CompletableFuture exception?
  ├─ Need recovery → exceptionally()
  ├─ Transform both → handle()
  └─ Log only → whenComplete()

Stream exception?
  ├─ Fail fast → Wrap in unchecked
  ├─ Continue processing → Optional/Result
  └─ Need error details → Result pattern

Checked in lambda?
  ├─ Simple case → Try-catch inside
  ├─ Reusable → Wrapper function
  ├─ Functional → Vavr Try
  └─ Clean → Extract method
```

---
