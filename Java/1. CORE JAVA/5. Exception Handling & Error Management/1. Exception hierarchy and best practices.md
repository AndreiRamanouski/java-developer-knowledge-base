# Exception Hierarchy and Best Practices

## Overview

Exception handling is fundamental to writing robust Java applications. Understanding the exception hierarchy, knowing when to use checked vs unchecked exceptions, and following best practices separates production-quality code from fragile code. This guide covers the complete exception system from Throwable to modern patterns used in frameworks.


---

## 1. Throwable → Error vs Exception

### The Complete Exception Hierarchy

```java
/**
 * EXCEPTION HIERARCHY
 * 
 * Understanding the complete class hierarchy
 */

import java.io.*;
import java.util.*;

public class ExceptionHierarchy {
    
    /**
     * The complete hierarchy
     */
    public static void hierarchyOverview() {
        /**
         * JAVA EXCEPTION HIERARCHY:
         * 
         * java.lang.Object
         *    ↓
         * java.lang.Throwable
         *    ├── java.lang.Error (unchecked)
         *    │   ├── VirtualMachineError
         *    │   │   ├── OutOfMemoryError
         *    │   │   ├── StackOverflowError
         *    │   │   └── InternalError
         *    │   ├── AssertionError
         *    │   ├── LinkageError
         *    │   │   ├── NoClassDefFoundError
         *    │   │   └── ClassCircularityError
         *    │   └── ThreadDeath
         *    │
         *    └── java.lang.Exception
         *        ├── IOException (checked)
         *        │   ├── FileNotFoundException
         *        │   ├── EOFException
         *        │   └── SocketException
         *        ├── SQLException (checked)
         *        ├── ClassNotFoundException (checked)
         *        ├── ReflectiveOperationException (checked)
         *        │   ├── NoSuchMethodException
         *        │   ├── NoSuchFieldException
         *        │   └── IllegalAccessException
         *        │
         *        └── RuntimeException (unchecked)
         *            ├── NullPointerException
         *            ├── IllegalArgumentException
         *            │   └── NumberFormatException
         *            ├── IllegalStateException
         *            ├── IndexOutOfBoundsException
         *            │   ├── ArrayIndexOutOfBoundsException
         *            │   └── StringIndexOutOfBoundsException
         *            ├── ClassCastException
         *            ├── ArithmeticException
         *            ├── UnsupportedOperationException
         *            └── ConcurrentModificationException
         * 
         * 
         * KEY DISTINCTION:
         * 
         * Throwable (all can be thrown)
         *   ├── Error: Serious problems, don't catch
         *   └── Exception: Recoverable problems
         *       ├── Checked: Must handle
         *       └── RuntimeException: Optional to handle
         */
    }
    
    /**
     * Throwable - the root
     */
    public static void throwableRoot() {
        /**
         * THROWABLE:
         * 
         * public class Throwable implements Serializable
         * 
         * Root of exception hierarchy
         * Only Throwable and subclasses can be thrown
         * 
         * Key methods:
         * - String getMessage()
         * - Throwable getCause()
         * - void printStackTrace()
         * - StackTraceElement[] getStackTrace()
         * - Throwable initCause(Throwable cause)
         * - void addSuppressed(Throwable exception)
         * - Throwable[] getSuppressed()
         * 
         * 
         * TWO DIRECT SUBCLASSES:
         * 1. Error
         * 2. Exception
         */
        
        try {
            throw new Throwable("Generic throwable");
        } catch (Throwable t) {
            System.out.println("Caught: " + t.getMessage());
            // Generally don't catch Throwable directly
        }
    }
    
    /**
     * Error - serious problems
     */
    public static void errorClass() {
        /**
         * ERROR:
         * 
         * public class Error extends Throwable
         * 
         * Indicates serious problems that applications
         * should NOT try to catch
         * 
         * Typically unrecoverable
         * JVM issues or system failures
         * 
         * 
         * COMMON ERRORS:
         * 
         * OutOfMemoryError:
         * - JVM ran out of heap
         * - Can't allocate more objects
         * 
         * StackOverflowError:
         * - Infinite recursion
         * - Stack too deep
         * 
         * NoClassDefFoundError:
         * - Class was available at compile time
         * - Missing at runtime
         * 
         * AssertionError:
         * - assert statement failed
         * - Programming logic error
         * 
         * 
         * WHY NOT CATCH:
         * 
         * try {
         *     // some code
         * } catch (OutOfMemoryError e) {
         *     // What can you do? System is out of memory
         *     // Cleanup? Might need more memory
         *     // Log? Might need memory to log
         * }
         * 
         * Generally let Error propagate
         * JVM will terminate if necessary
         */
    }
    
    /**
     * StackOverflowError example
     */
    public static void stackOverflowExample() {
        try {
            infiniteRecursion(0);
        } catch (StackOverflowError e) {
            System.out.println("Caught StackOverflowError");
            // Rare case where catching Error is acceptable
            // Only for demonstration/testing
        }
    }
    
    private static void infiniteRecursion(int depth) {
        infiniteRecursion(depth + 1);  // No base case
    }
    
    /**
     * OutOfMemoryError demonstration
     */
    public static void outOfMemoryExample() {
        /**
         * DON'T RUN THIS IN PRODUCTION:
         * 
         * try {
         *     List<byte[]> list = new ArrayList<>();
         *     while (true) {
         *         list.add(new byte[1024 * 1024]);  // 1 MB each
         *     }
         * } catch (OutOfMemoryError e) {
         *     // System already unstable
         *     // Can't reliably recover
         * }
         */
        
        System.out.println("OutOfMemoryError typically shouldn't be caught");
    }
    
    /**
     * Exception - recoverable problems
     */
    public static void exceptionClass() {
        /**
         * EXCEPTION:
         * 
         * public class Exception extends Throwable
         * 
         * Conditions that applications might want to catch
         * Recoverable problems
         * 
         * TWO CATEGORIES:
         * 
         * 1. Checked Exceptions (not RuntimeException)
         *    - Compile-time verification
         *    - Must handle or declare
         *    - Examples: IOException, SQLException
         * 
         * 2. Unchecked Exceptions (RuntimeException)
         *    - No compile-time checking
         *    - Optional to handle
         *    - Examples: NullPointerException, IllegalArgumentException
         * 
         * 
         * DESIGN DECISION:
         * 
         * Checked: Expected, recoverable conditions
         * Unchecked: Programming errors, unexpected conditions
         */
    }
    
    /**
     * When to catch what
     */
    public static void whenToCatchWhat() {
        /**
         * CATCHING STRATEGY:
         * 
         * ❌ DON'T CATCH:
         * - Error (generally)
         * - Throwable (too broad)
         * 
         * ✅ DO CATCH:
         * - Specific Exception types
         * - When you can actually recover
         * - When you can provide value
         * 
         * 
         * EXAMPLES:
         */
        
        // ❌ BAD: Catching Error
        try {
            // some code
        } catch (Error e) {
            // What can you do about OutOfMemoryError?
        }
        
        // ❌ BAD: Catching Throwable
        try {
            // some code
        } catch (Throwable t) {
            // Catches everything, even Errors
        }
        
        // ✅ GOOD: Specific exception
        try {
            // some code
        } catch (IOException e) {
            // Can retry, use default, inform user
        }
    }
    
    /**
     * Exception vs Error summary
     */
    public static void exceptionVsErrorSummary() {
        /**
         * ERROR:
         * ❌ Don't catch (generally)
         * ❌ Can't recover
         * ❌ System/JVM issues
         * Examples: OutOfMemoryError, StackOverflowError
         * 
         * EXCEPTION:
         * ✅ Should catch (when appropriate)
         * ✅ Can recover
         * ✅ Application issues
         * Examples: IOException, SQLException
         * 
         * RUNTIMEEXCEPTION:
         * ⚠️  Optional to catch
         * ⚠️  Usually programming errors
         * ⚠️  Fix the code, not catch
         * Examples: NullPointerException, IllegalArgumentException
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Exception Hierarchy ===");
        hierarchyOverview();
        
        System.out.println("\n=== Throwable Root ===");
        throwableRoot();
        
        System.out.println("\n=== StackOverflow Example ===");
        stackOverflowExample();
        
        System.out.println("\n=== Exception vs Error Summary ===");
        exceptionVsErrorSummary();
    }
}
```

---

## 2. Checked vs Unchecked Exceptions

### The Fundamental Distinction

```java
/**
 * CHECKED VS UNCHECKED EXCEPTIONS
 * 
 * Understanding the difference and implications
 */

import java.io.*;
import java.util.*;

public class CheckedVsUnchecked {
    
    /**
     * Checked exceptions
     */
    public static void checkedExceptions() {
        /**
         * CHECKED EXCEPTIONS:
         * 
         * Definition:
         * - All Exception subclasses except RuntimeException
         * - Compiler enforces handling
         * - Must catch or declare (throws clause)
         * 
         * Common examples:
         * - IOException
         * - SQLException
         * - ClassNotFoundException
         * - InterruptedException
         * - ParseException
         * 
         * 
         * WHY CHECKED:
         * 
         * Represent expected, recoverable conditions
         * Compiler forces you to think about them
         * Part of method's contract
         */
    }
    
    /**
     * Checked exception example
     */
    public static void checkedExample() throws IOException {
        // MUST handle or declare
        
        // Option 1: Declare (throws clause)
        FileReader reader = new FileReader("file.txt");
        // Caller must handle IOException
        
        // Option 2: Handle (try-catch)
        try {
            FileReader reader2 = new FileReader("file2.txt");
        } catch (IOException e) {
            System.out.println("File not found: " + e.getMessage());
        }
        
        /**
         * COMPILE ERROR if you don't:
         * 
         * FileReader reader = new FileReader("file.txt");
         * 
         * error: unreported exception IOException
         */
    }
    
    /**
     * Unchecked exceptions
     */
    public static void uncheckedExceptions() {
        /**
         * UNCHECKED EXCEPTIONS:
         * 
         * Definition:
         * - RuntimeException and its subclasses
         * - Error and its subclasses
         * - No compile-time checking
         * - Optional to handle
         * 
         * Common RuntimeException examples:
         * - NullPointerException
         * - IllegalArgumentException
         * - IllegalStateException
         * - IndexOutOfBoundsException
         * - ClassCastException
         * - ArithmeticException
         * - UnsupportedOperationException
         * 
         * 
         * WHY UNCHECKED:
         * 
         * Represent programming errors
         * Should be prevented by code quality
         * Not part of normal execution flow
         */
    }
    
    /**
     * Unchecked exception example
     */
    public static void uncheckedExample() {
        // NO compile-time checking
        
        String str = null;
        // This compiles fine
        int length = str.length();  // NullPointerException at runtime
        
        // Optional to catch
        try {
            String str2 = null;
            int length2 = str2.length();
        } catch (NullPointerException e) {
            System.out.println("Null string");
        }
        
        /**
         * NO COMPILE ERROR:
         * 
         * Compiler doesn't force you to handle
         * Your choice whether to catch or not
         */
    }
    
    /**
     * Key differences
     */
    public static void keyDifferences() {
        /**
         * CHECKED EXCEPTIONS:
         * 
         * ✓ Compile-time verification
         * ✓ Must handle or declare
         * ✓ Part of method signature
         * ✓ Represent expected conditions
         * 
         * Example method:
         * public void read() throws IOException
         *                    ^^^^^^^^^^^^^^^^^^
         * Caller knows IOException can occur
         * 
         * 
         * UNCHECKED EXCEPTIONS:
         * 
         * ✓ No compile-time checking
         * ✓ Optional to handle
         * ✓ Not in method signature
         * ✓ Represent programming errors
         * 
         * Example method:
         * public void process(String s)
         * 
         * No indication NullPointerException can occur
         * Caller should pass non-null
         */
    }
    
    /**
     * Converting checked to unchecked
     */
    public static void convertingExceptions() {
        /**
         * WRAPPING CHECKED IN UNCHECKED:
         * 
         * Sometimes you want to avoid checked exception
         * Wrap in unchecked (RuntimeException)
         */
        
        try {
            readFile("file.txt");
        } catch (IOException e) {
            // Convert to unchecked
            throw new RuntimeException("Failed to read file", e);
        }
        
        /**
         * WHY CONVERT:
         * 
         * - Using lambdas/streams (can't throw checked)
         * - Method can't declare throws
         * - Caller can't reasonably recover
         * - Simplify API
         * 
         * 
         * CAUTION:
         * 
         * Loses compile-time verification
         * Caller unaware of potential failure
         * Use judiciously
         */
    }
    
    private static void readFile(String path) throws IOException {
        new FileReader(path);
    }
    
    /**
     * Checked exceptions in lambdas
     */
    public static void checkedInLambdas() {
        List<String> files = Arrays.asList("file1.txt", "file2.txt");
        
        /**
         * PROBLEM: Can't throw checked exception from lambda
         */
        
        // ❌ DOESN'T COMPILE:
        // files.forEach(file -> {
        //     FileReader reader = new FileReader(file);  // IOException
        // });
        
        // ✅ SOLUTION 1: Try-catch inside lambda
        files.forEach(file -> {
            try {
                FileReader reader = new FileReader(file);
            } catch (IOException e) {
                throw new RuntimeException(e);  // Convert to unchecked
            }
        });
        
        // ✅ SOLUTION 2: Helper method
        files.forEach(CheckedVsUnchecked::readFileSafe);
    }
    
    private static void readFileSafe(String file) {
        try {
            new FileReader(file);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
    
    /**
     * Comparison table
     */
    public static void comparisonTable() {
        /**
         * CHECKED VS UNCHECKED:
         * 
         * ┌──────────────────┬─────────────────┬─────────────────┐
         * │ Aspect           │ Checked         │ Unchecked       │
         * ├──────────────────┼─────────────────┼─────────────────┤
         * │ Extends          │ Exception       │ RuntimeException│
         * │                  │                 │ or Error        │
         * ├──────────────────┼─────────────────┼─────────────────┤
         * │ Compile check    │ Yes             │ No              │
         * ├──────────────────┼─────────────────┼─────────────────┤
         * │ Must handle      │ Yes (or declare)│ Optional        │
         * ├──────────────────┼─────────────────┼─────────────────┤
         * │ In signature     │ Yes (throws)    │ No              │
         * ├──────────────────┼─────────────────┼─────────────────┤
         * │ Represents       │ Expected issues │ Programming bugs│
         * ├──────────────────┼─────────────────┼─────────────────┤
         * │ Examples         │ IOException     │ NullPointer     │
         * │                  │ SQLException    │ IllegalArgument │
         * ├──────────────────┼─────────────────┼─────────────────┤
         * │ Recovery         │ Often possible  │ Usually not     │
         * ├──────────────────┼─────────────────┼─────────────────┤
         * │ Should fix       │ Handle at       │ Fix in code     │
         * │                  │ runtime         │                 │
         * └──────────────────┴─────────────────┴─────────────────┘
         */
    }
    
    public static void main(String[] args) throws IOException {
        System.out.println("=== Checked Exceptions ===");
        checkedExceptions();
        
        System.out.println("\n=== Unchecked Exceptions ===");
        uncheckedExceptions();
        
        System.out.println("\n=== Key Differences ===");
        keyDifferences();
        
        System.out.println("\n=== Comparison Table ===");
        comparisonTable();
    }
}
```

---

## 3. When to Use Each Type

### Design Decisions and Best Practices

```java
/**
 * WHEN TO USE EACH EXCEPTION TYPE
 * 
 * Guidelines for choosing checked vs unchecked
 */

import java.io.*;
import java.util.*;

public class WhenToUseEach {
    
    /**
     * Use checked exceptions for
     */
    public static void useCheckedFor() {
        /**
         * USE CHECKED EXCEPTIONS FOR:
         * 
         * 1. RECOVERABLE CONDITIONS
         *    Caller can reasonably recover
         *    
         * 2. EXPECTED FAILURES
         *    Part of normal program flow
         *    
         * 3. EXTERNAL DEPENDENCIES
         *    File systems, networks, databases
         *    
         * 4. CALLER SHOULD KNOW
         *    Important part of API contract
         * 
         * 
         * EXAMPLES:
         */
    }
    
    /**
     * Example: File operations
     */
    public static String readConfig(String path) throws FileNotFoundException {
        /**
         * CHECKED: FileNotFoundException
         * 
         * Why checked:
         * - File might not exist (expected)
         * - Caller can recover (use default, prompt user)
         * - External dependency
         * - Caller should handle
         */
        
        try (FileReader reader = new FileReader(path)) {
            // Read config
            return "config";
        } catch (IOException e) {
            throw new FileNotFoundException("Config file not found: " + path);
        }
    }
    
    /**
     * Example: Database operations
     */
    public static class UserRepository {
        public User findById(Long id) throws UserNotFoundException {
            /**
             * CHECKED: UserNotFoundException
             * 
             * Why checked:
             * - User might not exist (expected)
             * - Caller can recover (show 404, use guest)
             * - Database dependency
             * - Caller should know
             */
            
            // Simulate database lookup
            if (id == null || id <= 0) {
                throw new UserNotFoundException("User not found: " + id);
            }
            
            return new User(id, "User " + id);
        }
    }
    
    static class User {
        Long id;
        String name;
        User(Long id, String name) {
            this.id = id;
            this.name = name;
        }
    }
    
    static class UserNotFoundException extends Exception {
        public UserNotFoundException(String message) {
            super(message);
        }
    }
    
    /**
     * Use unchecked exceptions for
     */
    public static void useUncheckedFor() {
        /**
         * USE UNCHECKED EXCEPTIONS FOR:
         * 
         * 1. PROGRAMMING ERRORS
         *    Bugs that should be fixed in code
         *    
         * 2. PRECONDITION VIOLATIONS
         *    Invalid arguments, illegal state
         *    
         * 3. UNRECOVERABLE FAILURES
         *    Caller can't reasonably handle
         *    
         * 4. TECHNICAL EXCEPTIONS
         *    Not business logic
         * 
         * 
         * EXAMPLES:
         */
    }
    
    /**
     * Example: Argument validation
     */
    public static void setAge(int age) {
        /**
         * UNCHECKED: IllegalArgumentException
         * 
         * Why unchecked:
         * - Programming error (caller passed invalid)
         * - Should be prevented by caller
         * - Not recoverable (invalid is invalid)
         * - Fix the calling code
         */
        
        if (age < 0 || age > 150) {
            throw new IllegalArgumentException(
                "Age must be between 0 and 150: " + age);
        }
    }
    
    /**
     * Example: State validation
     */
    public static class ShoppingCart {
        private List<String> items = new ArrayList<>();
        private boolean checkedOut = false;
        
        public void checkout() {
            /**
             * UNCHECKED: IllegalStateException
             * 
             * Why unchecked:
             * - Programming error (already checked out)
             * - Caller should track state
             * - Not recoverable
             * - Fix the calling code
             */
            
            if (checkedOut) {
                throw new IllegalStateException("Already checked out");
            }
            
            if (items.isEmpty()) {
                throw new IllegalStateException("Cart is empty");
            }
            
            checkedOut = true;
        }
        
        public void addItem(String item) {
            if (checkedOut) {
                throw new IllegalStateException(
                    "Cannot add items after checkout");
            }
            items.add(item);
        }
    }
    
    /**
     * Design guidelines
     */
    public static void designGuidelines() {
        /**
         * DECISION FLOWCHART:
         * 
         * Can caller reasonably recover?
         *   YES → Is it expected in normal flow?
         *     YES → Use CHECKED exception
         *     NO  → Consider UNCHECKED
         *   NO → Use UNCHECKED exception
         * 
         * 
         * ASK YOURSELF:
         * 
         * 1. "Can the caller do something useful?"
         *    YES → Checked
         *    NO → Unchecked
         * 
         * 2. "Is this an expected condition?"
         *    YES → Checked
         *    NO → Unchecked
         * 
         * 3. "Is this a programming error?"
         *    YES → Unchecked
         *    NO → Consider checked
         * 
         * 4. "Would catching this add value?"
         *    YES → Checked
         *    NO → Unchecked
         */
    }
    
    /**
     * Real-world examples
     */
    public static void realWorldExamples() {
        /**
         * CHECKED EXAMPLES:
         * 
         * IOException - File might not exist
         * SQLException - Database might be down
         * TimeoutException - Operation might take too long
         * ParseException - Input might be invalid format
         * 
         * → Caller can retry, use fallback, inform user
         * 
         * 
         * UNCHECKED EXAMPLES:
         * 
         * NullPointerException - Don't pass null
         * IllegalArgumentException - Validate arguments
         * IllegalStateException - Check state before call
         * IndexOutOfBoundsException - Check bounds
         * ClassCastException - Check type before cast
         * 
         * → Caller should fix the code
         */
    }
    
    /**
     * Industry trends
     */
    public static void industryTrends() {
        /**
         * MODERN TREND: FAVOR UNCHECKED
         * 
         * Many modern frameworks prefer unchecked:
         * - Spring Framework (mostly unchecked)
         * - Hibernate (unchecked)
         * - Google Guava (unchecked)
         * - Modern Java APIs (streams, etc.)
         * 
         * WHY:
         * - Cleaner code (no try-catch noise)
         * - Better with lambdas/streams
         * - Layers don't need to declare throws
         * - Caller still can catch if wanted
         * 
         * 
         * BUT:
         * - Some argue losing compile-time checking
         * - Harder to discover what can go wrong
         * - Documentation becomes critical
         * 
         * 
         * JAVA'S DECISION:
         * - Core I/O: Checked
         * - Collections: Unchecked
         * - Streams: Unchecked
         * - No consensus
         */
    }
    
    /**
     * Converting between types
     */
    public static void convertingBetweenTypes() {
        /**
         * CHECKED → UNCHECKED:
         * 
         * When to convert:
         * - Lambda/stream context
         * - Caller can't recover anyway
         * - Simplifying API
         */
        
        // Example: In stream
        List<String> files = Arrays.asList("file1.txt", "file2.txt");
        
        files.stream()
            .map(file -> {
                try {
                    return new FileReader(file);
                } catch (IOException e) {
                    throw new UncheckedIOException(e);  // Wrapper
                }
            });
        
        /**
         * UNCHECKED → CHECKED:
         * 
         * Rare, but sometimes useful:
         * - Public API should signal failure
         * - Force callers to think about error
         */
    }
    
    /**
     * Best practices summary
     */
    public static void bestPracticesSummary() {
        /**
         * BEST PRACTICES:
         * 
         * ✅ DO:
         * - Use checked for recoverable conditions
         * - Use unchecked for programming errors
         * - Be consistent within your project
         * - Document what can be thrown
         * 
         * ❌ DON'T:
         * - Catch Exception (too broad)
         * - Swallow exceptions silently
         * - Use exceptions for control flow
         * - Overuse checked exceptions
         * 
         * 
         * RULE OF THUMB:
         * 
         * If in doubt, use unchecked
         * Modern Java favors unchecked
         * Can always catch if needed
         */
    }
    
    public static void main(String[] args) throws FileNotFoundException, UserNotFoundException {
        System.out.println("=== Use Checked For ===");
        useCheckedFor();
        
        System.out.println("\n=== Use Unchecked For ===");
        useUncheckedFor();
        
        System.out.println("\n=== Design Guidelines ===");
        designGuidelines();
        
        System.out.println("\n=== Best Practices ===");
        bestPracticesSummary();
    }
}
```

---

## 4. Custom Exception Design

### Creating Domain-Specific Exceptions

```java
/**
 * CUSTOM EXCEPTION DESIGN
 * 
 * Best practices for creating custom exceptions
 */

import java.util.*;

public class CustomExceptionDesign {
    
    /**
     * Basic custom exception
     */
    static class BasicCustomException extends Exception {
        public BasicCustomException(String message) {
            super(message);
        }
        
        public BasicCustomException(String message, Throwable cause) {
            super(message, cause);
        }
    }
    
    /**
     * Custom exception with context
     */
    static class InsufficientFundsException extends Exception {
        private final double balance;
        private final double requestedAmount;
        
        public InsufficientFundsException(double balance, double requestedAmount) {
            super(String.format(
                "Insufficient funds: balance=%.2f, requested=%.2f",
                balance, requestedAmount
            ));
            this.balance = balance;
            this.requestedAmount = requestedAmount;
        }
        
        public double getBalance() {
            return balance;
        }
        
        public double getRequestedAmount() {
            return requestedAmount;
        }
        
        public double getShortfall() {
            return requestedAmount - balance;
        }
    }
    
    public static void customExceptionWithContext() {
        try {
            double balance = 100.0;
            double amount = 150.0;
            
            if (balance < amount) {
                throw new InsufficientFundsException(balance, amount);
            }
        } catch (InsufficientFundsException e) {
            System.out.println("Error: " + e.getMessage());
            System.out.println("Shortfall: " + e.getShortfall());
            
            // Can use context for recovery
            if (e.getShortfall() < 10) {
                System.out.println("Consider using credit");
            }
        }
        
        /**
         * CONTEXT IN EXCEPTIONS:
         * 
         * ✅ Store relevant data
         * ✅ Provide getter methods
         * ✅ Enable intelligent recovery
         * ✅ Better error messages
         */
    }
    
    /**
     * Exception hierarchy for domain
     */
    static class PaymentException extends Exception {
        public PaymentException(String message) {
            super(message);
        }
        
        public PaymentException(String message, Throwable cause) {
            super(message, cause);
        }
    }
    
    static class PaymentDeclinedException extends PaymentException {
        private final String declineReason;
        
        public PaymentDeclinedException(String declineReason) {
            super("Payment declined: " + declineReason);
            this.declineReason = declineReason;
        }
        
        public String getDeclineReason() {
            return declineReason;
        }
    }
    
    static class PaymentTimeoutException extends PaymentException {
        public PaymentTimeoutException() {
            super("Payment processing timed out");
        }
    }
    
    static class InvalidCardException extends PaymentException {
        private final String cardNumber;
        
        public InvalidCardException(String cardNumber) {
            super("Invalid card: " + maskCard(cardNumber));
            this.cardNumber = cardNumber;
        }
        
        private static String maskCard(String card) {
            if (card.length() < 4) return "****";
            return "****" + card.substring(card.length() - 4);
        }
    }
    
    public static void exceptionHierarchyForDomain() {
        try {
            processPayment("1234-5678-9012-3456");
        } catch (PaymentDeclinedException e) {
            System.out.println("Declined: " + e.getDeclineReason());
            // Specific handling
        } catch (PaymentTimeoutException e) {
            System.out.println("Timeout - retry?");
            // Retry logic
        } catch (InvalidCardException e) {
            System.out.println("Invalid card");
            // Validation error
        } catch (PaymentException e) {
            System.out.println("Payment failed: " + e.getMessage());
            // Generic handling
        }
        
        /**
         * DOMAIN HIERARCHY:
         * 
         * PaymentException (base)
         *   ├── PaymentDeclinedException
         *   ├── PaymentTimeoutException
         *   └── InvalidCardException
         * 
         * Benefits:
         * - Can catch specific types
         * - Can catch base for all payment errors
         * - Clear domain model
         * - Specific recovery strategies
         */
    }
    
    private static void processPayment(String card) throws PaymentException {
        throw new PaymentDeclinedException("Insufficient funds");
    }
    
    /**
     * Required constructors
     */
    static class WellDesignedException extends Exception {
        // Standard constructors
        
        public WellDesignedException() {
            super();
        }
        
        public WellDesignedException(String message) {
            super(message);
        }
        
        public WellDesignedException(String message, Throwable cause) {
            super(message, cause);
        }
        
        public WellDesignedException(Throwable cause) {
            super(cause);
        }
        
        /**
         * ALL FOUR CONSTRUCTORS:
         * 
         * 1. Default: WellDesignedException()
         * 2. Message: WellDesignedException(String)
         * 3. Message + Cause: WellDesignedException(String, Throwable)
         * 4. Cause: WellDesignedException(Throwable)
         * 
         * Provides flexibility for users
         * Follows Java conventions
         */
    }
    
    /**
     * Unchecked custom exceptions
     */
    static class ConfigurationException extends RuntimeException {
        public ConfigurationException(String message) {
            super(message);
        }
        
        public ConfigurationException(String message, Throwable cause) {
            super(message, cause);
        }
    }
    
    static class InvalidConfigurationException extends ConfigurationException {
        private final String configKey;
        private final String configValue;
        
        public InvalidConfigurationException(String configKey, String configValue) {
            super("Invalid configuration: " + configKey + " = " + configValue);
            this.configKey = configKey;
            this.configValue = configValue;
        }
    }
    
    /**
     * Exception design guidelines
     */
    public static void exceptionDesignGuidelines() {
        /**
         * CUSTOM EXCEPTION GUIDELINES:
         * 
         * 1. NAMING:
         *    - End with "Exception"
         *    - Descriptive name
         *    - Clear what went wrong
         * 
         * 2. INHERITANCE:
         *    - Extend Exception for checked
         *    - Extend RuntimeException for unchecked
         *    - Create hierarchy for related errors
         * 
         * 3. CONSTRUCTORS:
         *    - Provide standard 4 constructors
         *    - Message, cause, both, neither
         * 
         * 4. CONTEXT:
         *    - Store relevant data
         *    - Provide getters
         *    - Don't expose sensitive data
         * 
         * 5. IMMUTABILITY:
         *    - Make fields final
         *    - No setters
         *    - Thread-safe by default
         * 
         * 6. SERIALIZATION:
         *    - Make serializable if needed
         *    - Add serialVersionUID
         * 
         * 
         * ✅ DO:
         * - Create specific exceptions
         * - Store context data
         * - Build hierarchies
         * - Provide good messages
         * 
         * ❌ DON'T:
         * - Create too many exceptions
         * - Expose sensitive data
         * - Make them mutable
         * - Forget standard constructors
         */
    }
    
    /**
     * Validation exception pattern
     */
    static class ValidationException extends RuntimeException {
        private final List<String> errors;
        
        public ValidationException(List<String> errors) {
            super("Validation failed: " + errors.size() + " error(s)");
            this.errors = new ArrayList<>(errors);  // Defensive copy
        }
        
        public List<String> getErrors() {
            return new ArrayList<>(errors);  // Defensive copy
        }
        
        public int getErrorCount() {
            return errors.size();
        }
    }
    
    public static void validationExceptionPattern() {
        List<String> errors = new ArrayList<>();
        errors.add("Name is required");
        errors.add("Email is invalid");
        errors.add("Age must be positive");
        
        try {
            throw new ValidationException(errors);
        } catch (ValidationException e) {
            System.out.println(e.getMessage());
            System.out.println("Errors:");
            e.getErrors().forEach(error -> System.out.println("  - " + error));
        }
        
        /**
         * VALIDATION PATTERN:
         * 
         * Collect all errors
         * Throw single exception
         * Caller gets complete picture
         * Better UX (show all errors at once)
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Custom Exception with Context ===");
        customExceptionWithContext();
        
        System.out.println("\n=== Exception Hierarchy ===");
        exceptionHierarchyForDomain();
        
        System.out.println("\n=== Design Guidelines ===");
        exceptionDesignGuidelines();
        
        System.out.println("\n=== Validation Pattern ===");
        validationExceptionPattern();
    }
}
```

---

## 5. Exception Chaining (getCause())

### Preserving the Complete Error Context

```java
/**
 * EXCEPTION CHAINING
 * 
 * Linking exceptions to preserve context
 */

import java.io.*;
import java.sql.*;

public class ExceptionChaining {
    
    /**
     * Basic exception chaining
     */
    public static void basicChaining() {
        try {
            lowLevelOperation();
        } catch (IOException e) {
            // Chain the exception
            throw new RuntimeException("High-level operation failed", e);
            //                                                        ^
            //                                                    Cause
        }
    }
    
    private static void lowLevelOperation() throws IOException {
        throw new IOException("File not found");
    }
    
    /**
     * Why chain exceptions
     */
    public static void whyChain() {
        /**
         * WHY EXCEPTION CHAINING:
         * 
         * 1. PRESERVE CONTEXT
         *    Keep original exception
         *    Don't lose stack trace
         * 
         * 2. ADD INFORMATION
         *    Higher-level meaning
         *    Business context
         * 
         * 3. ABSTRACTION
         *    Hide implementation details
         *    Show what caller cares about
         * 
         * 4. DEBUGGING
         *    Complete error chain
         *    See root cause
         * 
         * 
         * WITHOUT CHAINING:
         * catch (IOException e) {
         *     throw new RuntimeException("Operation failed");
         *     // Lost original exception!
         *     // Lost stack trace!
         * }
         * 
         * WITH CHAINING:
         * catch (IOException e) {
         *     throw new RuntimeException("Operation failed", e);
         *     // Preserved original!
         *     // Preserved stack trace!
         * }
         */
    }
    
    /**
     * Multi-level chaining
     */
    static class DataAccessException extends RuntimeException {
        public DataAccessException(String message, Throwable cause) {
            super(message, cause);
        }
    }
    
    static class ServiceException extends RuntimeException {
        public ServiceException(String message, Throwable cause) {
            super(message, cause);
        }
    }
    
    static class ControllerException extends RuntimeException {
        public ControllerException(String message, Throwable cause) {
            super(message, cause);
        }
    }
    
    public static void multiLevelChaining() {
        try {
            controller();
        } catch (ControllerException e) {
            System.out.println("Top-level error: " + e.getMessage());
            
            // Walk the chain
            Throwable cause = e;
            int level = 0;
            while (cause != null) {
                System.out.println("  ".repeat(level) + 
                    "Level " + level + ": " + 
                    cause.getClass().getSimpleName() + " - " + 
                    cause.getMessage());
                cause = cause.getCause();
                level++;
            }
        }
        
        /**
         * OUTPUT:
         * Top-level error: Controller failed
         * Level 0: ControllerException - Controller failed
         *   Level 1: ServiceException - Service failed
         *     Level 2: DataAccessException - Data access failed
         *       Level 3: SQLException - Table not found
         * 
         * Complete chain preserved!
         */
    }
    
    private static void controller() {
        try {
            service();
        } catch (ServiceException e) {
            throw new ControllerException("Controller failed", e);
        }
    }
    
    private static void service() {
        try {
            dataAccess();
        } catch (DataAccessException e) {
            throw new ServiceException("Service failed", e);
        }
    }
    
    private static void dataAccess() {
        try {
            database();
        } catch (SQLException e) {
            throw new DataAccessException("Data access failed", e);
        }
    }
    
    private static void database() throws SQLException {
        throw new SQLException("Table not found");
    }
    
    /**
     * Getting the root cause
     */
    public static Throwable getRootCause(Throwable throwable) {
        Throwable cause = throwable;
        while (cause.getCause() != null) {
            cause = cause.getCause();
        }
        return cause;
    }
    
    public static void getRootCauseExample() {
        try {
            controller();
        } catch (Exception e) {
            Throwable root = getRootCause(e);
            System.out.println("Root cause: " + root.getClass().getSimpleName());
            System.out.println("Message: " + root.getMessage());
        }
        
        /**
         * ROOT CAUSE:
         * 
         * Often the most important
         * Original problem
         * What actually went wrong
         */
    }
    
    /**
     * initCause method
     */
    public static void initCauseMethod() {
        /**
         * INITCAUSE():
         * 
         * For exceptions created before cause known
         * Can only be called once
         */
        
        Exception e = new Exception("High-level error");
        
        try {
            lowLevelOperation();
        } catch (IOException cause) {
            e.initCause(cause);  // Set cause after creation
        }
        
        System.out.println("Exception: " + e.getMessage());
        System.out.println("Cause: " + e.getCause().getMessage());
        
        /**
         * WHEN TO USE:
         * 
         * - Exception created before cause known
         * - Legacy code without cause constructor
         * - Building exception dynamically
         * 
         * 
         * LIMITATION:
         * 
         * Can only call once
         * e.initCause(cause1);  // OK
         * e.initCause(cause2);  // IllegalStateException
         */
    }
    
    /**
     * Stack trace preservation
     */
    public static void stackTracePreservation() {
        try {
            try {
                throw new IOException("Original error");
            } catch (IOException e) {
                // Correct: Preserve stack trace
                throw new RuntimeException("Wrapped error", e);
            }
        } catch (RuntimeException e) {
            System.out.println("Stack trace:");
            e.printStackTrace();
            
            System.out.println("\nCause stack trace:");
            e.getCause().printStackTrace();
        }
        
        /**
         * STACK TRACE CHAINING:
         * 
         * Each exception has its own stack trace
         * Cause has its own stack trace
         * Can see complete call chain
         * Essential for debugging
         */
    }
    
    /**
     * Exception translation pattern
     */
    public static void exceptionTranslationPattern() {
        /**
         * EXCEPTION TRANSLATION:
         * 
         * Convert low-level exception to high-level
         * Keep cause for debugging
         * Show meaningful error to caller
         */
        
        try {
            // Low-level: SQLException
            throw new SQLException("Connection failed");
        } catch (SQLException e) {
            // High-level: ServiceException
            throw new ServiceException(
                "Unable to retrieve user data", e);
        }
        
        /**
         * BENEFITS:
         * 
         * Caller sees: ServiceException
         * - Business-level error
         * - Meaningful message
         * - Knows what to do
         * 
         * Developer sees: SQLException (cause)
         * - Technical details
         * - Debugging info
         * - Root problem
         */
    }
    
    /**
     * Chaining best practices
     */
    public static void chainingBestPractices() {
        /**
         * CHAINING BEST PRACTICES:
         * 
         * ✅ DO:
         * - Always chain exceptions
         * - Use cause constructor
         * - Preserve stack traces
         * - Add business context
         * 
         * ❌ DON'T:
         * - Lose original exception
         * - Chain unnecessarily (same level)
         * - Expose low-level details to caller
         * 
         * 
         * PATTERN:
         * 
         * try {
         *     lowLevel();
         * } catch (LowLevelException e) {
         *     throw new HighLevelException(
         *         "Business message", e);  // Chain!
         * }
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Why Chain ===");
        whyChain();
        
        System.out.println("\n=== Multi-Level Chaining ===");
        multiLevelChaining();
        
        System.out.println("\n=== Root Cause ===");
        getRootCauseExample();
        
        System.out.println("\n=== InitCause Method ===");
        initCauseMethod();
    }
}
```

---

## 6. Suppressed Exceptions

### Try-With-Resources and Exception Handling

```java
/**
 * SUPPRESSED EXCEPTIONS
 * 
 * Exceptions hidden by try-with-resources
 */

import java.io.*;

public class SuppressedExceptions {
    
    /**
     * The problem without try-with-resources
     */
    public static void problemWithoutTryWithResources() {
        FileReader reader = null;
        try {
            reader = new FileReader("file.txt");
            // Exception thrown here
            throw new RuntimeException("Processing error");
        } catch (IOException e) {
            throw new RuntimeException("Open failed", e);
        } finally {
            if (reader != null) {
                try {
                    reader.close();
                    // Exception thrown here too!
                    throw new RuntimeException("Close error");
                } catch (IOException e) {
                    // Close exception LOST
                    // Only see processing error
                }
            }
        }
        
        /**
         * PROBLEM:
         * 
         * Two exceptions:
         * 1. Processing error
         * 2. Close error
         * 
         * Only see one (processing error)
         * Close error lost!
         * 
         * Hard to debug
         */
    }
    
    /**
     * Solution: try-with-resources
     */
    static class MyResource implements AutoCloseable {
        private final String name;
        
        MyResource(String name) {
            this.name = name;
            System.out.println("Opening: " + name);
        }
        
        public void process() {
            System.out.println("Processing: " + name);
            throw new RuntimeException("Processing failed");
        }
        
        @Override
        public void close() {
            System.out.println("Closing: " + name);
            throw new RuntimeException("Close failed");
        }
    }
    
    public static void tryWithResourcesSolution() {
        try (MyResource resource = new MyResource("test")) {
            resource.process();  // Throws exception
            // close() also throws exception
        } catch (Exception e) {
            System.out.println("Main exception: " + e.getMessage());
            
            // Suppressed exceptions available!
            Throwable[] suppressed = e.getSuppressed();
            System.out.println("Suppressed count: " + suppressed.length);
            
            for (Throwable s : suppressed) {
                System.out.println("Suppressed: " + s.getMessage());
            }
        }
        
        /**
         * OUTPUT:
         * Opening: test
         * Processing: test
         * Closing: test
         * Main exception: Processing failed
         * Suppressed count: 1
         * Suppressed: Close failed
         * 
         * BOTH EXCEPTIONS PRESERVED!
         */
    }
    
    /**
     * Multiple suppressed exceptions
     */
    static class Resource1 implements AutoCloseable {
        @Override
        public void close() {
            throw new RuntimeException("Resource1 close failed");
        }
    }
    
    static class Resource2 implements AutoCloseable {
        @Override
        public void close() {
            throw new RuntimeException("Resource2 close failed");
        }
    }
    
    public static void multipleSuppressedExceptions() {
        try (Resource1 r1 = new Resource1();
             Resource2 r2 = new Resource2()) {
            
            throw new RuntimeException("Main exception");
            
        } catch (Exception e) {
            System.out.println("Main: " + e.getMessage());
            
            for (Throwable s : e.getSuppressed()) {
                System.out.println("Suppressed: " + s.getMessage());
            }
        }
        
        /**
         * OUTPUT:
         * Main: Main exception
         * Suppressed: Resource2 close failed
         * Suppressed: Resource1 close failed
         * 
         * All close exceptions preserved
         * Closed in reverse order
         */
    }
    
    /**
     * Manual suppression
     */
    public static void manualSuppression() {
        Exception main = new Exception("Main exception");
        Exception suppressed1 = new Exception("Suppressed 1");
        Exception suppressed2 = new Exception("Suppressed 2");
        
        main.addSuppressed(suppressed1);
        main.addSuppressed(suppressed2);
        
        System.out.println("Main: " + main.getMessage());
        for (Throwable s : main.getSuppressed()) {
            System.out.println("Suppressed: " + s.getMessage());
        }
        
        /**
         * ADDSUPPRESSED():
         * 
         * Manually add suppressed exceptions
         * Useful for:
         * - Custom resource management
         * - Batch operations
         * - Complex cleanup
         */
    }
    
    /**
     * Suppression patterns
     */
    public static void suppressionPatterns() {
        /**
         * WHEN SUPPRESSION OCCURS:
         * 
         * 1. TRY-WITH-RESOURCES:
         *    - Main exception in try
         *    - Close exception suppressed
         * 
         * 2. MANUAL:
         *    - Call addSuppressed()
         *    - Custom resource handling
         * 
         * 
         * SUPPRESSION RULES:
         * 
         * - Primary exception thrown
         * - Subsequent exceptions suppressed
         * - All exceptions preserved
         * - Available via getSuppressed()
         * 
         * 
         * PRIORITY:
         * 
         * Try block exception is primary
         * Close exceptions are suppressed
         * Makes sense: try block is the main operation
         */
    }
    
    /**
     * Best practices
     */
    public static void bestPractices() {
        /**
         * SUPPRESSED EXCEPTIONS BEST PRACTICES:
         * 
         * ✅ DO:
         * - Use try-with-resources
         * - Check getSuppressed() when debugging
         * - Log suppressed exceptions
         * - Consider all exceptions in error handling
         * 
         * ❌ DON'T:
         * - Ignore suppressed exceptions
         * - Rely on manual close() in finally
         * - Forget to implement AutoCloseable
         * 
         * 
         * LOGGING PATTERN:
         */
        
        try (MyResource resource = new MyResource("test")) {
            resource.process();
        } catch (Exception e) {
            // Log main exception
            System.err.println("Error: " + e.getMessage());
            
            // Log suppressed exceptions too!
            for (Throwable suppressed : e.getSuppressed()) {
                System.err.println("Suppressed: " + suppressed.getMessage());
            }
            
            // Or just printStackTrace() - shows all
            e.printStackTrace();
        }
    }
    
    /**
     * Real-world example
     */
    static class DatabaseConnection implements AutoCloseable {
        public void execute(String sql) {
            throw new RuntimeException("SQL execution failed");
        }
        
        @Override
        public void close() {
            throw new RuntimeException("Connection close failed");
        }
    }
    
    public static void realWorldExample() {
        try (DatabaseConnection conn = new DatabaseConnection()) {
            conn.execute("SELECT * FROM users");
        } catch (Exception e) {
            System.out.println("Database error: " + e.getMessage());
            
            // Check for connection close issues
            Throwable[] suppressed = e.getSuppressed();
            if (suppressed.length > 0) {
                System.out.println("Warning: Connection cleanup failed");
                for (Throwable s : suppressed) {
                    System.out.println("  " + s.getMessage());
                }
            }
        }
        
        /**
         * REAL-WORLD VALUE:
         * 
         * Know both:
         * - Query failed (main)
         * - Connection cleanup failed (suppressed)
         * 
         * Complete picture of what went wrong
         * Better debugging
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Try-With-Resources Solution ===");
        tryWithResourcesSolution();
        
        System.out.println("\n=== Multiple Suppressed ===");
        multipleSuppressedExceptions();
        
        System.out.println("\n=== Manual Suppression ===");
        manualSuppression();
        
        System.out.println("\n=== Real-World Example ===");
        realWorldExample();
    }
}
```

---

## 7. Exception Translation in Layers

### Architectural Pattern for Clean Error Handling

```java
/**
 * EXCEPTION TRANSLATION IN LAYERS
 * 
 * Converting exceptions between architectural layers
 */

import java.io.*;
import java.sql.*;
import java.util.*;

public class ExceptionTranslationLayers {
    
    /**
     * Layered architecture
     */
    public static void layeredArchitecture() {
        /**
         * TYPICAL LAYERS:
         * 
         * Controller (Presentation)
         *    ↓
         * Service (Business Logic)
         *    ↓
         * Repository (Data Access)
         *    ↓
         * Database
         * 
         * 
         * EXCEPTION FLOW:
         * 
         * SQLException (Database)
         *    ↓ translate
         * DataAccessException (Repository)
         *    ↓ translate
         * BusinessException (Service)
         *    ↓ translate
         * HttpException (Controller)
         * 
         * Each layer translates to its abstraction level
         */
    }
    
    /**
     * Repository layer exceptions
     */
    static class DataAccessException extends RuntimeException {
        public DataAccessException(String message, Throwable cause) {
            super(message, cause);
        }
    }
    
    static class EntityNotFoundException extends DataAccessException {
        public EntityNotFoundException(String entity, Object id) {
            super("Entity not found: " + entity + " with id: " + id, null);
        }
    }
    
    static class User {
        Long id;
        String email;
        User(Long id, String email) {
            this.id = id;
            this.email = email;
        }
    }
    
    static class UserRepository {
        public User findById(Long id) {
            try {
                // Simulate database call
                return queryDatabase(id);
            } catch (SQLException e) {
                // Translate SQLException → DataAccessException
                throw new DataAccessException(
                    "Failed to retrieve user: " + id, e);
            }
        }
        
        private User queryDatabase(Long id) throws SQLException {
            if (id == null || id <= 0) {
                throw new SQLException("Invalid ID");
            }
            return new User(id, "user@example.com");
        }
        
        /**
         * REPOSITORY LAYER:
         * 
         * Hides: SQLException (database detail)
         * Exposes: DataAccessException (abstraction)
         * 
         * Caller doesn't know:
         * - Database type (MySQL, PostgreSQL)
         * - Connection details
         * - SQL syntax
         * 
         * Caller knows:
         * - Data access failed
         * - Can't retrieve entity
         */
    }
    
    /**
     * Service layer exceptions
     */
    static class BusinessException extends RuntimeException {
        public BusinessException(String message, Throwable cause) {
            super(message, cause);
        }
    }
    
    static class UserNotFoundException extends BusinessException {
        public UserNotFoundException(Long userId) {
            super("User not found: " + userId, null);
        }
    }
    
    static class UserService {
        private final UserRepository repository = new UserRepository();
        
        public User getUser(Long id) {
            try {
                return repository.findById(id);
            } catch (DataAccessException e) {
                // Translate DataAccessException → BusinessException
                throw new UserNotFoundException(id);
            }
        }
        
        /**
         * SERVICE LAYER:
         * 
         * Hides: DataAccessException (repository detail)
         * Exposes: BusinessException (business concept)
         * 
         * Caller doesn't know:
         * - Repository implementation
         * - Data access mechanism
         * 
         * Caller knows:
         * - Business operation failed
         * - User doesn't exist
         */
    }
    
    /**
     * Controller layer exceptions
     */
    static class HttpException extends RuntimeException {
        private final int statusCode;
        
        public HttpException(int statusCode, String message) {
            super(message);
            this.statusCode = statusCode;
        }
        
        public int getStatusCode() {
            return statusCode;
        }
    }
    
    static class NotFoundException extends HttpException {
        public NotFoundException(String message) {
            super(404, message);
        }
    }
    
    static class UserController {
        private final UserService service = new UserService();
        
        public String getUserEndpoint(Long id) {
            try {
                User user = service.getUser(id);
                return "User: " + user.email;
            } catch (UserNotFoundException e) {
                // Translate BusinessException → HttpException
                throw new NotFoundException("User not found: " + id);
            } catch (BusinessException e) {
                throw new HttpException(500, "Internal error");
            }
        }
        
        /**
         * CONTROLLER LAYER:
         * 
         * Hides: BusinessException (service detail)
         * Exposes: HttpException (HTTP concept)
         * 
         * Caller doesn't know:
         * - Business logic
         * - Service implementation
         * 
         * Caller knows:
         * - HTTP status code
         * - User-facing message
         */
    }
    
    /**
     * Complete flow example
     */
    public static void completeFlowExample() {
        UserController controller = new UserController();
        
        try {
            String response = controller.getUserEndpoint(-1L);
            System.out.println(response);
        } catch (NotFoundException e) {
            System.out.println("HTTP " + e.getStatusCode() + ": " + e.getMessage());
            
            // Walk the exception chain
            Throwable cause = e.getCause();
            while (cause != null) {
                System.out.println("  Caused by: " + 
                    cause.getClass().getSimpleName() + " - " + 
                    cause.getMessage());
                cause = cause.getCause();
            }
        }
        
        /**
         * OUTPUT:
         * HTTP 404: User not found: -1
         *   Caused by: UserNotFoundException - User not found: -1
         *   Caused by: DataAccessException - Failed to retrieve user: -1
         *   Caused by: SQLException - Invalid ID
         * 
         * Complete chain shows all layers!
         */
    }
    
    /**
     * Translation strategies
     */
    public static void translationStrategies() {
        /**
         * TRANSLATION STRATEGIES:
         * 
         * 1. WRAP AND RETHROW:
         *    catch (LowLevel e) {
         *        throw new HighLevel("message", e);
         *    }
         *    Preserves cause, adds context
         * 
         * 2. REPLACE:
         *    catch (LowLevel e) {
         *        throw new HighLevel("message");
         *    }
         *    Hides implementation, loses cause
         * 
         * 3. MAP:
         *    catch (SQLException e) {
         *        if (e.getErrorCode() == 1062) {
         *            throw new DuplicateKeyException();
         *        }
         *    }
         *    Specific translation based on details
         * 
         * 
         * PREFER WRAP AND RETHROW:
         * Preserves debugging information
         * Shows complete picture
         */
    }
    
    /**
     * Exception boundaries
     */
    public static void exceptionBoundaries() {
        /**
         * EXCEPTION BOUNDARIES:
         * 
         * Define clear boundaries between layers
         * Each layer has its own exception types
         * 
         * 
         * LAYER BOUNDARIES:
         * 
         * Database Layer:
         * - SQLException
         * - Vendor-specific exceptions
         * 
         * Repository Layer:
         * - DataAccessException
         * - EntityNotFoundException
         * 
         * Service Layer:
         * - BusinessException
         * - ValidationException
         * 
         * Controller Layer:
         * - HttpException
         * - User-facing errors
         * 
         * 
         * BENEFITS:
         * - Clear separation
         * - Easy to change implementation
         * - Test layers independently
         * - Hide implementation details
         */
    }
    
    /**
     * Generic translation utility
     */
    static class ExceptionTranslator {
        @FunctionalInterface
        interface ThrowingSupplier<T> {
            T get() throws Exception;
        }
        
        public static <T> T translateDataAccess(ThrowingSupplier<T> supplier) {
            try {
                return supplier.get();
            } catch (SQLException e) {
                throw new DataAccessException("Database error", e);
            } catch (Exception e) {
                throw new DataAccessException("Unexpected error", e);
            }
        }
        
        public static <T> T translateBusiness(ThrowingSupplier<T> supplier) {
            try {
                return supplier.get();
            } catch (DataAccessException e) {
                throw new BusinessException("Business operation failed", e);
            } catch (Exception e) {
                throw new BusinessException("Unexpected error", e);
            }
        }
    }
    
    /**
     * Best practices
     */
    public static void bestPractices() {
        /**
         * EXCEPTION TRANSLATION BEST PRACTICES:
         * 
         * ✅ DO:
         * - Define layer-specific exceptions
         * - Translate at layer boundaries
         * - Preserve original exception (chain)
         * - Add business context
         * - Hide implementation details
         * 
         * ❌ DON'T:
         * - Let low-level exceptions escape
         * - Lose original exception
         * - Catch and ignore
         * - Create too many exception types
         * - Mix layer concerns
         * 
         * 
         * PATTERN:
         * 
         * Each layer:
         * 1. Catches exceptions from below
         * 2. Translates to its own type
         * 3. Adds business context
         * 4. Chains original exception
         * 5. Throws to layer above
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Layered Architecture ===");
        layeredArchitecture();
        
        System.out.println("\n=== Complete Flow ===");
        completeFlowExample();
        
        System.out.println("\n=== Translation Strategies ===");
        translationStrategies();
        
        System.out.println("\n=== Best Practices ===");
        bestPractices();
    }
}
```

---

## Summary

### Exception Hierarchy Quick Reference

```
Throwable
├── Error (unchecked) - DON'T catch
│   ├── OutOfMemoryError
│   ├── StackOverflowError
│   ├── NoClassDefFoundError
│   └── AssertionError
│
└── Exception
    ├── Checked (must handle) - recoverable
    │   ├── IOException
    │   ├── SQLException
    │   ├── ClassNotFoundException
    │   └── InterruptedException
    │
    └── RuntimeException (unchecked) - programming errors
        ├── NullPointerException
        ├── IllegalArgumentException
        ├── IllegalStateException
        ├── IndexOutOfBoundsException
        └── ClassCastException
```

### Decision Trees

**Checked vs Unchecked:**

```
Is it recoverable?
  YES → Can caller do something useful?
    YES → CHECKED
    NO → UNCHECKED
  NO → UNCHECKED

Is it expected?
  YES → CHECKED
  NO → UNCHECKED (programming error)
```

**Exception Design:**

```
Creating custom exception?
  ├─ Checked or unchecked?
  ├─ Add context fields?
  ├─ Create hierarchy?
  └─ Provide 4 constructors
```

**Exception Translation:**

```
Database → Repository: SQLException → DataAccessException
Repository → Service: DataAccessException → BusinessException
Service → Controller: BusinessException → HttpException
```

### Best Practices Checklist

**✅ DO:**

- Use specific exception types
- Chain exceptions (preserve cause)
- Add business context
- Translate at layer boundaries
- Check suppressed exceptions
- Use try-with-resources
- Create domain hierarchies
- Document what can be thrown

**❌ DON'T:**

- Catch Error (generally)
- Catch Throwable
- Swallow exceptions silently
- Lose original exception
- Use exceptions for control flow
- Create too many custom exceptions
- Mix layer concerns
- Expose implementation details

---
