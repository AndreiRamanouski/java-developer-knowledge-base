# Try-With-Resources and AutoCloseable

## Overview

Try-with-resources (TWR), introduced in Java 7, revolutionized resource management by automatically closing resources and properly handling suppressed exceptions. Understanding TWR is essential for writing robust, leak-free code. This guide covers everything from basic usage to advanced patterns and custom implementations.

---

## 1. Automatic Resource Management

### The Resource Leak Problem and Solution

```java
/**
 * AUTOMATIC RESOURCE MANAGEMENT
 * 
 * Understanding the problem and solution
 */

import java.io.*;
import java.util.*;

public class AutomaticResourceManagement {
    
    /**
     * The resource leak problem
     */
    public static void resourceLeakProblem() {
        /**
         * THE PROBLEM:
         * 
         * Resources must be closed:
         * - Files
         * - Streams
         * - Database connections
         * - Network sockets
         * - Locks
         * 
         * Forgetting to close = resource leak
         * 
         * 
         * CONSEQUENCES:
         * - File descriptors exhausted
         * - Memory leaks
         * - Connection pool exhausted
         * - System instability
         * - Production failures
         */
    }
    
    /**
     * Manual resource management (error-prone)
     */
    public static void manualResourceManagement() {
        FileReader reader = null;
        
        try {
            reader = new FileReader("data.txt");
            // Read data
            int data = reader.read();
            
            // Problem: If exception here, reader not closed!
            if (data == -1) {
                return;  // LEAK! Forgot to close
            }
            
        } catch (IOException e) {
            System.out.println("Error: " + e.getMessage());
            // Problem: Exception handling, forgot close
            // LEAK!
        }
        
        // Problem: Only closed on normal path
        // Not closed on exception or early return
        // LEAK!
        
        /**
         * ISSUES:
         * 
         * ❌ Forgot to close on exception
         * ❌ Forgot to close on early return
         * ❌ No finally block
         * ❌ Resource leaked
         */
    }
    
    /**
     * Pre-Java 7 solution: try-finally
     */
    public static void tryFinallySolution() {
        FileReader reader = null;
        
        try {
            reader = new FileReader("data.txt");
            int data = reader.read();
            
        } catch (IOException e) {
            System.out.println("Error: " + e.getMessage());
            
        } finally {
            // Always executed
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e) {
                    System.out.println("Close failed: " + e.getMessage());
                }
            }
        }
        
        /**
         * BETTER BUT:
         * 
         * ✓ Resource closed
         * ✓ Closed on exception
         * ✓ Closed on early return
         * 
         * ❌ Verbose (9 lines for close!)
         * ❌ Nested try-catch
         * ❌ Close exception handling complex
         * ❌ Suppressed exception problem
         */
    }
    
    /**
     * Java 7+ solution: try-with-resources
     */
    public static void tryWithResourcesSolution() {
        try (FileReader reader = new FileReader("data.txt")) {
            int data = reader.read();
            
        } catch (IOException e) {
            System.out.println("Error: " + e.getMessage());
        }
        
        // reader.close() called automatically!
        
        /**
         * PERFECT:
         * 
         * ✓ Automatic close
         * ✓ Closed on exception
         * ✓ Closed on early return
         * ✓ Concise (1 line!)
         * ✓ Handles suppressed exceptions
         * ✓ Correct close order
         * 
         * reader automatically closed here
         * Even if exception occurs
         * Even if early return
         */
    }
    
    /**
     * How it works
     */
    public static void howItWorks() {
        /**
         * TRY-WITH-RESOURCES MECHANICS:
         * 
         * try (Resource r = new Resource()) {
         *     // Use r
         * }
         * 
         * 
         * COMPILER TRANSFORMS TO:
         * 
         * Resource r = new Resource();
         * Throwable primaryException = null;
         * 
         * try {
         *     // Use r
         * } catch (Throwable t) {
         *     primaryException = t;
         *     throw t;
         * } finally {
         *     if (r != null) {
         *         if (primaryException != null) {
         *             try {
         *                 r.close();
         *             } catch (Throwable closeException) {
         *                 primaryException.addSuppressed(closeException);
         *             }
         *         } else {
         *             r.close();
         *         }
         *     }
         * }
         * 
         * 
         * GUARANTEES:
         * 
         * 1. close() always called
         * 2. Primary exception thrown
         * 3. Close exceptions suppressed
         * 4. All exceptions preserved
         */
    }
    
    /**
     * What can be used in try-with-resources
     */
    public static void whatCanBeUsed() {
        /**
         * REQUIREMENTS:
         * 
         * Must implement AutoCloseable
         * 
         * public interface AutoCloseable {
         *     void close() throws Exception;
         * }
         * 
         * 
         * COMMON TYPES:
         * 
         * ✓ FileReader/FileWriter
         * ✓ BufferedReader/BufferedWriter
         * ✓ InputStream/OutputStream
         * ✓ Socket/ServerSocket
         * ✓ Connection/Statement/ResultSet (JDBC)
         * ✓ Scanner
         * ✓ Formatter
         * ✓ Lock (with custom wrapper)
         * 
         * Any class implementing AutoCloseable
         */
    }
    
    /**
     * Benefits summary
     */
    public static void benefitsSummary() {
        /**
         * TRY-WITH-RESOURCES BENEFITS:
         * 
         * 1. AUTOMATIC:
         *    - No manual close
         *    - Can't forget
         * 
         * 2. SAFE:
         *    - Always closes
         *    - Even on exception
         *    - Even on early return
         * 
         * 3. CONCISE:
         *    - 1 line vs 9 lines
         *    - Clear intent
         *    - Less boilerplate
         * 
         * 4. CORRECT:
         *    - Proper close order
         *    - Suppressed exceptions
         *    - No resource leaks
         * 
         * 5. MAINTAINABLE:
         *    - Easy to read
         *    - Hard to get wrong
         *    - Clear scope
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Resource Leak Problem ===");
        resourceLeakProblem();
        
        System.out.println("\n=== Manual Resource Management ===");
        manualResourceManagement();
        
        System.out.println("\n=== Try-Finally Solution ===");
        tryFinallySolution();
        
        System.out.println("\n=== Try-With-Resources Solution ===");
        tryWithResourcesSolution();
        
        System.out.println("\n=== How It Works ===");
        howItWorks();
    }
}
```

---

## 2. AutoCloseable vs Closeable

### Understanding the Interfaces

```java
/**
 * AUTOCLOSEABLE VS CLOSEABLE
 * 
 * Two interfaces for resource management
 */

import java.io.*;

public class AutoCloseableVsCloseable {
    
    /**
     * The interfaces
     */
    public static void theInterfaces() {
        /**
         * AUTOCLOSEABLE (Java 7):
         * 
         * package java.lang;
         * 
         * public interface AutoCloseable {
         *     void close() throws Exception;
         *              ^^^^^^^^^^^^^^^^^^^^
         *              Can throw ANY exception
         * }
         * 
         * 
         * CLOSEABLE (Java 5):
         * 
         * package java.io;
         * 
         * public interface Closeable extends AutoCloseable {
         *     void close() throws IOException;
         *              ^^^^^^^^^^^^^^^^^^^^^^^
         *              Only throws IOException
         * }
         * 
         * 
         * KEY DIFFERENCES:
         * 
         * AutoCloseable:
         * - Generic interface
         * - close() throws Exception
         * - Any resource type
         * - Since Java 7
         * 
         * Closeable:
         * - I/O specific
         * - close() throws IOException
         * - I/O resources only
         * - Extends AutoCloseable
         * - Since Java 5
         */
    }
    
    /**
     * When to use AutoCloseable
     */
    static class DatabaseConnection implements AutoCloseable {
        public DatabaseConnection() {
            System.out.println("Opening database connection");
        }
        
        @Override
        public void close() throws Exception {
            System.out.println("Closing database connection");
            // Can throw any Exception
            // throw new SQLException("Connection close failed");
        }
    }
    
    public static void whenToUseAutoCloseable() {
        try (DatabaseConnection conn = new DatabaseConnection()) {
            System.out.println("Using connection");
        } catch (Exception e) {
            System.out.println("Error: " + e.getMessage());
        }
        
        /**
         * USE AUTOCLOSEABLE FOR:
         * 
         * - Non-I/O resources
         * - Database connections
         * - Network connections
         * - Locks
         * - Custom resources
         * - May throw different exceptions
         */
    }
    
    /**
     * When to use Closeable
     */
    static class CustomInputStream implements Closeable {
        @Override
        public void close() throws IOException {
            System.out.println("Closing stream");
            // Can only throw IOException
        }
    }
    
    public static void whenToUseCloseable() {
        try (CustomInputStream stream = new CustomInputStream()) {
            System.out.println("Using stream");
        } catch (IOException e) {
            System.out.println("I/O error: " + e.getMessage());
        }
        
        /**
         * USE CLOSEABLE FOR:
         * 
         * - I/O resources
         * - Streams
         * - Readers/Writers
         * - Files
         * - Only throws IOException
         * - More specific contract
         */
    }
    
    /**
     * Idempotence requirement
     */
    public static void idempotenceRequirement() {
        /**
         * CLOSEABLE CONTRACT:
         * 
         * From Closeable javadoc:
         * "Closing a previously closed stream has NO EFFECT"
         * 
         * Must be idempotent:
         * - First close() does cleanup
         * - Subsequent close() do nothing
         * - Don't throw exception on second close
         * 
         * 
         * AUTOCLOSEABLE:
         * 
         * Idempotence not required
         * But recommended
         * 
         * 
         * BEST PRACTICE:
         * 
         * Make close() idempotent
         * Safe to call multiple times
         */
    }
    
    /**
     * Idempotent close example
     */
    static class IdempotentResource implements AutoCloseable {
        private boolean closed = false;
        
        @Override
        public void close() {
            if (closed) {
                return;  // Already closed, no-op
            }
            
            System.out.println("Closing resource");
            // Actual cleanup
            closed = true;
        }
    }
    
    public static void idempotentCloseExample() {
        IdempotentResource resource = new IdempotentResource();
        resource.close();  // Closes
        resource.close();  // No-op
        resource.close();  // No-op
        
        /**
         * IDEMPOTENT PATTERN:
         * 
         * 1. Track closed state
         * 2. Check in close()
         * 3. Return early if closed
         * 4. Do cleanup
         * 5. Set closed flag
         * 
         * Safe to call multiple times
         */
    }
    
    /**
     * Exception handling differences
     */
    public static void exceptionHandlingDifferences() {
        /**
         * AUTOCLOSEABLE:
         * 
         * try (AutoCloseableResource r = ...) {
         *     // use
         * } catch (Exception e) {  // Broad catch needed
         *     // Handle any exception
         * }
         * 
         * 
         * CLOSEABLE:
         * 
         * try (CloseableResource r = ...) {
         *     // use
         * } catch (IOException e) {  // Specific catch
         *     // Handle I/O exception
         * }
         * 
         * 
         * CHOOSE BASED ON:
         * 
         * AutoCloseable:
         * - Generic resources
         * - May throw different types
         * 
         * Closeable:
         * - I/O resources
         * - Only throws IOException
         * - More specific contract
         */
    }
    
    /**
     * Hierarchy and compatibility
     */
    public static void hierarchyAndCompatibility() {
        /**
         * HIERARCHY:
         * 
         * AutoCloseable (interface)
         *    ↑
         *    └── Closeable (interface)
         *           ↑
         *           ├── InputStream
         *           ├── OutputStream
         *           ├── Reader
         *           ├── Writer
         *           └── etc.
         * 
         * 
         * COMPATIBILITY:
         * 
         * Closeable IS AutoCloseable
         * Can use Closeable where AutoCloseable expected
         * 
         * try (AutoCloseable r = new FileReader("file.txt")) {
         *     // FileReader is Closeable is AutoCloseable
         * }
         * 
         * 
         * OVERRIDE RULES:
         * 
         * class MyStream implements Closeable {
         *     @Override
         *     public void close() throws IOException {
         *         // Must throw IOException or less
         *         // Can't throw Exception
         *     }
         * }
         */
    }
    
    /**
     * Design decision guidelines
     */
    public static void designDecisionGuidelines() {
        /**
         * CHOOSING THE INTERFACE:
         * 
         * Choose CLOSEABLE when:
         * ✓ I/O resource
         * ✓ Only throws IOException
         * ✓ Following I/O conventions
         * ✓ Want specific contract
         * 
         * Choose AUTOCLOSEABLE when:
         * ✓ Non-I/O resource
         * ✓ May throw different exceptions
         * ✓ Custom resource type
         * ✓ Generic resource management
         * 
         * 
         * DEFAULT CHOICE:
         * 
         * If I/O → Closeable
         * If other → AutoCloseable
         * 
         * When in doubt → AutoCloseable (more generic)
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== The Interfaces ===");
        theInterfaces();
        
        System.out.println("\n=== Use AutoCloseable ===");
        whenToUseAutoCloseable();
        
        System.out.println("\n=== Use Closeable ===");
        whenToUseCloseable();
        
        System.out.println("\n=== Idempotent Close ===");
        idempotentCloseExample();
    }
}
```

---

## 3. Multiple Resources in Try-With-Resources

### Managing Multiple Resources

```java
/**
 * MULTIPLE RESOURCES IN TRY-WITH-RESOURCES
 * 
 * Handling multiple resources correctly
 */

import java.io.*;
import java.util.*;

public class MultipleResources {
    
    /**
     * Basic multiple resources
     */
    public static void basicMultipleResources() {
        try (FileReader reader = new FileReader("input.txt");
             FileWriter writer = new FileWriter("output.txt")) {
            
            int data;
            while ((data = reader.read()) != -1) {
                writer.write(data);
            }
            
        } catch (IOException e) {
            System.out.println("I/O error: " + e.getMessage());
        }
        
        // Both reader and writer closed automatically
        // In REVERSE order: writer first, then reader
        
        /**
         * MULTIPLE RESOURCES SYNTAX:
         * 
         * try (Resource1 r1 = new Resource1();
         *      Resource2 r2 = new Resource2();
         *      Resource3 r3 = new Resource3()) {
         *     // Use resources
         * }
         * 
         * Separated by semicolons
         * Close in reverse order
         */
    }
    
    /**
     * Close order demonstration
     */
    static class Resource implements AutoCloseable {
        private final String name;
        
        Resource(String name) {
            this.name = name;
            System.out.println("Opening: " + name);
        }
        
        @Override
        public void close() {
            System.out.println("Closing: " + name);
        }
    }
    
    public static void closeOrderDemo() {
        try (Resource r1 = new Resource("First");
             Resource r2 = new Resource("Second");
             Resource r3 = new Resource("Third")) {
            
            System.out.println("Using resources");
        }
        
        /**
         * OUTPUT:
         * Opening: First
         * Opening: Second
         * Opening: Third
         * Using resources
         * Closing: Third
         * Closing: Second
         * Closing: First
         * 
         * REVERSE ORDER CLOSING!
         * Like a stack: LIFO
         * Last opened, first closed
         */
    }
    
    /**
     * Why reverse order?
     */
    public static void whyReverseOrder() {
        /**
         * REVERSE ORDER REASON:
         * 
         * Later resources may depend on earlier ones
         * 
         * Example:
         * try (Connection conn = getConnection();
         *      Statement stmt = conn.createStatement();
         *      ResultSet rs = stmt.executeQuery("...")) {
         *     // Use rs
         * }
         * 
         * Dependencies:
         * rs depends on stmt
         * stmt depends on conn
         * 
         * Close order:
         * 1. rs.close()    (depends on stmt)
         * 2. stmt.close()  (depends on conn)
         * 3. conn.close()  (independent)
         * 
         * Reverse order ensures:
         * - Dependent resources closed first
         * - No use-after-close
         * - Proper cleanup
         */
    }
    
    /**
     * Dependent resources example
     */
    public static void dependentResourcesExample() {
        try (FileInputStream fis = new FileInputStream("data.txt");
             BufferedInputStream bis = new BufferedInputStream(fis)) {
            
            int data = bis.read();
            
        } catch (IOException e) {
            System.out.println("Error: " + e.getMessage());
        }
        
        /**
         * DEPENDENCIES:
         * 
         * bis wraps fis
         * bis depends on fis
         * 
         * Close order:
         * 1. bis.close()  (closes and flushes buffer)
         * 2. fis.close()  (closes file)
         * 
         * Correct order guarantees:
         * - Buffer flushed before file closed
         * - No data loss
         */
    }
    
    /**
     * Exception during resource initialization
     */
    static class FailingResource implements AutoCloseable {
        private final String name;
        private final boolean failOnInit;
        
        FailingResource(String name, boolean failOnInit) throws Exception {
            this.name = name;
            this.failOnInit = failOnInit;
            System.out.println("Opening: " + name);
            
            if (failOnInit) {
                throw new Exception("Init failed: " + name);
            }
        }
        
        @Override
        public void close() {
            System.out.println("Closing: " + name);
        }
    }
    
    public static void exceptionDuringInit() {
        try (FailingResource r1 = new FailingResource("R1", false);
             FailingResource r2 = new FailingResource("R2", true);
             FailingResource r3 = new FailingResource("R3", false)) {
            
            System.out.println("Using resources");
            
        } catch (Exception e) {
            System.out.println("Error: " + e.getMessage());
        }
        
        /**
         * OUTPUT:
         * Opening: R1
         * Opening: R2
         * Error: Init failed: R2
         * Closing: R1
         * 
         * BEHAVIOR:
         * 
         * R1 opened successfully
         * R2 failed on init
         * R3 never initialized
         * 
         * Only R1 gets closed
         * (Only successfully initialized resources closed)
         * 
         * IMPORTANT:
         * Resources initialized before failure get closed
         * Resources after failure not initialized
         */
    }
    
    /**
     * Complex resource initialization
     */
    public static void complexResourceInit() {
        try (Scanner scanner = new Scanner(new File("input.txt"));
             PrintWriter writer = new PrintWriter(new File("output.txt"))) {
            
            while (scanner.hasNextLine()) {
                writer.println(scanner.nextLine());
            }
            
        } catch (FileNotFoundException e) {
            System.out.println("File not found: " + e.getMessage());
        }
        
        /**
         * RESOURCE CREATION:
         * 
         * Scanner and PrintWriter created inline
         * File objects created as arguments
         * File objects not AutoCloseable (no close needed)
         * 
         * Only Scanner and PrintWriter closed
         */
    }
    
    /**
     * Separating resource creation
     */
    public static void separatingResourceCreation() {
        File inputFile = new File("input.txt");
        File outputFile = new File("output.txt");
        
        try (Scanner scanner = new Scanner(inputFile);
             PrintWriter writer = new PrintWriter(outputFile)) {
            
            // Use resources
            
        } catch (FileNotFoundException e) {
            System.out.println("Error: " + e.getMessage());
        }
        
        /**
         * BEST PRACTICE:
         * 
         * Separate resource creation from initialization
         * Clearer code
         * Easier debugging
         * 
         * BUT:
         * Only AutoCloseable resources in try()
         * Non-closeable resources before
         */
    }
    
    /**
     * Same resource type
     */
    public static void sameResourceType() {
        try (FileReader r1 = new FileReader("file1.txt");
             FileReader r2 = new FileReader("file2.txt");
             FileReader r3 = new FileReader("file3.txt")) {
            
            // Read from multiple files
            
        } catch (IOException e) {
            System.out.println("Error: " + e.getMessage());
        }
        
        /**
         * MULTIPLE SAME TYPE:
         * 
         * Perfectly valid
         * Each needs unique name
         * Closed in reverse order
         */
    }
    
    /**
     * Best practices
     */
    public static void bestPractices() {
        /**
         * MULTIPLE RESOURCES BEST PRACTICES:
         * 
         * ✅ DO:
         * - Use semicolons between resources
         * - Rely on reverse close order
         * - One resource per line (readability)
         * - Name variables clearly
         * 
         * ❌ DON'T:
         * - Assume close order
         * - Create circular dependencies
         * - Put non-AutoCloseable in try()
         * - Ignore initialization exceptions
         * 
         * 
         * FORMATTING:
         * 
         * // Good: One per line
         * try (Resource r1 = new Resource();
         *      Resource r2 = new Resource()) {
         * 
         * // Acceptable: Short declarations
         * try (Resource r1 = new Resource(); Resource r2 = new Resource()) {
         * 
         * // Best for many resources: One per line
         * try (Resource r1 = new Resource();
         *      Resource r2 = new Resource();
         *      Resource r3 = new Resource();
         *      Resource r4 = new Resource()) {
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Basic Multiple Resources ===");
        basicMultipleResources();
        
        System.out.println("\n=== Close Order Demo ===");
        closeOrderDemo();
        
        System.out.println("\n=== Why Reverse Order ===");
        whyReverseOrder();
        
        System.out.println("\n=== Exception During Init ===");
        exceptionDuringInit();
    }
}
```

---

## 4. Suppressed Exceptions in Try-With-Resources

### Understanding Exception Suppression

```java
/**
 * SUPPRESSED EXCEPTIONS IN TWR
 * 
 * How TWR handles multiple exceptions
 */

import java.io.*;

public class SuppressedExceptionsTWR {
    
    /**
     * The suppression problem
     */
    static class ThrowingResource implements AutoCloseable {
        private final String name;
        private final boolean throwOnUse;
        private final boolean throwOnClose;
        
        ThrowingResource(String name, boolean throwOnUse, boolean throwOnClose) {
            this.name = name;
            this.throwOnUse = throwOnUse;
            this.throwOnClose = throwOnClose;
            System.out.println("Created: " + name);
        }
        
        public void use() {
            System.out.println("Using: " + name);
            if (throwOnUse) {
                throw new RuntimeException(name + " use failed");
            }
        }
        
        @Override
        public void close() {
            System.out.println("Closing: " + name);
            if (throwOnClose) {
                throw new RuntimeException(name + " close failed");
            }
        }
    }
    
    /**
     * Single exception in try block
     */
    public static void singleExceptionInTry() {
        try (ThrowingResource r = new ThrowingResource("R1", true, false)) {
            r.use();  // Throws
        } catch (Exception e) {
            System.out.println("Caught: " + e.getMessage());
            System.out.println("Suppressed count: " + e.getSuppressed().length);
        }
        
        /**
         * OUTPUT:
         * Created: R1
         * Using: R1
         * Closing: R1
         * Caught: R1 use failed
         * Suppressed count: 0
         * 
         * No suppression needed
         * Only one exception
         */
    }
    
    /**
     * Single exception in close
     */
    public static void singleExceptionInClose() {
        try (ThrowingResource r = new ThrowingResource("R1", false, true)) {
            r.use();  // Succeeds
        } catch (Exception e) {
            System.out.println("Caught: " + e.getMessage());
            System.out.println("Suppressed count: " + e.getSuppressed().length);
        }
        
        /**
         * OUTPUT:
         * Created: R1
         * Using: R1
         * Closing: R1
         * Caught: R1 close failed
         * Suppressed count: 0
         * 
         * Close exception is primary
         * No suppression needed
         */
    }
    
    /**
     * Exceptions in both try and close
     */
    public static void exceptionsInBoth() {
        try (ThrowingResource r = new ThrowingResource("R1", true, true)) {
            r.use();  // Throws
            // close() also throws
        } catch (Exception e) {
            System.out.println("Primary: " + e.getMessage());
            
            Throwable[] suppressed = e.getSuppressed();
            System.out.println("Suppressed count: " + suppressed.length);
            
            for (Throwable s : suppressed) {
                System.out.println("Suppressed: " + s.getMessage());
            }
        }
        
        /**
         * OUTPUT:
         * Created: R1
         * Using: R1
         * Closing: R1
         * Primary: R1 use failed
         * Suppressed count: 1
         * Suppressed: R1 close failed
         * 
         * SUPPRESSION:
         * Primary: try block exception
         * Suppressed: close exception
         * 
         * Try block exception is more important
         * Close exception preserved but suppressed
         */
    }
    
    /**
     * Multiple resources with exceptions
     */
    public static void multipleResourcesWithExceptions() {
        try (ThrowingResource r1 = new ThrowingResource("R1", false, true);
             ThrowingResource r2 = new ThrowingResource("R2", false, true);
             ThrowingResource r3 = new ThrowingResource("R3", true, true)) {
            
            r3.use();  // Throws
            
        } catch (Exception e) {
            System.out.println("Primary: " + e.getMessage());
            
            System.out.println("\nSuppressed exceptions:");
            for (Throwable s : e.getSuppressed()) {
                System.out.println("  " + s.getMessage());
            }
        }
        
        /**
         * OUTPUT:
         * Created: R1
         * Created: R2
         * Created: R3
         * Using: R3
         * Closing: R3
         * Closing: R2
         * Closing: R1
         * Primary: R3 use failed
         * 
         * Suppressed exceptions:
         *   R3 close failed
         *   R2 close failed
         *   R1 close failed
         * 
         * MULTIPLE SUPPRESSION:
         * 
         * Primary: R3 use exception
         * Suppressed: All close exceptions
         * Order: R3, R2, R1 (close order)
         */
    }
    
    /**
     * Accessing suppressed exceptions
     */
    public static void accessingSuppressedExceptions() {
        try (ThrowingResource r = new ThrowingResource("R1", true, true)) {
            r.use();
        } catch (Exception e) {
            // Primary exception
            System.out.println("Primary: " + e.getMessage());
            e.printStackTrace();
            
            // Suppressed exceptions
            Throwable[] suppressed = e.getSuppressed();
            
            if (suppressed.length > 0) {
                System.out.println("\nSuppressed exceptions:");
                
                for (int i = 0; i < suppressed.length; i++) {
                    System.out.println(i + ": " + suppressed[i].getMessage());
                    suppressed[i].printStackTrace();
                }
            }
        }
        
        /**
         * ACCESSING PATTERN:
         * 
         * Throwable[] suppressed = exception.getSuppressed();
         * 
         * Returns array of suppressed exceptions
         * Empty array if none
         * Never null
         */
    }
    
    /**
     * Why suppression matters
     */
    public static void whySuppressionMatters() {
        /**
         * WHY SUPPRESSION IS IMPORTANT:
         * 
         * 1. COMPLETE INFORMATION:
         *    - See ALL exceptions
         *    - Try block exception
         *    - All close exceptions
         * 
         * 2. DEBUGGING:
         *    - Why did close fail?
         *    - Resource cleanup issues?
         *    - Connection problems?
         * 
         * 3. PRODUCTION MONITORING:
         *    - Log all exceptions
         *    - Detect cleanup issues
         *    - Prevent resource leaks
         * 
         * 
         * WITHOUT SUPPRESSION:
         * 
         * Only see one exception
         * Lose close exception information
         * Harder to debug
         * 
         * 
         * WITH SUPPRESSION:
         * 
         * All exceptions preserved
         * Complete error context
         * Better debugging
         */
    }
    
    /**
     * Logging suppressed exceptions
     */
    public static void loggingSuppressed() {
        try (ThrowingResource r = new ThrowingResource("R1", true, true)) {
            r.use();
        } catch (Exception e) {
            // Log primary exception
            System.err.println("ERROR: " + e.getMessage());
            
            // Log suppressed exceptions
            Throwable[] suppressed = e.getSuppressed();
            if (suppressed.length > 0) {
                System.err.println("Suppressed exceptions during cleanup:");
                for (Throwable s : suppressed) {
                    System.err.println("  - " + s.getMessage());
                }
            }
            
            // Or just: e.printStackTrace()
            // Automatically shows suppressed
        }
        
        /**
         * LOGGING BEST PRACTICE:
         * 
         * Always log suppressed exceptions
         * They indicate cleanup problems
         * Important for production debugging
         */
    }
    
    /**
     * Suppression order
     */
    public static void suppressionOrder() {
        /**
         * SUPPRESSION ORDER:
         * 
         * Resources closed in reverse order
         * Suppressed exceptions added in close order
         * 
         * try (R1 r1 = new R1();
         *      R2 r2 = new R2();
         *      R3 r3 = new R3()) {
         *     throw new Exception("Primary");
         * }
         * 
         * Execution order:
         * 1. Primary exception thrown
         * 2. r3.close() - exception suppressed
         * 3. r2.close() - exception suppressed
         * 4. r1.close() - exception suppressed
         * 
         * getSuppressed() returns:
         * [r3 close exception, r2 close exception, r1 close exception]
         * 
         * Order matches close order
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Single Exception in Try ===");
        singleExceptionInTry();
        
        System.out.println("\n=== Single Exception in Close ===");
        singleExceptionInClose();
        
        System.out.println("\n=== Exceptions in Both ===");
        exceptionsInBoth();
        
        System.out.println("\n=== Multiple Resources ===");
        multipleResourcesWithExceptions();
    }
}
```

---

## 5. Resource Ordering and Closing

### Detailed Closing Behavior

```java
/**
 * RESOURCE ORDERING AND CLOSING
 * 
 * Understanding resource lifecycle
 */

import java.io.*;

public class ResourceOrderingAndClosing {
    
    /**
     * Resource lifecycle
     */
    static class LifecycleResource implements AutoCloseable {
        private final String name;
        private boolean closed = false;
        
        LifecycleResource(String name) {
            this.name = name;
            System.out.println("1. Constructor: " + name);
        }
        
        public void initialize() {
            System.out.println("2. Initialize: " + name);
        }
        
        public void use() {
            if (closed) {
                throw new IllegalStateException("Already closed: " + name);
            }
            System.out.println("3. Use: " + name);
        }
        
        @Override
        public void close() {
            if (closed) {
                System.out.println("4. Already closed: " + name);
                return;
            }
            System.out.println("4. Close: " + name);
            closed = true;
        }
    }
    
    public static void resourceLifecycle() {
        try (LifecycleResource r = new LifecycleResource("Resource")) {
            r.initialize();
            r.use();
        }
        
        /**
         * OUTPUT:
         * 1. Constructor: Resource
         * 2. Initialize: Resource
         * 3. Use: Resource
         * 4. Close: Resource
         * 
         * LIFECYCLE:
         * 1. Resource created
         * 2. Initialized
         * 3. Used
         * 4. Automatically closed
         */
    }
    
    /**
     * LIFO closing order
     */
    static class OrderedResource implements AutoCloseable {
        private static int constructorOrder = 0;
        private static int closeOrder = 0;
        
        private final String name;
        private final int constructionOrder;
        
        OrderedResource(String name) {
            this.name = name;
            this.constructionOrder = ++constructorOrder;
            System.out.println("Create " + constructionOrder + ": " + name);
        }
        
        @Override
        public void close() {
            int order = ++closeOrder;
            System.out.println("Close " + order + ": " + name + 
                             " (created " + constructionOrder + ")");
        }
        
        public static void reset() {
            constructorOrder = 0;
            closeOrder = 0;
        }
    }
    
    public static void lifoClosingOrder() {
        OrderedResource.reset();
        
        try (OrderedResource r1 = new OrderedResource("First");
             OrderedResource r2 = new OrderedResource("Second");
             OrderedResource r3 = new OrderedResource("Third");
             OrderedResource r4 = new OrderedResource("Fourth")) {
            
            System.out.println("Using resources...");
        }
        
        /**
         * OUTPUT:
         * Create 1: First
         * Create 2: Second
         * Create 3: Third
         * Create 4: Fourth
         * Using resources...
         * Close 1: Fourth (created 4)
         * Close 2: Third (created 3)
         * Close 3: Second (created 2)
         * Close 4: First (created 1)
         * 
         * LIFO: Last In, First Out
         * Like a stack
         * Reverse of creation order
         */
    }
    
    /**
     * Partial initialization
     */
    static class InitializingResource implements AutoCloseable {
        private final String name;
        
        InitializingResource(String name, boolean failOnInit) throws Exception {
            this.name = name;
            System.out.println("Creating: " + name);
            
            if (failOnInit) {
                throw new Exception("Init failed: " + name);
            }
            
            System.out.println("Created successfully: " + name);
        }
        
        @Override
        public void close() {
            System.out.println("Closing: " + name);
        }
    }
    
    public static void partialInitialization() {
        try (InitializingResource r1 = new InitializingResource("R1", false);
             InitializingResource r2 = new InitializingResource("R2", false);
             InitializingResource r3 = new InitializingResource("R3", true);
             InitializingResource r4 = new InitializingResource("R4", false)) {
            
            System.out.println("Using resources");
            
        } catch (Exception e) {
            System.out.println("Error: " + e.getMessage());
        }
        
        /**
         * OUTPUT:
         * Creating: R1
         * Created successfully: R1
         * Creating: R2
         * Created successfully: R2
         * Creating: R3
         * Error: Init failed: R3
         * Closing: R2
         * Closing: R1
         * 
         * IMPORTANT:
         * 
         * R1, R2 created successfully → Closed
         * R3 failed → Not closed (never fully created)
         * R4 never created → Not closed
         * 
         * Only successfully created resources are closed
         */
    }
    
    /**
     * Close happens even on early return
     */
    public static void closeOnEarlyReturn() {
        try (LifecycleResource r = new LifecycleResource("Resource")) {
            r.use();
            
            if (true) {
                System.out.println("Early return");
                return;  // Early return
            }
            
            System.out.println("This never executes");
            
        }
        // close() still called!
        
        /**
         * OUTPUT:
         * 1. Constructor: Resource
         * 3. Use: Resource
         * Early return
         * 4. Close: Resource
         * 
         * Close happens despite early return
         * Guaranteed cleanup
         */
    }
    
    /**
     * Close happens even on exception
     */
    public static void closeOnException() {
        try (LifecycleResource r = new LifecycleResource("Resource")) {
            r.use();
            throw new RuntimeException("Error during use");
        } catch (RuntimeException e) {
            System.out.println("Caught: " + e.getMessage());
        }
        
        /**
         * OUTPUT:
         * 1. Constructor: Resource
         * 3. Use: Resource
         * 4. Close: Resource
         * Caught: Error during use
         * 
         * Close happens before exception propagates
         * Resource cleaned up
         */
    }
    
    /**
     * Dependency order
     */
    public static void dependencyOrder() throws IOException {
        /**
         * COMMON PATTERN:
         * 
         * Dependent resources in creation order
         * Closed in reverse = correct cleanup
         */
        
        try (FileInputStream fis = new FileInputStream("data.txt");
             BufferedInputStream bis = new BufferedInputStream(fis);
             DataInputStream dis = new DataInputStream(bis)) {
            
            // dis wraps bis wraps fis
            // Dependencies: dis → bis → fis
            
            // Use dis
            
        } // Closing order: dis, bis, fis ✓
        
        /**
         * DEPENDENCY CHAIN:
         * 
         * dis depends on bis
         * bis depends on fis
         * fis depends on nothing
         * 
         * Close order (reverse):
         * 1. dis.close()  - closes DataInputStream
         * 2. bis.close()  - flushes buffer, closes wrapper
         * 3. fis.close()  - closes file
         * 
         * Correct order ensures:
         * - Buffers flushed before stream closed
         * - Wrappers closed before base stream
         * - No use-after-close
         */
    }
    
    /**
     * Close idempotence
     */
    static class IdempotentCloseResource implements AutoCloseable {
        private boolean closed = false;
        
        @Override
        public void close() {
            if (closed) {
                System.out.println("Already closed, no-op");
                return;
            }
            
            System.out.println("Closing resource");
            // Actual cleanup
            closed = true;
        }
    }
    
    public static void closeIdempotence() {
        IdempotentCloseResource resource = new IdempotentCloseResource();
        
        resource.close();  // First close
        resource.close();  // Second close (no-op)
        resource.close();  // Third close (no-op)
        
        /**
         * IDEMPOTENCE:
         * 
         * close() safe to call multiple times
         * First call does cleanup
         * Subsequent calls do nothing
         * 
         * Required by Closeable
         * Recommended for AutoCloseable
         * 
         * Benefits:
         * - Safe in complex finally blocks
         * - No error on accidental double-close
         * - Defensive programming
         */
    }
    
    /**
     * Close order guarantees
     */
    public static void closeOrderGuarantees() {
        /**
         * CLOSE ORDER GUARANTEES:
         * 
         * 1. REVERSE OF DECLARATION:
         *    Resources closed in reverse order
         *    Last declared, first closed
         * 
         * 2. ONLY INITIALIZED RESOURCES:
         *    Only successfully created resources closed
         *    Partial initialization handled correctly
         * 
         * 3. ALWAYS ATTEMPTS CLOSE:
         *    Even if exception in try block
         *    Even if earlier close fails
         *    All closes attempted
         * 
         * 4. SUPPRESSION ON FAILURE:
         *    If close fails, next close still attempted
         *    Failed closes added to suppressed
         * 
         * 5. EXCEPTION PRIORITY:
         *    Try block exception is primary
         *    Close exceptions are suppressed
         */
    }
    
    public static void main(String[] args) throws IOException {
        System.out.println("=== Resource Lifecycle ===");
        resourceLifecycle();
        
        System.out.println("\n=== LIFO Closing Order ===");
        lifoClosingOrder();
        
        System.out.println("\n=== Partial Initialization ===");
        partialInitialization();
        
        System.out.println("\n=== Close on Early Return ===");
        closeOnEarlyReturn();
        
        System.out.println("\n=== Close on Exception ===");
        closeOnException();
    }
}
```

---

## 6. Custom AutoCloseable Implementations

### Creating Your Own Resources

```java
/**
 * CUSTOM AUTOCLOSEABLE IMPLEMENTATIONS
 * 
 * Best practices for implementing AutoCloseable
 */

import java.util.concurrent.locks.*;

public class CustomAutoCloseableImpl {
    
    /**
     * Basic implementation
     */
    static class BasicResource implements AutoCloseable {
        private boolean closed = false;
        
        public BasicResource() {
            System.out.println("Resource created");
            // Allocate resources
        }
        
        public void doWork() {
            if (closed) {
                throw new IllegalStateException("Resource is closed");
            }
            System.out.println("Doing work");
        }
        
        @Override
        public void close() {
            if (closed) {
                return;  // Idempotent
            }
            
            System.out.println("Resource closed");
            // Release resources
            closed = true;
        }
    }
    
    /**
     * Lock wrapper
     */
    static class LockWrapper implements AutoCloseable {
        private final Lock lock;
        
        public LockWrapper(Lock lock) {
            this.lock = lock;
            lock.lock();  // Acquire in constructor
        }
        
        @Override
        public void close() {
            lock.unlock();  // Release in close
        }
    }
    
    public static void lockWrapperExample() {
        Lock lock = new ReentrantLock();
        
        try (LockWrapper wrapper = new LockWrapper(lock)) {
            // Critical section
            System.out.println("Lock held");
            
        } // Lock automatically released
        
        /**
         * LOCK PATTERN:
         * 
         * Acquire in constructor
         * Release in close()
         * Guaranteed release with TWR
         * 
         * Better than:
         * lock.lock();
         * try {
         *     ...
         * } finally {
         *     lock.unlock();
         * }
         */
    }
    
    /**
     * Timer resource
     */
    static class TimedOperation implements AutoCloseable {
        private final String operationName;
        private final long startTime;
        
        public TimedOperation(String operationName) {
            this.operationName = operationName;
            this.startTime = System.nanoTime();
            System.out.println("Started: " + operationName);
        }
        
        @Override
        public void close() {
            long endTime = System.nanoTime();
            long durationMs = (endTime - startTime) / 1_000_000;
            System.out.println("Finished: " + operationName + 
                             " (" + durationMs + "ms)");
        }
    }
    
    public static void timedOperationExample() {
        try (TimedOperation timer = new TimedOperation("Database Query")) {
            // Simulate work
            Thread.sleep(100);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        /**
         * TIMER PATTERN:
         * 
         * Start timing in constructor
         * End timing in close()
         * Automatic duration logging
         * 
         * Great for:
         * - Performance monitoring
         * - Operation tracking
         * - Profiling
         */
    }
    
    /**
     * Temporary file resource
     */
    static class TempFile implements AutoCloseable {
        private final java.io.File file;
        
        public TempFile(String prefix) throws java.io.IOException {
            this.file = java.io.File.createTempFile(prefix, ".tmp");
            System.out.println("Created temp file: " + file.getAbsolutePath());
        }
        
        public java.io.File getFile() {
            return file;
        }
        
        @Override
        public void close() {
            if (file.exists()) {
                if (file.delete()) {
                    System.out.println("Deleted temp file");
                } else {
                    System.err.println("Failed to delete temp file");
                }
            }
        }
    }
    
    public static void tempFileExample() {
        try (TempFile temp = new TempFile("test")) {
            java.io.File file = temp.getFile();
            // Use temp file
            System.out.println("Using: " + file.getName());
            
        } catch (java.io.IOException e) {
            System.err.println("Error: " + e.getMessage());
        }
        
        /**
         * TEMP FILE PATTERN:
         * 
         * Create in constructor
         * Delete in close()
         * Guaranteed cleanup
         * 
         * No temp file leaks
         * Clean filesystem
         */
    }
    
    /**
     * State machine resource
     */
    static class StateMachineResource implements AutoCloseable {
        enum State { CREATED, INITIALIZED, ACTIVE, CLOSED }
        
        private State state = State.CREATED;
        
        public void initialize() {
            if (state != State.CREATED) {
                throw new IllegalStateException("Already initialized");
            }
            System.out.println("Initializing");
            state = State.INITIALIZED;
        }
        
        public void activate() {
            if (state != State.INITIALIZED) {
                throw new IllegalStateException("Must be initialized");
            }
            System.out.println("Activating");
            state = State.ACTIVE;
        }
        
        public void doWork() {
            if (state != State.ACTIVE) {
                throw new IllegalStateException("Must be active");
            }
            System.out.println("Working");
        }
        
        @Override
        public void close() {
            if (state == State.CLOSED) {
                return;  // Idempotent
            }
            
            System.out.println("Closing from state: " + state);
            state = State.CLOSED;
        }
    }
    
    /**
     * Implementation best practices
     */
    public static void implementationBestPractices() {
        /**
         * AUTOCLOSEABLE BEST PRACTICES:
         * 
         * 1. IDEMPOTENCE:
         *    ✅ Make close() idempotent
         *    ✅ Track closed state
         *    ✅ Return early if closed
         * 
         * 2. STATE CHECKING:
         *    ✅ Check state in methods
         *    ✅ Throw IllegalStateException if closed
         *    ✅ Clear error messages
         * 
         * 3. EXCEPTION HANDLING:
         *    ✅ close() should not throw unless critical
         *    ✅ Catch and log exceptions in close()
         *    ✅ Don't suppress important errors
         * 
         * 4. RESOURCE CLEANUP:
         *    ✅ Release all resources
         *    ✅ Null out references (help GC)
         *    ✅ Clean up in reverse order
         * 
         * 5. DOCUMENTATION:
         *    ✅ Document what close() does
         *    ✅ Document idempotence
         *    ✅ Document exceptions
         */
    }
    
    /**
     * Complete implementation example
     */
    static class WellImplementedResource implements AutoCloseable {
        private boolean closed = false;
        private final String name;
        
        public WellImplementedResource(String name) {
            this.name = name;
            System.out.println("Created: " + name);
        }
        
        public void doWork() {
            checkNotClosed();
            System.out.println("Working: " + name);
        }
        
        private void checkNotClosed() {
            if (closed) {
                throw new IllegalStateException(
                    "Resource is closed: " + name);
            }
        }
        
        @Override
        public void close() {
            if (closed) {
                return;  // Idempotent
            }
            
            try {
                // Cleanup operations
                System.out.println("Closing: " + name);
                // Release resources here
                
            } catch (Exception e) {
                System.err.println("Error during close: " + e.getMessage());
                // Log but don't rethrow unless critical
                
            } finally {
                closed = true;  // Always mark closed
            }
        }
        
        /**
         * WELL-IMPLEMENTED FEATURES:
         * 
         * ✓ Idempotent close
         * ✓ State tracking
         * ✓ State checking
         * ✓ Exception handling
         * ✓ Clear messages
         * ✓ Finally block
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Lock Wrapper ===");
        lockWrapperExample();
        
        System.out.println("\n=== Timed Operation ===");
        timedOperationExample();
        
        System.out.println("\n=== Temp File ===");
        tempFileExample();
    }
}
```

---

## 7. Before Java 7 Patterns

### Historical Context and Migration

```java
/**
 * BEFORE JAVA 7 PATTERNS
 * 
 * Understanding pre-TWR code
 */

import java.io.*;

public class BeforeJava7Patterns {
    
    /**
     * The old way: try-finally
     */
    public static void oldTryFinallyPattern() {
        FileReader reader = null;
        
        try {
            reader = new FileReader("data.txt");
            
            int data;
            while ((data = reader.read()) != -1) {
                System.out.print((char) data);
            }
            
        } catch (IOException e) {
            System.err.println("Error: " + e.getMessage());
            
        } finally {
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e) {
                    System.err.println("Close failed: " + e.getMessage());
                }
            }
        }
        
        /**
         * OLD PATTERN ISSUES:
         * 
         * ❌ Verbose (9 lines for cleanup)
         * ❌ Nested try-catch
         * ❌ Easy to forget
         * ❌ Suppressed exception problem
         * ❌ Duplication for multiple resources
         */
    }
    
    /**
     * Multiple resources the old way
     */
    public static void oldMultipleResources() {
        FileReader reader = null;
        FileWriter writer = null;
        
        try {
            reader = new FileReader("input.txt");
            writer = new FileWriter("output.txt");
            
            int data;
            while ((data = reader.read()) != -1) {
                writer.write(data);
            }
            
        } catch (IOException e) {
            System.err.println("Error: " + e.getMessage());
            
        } finally {
            // Close reader
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e) {
                    System.err.println("Reader close failed: " + e);
                }
            }
            
            // Close writer
            if (writer != null) {
                try {
                    writer.close();
                } catch (IOException e) {
                    System.err.println("Writer close failed: " + e);
                }
            }
        }
        
        /**
         * MULTIPLE RESOURCES PROBLEMS:
         * 
         * ❌ 18+ lines for cleanup
         * ❌ Duplicated pattern
         * ❌ Easy to miss a resource
         * ❌ Wrong order possible
         */
    }
    
    /**
     * Modern equivalent
     */
    public static void modernEquivalent() {
        try (FileReader reader = new FileReader("input.txt");
             FileWriter writer = new FileWriter("output.txt")) {
            
            int data;
            while ((data = reader.read()) != -1) {
                writer.write(data);
            }
            
        } catch (IOException e) {
            System.err.println("Error: " + e.getMessage());
        }
        
        /**
         * MODERN PATTERN BENEFITS:
         * 
         * ✅ 5 lines vs 18 lines
         * ✅ No nested try-catch
         * ✅ Automatic close
         * ✅ Correct order guaranteed
         * ✅ Suppressed exceptions handled
         */
    }
    
    /**
     * The suppressed exception problem
     */
    public static void suppressedExceptionProblem() {
        /**
         * OLD WAY PROBLEM:
         * 
         * BufferedReader reader = null;
         * try {
         *     reader = new BufferedReader(...);
         *     // Exception thrown here
         *     throw new IOException("Read error");
         * } finally {
         *     if (reader != null) {
         *         reader.close();  // Also throws
         *     }
         * }
         * 
         * Result: Only see close exception
         * Read exception LOST!
         * 
         * 
         * SOLUTION ATTEMPT:
         * 
         * BufferedReader reader = null;
         * IOException primaryException = null;
         * try {
         *     reader = new BufferedReader(...);
         *     // work
         * } catch (IOException e) {
         *     primaryException = e;
         *     throw e;
         * } finally {
         *     if (reader != null) {
         *         try {
         *             reader.close();
         *         } catch (IOException closeException) {
         *             if (primaryException != null) {
         *                 // How to preserve both?
         *                 // No addSuppressed before Java 7!
         *             } else {
         *                 throw closeException;
         *             }
         *         }
         *     }
         * }
         * 
         * Complex and error-prone!
         * 
         * 
         * MODERN SOLUTION:
         * 
         * try (BufferedReader reader = new BufferedReader(...)) {
         *     // work
         * }
         * 
         * Automatic suppression!
         * Both exceptions preserved!
         */
    }
    
    /**
     * Migration patterns
     */
    public static void migrationPatterns() {
        /**
         * MIGRATING TO TWR:
         * 
         * BEFORE:
         * Resource r = null;
         * try {
         *     r = new Resource();
         *     r.use();
         * } finally {
         *     if (r != null) {
         *         r.close();
         *     }
         * }
         * 
         * AFTER:
         * try (Resource r = new Resource()) {
         *     r.use();
         * }
         * 
         * 
         * BENEFITS:
         * ✅ Simpler
         * ✅ Safer
         * ✅ Correct
         * ✅ Less code
         */
    }
    
    /**
     * When you can't use TWR
     */
    public static void whenYouCantUseTWR() {
        /**
         * CANNOT USE TWR WHEN:
         * 
         * 1. Resource outlives method:
         *    Resource created in one method
         *    Closed in another
         *    TWR scope too limited
         * 
         * 2. Conditional closing:
         *    Sometimes close, sometimes not
         *    TWR always closes
         * 
         * 3. Resource reuse:
         *    Same resource used across multiple operations
         *    TWR closes at end of block
         * 
         * 
         * SOLUTIONS:
         * 
         * 1. Manual try-finally:
         *    Resource field = null;
         *    try {
         *        field = new Resource();
         *        return field;  // Don't close
         *    } catch (Exception e) {
         *        if (field != null) {
         *            field.close();
         *        }
         *        throw e;
         *    }
         * 
         * 2. Wrapper class:
         *    Store resource in object
         *    Implement AutoCloseable
         *    Delegate to resource.close()
         */
    }
    
    /**
     * Best practices summary
     */
    public static void bestPracticesSummary() {
        /**
         * BEST PRACTICES:
         * 
         * ✅ DO:
         * - Use try-with-resources (Java 7+)
         * - Implement AutoCloseable for custom resources
         * - Make close() idempotent
         * - Check suppressed exceptions
         * - Rely on automatic closing
         * 
         * ❌ DON'T:
         * - Use try-finally (unless necessary)
         * - Forget to implement AutoCloseable
         * - Ignore close exceptions
         * - Manually close in finally
         * 
         * 
         * MIGRATION:
         * 
         * Replace old try-finally with TWR
         * Simpler, safer, correct
         * 
         * Minimum Java 7 required
         * Well worth it!
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Old Try-Finally ===");
        oldTryFinallyPattern();
        
        System.out.println("\n=== Old Multiple Resources ===");
        oldMultipleResources();
        
        System.out.println("\n=== Modern Equivalent ===");
        modernEquivalent();
    }
}
```

---

## Summary

### Quick Reference

**Basic Try-With-Resources:**

```java
// Single resource
try (Resource r = new Resource()) {
    r.use();
}

// Multiple resources
try (Resource1 r1 = new Resource1();
     Resource2 r2 = new Resource2()) {
    r1.use();
    r2.use();
}
// Closed in reverse order: r2, r1
```

**AutoCloseable vs Closeable:**

```java
// AutoCloseable (generic)
public interface AutoCloseable {
    void close() throws Exception;  // Any exception
}

// Closeable (I/O specific)
public interface Closeable extends AutoCloseable {
    void close() throws IOException;  // Only IOException
}

Use Closeable for I/O
Use AutoCloseable for other resources
```

**Suppressed Exceptions:**

```java
try (Resource r = new Resource()) {
    throw new Exception("Primary");
    // r.close() throws too
} catch (Exception e) {
    // Primary exception
    Throwable[] suppressed = e.getSuppressed();
    // Close exception in suppressed[0]
}
```

**Custom Implementation:**

```java
class MyResource implements AutoCloseable {
    private boolean closed = false;
    
    @Override
    public void close() {
        if (closed) return;  // Idempotent
        
        // Cleanup
        closed = true;
    }
}
```

### Comparison Tables

**Try-With-Resources vs Try-Finally:**

```
┌────────────────┬─────────────────┬──────────────────┐
│ Aspect         │ TWR (Java 7+)   │ Try-Finally      │
├────────────────┼─────────────────┼──────────────────┤
│ Lines of code  │ 1 line          │ 9+ lines         │
│ Suppression    │ Automatic       │ Manual/Complex   │
│ Idempotence    │ Guaranteed      │ Manual           │
│ Error-prone    │ No              │ Yes              │
│ Multiple       │ Easy            │ Duplicative      │
└────────────────┴─────────────────┴──────────────────┘
```

**AutoCloseable vs Closeable:**

```
┌──────────────┬─────────────────┬──────────────────┐
│ Aspect       │ AutoCloseable   │ Closeable        │
├──────────────┼─────────────────┼──────────────────┤
│ Exception    │ Exception       │ IOException      │
│ Scope        │ Generic         │ I/O specific     │
│ Idempotence  │ Recommended     │ Required         │
│ Use case     │ Any resource    │ I/O resources    │
└──────────────┴─────────────────┴──────────────────┘
```

### Best Practices Checklist

**✅ DO:**

- Use try-with-resources for all AutoCloseable resources
- Implement AutoCloseable for custom resources
- Make close() idempotent
- Check suppressed exceptions when debugging
- Close resources in reverse order (automatic with TWR)
- Track closed state
- Log close exceptions

**❌ DON'T:**

- Use try-finally unless absolutely necessary
- Forget null checks in old code
- Ignore suppressed exceptions
- Throw exceptions from close() unless critical
- Assume close order
- Create resources that aren't AutoCloseable

---

