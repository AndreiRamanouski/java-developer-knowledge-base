# Exception Handling Anti-Patterns

## Overview

Understanding what NOT to do is just as important as knowing best practices. This guide covers common exception handling mistakes that plague production code, why they're problematic, and how to fix them. These anti-patterns lead to bugs that are hard to debug, poor error handling, and maintenance nightmares.


---

## 1. Catching Exception or Throwable

### The "Catch-All" Anti-Pattern

```java
/**
 * CATCHING EXCEPTION OR THROWABLE
 * 
 * Why broad catches are dangerous
 */

import java.io.*;

public class CatchingExceptionOrThrowable {
    
    /**
     * Anti-pattern: Catching Exception
     */
    public static void catchingExceptionAntiPattern() {
        try {
            readFile("data.txt");
            processData();
            writeResults();
        } catch (Exception e) {  // ❌ TOO BROAD
            System.out.println("Something went wrong: " + e.getMessage());
        }
        
        /**
         * PROBLEMS:
         * 
         * 1. CATCHES TOO MUCH:
         *    - IOException (expected)
         *    - NullPointerException (bug)
         *    - IllegalArgumentException (bug)
         *    - Any RuntimeException (bugs)
         * 
         * 2. HIDES PROGRAMMING ERRORS:
         *    NullPointerException should crash
         *    Now it's silently caught
         *    Bug goes unnoticed
         * 
         * 3. LOSES SPECIFICITY:
         *    Can't handle different errors differently
         *    All errors treated the same
         * 
         * 4. HARD TO DEBUG:
         *    What actually went wrong?
         *    File missing? NPE? Something else?
         */
    }
    
    private static void readFile(String path) throws IOException {
        new FileReader(path);
    }
    
    private static void processData() {
        // Might throw NullPointerException
    }
    
    private static void writeResults() throws IOException {
        // I/O operations
    }
    
    /**
     * Anti-pattern: Catching Throwable
     */
    public static void catchingThrowableAntiPattern() {
        try {
            doWork();
        } catch (Throwable t) {  // ❌ EXTREMELY DANGEROUS
            System.out.println("Error: " + t.getMessage());
        }
        
        /**
         * WORSE THAN CATCHING EXCEPTION:
         * 
         * Catches EVERYTHING:
         * - Exception (all exceptions)
         * - Error (system errors)
         * - OutOfMemoryError
         * - StackOverflowError
         * - ThreadDeath
         * 
         * 
         * SEVERE PROBLEMS:
         * 
         * 1. MASKS JVM ERRORS:
         *    OutOfMemoryError should terminate
         *    Now application continues in unstable state
         * 
         * 2. CAN'T RECOVER:
         *    From OutOfMemoryError: Can't allocate
         *    From StackOverflowError: Can't call methods
         *    System is broken
         * 
         * 3. BREAKS THREAD INTERRUPTION:
         *    ThreadDeath shouldn't be caught
         *    Breaking thread lifecycle
         * 
         * 4. UNPREDICTABLE BEHAVIOR:
         *    After catching Error, system unstable
         *    Anything can happen
         */
    }
    
    private static void doWork() {
        // Work
    }
    
    /**
     * Correct pattern: Catch specific exceptions
     */
    public static void correctSpecificCatches() {
        try {
            readFile("data.txt");
            processData();
            writeResults();
            
        } catch (FileNotFoundException e) {
            // File doesn't exist - use default
            System.out.println("File not found, using defaults");
            useDefaults();
            
        } catch (IOException e) {
            // I/O problem - can't recover
            System.err.println("I/O error: " + e.getMessage());
            throw new RuntimeException("Failed to process file", e);
            
        } catch (IllegalStateException e) {
            // Application state problem
            System.err.println("Invalid state: " + e.getMessage());
            resetState();
        }
        
        /**
         * BENEFITS:
         * 
         * ✓ Different errors handled differently
         * ✓ Programming errors (NPE) still crash
         * ✓ Clear what can go wrong
         * ✓ Specific recovery strategies
         */
    }
    
    private static void useDefaults() {}
    private static void resetState() {}
    
    /**
     * When broad catches are acceptable
     */
    public static void acceptableBroadCatches() {
        /**
         * ACCEPTABLE CASES:
         * 
         * 1. TOP-LEVEL HANDLER:
         *    In main() or thread run()
         *    Last resort error handler
         *    Log and terminate cleanly
         */
        
        // Example: Main method
        // public static void main(String[] args) {
        //     try {
        //         runApplication(args);
        //     } catch (Exception e) {  // OK here
        //         logger.error("Application failed", e);
        //         System.exit(1);
        //     }
        // }
        
        /**
         * 2. FRAMEWORK CODE:
         *    Servlet containers
         *    Thread pools
         *    Must catch everything
         *    But log and report properly
         */
        
        // Example: Runnable
        Runnable task = () -> {
            try {
                doWork();
            } catch (Exception e) {  // OK in thread
                System.err.println("Task failed: " + e);
                // Log and continue
            }
        };
        
        /**
         * 3. FINALLY-EQUIVALENT:
         *    Ensuring cleanup
         *    Catch, cleanup, rethrow
         */
        
        try {
            performOperation();
        } catch (Exception e) {  // Catch all
            cleanup();  // Ensure cleanup
            throw e;    // Rethrow immediately
        }
        
        /**
         * RULES FOR BROAD CATCHES:
         * 
         * ✓ Top-level only
         * ✓ Log thoroughly
         * ✓ Don't suppress
         * ✓ Document why
         */
    }
    
    private static void performOperation() {}
    private static void cleanup() {}
    
    /**
     * Multi-catch alternative (Java 7+)
     */
    public static void multiCatchAlternative() {
        try {
            readFile("data.txt");
            processData();
            
        } catch (FileNotFoundException | IllegalStateException e) {
            // Handle both the same way
            System.out.println("Recoverable error: " + e.getMessage());
            
        } catch (IOException e) {
            // Different handling
            System.err.println("I/O error: " + e.getMessage());
            throw new RuntimeException("Processing failed", e);
        }
        
        /**
         * MULTI-CATCH BENEFITS:
         * 
         * ✓ Avoid duplicating catch blocks
         * ✓ Still specific (not catching all)
         * ✓ Clear intent
         * ✓ Type-safe
         */
    }
    
    /**
     * Decision tree
     */
    public static void decisionTree() {
        /**
         * SHOULD I CATCH EXCEPTION?
         * 
         * Am I at the top level (main/thread)?
         *   YES → OK, but log and terminate
         *   NO → Continue...
         * 
         * Am I implementing a framework contract?
         *   YES → OK, but log thoroughly
         *   NO → Continue...
         * 
         * Do I need to cleanup before rethrowing?
         *   YES → Catch, cleanup, rethrow
         *   NO → Continue...
         * 
         * → DON'T CATCH EXCEPTION
         *   Use specific exceptions instead
         * 
         * 
         * SHOULD I CATCH THROWABLE?
         * 
         * Are you absolutely sure?
         *   NO → Don't do it
         *   YES → You're probably wrong, don't do it
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Anti-Pattern: Catching Exception ===");
        catchingExceptionAntiPattern();
        
        System.out.println("\n=== Correct: Specific Catches ===");
        correctSpecificCatches();
        
        System.out.println("\n=== Multi-Catch Alternative ===");
        multiCatchAlternative();
    }
}
```

---

## 2. Empty Catch Blocks

### The Silent Failure Anti-Pattern

```java
/**
 * EMPTY CATCH BLOCKS
 * 
 * The most dangerous anti-pattern
 */

import java.io.*;

public class EmptyCatchBlocks {
    
    /**
     * Anti-pattern: Empty catch block
     */
    public static void emptyCatchBlockAntiPattern() {
        try {
            String result = readFile("config.txt");
            processConfig(result);
        } catch (IOException e) {
            // ❌ EMPTY CATCH BLOCK - WORST ANTI-PATTERN
        }
        
        /**
         * CATASTROPHIC PROBLEMS:
         * 
         * 1. SILENT FAILURE:
         *    File not found? No error
         *    Permission denied? No error
         *    Disk full? No error
         *    
         *    Application continues with undefined state
         *    Results unpredictable
         * 
         * 2. IMPOSSIBLE TO DEBUG:
         *    No error message
         *    No stack trace
         *    No indication what went wrong
         *    
         *    Debugging nightmare
         * 
         * 3. DATA CORRUPTION:
         *    Config not loaded → defaults used
         *    Wrong configuration → wrong behavior
         *    Silent corruption spreads
         * 
         * 4. PRODUCTION DISASTERS:
         *    Error in production
         *    No logs
         *    Can't reproduce
         *    Can't fix
         */
    }
    
    private static String readFile(String path) throws IOException {
        return new String(java.nio.file.Files.readAllBytes(
            java.nio.file.Paths.get(path)));
    }
    
    private static void processConfig(String config) {
        // Process
    }
    
    /**
     * Anti-pattern: Comment but no action
     */
    public static void commentButNoAction() {
        try {
            readFile("data.txt");
        } catch (IOException e) {
            // ❌ "This should never happen"
            // ❌ "TODO: Handle this"
            // ❌ "Ignore this error"
        }
        
        /**
         * PROBLEMS:
         * 
         * 1. FAMOUS LAST WORDS:
         *    "Should never happen" → Will happen
         *    Murphy's Law applies
         * 
         * 2. TODO DEBT:
         *    TODO comments never get done
         *    Ship with TODOs
         *    Production bugs
         * 
         * 3. IGNORED ERRORS AREN'T IGNORABLE:
         *    What seems ignorable in dev
         *    Causes outages in production
         */
    }
    
    /**
     * Anti-pattern: Catching to satisfy compiler
     */
    public static void catchToSatisfyCompiler() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            // ❌ Caught just to compile
        }
        
        /**
         * SPECIFIC PROBLEM:
         * 
         * InterruptedException is special
         * Signals thread should stop
         * Empty catch = ignore shutdown
         * 
         * Threads don't stop
         * Application doesn't shutdown
         * Have to kill -9
         */
    }
    
    /**
     * Correct pattern: Always log
     */
    public static void correctAlwaysLog() {
        try {
            String result = readFile("config.txt");
            processConfig(result);
            
        } catch (IOException e) {
            // ✓ Log the error
            System.err.println("Failed to read config: " + e.getMessage());
            e.printStackTrace();
            
            // ✓ Use defaults
            useDefaultConfig();
        }
        
        /**
         * MINIMUM REQUIREMENT:
         * 
         * ✓ Log the exception
         * ✓ Include stack trace
         * ✓ Take some action (defaults, rethrow, etc.)
         */
    }
    
    private static void useDefaultConfig() {
        System.out.println("Using default configuration");
    }
    
    /**
     * Correct pattern: Log and rethrow
     */
    public static void correctLogAndRethrow() {
        try {
            String result = readFile("config.txt");
            processConfig(result);
            
        } catch (IOException e) {
            // ✓ Log
            System.err.println("Config error: " + e.getMessage());
            
            // ✓ Can't recover - rethrow
            throw new RuntimeException("Failed to initialize", e);
        }
        
        /**
         * WHEN TO RETHROW:
         * 
         * Can't recover at this level
         * Let caller decide
         * But log first for debugging
         */
    }
    
    /**
     * Correct pattern: InterruptedException
     */
    public static void correctInterruptedExceptionHandling() {
        try {
            Thread.sleep(1000);
            
        } catch (InterruptedException e) {
            // ✓ Restore interrupt status
            Thread.currentThread().interrupt();
            
            // ✓ Log
            System.err.println("Thread interrupted: " + e.getMessage());
            
            // ✓ Cleanup and return/throw
            cleanup();
            throw new RuntimeException("Interrupted", e);
        }
        
        /**
         * INTERRUPTED EXCEPTION PATTERN:
         * 
         * 1. Restore interrupt flag
         * 2. Log the interruption
         * 3. Cleanup resources
         * 4. Propagate (rethrow or return)
         */
    }
    
    private static void cleanup() {}
    
    /**
     * When empty catch is acceptable
     */
    public static void whenEmptyCatchAcceptable() {
        /**
         * VERY RARE CASES:
         * 
         * 1. PROVEN IMPOSSIBLE:
         *    Checked exception that can't happen
         *    Must document thoroughly
         */
        
        try {
            // ByteArrayInputStream.close() never throws
            java.io.ByteArrayInputStream bais = 
                new java.io.ByteArrayInputStream(new byte[0]);
            bais.close();
            
        } catch (IOException e) {
            // Documented as never thrown
            // But must explain
            throw new AssertionError("ByteArrayInputStream.close() never throws", e);
        }
        
        /**
         * 2. BEST-EFFORT CLEANUP:
         *    In finally block
         *    Already handling another error
         *    Don't mask original error
         */
        
        Exception primaryException = null;
        AutoCloseable resource = null;
        
        try {
            // resource = openResource();
            // use resource
            
        } catch (Exception e) {
            primaryException = e;
            
        } finally {
            if (resource != null) {
                try {
                    resource.close();
                } catch (Exception e) {
                    if (primaryException != null) {
                        // Empty catch acceptable here
                        // Don't want to mask primary exception
                        // But better: use addSuppressed()
                        primaryException.addSuppressed(e);
                    }
                }
            }
        }
        
        /**
         * EVEN THEN:
         * 
         * Document why
         * Consider try-with-resources instead
         * Empty catch is code smell
         */
    }
    
    /**
     * Static analysis tools
     */
    public static void staticAnalysisTools() {
        /**
         * DETECT EMPTY CATCHES:
         * 
         * - Checkstyle: EmptyBlock
         * - PMD: EmptyCatchBlock
         * - SonarQube: squid:S108
         * - IntelliJ IDEA: "Empty 'catch' block"
         * - SpotBugs: DE_MIGHT_IGNORE
         * 
         * Configure to fail build
         * Force developers to address
         */
    }
    
    /**
     * Summary
     */
    public static void summary() {
        /**
         * EMPTY CATCH BLOCKS:
         * 
         * ❌ NEVER acceptable (99.9% of cases)
         * ❌ Silent failures
         * ❌ Impossible to debug
         * ❌ Production disasters
         * 
         * ✓ Always log
         * ✓ Always take action
         * ✓ Use static analysis
         * ✓ If truly needed, document extensively
         * 
         * 
         * MINIMUM CODE:
         * 
         * catch (Exception e) {
         *     e.printStackTrace();  // At minimum!
         * }
         * 
         * BETTER:
         * 
         * catch (Exception e) {
         *     logger.error("Operation failed", e);
         *     // Take appropriate action
         * }
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Anti-Pattern: Empty Catch ===");
        emptyCatchBlockAntiPattern();
        
        System.out.println("\n=== Correct: Always Log ===");
        correctAlwaysLog();
        
        System.out.println("\n=== Correct: Log and Rethrow ===");
        correctLogAndRethrow();
    }
}
```

---

## 3. Using Exceptions for Flow Control

### The Exception as GOTO Anti-Pattern

```java
/**
 * USING EXCEPTIONS FOR FLOW CONTROL
 * 
 * Why exceptions aren't control structures
 */

import java.util.*;

public class ExceptionsForFlowControl {
    
    /**
     * Anti-pattern: Exceptions for normal flow
     */
    public static void exceptionsForNormalFlow() {
        String[] items = {"apple", "banana", "cherry"};
        
        try {
            int i = 0;
            while (true) {  // ❌ Infinite loop
                System.out.println(items[i]);
                i++;
            }
        } catch (ArrayIndexOutOfBoundsException e) {
            // ❌ Using exception to exit loop
        }
        
        /**
         * PROBLEMS:
         * 
         * 1. PERFORMANCE:
         *    Creating exception is expensive
         *    Stack trace capture
         *    Much slower than normal control flow
         * 
         * 2. UNCLEAR INTENT:
         *    Exceptions signal errors
         *    Not normal program flow
         *    Confusing to readers
         * 
         * 3. DEBUGGING NIGHTMARE:
         *    Debugger stops on exceptions
         *    Break on ArrayIndexOutOfBoundsException?
         *    Can't distinguish real bugs
         * 
         * 4. MISLEADING:
         *    Looks like a bug
         *    Code reviews flag it
         *    Maintenance confusion
         */
    }
    
    /**
     * Correct pattern: Normal control flow
     */
    public static void correctNormalControlFlow() {
        String[] items = {"apple", "banana", "cherry"};
        
        // ✓ Use array length
        for (int i = 0; i < items.length; i++) {
            System.out.println(items[i]);
        }
        
        // ✓ Or enhanced for loop
        for (String item : items) {
            System.out.println(item);
        }
        
        /**
         * BENEFITS:
         * 
         * ✓ Clear intent
         * ✓ Fast execution
         * ✓ Easy to debug
         * ✓ Standard pattern
         */
    }
    
    /**
     * Anti-pattern: Exception for validation
     */
    public static boolean isValidNumberAntiPattern(String str) {
        try {
            Integer.parseInt(str);
            return true;  // ❌ Success via no exception
        } catch (NumberFormatException e) {
            return false;  // ❌ Expected case via exception
        }
        
        /**
         * PROBLEMS:
         * 
         * 1. PERFORMANCE:
         *    parseInt throws for non-numbers
         *    Expensive for validation
         * 
         * 2. EXPECTED CASE:
         *    Non-numbers are expected
         *    Not exceptional
         *    Exceptions for exceptional cases only
         * 
         * 3. MISLEADING METRICS:
         *    Exception rate monitoring
         *    High exception rate looks bad
         *    But it's "normal" here
         */
    }
    
    /**
     * Correct pattern: Validation without exceptions
     */
    public static boolean isValidNumberCorrect(String str) {
        if (str == null || str.isEmpty()) {
            return false;
        }
        
        // ✓ Check each character
        for (int i = 0; i < str.length(); i++) {
            char c = str.charAt(i);
            if (i == 0 && c == '-') {
                continue;  // Allow negative
            }
            if (c < '0' || c '9') {
                return false;
            }
        }
        
        return true;
        
        /**
         * ALTERNATIVE:
         * 
         * return str.matches("-?\\d+");
         * 
         * No exceptions
         * Clear intent
         * Better performance
         */
    }
    
    /**
     * Anti-pattern: Exception for existence check
     */
    public static String getConfigAntiPattern(Map<String, String> config, String key) {
        try {
            String value = config.get(key);
            if (value == null) {
                throw new RuntimeException();  // ❌ Artificial exception
            }
            return value;
            
        } catch (RuntimeException e) {
            return "default";  // ❌ Exception for flow control
        }
        
        /**
         * ABSURD PATTERN:
         * 
         * Artificially throwing exception
         * To use catch block
         * Exception as GOTO
         */
    }
    
    /**
     * Correct pattern: Simple conditional
     */
    public static String getConfigCorrect(Map<String, String> config, String key) {
        String value = config.get(key);
        return value != null ? value : "default";
        
        /**
         * OR:
         * 
         * return config.getOrDefault(key, "default");
         * 
         * Clear, concise, correct
         */
    }
    
    /**
     * Anti-pattern: Optional misuse
     */
    public static void optionalMisuse() {
        Optional<String> value = findValue();
        
        try {
            String result = value.get();  // ❌ Throws NoSuchElementException
            processValue(result);
        } catch (NoSuchElementException e) {
            // ❌ Exception for absent value
            useDefault();
        }
        
        /**
         * PROBLEM:
         * 
         * Optional.get() throws if empty
         * Using exception for expected case
         * Optional has better methods
         */
    }
    
    /**
     * Correct pattern: Optional properly used
     */
    public static void optionalCorrect() {
        Optional<String> value = findValue();
        
        // ✓ Use ifPresentOrElse (Java 9+)
        value.ifPresentOrElse(
            v -> processValue(v),
            () -> useDefault()
        );
        
        // ✓ Or use orElse
        String result = value.orElse("default");
        processValue(result);
        
        // ✓ Or use isPresent
        if (value.isPresent()) {
            processValue(value.get());
        } else {
            useDefault();
        }
        
        /**
         * NO EXCEPTIONS FOR FLOW CONTROL
         * 
         * Use Optional's methods
         * Clear intent
         * No performance penalty
         */
    }
    
    private static Optional<String> findValue() {
        return Optional.empty();
    }
    
    private static void processValue(String value) {}
    private static void useDefault() {}
    
    /**
     * Performance impact
     */
    public static void performanceImpact() {
        /**
         * EXCEPTION COST:
         * 
         * Creating exception:
         * - Allocate object
         * - Capture stack trace
         * - Fill in stack frames
         * 
         * 100-1000x slower than return statement
         * 
         * 
         * BENCHMARK (approximate):
         * 
         * Normal return:     1 ns
         * Exception thrown:  1000 ns
         * 
         * 1000x slower!
         * 
         * 
         * USE CASES:
         * 
         * Validation loop: 1,000,000 iterations
         * Exception approach: 1,000,000 ms = 1000 seconds
         * Normal approach: 1 ms
         * 
         * Catastrophic performance impact
         */
    }
    
    /**
     * When exceptions ARE appropriate
     */
    public static void whenExceptionsAppropriate() {
        /**
         * USE EXCEPTIONS FOR:
         * 
         * 1. EXCEPTIONAL CONDITIONS:
         *    File not found (exceptional)
         *    Network timeout (exceptional)
         *    Out of memory (exceptional)
         * 
         * 2. ERRORS:
         *    Programming errors (NPE)
         *    Invalid state (IllegalStateException)
         *    Invalid arguments (IllegalArgumentException)
         * 
         * 3. UNRECOVERABLE FAILURES:
         *    Database connection failed
         *    Critical resource unavailable
         * 
         * 
         * DON'T USE EXCEPTIONS FOR:
         * 
         * ❌ Normal program flow
         * ❌ Validation
         * ❌ Existence checks
         * ❌ Loop termination
         * ❌ Expected conditions
         */
    }
    
    /**
     * Summary
     */
    public static void summary() {
        /**
         * EXCEPTIONS FOR FLOW CONTROL:
         * 
         * ❌ Performance killer (1000x slower)
         * ❌ Unclear intent
         * ❌ Debugging nightmare
         * ❌ Maintenance confusion
         * 
         * ✓ Use normal control structures
         * ✓ if/else for conditions
         * ✓ for/while for loops
         * ✓ return for early exit
         * ✓ Exceptions for exceptional cases only
         * 
         * 
         * RULE OF THUMB:
         * 
         * If it's expected → don't use exception
         * If it's exceptional → use exception
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Anti-Pattern: Loop with Exception ===");
        exceptionsForNormalFlow();
        
        System.out.println("\n=== Correct: Normal Loop ===");
        correctNormalControlFlow();
        
        System.out.println("\n=== Performance Impact ===");
        performanceImpact();
    }
}
```

---

## 4. Losing Stack Traces

### The Debug Information Loss Anti-Pattern

```java
/**
 * LOSING STACK TRACES
 * 
 * How to preserve debugging information
 */

import java.io.*;

public class LosingStackTraces {
    
    /**
     * Anti-pattern: Throwing new exception without cause
     */
    public static void throwingWithoutCause() {
        try {
            readFile("data.txt");
        } catch (IOException e) {
            // ❌ Lost original exception
            throw new RuntimeException("File operation failed");
        }
        
        /**
         * PROBLEM:
         * 
         * Original IOException lost
         * Stack trace lost
         * Can't see:
         * - What I/O error occurred
         * - Where it occurred
         * - Root cause
         * 
         * Debugging impossible
         */
    }
    
    /**
     * Correct pattern: Chain exceptions
     */
    public static void correctExceptionChaining() {
        try {
            readFile("data.txt");
        } catch (IOException e) {
            // ✓ Chain the exception
            throw new RuntimeException("File operation failed", e);
            //                                                   ^
            //                                              Preserve cause
        }
        
        /**
         * BENEFITS:
         * 
         * ✓ Original exception preserved
         * ✓ Stack trace preserved
         * ✓ Can call getCause()
         * ✓ Complete debugging info
         */
    }
    
    private static void readFile(String path) throws IOException {
        throw new FileNotFoundException("File not found: " + path);
    }
    
    /**
     * Anti-pattern: Printing then throwing new
     */
    public static void printingThenThrowingNew() {
        try {
            connectToDatabase();
        } catch (SQLException e) {
            // ❌ Print stack trace
            e.printStackTrace();
            
            // ❌ Then throw new exception without cause
            throw new RuntimeException("Database error");
            
            /**
             * PROBLEMS:
             * 
             * 1. DUPLICATE LOGS:
             *    Stack trace printed
             *    Then new exception thrown
             *    Same error logged twice
             * 
             * 2. LOST CAUSE:
             *    New exception has no cause
             *    Debugging harder
             * 
             * 3. CONFUSING LOGS:
             *    Two stack traces
             *    Which one matters?
             *    Log pollution
             */
        }
    }
    
    /**
     * Correct pattern: Chain and let caller log
     */
    public static void correctChainAndLetCallerLog() {
        try {
            connectToDatabase();
        } catch (SQLException e) {
            // ✓ Chain, don't print
            throw new RuntimeException("Database connection failed", e);
        }
        
        /**
         * BENEFITS:
         * 
         * ✓ Single exception
         * ✓ Cause preserved
         * ✓ Caller decides logging
         * ✓ Clean logs
         */
    }
    
    private static void connectToDatabase() throws SQLException {
        throw new SQLException("Connection refused");
    }
    
    /**
     * Anti-pattern: toString() instead of exception
     */
    public static void toStringInsteadOfException() {
        try {
            processData();
        } catch (IllegalStateException e) {
            // ❌ Only message, lost stack trace
            throw new RuntimeException("Processing failed: " + e.getMessage());
        }
        
        /**
         * PROBLEM:
         * 
         * e.getMessage() is just a string
         * Lost:
         * - Stack trace
         * - Exception type
         * - Cause chain
         * - All debugging context
         */
    }
    
    /**
     * Correct pattern: Full exception chaining
     */
    public static void correctFullChaining() {
        try {
            processData();
        } catch (IllegalStateException e) {
            // ✓ Preserve full exception
            throw new RuntimeException("Processing failed", e);
        }
        
        /**
         * MESSAGE ALREADY AVAILABLE:
         * 
         * RuntimeException includes:
         * - Its own message
         * - Cause's message
         * - Full stack trace
         * - Cause chain
         * 
         * No need to manually concatenate
         */
    }
    
    private static void processData() {
        throw new IllegalStateException("Invalid state");
    }
    
    /**
     * Anti-pattern: Creating new stack trace
     */
    public static void creatingNewStackTrace() {
        try {
            readFile("data.txt");
        } catch (IOException e) {
            // ❌ Creating new exception loses original stack
            RuntimeException newException = new RuntimeException("File error");
            throw newException;
        }
        
        /**
         * PROBLEM:
         * 
         * New exception has different stack trace
         * Points to this line, not original error
         * Root cause location lost
         */
    }
    
    /**
     * Anti-pattern: Rethrowing with throw e
     */
    public static void rethrowingWithThrowE() {
        Exception exception = null;
        
        try {
            readFile("data.txt");
        } catch (IOException e) {
            exception = e;
        }
        
        if (exception != null) {
            // ❌ Rethrowing later loses context
            throw new RuntimeException(exception);
        }
        
        /**
         * PROBLEM:
         * 
         * Stack trace shows throw from here
         * Not from original location
         * Misleading debugging info
         * 
         * 
         * BETTER:
         * 
         * throw new RuntimeException("Operation failed", exception);
         * 
         * Or rethrow immediately in catch block
         */
    }
    
    /**
     * Correct pattern: Immediate rethrow preserves stack
     */
    public static void correctImmediateRethrow() throws IOException {
        try {
            readFile("data.txt");
        } catch (FileNotFoundException e) {
            // ✓ Can't handle, rethrow immediately
            throw e;  // Stack trace preserved
        }
        
        /**
         * IMMEDIATE RETHROW:
         * 
         * Same exception object
         * Same stack trace
         * No information lost
         * 
         * Use when:
         * - Can't handle at this level
         * - Want to add catch for other types
         * - Need to cleanup before propagating
         */
    }
    
    /**
     * Anti-pattern: Logging exception message only
     */
    public static void loggingMessageOnly() {
        try {
            connectToDatabase();
        } catch (SQLException e) {
            // ❌ Only logging message
            System.err.println("Error: " + e.getMessage());
            
            /**
             * LOST INFORMATION:
             * 
             * - Stack trace
             * - Exception type
             * - Cause chain
             * - Line numbers
             * 
             * Can't debug from message alone
             */
        }
    }
    
    /**
     * Correct pattern: Logging full exception
     */
    public static void correctLoggingFullException() {
        try {
            connectToDatabase();
        } catch (SQLException e) {
            // ✓ Log full exception
            System.err.println("Database connection failed:");
            e.printStackTrace();
            
            // ✓ Or with logger
            // logger.error("Database connection failed", e);
            //                                             ^
            //                                  Full exception logged
            
            /**
             * LOGGED INFORMATION:
             * 
             * ✓ Exception type
             * ✓ Message
             * ✓ Stack trace
             * ✓ Cause chain
             * ✓ Line numbers
             * ✓ Method names
             * 
             * Complete debugging context
             */
        }
    }
    
    /**
     * Exception chaining best practices
     */
    public static void exceptionChainingBestPractices() {
        /**
         * BEST PRACTICES:
         * 
         * 1. ALWAYS CHAIN:
         *    throw new HighLevelException("message", originalException);
         *    Never lose the cause
         * 
         * 2. ADD CONTEXT:
         *    Include business context in message
         *    Original exception has technical details
         * 
         * 3. LOG AT TOP LEVEL:
         *    Don't log and rethrow
         *    Log once at top level
         *    Avoid duplicate logs
         * 
         * 4. PRESERVE STACK TRACES:
         *    Never create new exception without cause
         *    Chain maintains debugging info
         * 
         * 5. USE LOGGER PROPERLY:
         *    logger.error("Message", exception);
         *    Not: logger.error("Message: " + exception.getMessage());
         */
    }
    
    /**
     * Complete example
     */
    public static void completeExample() {
        try {
            performBusinessOperation();
            
        } catch (IOException e) {
            // ✓ Log with context
            System.err.println("Business operation failed:");
            e.printStackTrace();
            
            // ✓ Chain for caller
            throw new RuntimeException("Failed to perform operation", e);
        }
    }
    
    private static void performBusinessOperation() throws IOException {
        try {
            readFile("business-data.txt");
        } catch (FileNotFoundException e) {
            // ✓ Add business context, chain exception
            throw new IOException("Required business data not found", e);
        }
    }
    
    /**
     * Summary
     */
    public static void summary() {
        /**
         * LOSING STACK TRACES:
         * 
         * ❌ throw new Exception("message") - Lost cause
         * ❌ e.getMessage() only - Lost stack
         * ❌ Print then throw new - Lost chain
         * ❌ Rethrowing later - Lost context
         * 
         * ✓ throw new Exception("message", e) - Preserved
         * ✓ e.printStackTrace() - Full info
         * ✓ logger.error("msg", e) - Proper logging
         * ✓ Immediate rethrow - Stack intact
         * 
         * 
         * GOLDEN RULE:
         * 
         * Never lose the original exception
         * Always chain exceptions
         * Log full stack traces
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Anti-Pattern: Lost Stack ===");
        try {
            throwingWithoutCause();
        } catch (RuntimeException e) {
            System.out.println("Caught but cause is null: " + (e.getCause() == null));
        }
        
        System.out.println("\n=== Correct: Chained ===");
        try {
            correctExceptionChaining();
        } catch (RuntimeException e) {
            System.out.println("Caught with cause: " + (e.getCause() != null));
        }
    }
}
```

---

## 5. Rethrowing Without Context

### The Information Loss Anti-Pattern

```java
/**
 * RETHROWING WITHOUT CONTEXT
 * 
 * Adding meaningful context to exceptions
 */

import java.io.*;
import java.sql.*;

public class RethrowingWithoutContext {
    
    /**
     * Anti-pattern: Rethrowing without context
     */
    public static void rethrowingWithoutContext() {
        try {
            processUser("12345");
        } catch (SQLException e) {
            // ❌ Rethrow without adding context
            throw new RuntimeException(e);
        }
        
        /**
         * PROBLEM:
         * 
         * SQLException message: "Column not found"
         * 
         * But which operation?
         * Which user?
         * Which table?
         * Which column?
         * 
         * No business context added
         */
    }
    
    /**
     * Correct pattern: Add business context
     */
    public static void correctAddingContext() {
        String userId = "12345";
        
        try {
            processUser(userId);
        } catch (SQLException e) {
            // ✓ Add business context
            throw new RuntimeException(
                "Failed to process user: " + userId, e);
        }
        
        /**
         * NOW WE KNOW:
         * 
         * - Which operation (process user)
         * - Which user (12345)
         * - Technical details (SQLException)
         * 
         * Complete debugging context
         */
    }
    
    private static void processUser(String userId) throws SQLException {
        throw new SQLException("Column not found");
    }
    
    /**
     * Anti-pattern: Generic error messages
     */
    public static void genericErrorMessages() {
        try {
            readConfiguration();
        } catch (IOException e) {
            // ❌ Generic message
            throw new RuntimeException("Error occurred", e);
        }
        
        /**
         * PROBLEMS:
         * 
         * "Error occurred" - What error?
         * No useful information added
         * Just noise
         * 
         * Better to just rethrow original
         */
    }
    
    /**
     * Correct pattern: Specific error messages
     */
    public static void specificErrorMessages() {
        String configFile = "app-config.xml";
        
        try {
            readConfiguration();
        } catch (IOException e) {
            // ✓ Specific message with context
            throw new RuntimeException(
                "Failed to load application configuration from: " + configFile, e);
        }
        
        /**
         * NOW WE KNOW:
         * 
         * - What failed (load configuration)
         * - Which file (app-config.xml)
         * - Why (IOException details)
         */
    }
    
    private static void readConfiguration() throws IOException {
        throw new FileNotFoundException("File not found");
    }
    
    /**
     * Anti-pattern: Losing parameters
     */
    public static void calculateDiscount(String customerId, double amount) {
        try {
            applyBusinessRules(amount);
        } catch (IllegalArgumentException e) {
            // ❌ Lost customer ID and amount
            throw new RuntimeException("Discount calculation failed", e);
        }
        
        /**
         * MISSING INFORMATION:
         * 
         * Which customer?
         * What amount?
         * 
         * Parameters lost
         * Can't reproduce bug
         */
    }
    
    /**
     * Correct pattern: Include all relevant parameters
     */
    public static void correctIncludeParameters(String customerId, double amount) {
        try {
            applyBusinessRules(amount);
        } catch (IllegalArgumentException e) {
            // ✓ Include all relevant data
            throw new RuntimeException(String.format(
                "Discount calculation failed for customer %s with amount %.2f",
                customerId, amount), e);
        }
        
        /**
         * COMPLETE CONTEXT:
         * 
         * - Customer ID
         * - Amount
         * - Original error
         * 
         * Can reproduce and debug
         */
    }
    
    private static void applyBusinessRules(double amount) {
        if (amount < 0) {
            throw new IllegalArgumentException("Amount cannot be negative");
        }
    }
    
    /**
     * Multi-layer context accumulation
     */
    static class DataAccessLayer {
        public void saveOrder(String orderId) throws SQLException {
            throw new SQLException("Constraint violation");
        }
    }
    
    static class ServiceLayer {
        private DataAccessLayer dal = new DataAccessLayer();
        
        public void processOrder(String orderId, String customerId) {
            try {
                dal.saveOrder(orderId);
            } catch (SQLException e) {
                // ✓ Service layer context
                throw new RuntimeException(
                    "Failed to save order " + orderId + 
                    " for customer " + customerId, e);
            }
        }
    }
    
    static class ControllerLayer {
        private ServiceLayer service = new ServiceLayer();
        
        public void handleRequest(String orderId, String customerId, String sessionId) {
            try {
                service.processOrder(orderId, customerId);
            } catch (RuntimeException e) {
                // ✓ Controller layer context
                throw new RuntimeException(
                    "Order processing failed in session " + sessionId, e);
            }
        }
    }
    
    public static void multiLayerContext() {
        ControllerLayer controller = new ControllerLayer();
        
        try {
            controller.handleRequest("ORD-123", "CUST-456", "SESS-789");
        } catch (RuntimeException e) {
            System.out.println("Top level: " + e.getMessage());
            
            // Walk the chain
            Throwable cause = e.getCause();
            while (cause != null) {
                System.out.println("  Caused by: " + cause.getMessage());
                cause = cause.getCause();
            }
        }
        
        /**
         * OUTPUT:
         * Top level: Order processing failed in session SESS-789
         *   Caused by: Failed to save order ORD-123 for customer CUST-456
         *   Caused by: Constraint violation
         * 
         * COMPLETE PICTURE:
         * 
         * Each layer adds context
         * Session ID from controller
         * Order/Customer from service
         * Technical detail from database
         * 
         * Perfect debugging information!
         */
    }
    
    /**
     * Sensitive information caution
     */
    public static void sensitiveInformationCaution() {
        String password = "secret123";
        
        try {
            authenticate("user", password);
        } catch (Exception e) {
            // ❌ DON'T include sensitive data
            // throw new RuntimeException(
            //     "Auth failed with password: " + password, e);
            
            // ✓ Include safe information only
            throw new RuntimeException(
                "Authentication failed for user: user", e);
            
            /**
             * NEVER LOG:
             * 
             * - Passwords
             * - Credit card numbers
             * - SSN
             * - Encryption keys
             * - Personal data (GDPR)
             * 
             * Include:
             * 
             * - User ID (not password)
             * - Transaction ID
             * - Timestamps
             * - Operation types
             */
        }
    }
    
    private static void authenticate(String user, String password) {
        throw new RuntimeException("Invalid credentials");
    }
    
    /**
     * Context formatting best practices
     */
    public static void contextFormattingBestPractices() {
        String orderId = "ORD-12345";
        String customerId = "CUST-67890";
        double amount = 150.50;
        
        try {
            processOrder(orderId, customerId, amount);
        } catch (Exception e) {
            // ✓ Structured message
            throw new RuntimeException(String.format(
                "Order processing failed: orderId=%s, customerId=%s, amount=%.2f",
                orderId, customerId, amount), e);
            
            /**
             * STRUCTURED FORMAT:
             * 
             * Key=value pairs
             * Easy to parse
             * Good for log aggregation
             * 
             * 
             * CONSIDER:
             * 
             * - JSON format for complex data
             * - Key-value pairs for parsing
             * - Consistent format across application
             */
        }
    }
    
    private static void processOrder(String orderId, String customerId, double amount) {
        throw new RuntimeException("Processing failed");
    }
    
    /**
     * When not to add context
     */
    public static void whenNotToAddContext() {
        try {
            performOperation();
        } catch (IllegalArgumentException e) {
            // Don't add useless context
            
            // ❌ BAD: "Error occurred"
            // throw new RuntimeException("Error occurred", e);
            
            // ❌ BAD: Repeat exception message
            // throw new RuntimeException(e.getMessage(), e);
            
            // ✓ GOOD: Just rethrow if no value to add
            throw e;
            
            /**
             * DON'T ADD CONTEXT IF:
             * 
             * - No useful information to add
             * - Just repeating exception message
             * - Generic "error occurred" messages
             * 
             * Better to rethrow original
             */
        }
    }
    
    private static void performOperation() {
        throw new IllegalArgumentException("Invalid parameter");
    }
    
    /**
     * Summary
     */
    public static void summary() {
        /**
         * RETHROWING WITHOUT CONTEXT:
         * 
         * ❌ Generic messages ("Error occurred")
         * ❌ Missing parameters
         * ❌ No business context
         * ❌ Can't reproduce bugs
         * 
         * ✓ Specific messages
         * ✓ Include all parameters
         * ✓ Add business context
         * ✓ Format consistently
         * ✓ Don't expose sensitive data
         * 
         * 
         * CONTEXT TO ADD:
         * 
         * ✓ User/Customer IDs
         * ✓ Transaction IDs
         * ✓ Resource identifiers
         * ✓ Operation parameters
         * ✓ Business entity names
         * 
         * ✗ Passwords
         * ✗ Credit cards
         * ✗ Personal data
         * ✗ Keys/secrets
         * 
         * 
         * GOLDEN RULE:
         * 
         * Add enough context to:
         * 1. Understand what failed
         * 2. Identify which data
         * 3. Reproduce the bug
         * 4. But not expose secrets
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Multi-Layer Context ===");
        multiLayerContext();
    }
}
```

---

## 6. Exception Swallowing

### The Silent Bug Anti-Pattern

```java
/**
 * EXCEPTION SWALLOWING
 * 
 * Catching exceptions but losing information
 */

import java.io.*;

public class ExceptionSwallowing {
    
    /**
     * Anti-pattern: Log and continue
     */
    public static void logAndContinue() {
        String[] files = {"file1.txt", "file2.txt", "file3.txt"};
        
        for (String file : files) {
            try {
                processFile(file);
            } catch (IOException e) {
                // ❌ Log but continue
                System.err.println("Error processing " + file);
                // Continue to next file
            }
        }
        
        // Method completes successfully
        System.out.println("Processing complete");
        
        /**
         * PROBLEMS:
         * 
         * 1. SILENT FAILURE:
         *    Some files failed
         *    Method returns success
         *    Caller doesn't know
         * 
         * 2. PARTIAL STATE:
         *    Some operations succeeded
         *    Some failed
         *    Inconsistent state
         * 
         * 3. LOST ERRORS:
         *    Logged but not handled
         *    Production: logs ignored
         *    Bugs go unnoticed
         */
    }
    
    private static void processFile(String file) throws IOException {
        throw new FileNotFoundException(file);
    }
    
    /**
     * Correct pattern: Collect errors and report
     */
    public static void correctCollectAndReport() {
        String[] files = {"file1.txt", "file2.txt", "file3.txt"};
        java.util.List<String> failed = new java.util.ArrayList<>();
        
        for (String file : files) {
            try {
                processFile(file);
            } catch (IOException e) {
                // ✓ Collect failures
                failed.add(file);
                System.err.println("Failed: " + file + " - " + e.getMessage());
            }
        }
        
        // ✓ Report results
        if (!failed.isEmpty()) {
            throw new RuntimeException(
                "Failed to process files: " + failed);
        }
        
        System.out.println("All files processed successfully");
        
        /**
         * BENEFITS:
         * 
         * ✓ Caller knows about failures
         * ✓ Can decide how to handle
         * ✓ Clear success/failure status
         * ✓ All errors reported
         */
    }
    
    /**
     * Anti-pattern: Return null on error
     */
    public static String readConfigAntiPattern(String key) {
        try {
            return loadConfigValue(key);
        } catch (IOException e) {
            // ❌ Swallow exception, return null
            return null;
        }
        
        /**
         * PROBLEMS:
         * 
         * 1. LOST ERROR:
         *    IOException swallowed
         *    Caller doesn't know why null
         * 
         * 2. AMBIGUOUS NULL:
         *    null = not found?
         *    null = error?
         *    null = not configured?
         *    Can't distinguish
         * 
         * 3. NPE LATER:
         *    Caller might not check null
         *    NullPointerException later
         *    Far from root cause
         */
    }
    
    /**
     * Correct pattern: Let exception propagate
     */
    public static String readConfigCorrect(String key) throws IOException {
        return loadConfigValue(key);
        
        /**
         * OR: Wrap with context
         * 
         * try {
         *     return loadConfigValue(key);
         * } catch (IOException e) {
         *     throw new RuntimeException(
         *         "Failed to load config: " + key, e);
         * }
         * 
         * Caller knows error occurred
         * Can handle appropriately
         */
    }
    
    private static String loadConfigValue(String key) throws IOException {
        throw new IOException("Config not found");
    }
    
    /**
     * Anti-pattern: Return default on any error
     */
    public static int getPortAntiPattern() {
        try {
            return Integer.parseInt(System.getProperty("server.port"));
        } catch (Exception e) {  // ❌ Catch all exceptions
            return 8080;  // ❌ Silent default
        }
        
        /**
         * PROBLEMS:
         * 
         * 1. HIDES CONFIGURATION ERRORS:
         *    port=abc → returns 8080 (wrong!)
         *    port=99999 → returns 8080 (wrong!)
         *    Missing port → returns 8080 (ok)
         * 
         * 2. SILENT MISCONFIGURATION:
         *    Production uses wrong port
         *    No error, no warning
         *    Hard to debug
         * 
         * 3. CATCHES TOO MUCH:
         *    NumberFormatException expected
         *    But catching Exception catches all
         *    NPE, SecurityException, etc. hidden
         */
    }
    
    /**
     * Correct pattern: Explicit default handling
     */
    public static int getPortCorrect() {
        String portStr = System.getProperty("server.port");
        
        if (portStr == null) {
            // ✓ Explicit default for missing
            System.out.println("server.port not set, using default 8080");
            return 8080;
        }
        
        try {
            int port = Integer.parseInt(portStr);
            
            // ✓ Validate range
            if (port < 1 || port > 65535) {
                throw new IllegalArgumentException(
                    "Invalid port range: " + port);
            }
            
            return port;
            
        } catch (NumberFormatException e) {
            // ✓ Fail fast on invalid
            throw new IllegalArgumentException(
                "Invalid port format: " + portStr, e);
        }
        
        /**
         * BENEFITS:
         * 
         * ✓ Clear when default used
         * ✓ Fails fast on invalid
         * ✓ Validates range
         * ✓ No silent errors
         */
    }
    
    /**
     * Anti-pattern: Try-catch around everything
     */
    public static void tryCatchAroundEverything() {
        try {
            // ❌ Huge try block
            initializeSystem();
            loadConfiguration();
            connectToDatabase();
            startServices();
            registerShutdownHook();
            
        } catch (Exception e) {
            // ❌ Generic catch
            System.err.println("Startup failed: " + e.getMessage());
            // ❌ Continue anyway?
        }
        
        System.out.println("System started");
        
        /**
         * PROBLEMS:
         * 
         * 1. CAN'T TELL WHAT FAILED:
         *    Which step failed?
         *    System partially initialized?
         *    Unsafe to continue?
         * 
         * 2. PARTIAL INITIALIZATION:
         *    Some steps succeeded
         *    Some failed
         *    System in unknown state
         * 
         * 3. FALSE SUCCESS:
         *    "System started" printed
         *    But system not actually started
         *    Complete lie
         */
    }
    
    /**
     * Correct pattern: Fine-grained error handling
     */
    public static void correctFineGrainedHandling() {
        try {
            initializeSystem();
        } catch (Exception e) {
            throw new RuntimeException("System initialization failed", e);
        }
        
        try {
            loadConfiguration();
        } catch (IOException e) {
            System.out.println("Config not found, using defaults");
            loadDefaultConfiguration();
        }
        
        try {
            connectToDatabase();
        } catch (SQLException e) {
            throw new RuntimeException("Database connection required", e);
        }
        
        // etc.
        
        System.out.println("System started successfully");
        
        /**
         * BENEFITS:
         * 
         * ✓ Know exactly what failed
         * ✓ Can recover from some errors
         * ✓ Fail fast on critical errors
         * ✓ True success message
         */
    }
    
    private static void initializeSystem() {}
    private static void loadConfiguration() throws IOException {}
    private static void loadDefaultConfiguration() {}
    private static void connectToDatabase() throws SQLException {}
    private static void startServices() {}
    private static void registerShutdownHook() {}
    
    /**
     * Anti-pattern: Swallowing InterruptedException
     */
    public static void swallowingInterruptedException() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            // ❌ Swallowed - thread can't be interrupted
        }
        
        // Continue processing
        
        /**
         * SEVERE PROBLEM:
         * 
         * InterruptedException signals:
         * - Thread should stop
         * - Shutdown requested
         * - Cancel operation
         * 
         * Swallowing it:
         * - Thread doesn't stop
         * - Application doesn't shutdown
         * - Have to kill -9
         */
    }
    
    /**
     * Correct pattern: Preserve interrupt status
     */
    public static void correctPreserveInterrupt() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            // ✓ Restore interrupt flag
            Thread.currentThread().interrupt();
            
            // ✓ Log
            System.err.println("Interrupted: " + e.getMessage());
            
            // ✓ Exit method or throw
            return;
        }
        
        /**
         * CORRECT HANDLING:
         * 
         * 1. Restore interrupt flag
         * 2. Log the interruption
         * 3. Exit method or propagate
         * 
         * Thread can be interrupted properly
         */
    }
    
    /**
     * Summary
     */
    public static void summary() {
        /**
         * EXCEPTION SWALLOWING:
         * 
         * ❌ Log and continue
         * ❌ Return null on error
         * ❌ Silent defaults
         * ❌ Huge try blocks
         * ❌ Swallow InterruptedException
         * 
         * ✓ Collect errors and report
         * ✓ Let exceptions propagate
         * ✓ Explicit default handling
         * ✓ Fine-grained try blocks
         * ✓ Preserve interrupt status
         * 
         * 
         * GOLDEN RULE:
         * 
         * Don't swallow exceptions
         * Either:
         * 1. Handle them completely
         * 2. Propagate them
         * 3. Collect and report
         * 
         * Never silently ignore
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Anti-Pattern: Log and Continue ===");
        logAndContinue();
        
        System.out.println("\n=== Correct: Collect and Report ===");
        try {
            correctCollectAndReport();
        } catch (RuntimeException e) {
            System.out.println("Caught: " + e.getMessage());
        }
    }
}
```

---

## 7. Correct Patterns

### Exception Handling Best Practices

```java
/**
 * CORRECT EXCEPTION HANDLING PATTERNS
 * 
 * Best practices and recommended patterns
 */

import java.io.*;
import java.util.*;

public class CorrectPatterns {
    
    /**
     * Pattern 1: Catch specific exceptions
     */
    public static void catchSpecificExceptions() {
        try {
            performOperation();
            
        } catch (FileNotFoundException e) {
            // ✓ Specific: File doesn't exist
            System.out.println("File not found, using defaults");
            useDefaults();
            
        } catch (IOException e) {
            // ✓ Specific: Other I/O error
            System.err.println("I/O error: " + e.getMessage());
            throw new RuntimeException("Operation failed", e);
            
        } catch (IllegalStateException e) {
            // ✓ Specific: State problem
            System.err.println("Invalid state: " + e.getMessage());
            resetState();
        }
        
        /**
         * BENEFITS:
         * 
         * ✓ Different handling per error type
         * ✓ Programming errors still crash
         * ✓ Clear what can go wrong
         * ✓ Specific recovery strategies
         */
    }
    
    private static void performOperation() throws IOException {}
    private static void useDefaults() {}
    private static void resetState() {}
    
    /**
     * Pattern 2: Always add context when rethrowing
     */
    public static void processUser(String userId) {
        try {
            loadUserData(userId);
            validateUser();
            updateDatabase();
            
        } catch (SQLException e) {
            // ✓ Add business context
            throw new RuntimeException(
                "Failed to process user: " + userId, e);
        }
        
        /**
         * CONTEXT ADDED:
         * 
         * - Which operation
         * - Which user
         * - Original technical error
         * 
         * Complete debugging information
         */
    }
    
    private static void loadUserData(String userId) throws SQLException {}
    private static void validateUser() {}
    private static void updateDatabase() throws SQLException {}
    
    /**
     * Pattern 3: Use try-with-resources
     */
    public static void useTryWithResources() {
        try (BufferedReader reader = new BufferedReader(
                new FileReader("data.txt"))) {
            
            String line;
            while ((line = reader.readLine()) != null) {
                processLine(line);
            }
            
        } catch (IOException e) {
            System.err.println("Error reading file: " + e.getMessage());
            throw new RuntimeException("File processing failed", e);
        }
        
        /**
         * BENEFITS:
         * 
         * ✓ Automatic resource closing
         * ✓ Even on exception
         * ✓ Suppressed exceptions preserved
         * ✓ No resource leaks
         */
    }
    
    private static void processLine(String line) {}
    
    /**
     * Pattern 4: Log once at the top level
     */
    static class DataLayer {
        public void save(String data) throws SQLException {
            throw new SQLException("Constraint violation");
        }
    }
    
    static class ServiceLayer {
        private DataLayer dataLayer = new DataLayer();
        
        public void processData(String data) {
            try {
                dataLayer.save(data);
            } catch (SQLException e) {
                // ✓ Don't log here, add context and rethrow
                throw new RuntimeException(
                    "Failed to save data: " + data, e);
            }
        }
    }
    
    static class ControllerLayer {
        private ServiceLayer service = new ServiceLayer();
        
        public void handleRequest(String data) {
            try {
                service.processData(data);
                
            } catch (Exception e) {
                // ✓ Log once at top level
                System.err.println("Request failed:");
                e.printStackTrace();
                
                // Respond to client
                throw new RuntimeException("Request processing failed", e);
            }
        }
    }
    
    /**
     * Pattern 5: Fail fast
     */
    public static void failFast(String input) {
        // ✓ Validate early
        if (input == null) {
            throw new IllegalArgumentException("Input cannot be null");
        }
        
        if (input.isEmpty()) {
            throw new IllegalArgumentException("Input cannot be empty");
        }
        
        // Continue with valid input
        processInput(input);
        
        /**
         * FAIL FAST BENEFITS:
         * 
         * ✓ Catch errors early
         * ✓ Clear error messages
         * ✓ Easier debugging
         * ✓ Prevent invalid state
         */
    }
    
    private static void processInput(String input) {}
    
    /**
     * Pattern 6: Validate preconditions
     */
    public static void transfer(Account from, Account to, double amount) {
        // ✓ Validate all preconditions
        Objects.requireNonNull(from, "Source account cannot be null");
        Objects.requireNonNull(to, "Destination account cannot be null");
        
        if (amount <= 0) {
            throw new IllegalArgumentException(
                "Amount must be positive: " + amount);
        }
        
        if (from.getBalance() < amount) {
            throw new IllegalStateException(
                "Insufficient balance: " + from.getBalance());
        }
        
        // All valid - proceed
        from.withdraw(amount);
        to.deposit(amount);
        
        /**
         * PRECONDITION VALIDATION:
         * 
         * ✓ Check all assumptions
         * ✓ Fail fast on invalid
         * ✓ Clear error messages
         * ✓ Prevent invalid operations
         */
    }
    
    static class Account {
        private double balance;
        double getBalance() { return balance; }
        void withdraw(double amount) { balance -= amount; }
        void deposit(double amount) { balance += amount; }
    }
    
    /**
     * Pattern 7: Use custom exceptions for domain errors
     */
    static class InsufficientFundsException extends Exception {
        private final double balance;
        private final double requested;
        
        public InsufficientFundsException(double balance, double requested) {
            super(String.format(
                "Insufficient funds: balance=%.2f, requested=%.2f",
                balance, requested));
            this.balance = balance;
            this.requested = requested;
        }
        
        public double getShortfall() {
            return requested - balance;
        }
    }
    
    public static void withdraw(Account account, double amount) 
            throws InsufficientFundsException {
        
        if (account.getBalance() < amount) {
            throw new InsufficientFundsException(
                account.getBalance(), amount);
        }
        
        account.withdraw(amount);
        
        /**
         * CUSTOM EXCEPTION BENEFITS:
         * 
         * ✓ Domain-specific
         * ✓ Carries context data
         * ✓ Type-safe handling
         * ✓ Clear intent
         */
    }
    
    /**
     * Pattern 8: Document exceptions in javadoc
     */
    /**
     * Processes user data.
     *
     * @param userId the user ID to process
     * @throws IllegalArgumentException if userId is null or empty
     * @throws UserNotFoundException if user doesn't exist
     * @throws DataAccessException if database error occurs
     */
    public static void processUserDocumented(String userId) {
        // Implementation
    }
    
    /**
     * Pattern 9: Multi-catch for same handling
     */
    public static void multiCatchPattern() {
        try {
            performRiskyOperation();
            
        } catch (IOException | SQLException e) {
            // ✓ Handle both the same way
            System.err.println("Data operation failed: " + e.getMessage());
            throw new RuntimeException("Operation failed", e);
        }
        
        /**
         * MULTI-CATCH BENEFITS:
         * 
         * ✓ No code duplication
         * ✓ Clear same handling
         * ✓ Still specific (not all exceptions)
         */
    }
    
    private static void performRiskyOperation() throws IOException, SQLException {}
    
    /**
     * Pattern 10: Proper InterruptedException handling
     */
    public static void properInterruptHandling() {
        try {
            Thread.sleep(1000);
            
        } catch (InterruptedException e) {
            // ✓ 1. Restore interrupt flag
            Thread.currentThread().interrupt();
            
            // ✓ 2. Log
            System.err.println("Interrupted: " + e.getMessage());
            
            // ✓ 3. Cleanup and exit
            cleanup();
            throw new RuntimeException("Operation interrupted", e);
        }
        
        /**
         * INTERRUPT PATTERN:
         * 
         * 1. Thread.currentThread().interrupt()
         * 2. Log the interruption
         * 3. Cleanup resources
         * 4. Propagate (throw or return)
         */
    }
    
    private static void cleanup() {}
    
    /**
     * Best practices checklist
     */
    public static void bestPracticesChecklist() {
        /**
         * EXCEPTION HANDLING CHECKLIST:
         * 
         * ✓ Catch specific exceptions
         * ✓ Always chain exceptions
         * ✓ Add business context
         * ✓ Log at top level only
         * ✓ Use try-with-resources
         * ✓ Fail fast
         * ✓ Validate preconditions
         * ✓ Never swallow exceptions
         * ✓ Never empty catch blocks
         * ✓ Don't catch Throwable
         * ✓ Don't catch Exception (usually)
         * ✓ Don't use exceptions for flow control
         * ✓ Document in javadoc
         * ✓ Create custom exceptions for domain
         * ✓ Handle InterruptedException properly
         */
    }
    
    /**
     * Complete example
     */
    public static void completeExample(String userId) {
        // ✓ Validate
        Objects.requireNonNull(userId, "User ID cannot be null");
        
        // ✓ Try-with-resources
        try (Connection conn = openConnection()) {
            
            // ✓ Business operation
            User user = loadUser(conn, userId);
            validateUser(user);
            updateUser(conn, user);
            
        } catch (SQLException e) {
            // ✓ Add context
            System.err.println("Database operation failed for user: " + userId);
            e.printStackTrace();
            
            // ✓ Chain exception
            throw new RuntimeException(
                "Failed to process user: " + userId, e);
                
        } catch (ValidationException e) {
            // ✓ Handle specific error
            System.err.println("User validation failed: " + e.getMessage());
            throw new IllegalArgumentException(
                "Invalid user data: " + userId, e);
        }
        
        /**
         * DEMONSTRATES:
         * 
         * ✓ Precondition validation
         * ✓ Try-with-resources
         * ✓ Specific catches
         * ✓ Context added
         * ✓ Logging
         * ✓ Exception chaining
         * ✓ Different handling per type
         */
    }
    
    static class Connection implements AutoCloseable {
        @Override
        public void close() {}
    }
    
    static class User {}
    static class ValidationException extends Exception {
        public ValidationException(String message) { super(message); }
    }
    
    private static Connection openConnection() { return new Connection(); }
    private static User loadUser(Connection conn, String userId) throws SQLException {
        return new User();
    }
    private static void validateUser(User user) throws ValidationException {}
    private static void updateUser(Connection conn, User user) throws SQLException {}
    
    public static void main(String[] args) {
        System.out.println("=== Correct Patterns ===");
        catchSpecificExceptions();
        useTryWithResources();
        System.out.println("\nAll patterns demonstrated");
    }
}
```

---

## Summary

### Anti-Patterns Quick Reference

**❌ DON'T:**

```java
// 1. Catch Exception/Throwable
catch (Exception e) { }  // Too broad

// 2. Empty catch blocks
catch (IOException e) { }  // Silent failure

// 3. Exceptions for flow control
while (true) {
    try { array[i++]; }
    catch (ArrayIndexOutOfBoundsException e) { break; }
}

// 4. Lose stack traces
throw new RuntimeException("Failed");  // No cause

// 5. No context
throw new RuntimeException(e);  // What operation?

// 6. Swallow exceptions
catch (Exception e) { return null; }  // Silent error

// 7. Log and rethrow
e.printStackTrace();
throw new RuntimeException(e);  // Duplicate logs
```

**✅ DO:**

```java
// 1. Catch specific
catch (FileNotFoundException e) { }
catch (IOException e) { }

// 2. Always log or handle
catch (IOException e) {
    logger.error("File error", e);
    throw new RuntimeException("Failed", e);
}

// 3. Normal control flow
for (int i = 0; i < array.length; i++) { }

// 4. Chain exceptions
throw new RuntimeException("Failed", originalException);

// 5. Add context
throw new RuntimeException("Failed to process user: " + userId, e);

// 6. Propagate or handle fully
throw e;  // Or handle completely

// 7. Log once at top level
// Service: throw new RuntimeException("msg", e);
// Controller: logger.error("Request failed", e);
```

### Decision Trees

**Should I catch this exception?**

```
Can I handle it completely?
  YES → Handle it, don't rethrow
  NO → Continue...

Can I add useful context?
  YES → Add context, rethrow
  NO → Continue...

Is this top level?
  YES → Log and handle
  NO → Let it propagate
```

**What should I catch?**

```
Know specific exception type?
  YES → Catch specific
  NO → Continue...

Multiple types, same handling?
  YES → Multi-catch
  NO → Continue...

Top level or framework code?
  YES → Catch Exception
  NO → DON'T catch Exception
```

---
