# Immutable Collections and Defensive Copying

## Overview

Immutable collections are one of the most powerful tools for writing safe, concurrent, and maintainable code. This guide covers all approaches to immutability in Java - from JDK built-ins to third-party libraries - along with defensive copying strategies, performance characteristics, and best practices.



---

## 1. Collections.unmodifiableXXX()

### Wrapper-Based Immutability

```java
/**
 * COLLECTIONS.UNMODIFIABLE
 * 
 * Wrapping existing collections for read-only access
 */

import java.util.*;

public class UnmodifiableCollections {
    
    /**
     * Basic unmodifiable collections
     */
    public static void basicUnmodifiable() {
        // Create mutable collection
        List<String> mutableList = new ArrayList<>();
        mutableList.add("Alice");
        mutableList.add("Bob");
        mutableList.add("Charlie");
        
        // Wrap as unmodifiable
        List<String> unmodifiableList = 
            Collections.unmodifiableList(mutableList);
        
        System.out.println("Unmodifiable list: " + unmodifiableList);
        
        // Reading is fine
        System.out.println("First: " + unmodifiableList.get(0));
        System.out.println("Size: " + unmodifiableList.size());
        
        // Modification attempts throw exception
        try {
            unmodifiableList.add("Diana");
        } catch (UnsupportedOperationException e) {
            System.out.println("Cannot add: " + e.getClass().getSimpleName());
        }
        
        try {
            unmodifiableList.remove(0);
        } catch (UnsupportedOperationException e) {
            System.out.println("Cannot remove: " + e.getClass().getSimpleName());
        }
        
        try {
            unmodifiableList.clear();
        } catch (UnsupportedOperationException e) {
            System.out.println("Cannot clear: " + e.getClass().getSimpleName());
        }
        
        /**
         * OUTPUT:
         * Unmodifiable list: [Alice, Bob, Charlie]
         * First: Alice
         * Size: 3
         * Cannot add: UnsupportedOperationException
         * Cannot remove: UnsupportedOperationException
         * Cannot clear: UnsupportedOperationException
         * 
         * READ-ONLY VIEW:
         * All read operations work
         * All write operations throw UnsupportedOperationException
         */
    }
    
    /**
     * Critical pitfall: View, not copy
     */
    public static void viewNotCopy() {
        List<String> mutableList = new ArrayList<>();
        mutableList.add("Alice");
        mutableList.add("Bob");
        
        List<String> unmodifiableList = 
            Collections.unmodifiableList(mutableList);
        
        System.out.println("Before: " + unmodifiableList);
        
        // Modify original list
        mutableList.add("Charlie");
        
        System.out.println("After: " + unmodifiableList);
        
        // Remove from original
        mutableList.remove("Bob");
        
        System.out.println("After remove: " + unmodifiableList);
        
        /**
         * OUTPUT:
         * Before: [Alice, Bob]
         * After: [Alice, Bob, Charlie]  ← Changed!
         * After remove: [Alice, Charlie]  ← Changed!
         * 
         * CRITICAL ISSUE:
         * unmodifiableList is just a VIEW
         * Changes to original are visible!
         * NOT truly immutable!
         * 
         * SOLUTION:
         * Defensive copy before wrapping:
         * List<String> copy = new ArrayList<>(original);
         * List<String> unmod = Collections.unmodifiableList(copy);
         */
    }
    
    /**
     * All unmodifiable variants
     */
    public static void allVariants() {
        /**
         * AVAILABLE METHODS:
         * 
         * Collections.unmodifiableList(List)
         * Collections.unmodifiableSet(Set)
         * Collections.unmodifiableMap(Map)
         * Collections.unmodifiableSortedSet(SortedSet)
         * Collections.unmodifiableSortedMap(SortedMap)
         * Collections.unmodifiableNavigableSet(NavigableSet)
         * Collections.unmodifiableNavigableMap(NavigableMap)
         * Collections.unmodifiableCollection(Collection)
         * 
         * ALL return views, not copies!
         */
        
        // List
        List<String> list = new ArrayList<>(Arrays.asList("a", "b"));
        List<String> unmodList = Collections.unmodifiableList(list);
        
        // Set
        Set<String> set = new HashSet<>(Arrays.asList("x", "y"));
        Set<String> unmodSet = Collections.unmodifiableSet(set);
        
        // Map
        Map<String, Integer> map = new HashMap<>();
        map.put("one", 1);
        map.put("two", 2);
        Map<String, Integer> unmodMap = Collections.unmodifiableMap(map);
        
        System.out.println("List: " + unmodList);
        System.out.println("Set: " + unmodSet);
        System.out.println("Map: " + unmodMap);
    }
    
    /**
     * Nested collections pitfall
     */
    public static void nestedCollectionsPitfall() {
        List<List<String>> mutableNestedList = new ArrayList<>();
        List<String> innerList = new ArrayList<>(Arrays.asList("a", "b"));
        mutableNestedList.add(innerList);
        
        List<List<String>> unmodifiableNested = 
            Collections.unmodifiableList(mutableNestedList);
        
        System.out.println("Before: " + unmodifiableNested);
        
        // Cannot modify outer list
        try {
            unmodifiableNested.add(new ArrayList<>());
        } catch (UnsupportedOperationException e) {
            System.out.println("Cannot add to outer list");
        }
        
        // But CAN modify inner lists!
        unmodifiableNested.get(0).add("c");
        
        System.out.println("After: " + unmodifiableNested);
        
        /**
         * OUTPUT:
         * Before: [[a, b]]
         * Cannot add to outer list
         * After: [[a, b, c]]  ← Inner list modified!
         * 
         * PROBLEM:
         * Only outer collection is unmodifiable
         * Inner collections still mutable!
         * 
         * SOLUTION:
         * Deep defensive copy or use truly immutable collections
         */
    }
    
    /**
     * Proper defensive copy
     */
    public static void defensiveCopy() {
        List<String> original = new ArrayList<>();
        original.add("Alice");
        original.add("Bob");
        
        // Create defensive copy, then wrap
        List<String> defensiveCopy = new ArrayList<>(original);
        List<String> immutable = Collections.unmodifiableList(defensiveCopy);
        
        System.out.println("Immutable: " + immutable);
        
        // Modify original
        original.add("Charlie");
        original.remove("Bob");
        
        System.out.println("Original modified: " + original);
        System.out.println("Immutable unchanged: " + immutable);
        
        /**
         * OUTPUT:
         * Immutable: [Alice, Bob]
         * Original modified: [Alice, Charlie]
         * Immutable unchanged: [Alice, Bob]  ✓
         * 
         * PATTERN:
         * 1. Create copy of original
         * 2. Wrap copy as unmodifiable
         * 3. Don't keep reference to copy
         */
    }
    
    /**
     * Performance characteristics
     */
    public static void performanceCharacteristics() {
        /**
         * UNMODIFIABLE WRAPPER:
         * 
         * Creation: O(1) - just wraps existing collection
         * Memory: O(1) - one wrapper object (~16 bytes)
         * 
         * Read operations: Same as wrapped collection
         * - get(index): O(1) for ArrayList
         * - contains(e): O(1) for HashSet
         * 
         * Write operations: O(1) - throw exception immediately
         * 
         * 
         * WITH DEFENSIVE COPY:
         * 
         * Creation: O(n) - copy all elements
         * Memory: O(n) - full copy + wrapper
         * 
         * Trade-off:
         * - More creation overhead
         * - True immutability
         * - Safe from external changes
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Basic Unmodifiable ===");
        basicUnmodifiable();
        
        System.out.println("\n=== View Not Copy ===");
        viewNotCopy();
        
        System.out.println("\n=== Nested Collections Pitfall ===");
        nestedCollectionsPitfall();
        
        System.out.println("\n=== Defensive Copy ===");
        defensiveCopy();
    }
}
```

---

## 2. List.of(), Set.of(), Map.of() (Java 9+)

### True Immutable Collections

```java
/**
 * JAVA 9+ FACTORY METHODS
 * 
 * Truly immutable collections with convenient syntax
 */

import java.util.*;

public class Java9Immutables {
    
    /**
     * Basic factory methods
     */
    public static void basicFactoryMethods() {
        // List.of() - immutable list
        List<String> list = List.of("Alice", "Bob", "Charlie");
        System.out.println("List: " + list);
        
        // Set.of() - immutable set
        Set<Integer> set = Set.of(1, 2, 3, 4, 5);
        System.out.println("Set: " + set);
        
        // Map.of() - immutable map
        Map<String, Integer> map = Map.of(
            "Alice", 30,
            "Bob", 25,
            "Charlie", 35
        );
        System.out.println("Map: " + map);
        
        /**
         * OUTPUT:
         * List: [Alice, Bob, Charlie]
         * Set: [1, 2, 3, 4, 5]
         * Map: {Alice=30, Bob=25, Charlie=35}
         * 
         * CHARACTERISTICS:
         * - Truly immutable (not views)
         * - Cannot be modified
         * - Efficient memory layout
         * - Null elements/keys not allowed
         */
    }
    
    /**
     * Immutability enforcement
     */
    public static void immutabilityEnforcement() {
        List<String> list = List.of("a", "b", "c");
        
        // All modification attempts throw UnsupportedOperationException
        try {
            list.add("d");
        } catch (UnsupportedOperationException e) {
            System.out.println("Cannot add");
        }
        
        try {
            list.remove(0);
        } catch (UnsupportedOperationException e) {
            System.out.println("Cannot remove");
        }
        
        try {
            list.set(0, "x");
        } catch (UnsupportedOperationException e) {
            System.out.println("Cannot set");
        }
        
        try {
            list.clear();
        } catch (UnsupportedOperationException e) {
            System.out.println("Cannot clear");
        }
        
        /**
         * TRULY IMMUTABLE:
         * No way to modify after creation
         * Not a view - actual immutable implementation
         */
    }
    
    /**
     * Null handling
     */
    public static void nullHandling() {
        try {
            List<String> list = List.of("a", null, "c");
        } catch (NullPointerException e) {
            System.out.println("List.of() does not allow nulls");
        }
        
        try {
            Set<String> set = Set.of("a", null);
        } catch (NullPointerException e) {
            System.out.println("Set.of() does not allow nulls");
        }
        
        try {
            Map<String, String> map = Map.of("key", null);
        } catch (NullPointerException e) {
            System.out.println("Map.of() does not allow null values");
        }
        
        try {
            Map<String, String> map = Map.of(null, "value");
        } catch (NullPointerException e) {
            System.out.println("Map.of() does not allow null keys");
        }
        
        /**
         * NO NULLS ALLOWED:
         * - Cleaner semantics
         * - Avoid NullPointerExceptions later
         * - Fail fast at creation
         * 
         * If you need nulls, use Collections.unmodifiableXXX()
         */
    }
    
    /**
     * Set.of() duplicate handling
     */
    public static void duplicateHandling() {
        // No duplicates - fine
        Set<String> set1 = Set.of("a", "b", "c");
        System.out.println("No duplicates: " + set1);
        
        // Duplicates - throws exception!
        try {
            Set<String> set2 = Set.of("a", "b", "a");
        } catch (IllegalArgumentException e) {
            System.out.println("Set.of() rejects duplicates at creation");
        }
        
        /**
         * DUPLICATE DETECTION:
         * Set.of() checks for duplicates
         * Fails fast if found
         * 
         * Regular HashSet silently ignores duplicates
         */
    }
    
    /**
     * Map factory methods
     */
    public static void mapFactoryMethods() {
        // Map.of() - up to 10 entries
        Map<String, Integer> small = Map.of(
            "one", 1,
            "two", 2,
            "three", 3
        );
        System.out.println("Small map: " + small);
        
        // Map.ofEntries() - arbitrary number
        Map<String, Integer> large = Map.ofEntries(
            Map.entry("one", 1),
            Map.entry("two", 2),
            Map.entry("three", 3),
            Map.entry("four", 4),
            Map.entry("five", 5),
            Map.entry("six", 6),
            Map.entry("seven", 7),
            Map.entry("eight", 8),
            Map.entry("nine", 9),
            Map.entry("ten", 10),
            Map.entry("eleven", 11)
        );
        System.out.println("Large map size: " + large.size());
        
        /**
         * MAP FACTORY VARIANTS:
         * 
         * Map.of() - 0 to 10 key-value pairs
         * - Map.of()
         * - Map.of(k1, v1)
         * - Map.of(k1, v1, k2, v2)
         * - ...
         * - Map.of(k1, v1, ..., k10, v10)
         * 
         * Map.ofEntries() - any number
         * - More verbose but flexible
         * - Use Map.entry(k, v) for each entry
         */
    }
    
    /**
     * Iteration order
     */
    public static void iterationOrder() {
        // List.of() - predictable (insertion order)
        List<String> list = List.of("a", "b", "c");
        System.out.println("List order: " + list);
        
        // Set.of() - unpredictable!
        Set<String> set = Set.of("a", "b", "c", "d", "e");
        System.out.println("Set order: " + set);
        
        // Map.of() - unpredictable!
        Map<String, Integer> map = Map.of("a", 1, "b", 2, "c", 3);
        System.out.println("Map order: " + map);
        
        /**
         * ITERATION ORDER:
         * 
         * List.of(): Guaranteed insertion order
         * Set.of(): Unspecified (implementation-dependent)
         * Map.of(): Unspecified (implementation-dependent)
         * 
         * WARNING:
         * Don't rely on Set/Map iteration order!
         * May change between JVM versions
         */
    }
    
    /**
     * Performance characteristics
     */
    public static void performanceCharacteristics() {
        /**
         * SPACE-OPTIMIZED IMPLEMENTATIONS:
         * 
         * List.of():
         * - Small (0-2 elements): Specialized classes
         * - Large (3+ elements): Array-backed
         * - Memory: ~20% less than ArrayList
         * 
         * Set.of():
         * - Small (0-2 elements): Specialized classes
         * - Large (3+ elements): Custom implementation
         * - Memory: ~30% less than HashSet
         * 
         * Map.of():
         * - Small (0-1 entries): Specialized classes
         * - Large (2+ entries): Custom implementation
         * - Memory: ~40% less than HashMap
         * 
         * 
         * TIME COMPLEXITY:
         * Same as mutable counterparts:
         * - List.get(): O(1)
         * - Set.contains(): O(1)
         * - Map.get(): O(1)
         * 
         * 
         * CREATION:
         * - List.of(): O(n)
         * - Set.of(): O(n) with duplicate check
         * - Map.of(): O(n) with duplicate key check
         */
    }
    
    /**
     * Use cases
     */
    public static void useCases() {
        /**
         * PERFECT FOR:
         * 
         * 1. CONSTANTS:
         */
        static final List<String> WEEKDAYS = 
            List.of("Mon", "Tue", "Wed", "Thu", "Fri");
        
        /**
         * 2. CONFIGURATION:
         */
        static final Map<String, String> CONFIG = Map.of(
            "host", "localhost",
            "port", "8080",
            "protocol", "https"
        );
        
        /**
         * 3. METHOD RETURNS:
         */
        public List<String> getValidStates() {
            return List.of("PENDING", "APPROVED", "REJECTED");
        }
        
        /**
         * 4. TEST DATA:
         */
        @Test
        public void testProcessing() {
            List<User> users = List.of(
                new User("Alice", 30),
                new User("Bob", 25)
            );
            // Test with immutable data
        }
        
        /**
         * 5. API RESPONSES:
         */
        public Set<String> getTags() {
            return Set.of("java", "performance", "collections");
        }
    }
    
    public static void main(String[] args) {
        System.out.println("=== Basic Factory Methods ===");
        basicFactoryMethods();
        
        System.out.println("\n=== Immutability Enforcement ===");
        immutabilityEnforcement();
        
        System.out.println("\n=== Null Handling ===");
        nullHandling();
        
        System.out.println("\n=== Duplicate Handling ===");
        duplicateHandling();
        
        System.out.println("\n=== Map Factory Methods ===");
        mapFactoryMethods();
        
        System.out.println("\n=== Iteration Order ===");
        iterationOrder();
    }
}
```

---

## 3. Guava ImmutableList, ImmutableMap

### Industrial-Strength Immutability

```java
/**
 * GUAVA IMMUTABLE COLLECTIONS
 * 
 * Google's Guava library - most mature immutable collections
 */

import com.google.common.collect.*;
import java.util.*;

/**
 * Maven dependency:
 * <dependency>
 *     <groupId>com.google.guava</groupId>
 *     <artifactId>guava</artifactId>
 *     <version>32.1.3-jre</version>
 * </dependency>
 */

public class GuavaImmutables {
    
    /**
     * Basic Guava immutable collections
     */
    public static void basicGuavaCollections() {
        // ImmutableList
        ImmutableList<String> list = ImmutableList.of("a", "b", "c");
        System.out.println("ImmutableList: " + list);
        
        // ImmutableSet
        ImmutableSet<Integer> set = ImmutableSet.of(1, 2, 3, 4, 5);
        System.out.println("ImmutableSet: " + set);
        
        // ImmutableMap
        ImmutableMap<String, Integer> map = ImmutableMap.of(
            "Alice", 30,
            "Bob", 25,
            "Charlie", 35
        );
        System.out.println("ImmutableMap: " + map);
        
        /**
         * SIMILAR TO JAVA 9:
         * - Truly immutable
         * - Null-hostile
         * - Efficient implementations
         * 
         * ADVANTAGES OVER JAVA 9:
         * - More collection types
         * - Builder pattern
         * - Works with Java 8
         * - Better documented guarantees
         */
    }
    
    /**
     * Builder pattern
     */
    public static void builderPattern() {
        // Build ImmutableList
        ImmutableList<String> list = ImmutableList.<String>builder()
            .add("Alice")
            .add("Bob")
            .add("Charlie")
            .addAll(Arrays.asList("Diana", "Eve"))
            .build();
        
        System.out.println("Built list: " + list);
        
        // Build ImmutableSet
        ImmutableSet<Integer> set = ImmutableSet.<Integer>builder()
            .add(1)
            .add(2, 3, 4)
            .addAll(Arrays.asList(5, 6, 7))
            .build();
        
        System.out.println("Built set: " + set);
        
        // Build ImmutableMap
        ImmutableMap<String, Integer> map = ImmutableMap.<String, Integer>builder()
            .put("one", 1)
            .put("two", 2)
            .put("three", 3)
            .putAll(Map.of("four", 4, "five", 5))
            .build();
        
        System.out.println("Built map: " + map);
        
        /**
         * BUILDER BENEFITS:
         * - Flexible construction
         * - Can add conditionally
         * - Can add from multiple sources
         * - Type-safe
         * - Fluent API
         */
    }
    
    /**
     * copyOf() methods
     */
    public static void copyOfMethods() {
        // From existing collection
        List<String> mutableList = new ArrayList<>();
        mutableList.add("a");
        mutableList.add("b");
        mutableList.add("c");
        
        ImmutableList<String> immutableCopy = 
            ImmutableList.copyOf(mutableList);
        
        System.out.println("Copy: " + immutableCopy);
        
        // Modify original
        mutableList.add("d");
        mutableList.remove("b");
        
        System.out.println("Original modified: " + mutableList);
        System.out.println("Copy unchanged: " + immutableCopy);
        
        /**
         * DEFENSIVE COPY:
         * copyOf() creates actual copy
         * Safe from external changes
         * 
         * OPTIMIZATION:
         * If input is already immutable Guava collection,
         * copyOf() returns same instance (no copy needed)
         */
    }
    
    /**
     * Specialized immutable collections
     */
    public static void specializedCollections() {
        // ImmutableSortedSet - sorted
        ImmutableSortedSet<Integer> sortedSet = 
            ImmutableSortedSet.of(5, 2, 8, 1, 9);
        System.out.println("ImmutableSortedSet: " + sortedSet);
        
        // ImmutableSortedMap - sorted by keys
        ImmutableSortedMap<String, Integer> sortedMap = 
            ImmutableSortedMap.of(
                "charlie", 3,
                "alice", 1,
                "bob", 2
            );
        System.out.println("ImmutableSortedMap: " + sortedMap);
        
        // ImmutableMultiset - allows duplicates with counts
        ImmutableMultiset<String> multiset = 
            ImmutableMultiset.of("a", "b", "a", "c", "a");
        System.out.println("ImmutableMultiset: " + multiset);
        System.out.println("Count of 'a': " + multiset.count("a"));
        
        // ImmutableMultimap - multiple values per key
        ImmutableMultimap<String, String> multimap = 
            ImmutableMultimap.of(
                "fruit", "apple",
                "fruit", "banana",
                "vegetable", "carrot"
            );
        System.out.println("ImmutableMultimap: " + multimap);
        System.out.println("Fruits: " + multimap.get("fruit"));
        
        // ImmutableBiMap - bidirectional map
        ImmutableBiMap<String, Integer> bimap = 
            ImmutableBiMap.of(
                "Alice", 1,
                "Bob", 2,
                "Charlie", 3
            );
        System.out.println("ImmutableBiMap: " + bimap);
        System.out.println("Inverse: " + bimap.inverse());
        
        /**
         * SPECIALIZED TYPES:
         * - ImmutableSortedSet
         * - ImmutableSortedMap
         * - ImmutableMultiset
         * - ImmutableMultimap
         * - ImmutableListMultimap
         * - ImmutableSetMultimap
         * - ImmutableBiMap
         * - ImmutableTable
         * - ImmutableRangeSet
         * - ImmutableRangeMap
         * 
         * Much richer than JDK!
         */
    }
    
    /**
     * Null handling
     */
    public static void nullHandling() {
        try {
            ImmutableList<String> list = ImmutableList.of("a", null, "c");
        } catch (NullPointerException e) {
            System.out.println("Guava immutables reject nulls");
        }
        
        /**
         * NULL-HOSTILE:
         * All Guava immutable collections reject nulls
         * - Consistent with Java 9+
         * - Fail fast
         * - Cleaner semantics
         */
    }
    
    /**
     * Performance characteristics
     */
    public static void performanceCharacteristics() {
        /**
         * OPTIMIZED IMPLEMENTATIONS:
         * 
         * ImmutableList:
         * - Backed by array
         * - get(): O(1)
         * - Memory: ~20-30% less than ArrayList
         * 
         * ImmutableSet:
         * - Hash-based (like HashMap)
         * - contains(): O(1)
         * - Memory: ~30% less than HashSet
         * - Iteration order: unspecified
         * 
         * ImmutableMap:
         * - Hash-based
         * - get(): O(1)
         * - Memory: ~40% less than HashMap
         * - Optimized for small maps
         * 
         * ImmutableSortedSet:
         * - Sorted array (not tree!)
         * - contains(): O(log n) binary search
         * - Memory: less than TreeSet
         * - Faster iteration than TreeSet
         * 
         * 
         * CREATION COST:
         * - of(): O(n) - create from varargs
         * - copyOf(): O(n) - defensive copy
         * - builder().build(): O(n) - create from builder
         * 
         * MEMORY BENEFITS:
         * - No spare capacity
         * - No modification overhead
         * - Specialized implementations for small sizes
         */
    }
    
    /**
     * asList() for zero-copy sublists
     */
    public static void asListZeroCopy() {
        ImmutableSet<String> set = ImmutableSet.of("a", "b", "c", "d");
        
        // Get as List view (zero-copy)
        ImmutableList<String> list = set.asList();
        
        System.out.println("Set: " + set);
        System.out.println("List view: " + list);
        
        // Random access on set elements
        System.out.println("Element 0: " + list.get(0));
        System.out.println("Element 2: " + list.get(2));
        
        /**
         * ZERO-COPY VIEW:
         * asList() returns view, not copy
         * Enables indexed access to set elements
         * O(1) memory overhead
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Basic Guava Collections ===");
        basicGuavaCollections();
        
        System.out.println("\n=== Builder Pattern ===");
        builderPattern();
        
        System.out.println("\n=== copyOf() Methods ===");
        copyOfMethods();
        
        System.out.println("\n=== Specialized Collections ===");
        specializedCollections();
        
        System.out.println("\n=== asList() Zero-Copy ===");
        asListZeroCopy();
    }
}
```

---

## 4. Defensive Copying Strategies

### Protecting Internal State

```java
/**
 * DEFENSIVE COPYING
 * 
 * Strategies for safe encapsulation
 */

import java.util.*;
import com.google.common.collect.*;

public class DefensiveCopying {
    
    /**
     * Problem: Exposing mutable collections
     */
    static class BadClass {
        private List<String> items = new ArrayList<>();
        
        public BadClass() {
            items.add("Alice");
            items.add("Bob");
        }
        
        // BAD: Returns internal reference
        public List<String> getItems() {
            return items;
        }
    }
    
    public static void exposedMutableState() {
        BadClass bad = new BadClass();
        System.out.println("Initial: " + bad.getItems());
        
        // Client can modify internal state!
        List<String> items = bad.getItems();
        items.add("Malicious");
        items.clear();
        
        System.out.println("After client modification: " + bad.getItems());
        
        /**
         * OUTPUT:
         * Initial: [Alice, Bob]
         * After client modification: []
         * 
         * PROBLEM:
         * Internal state exposed and modified
         * Encapsulation broken!
         */
    }
    
    /**
     * Solution 1: Defensive copy on return
     */
    static class DefensiveCopyOnReturn {
        private List<String> items = new ArrayList<>();
        
        public DefensiveCopyOnReturn() {
            items.add("Alice");
            items.add("Bob");
        }
        
        // GOOD: Return defensive copy
        public List<String> getItems() {
            return new ArrayList<>(items);
        }
    }
    
    public static void defensiveCopyReturn() {
        DefensiveCopyOnReturn obj = new DefensiveCopyOnReturn();
        System.out.println("Initial: " + obj.getItems());
        
        // Client gets copy, can't affect internal state
        List<String> items = obj.getItems();
        items.add("Harmless");
        items.clear();
        
        System.out.println("After client modification: " + obj.getItems());
        
        /**
         * OUTPUT:
         * Initial: [Alice, Bob]
         * After client modification: [Alice, Bob]  ✓
         * 
         * PROTECTED:
         * Internal state safe from external modification
         */
    }
    
    /**
     * Solution 2: Return unmodifiable view
     */
    static class UnmodifiableReturn {
        private List<String> items = new ArrayList<>();
        
        public UnmodifiableReturn() {
            items.add("Alice");
            items.add("Bob");
        }
        
        // GOOD: Return unmodifiable view
        public List<String> getItems() {
            return Collections.unmodifiableList(items);
        }
        
        // Allow controlled modification
        public void addItem(String item) {
            items.add(item);
        }
    }
    
    public static void unmodifiableReturn() {
        UnmodifiableReturn obj = new UnmodifiableReturn();
        System.out.println("Initial: " + obj.getItems());
        
        // Client cannot modify
        List<String> items = obj.getItems();
        try {
            items.add("Fail");
        } catch (UnsupportedOperationException e) {
            System.out.println("Cannot modify");
        }
        
        // But can see updates
        obj.addItem("Charlie");
        System.out.println("After internal modification: " + items);
        
        /**
         * OUTPUT:
         * Initial: [Alice, Bob]
         * Cannot modify
         * After internal modification: [Alice, Bob, Charlie]
         * 
         * LIVE VIEW:
         * Read-only but reflects changes
         * Good for observable state
         */
    }
    
    /**
     * Solution 3: Immutable collection (Java 9+)
     */
    static class ImmutableReturn {
        private final List<String> items;
        
        public ImmutableReturn(List<String> items) {
            // Defensive copy + immutable
            this.items = List.copyOf(items);
        }
        
        // BEST: Return immutable
        public List<String> getItems() {
            return items;  // Already immutable, safe to return
        }
    }
    
    public static void immutableReturn() {
        List<String> input = new ArrayList<>();
        input.add("Alice");
        input.add("Bob");
        
        ImmutableReturn obj = new ImmutableReturn(input);
        System.out.println("Initial: " + obj.getItems());
        
        // Modify input
        input.add("Charlie");
        input.clear();
        
        System.out.println("After input modification: " + obj.getItems());
        
        // Client cannot modify
        try {
            obj.getItems().add("Fail");
        } catch (UnsupportedOperationException e) {
            System.out.println("Cannot modify");
        }
        
        /**
         * OUTPUT:
         * Initial: [Alice, Bob]
         * After input modification: [Alice, Bob]  ✓
         * Cannot modify
         * 
         * TRULY IMMUTABLE:
         * Safe from all external modification
         * No overhead on getItems() calls
         */
    }
    
    /**
     * Defensive copy on input
     */
    static class DefensiveCopyOnInput {
        private List<String> items;
        
        // BAD: Stores reference directly
        public void setItemsBad(List<String> items) {
            this.items = items;
        }
        
        // GOOD: Defensive copy on input
        public void setItemsGood(List<String> items) {
            this.items = new ArrayList<>(items);
        }
    }
    
    public static void defensiveCopyInput() {
        DefensiveCopyOnInput obj = new DefensiveCopyOnInput();
        
        List<String> external = new ArrayList<>();
        external.add("Alice");
        external.add("Bob");
        
        // Bad approach
        obj.setItemsBad(external);
        external.add("Evil");  // Modifies internal state!
        
        System.out.println("Bad approach affected by external change");
        
        // Good approach
        obj.setItemsGood(external);
        external.clear();  // Doesn't affect internal state
        
        System.out.println("Good approach safe from external change");
        
        /**
         * RULE:
         * Never store client-provided mutable objects directly
         * Always make defensive copy on input
         */
    }
    
    /**
     * Deep defensive copy for nested collections
     */
    static class DeepDefensiveCopy {
        private List<List<String>> nestedList;
        
        // Shallow copy - BAD
        public void setNestedBad(List<List<String>> nested) {
            this.nestedList = new ArrayList<>(nested);
        }
        
        // Deep copy - GOOD
        public void setNestedGood(List<List<String>> nested) {
            this.nestedList = new ArrayList<>();
            for (List<String> innerList : nested) {
                this.nestedList.add(new ArrayList<>(innerList));
            }
        }
        
        // Immutable - BEST
        public void setNestedBest(List<List<String>> nested) {
            List<ImmutableList<String>> temp = new ArrayList<>();
            for (List<String> innerList : nested) {
                temp.add(ImmutableList.copyOf(innerList));
            }
            this.nestedList = ImmutableList.copyOf(temp);
        }
        
        public List<List<String>> getNestedList() {
            return nestedList;
        }
    }
    
    public static void deepDefensiveCopy() {
        /**
         * NESTED COLLECTIONS REQUIRE DEEP COPY:
         * 
         * Shallow copy: Only copies outer collection
         * - Inner collections still shared
         * - Client can modify inner lists
         * 
         * Deep copy: Copies all levels
         * - Safe from all modifications
         * - More expensive
         * 
         * Immutable: Best of both worlds
         * - Truly safe
         * - Can return without copying
         */
    }
    
    /**
     * Performance trade-offs
     */
    public static void performanceTradeoffs() {
        int n = 10_000;
        List<String> data = new ArrayList<>(n);
        for (int i = 0; i < n; i++) {
            data.add("item" + i);
        }
        
        // Measure defensive copy
        long start = System.nanoTime();
        for (int i = 0; i < 1000; i++) {
            List<String> copy = new ArrayList<>(data);
        }
        long copyTime = System.nanoTime() - start;
        
        // Measure unmodifiable wrapper
        start = System.nanoTime();
        for (int i = 0; i < 1000; i++) {
            List<String> unmod = Collections.unmodifiableList(data);
        }
        long wrapTime = System.nanoTime() - start;
        
        // Measure immutable (already created)
        List<String> immutable = ImmutableList.copyOf(data);
        start = System.nanoTime();
        for (int i = 0; i < 1000; i++) {
            List<String> ref = immutable;  // Just reference
        }
        long immutableTime = System.nanoTime() - start;
        
        System.out.println("1000 calls with 10K elements:");
        System.out.println("Defensive copy: " + copyTime / 1_000_000 + "ms");
        System.out.println("Unmodifiable wrapper: " + wrapTime / 1_000_000 + "ms");
        System.out.println("Immutable (return): " + immutableTime / 1_000_000 + "ms");
        
        /**
         * OUTPUT (typical):
         * 1000 calls with 10K elements:
         * Defensive copy: 250ms (O(n) each call)
         * Unmodifiable wrapper: 1ms (O(1) each call)
         * Immutable (return): 0ms (just reference)
         * 
         * TRADE-OFFS:
         * Defensive copy: Safe, expensive on every call
         * Unmodifiable: Fast, but live view
         * Immutable: Best, but requires upfront creation
         */
    }
    
    /**
     * Best practices summary
     */
    public static void bestPractices() {
        /**
         * DEFENSIVE COPYING BEST PRACTICES:
         * 
         * 1. PREFER IMMUTABLE:
         *    Store immutable collections internally
         *    Return them directly (no copy needed)
         * 
         * 2. COPY ON INPUT:
         *    Never store client-provided mutable objects
         *    Make defensive copy in constructor/setter
         * 
         * 3. RETURN STRATEGY:
         *    a) If immutable: return directly
         *    b) If live view OK: return unmodifiable wrapper
         *    c) If snapshot needed: return defensive copy
         * 
         * 4. DEEP COPY WHEN NEEDED:
         *    Nested collections require deep copy
         *    Consider immutable for simplicity
         * 
         * 5. DOCUMENT BEHAVIOR:
         *    Javadoc whether returned collection is:
         *    - Immutable
         *    - Unmodifiable view
         *    - Defensive copy
         * 
         * 6. PREFER JAVA 9+ OR GUAVA:
         *    Use List.of(), ImmutableList
         *    Better than Collections.unmodifiableList()
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Exposed Mutable State ===");
        exposedMutableState();
        
        System.out.println("\n=== Defensive Copy on Return ===");
        defensiveCopyReturn();
        
        System.out.println("\n=== Unmodifiable Return ===");
        unmodifiableReturn();
        
        System.out.println("\n=== Immutable Return ===");
        immutableReturn();
        
        System.out.println("\n=== Performance Trade-offs ===");
        performanceTradeoffs();
    }
}
```

---

## 5. Performance of Immutable Collections

### Benchmarking and Optimization

```java
/**
 * IMMUTABLE COLLECTION PERFORMANCE
 * 
 * Detailed performance comparison
 */

import java.util.*;
import com.google.common.collect.*;
import org.openjdk.jmh.annotations.*;
import java.util.concurrent.TimeUnit;

@State(Scope.Benchmark)
@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
@Warmup(iterations = 5, time = 1)
@Measurement(iterations = 10, time = 1)
@Fork(2)
public class ImmutablePerformance {
    
    @Param({"10", "100", "1000"})
    private int size;
    
    private List<String> arrayList;
    private List<String> unmodifiableList;
    private List<String> javaImmutableList;
    private ImmutableList<String> guavaImmutableList;
    
    @Setup
    public void setup() {
        // Create data
        List<String> data = new ArrayList<>();
        for (int i = 0; i < size; i++) {
            data.add("item" + i);
        }
        
        // ArrayList
        arrayList = new ArrayList<>(data);
        
        // Unmodifiable wrapper
        unmodifiableList = Collections.unmodifiableList(
            new ArrayList<>(data)
        );
        
        // Java 9+ immutable
        javaImmutableList = List.copyOf(data);
        
        // Guava immutable
        guavaImmutableList = ImmutableList.copyOf(data);
    }
    
    @Benchmark
    public String arrayListGet() {
        return arrayList.get(size / 2);
    }
    
    @Benchmark
    public String unmodifiableListGet() {
        return unmodifiableList.get(size / 2);
    }
    
    @Benchmark
    public String javaImmutableListGet() {
        return javaImmutableList.get(size / 2);
    }
    
    @Benchmark
    public String guavaImmutableListGet() {
        return guavaImmutableList.get(size / 2);
    }
    
    @Benchmark
    public void arrayListIteration(Blackhole blackhole) {
        for (String s : arrayList) {
            blackhole.consume(s);
        }
    }
    
    @Benchmark
    public void javaImmutableIteration(Blackhole blackhole) {
        for (String s : javaImmutableList) {
            blackhole.consume(s);
        }
    }
    
    @Benchmark
    public void guavaImmutableIteration(Blackhole blackhole) {
        for (String s : guavaImmutableList) {
            blackhole.consume(s);
        }
    }
    
    /**
     * Typical results
     */
    public static void typicalResults() {
        /**
         * BENCHMARK RESULTS:
         * 
         * Benchmark                      (size)  Mode  Cnt   Score   Error  Units
         * arrayListGet                       10  avgt   20   2.1 ±   0.1   ns/op
         * unmodifiableListGet                10  avgt   20   2.3 ±   0.1   ns/op
         * javaImmutableListGet               10  avgt   20   2.1 ±   0.1   ns/op
         * guavaImmutableListGet              10  avgt   20   2.2 ±   0.1   ns/op
         * 
         * arrayListGet                      100  avgt   20   2.1 ±   0.1   ns/op
         * javaImmutableListGet              100  avgt   20   2.1 ±   0.1   ns/op
         * guavaImmutableListGet             100  avgt   20   2.1 ±   0.1   ns/op
         * 
         * arrayListIteration                100  avgt   20  215.3 ± 5.2   ns/op
         * javaImmutableIteration            100  avgt   20  212.8 ± 4.8   ns/op
         * guavaImmutableIteration           100  avgt   20  210.5 ± 4.5   ns/op
         * 
         * INSIGHTS:
         * - get() performance: Identical (all O(1) array access)
         * - Iteration: Immutable slightly faster (no modification checks)
         * - Minimal overhead for immutability
         */
    }
    
    /**
     * Memory comparison
     */
    public static void memoryComparison() {
        /**
         * MEMORY USAGE (1000 String elements):
         * 
         * ArrayList:
         * - ArrayList object: 24 bytes
         * - Array (capacity 1000): 8,016 bytes
         * - Total: 8,040 bytes
         * 
         * Collections.unmodifiableList:
         * - ArrayList: 8,040 bytes
         * - UnmodifiableList wrapper: 16 bytes
         * - Total: 8,056 bytes (+0.2%)
         * 
         * List.of() (Java 9+):
         * - ImmutableCollections.ListN: 32 bytes
         * - Array (exact size): 8,000 bytes
         * - Total: 8,032 bytes (-0.1%)
         * 
         * ImmutableList (Guava):
         * - RegularImmutableList: 24 bytes
         * - Array (exact size): 8,000 bytes
         * - Total: 8,024 bytes (-0.2%)
         * 
         * MEMORY SAVINGS:
         * - No spare capacity (ArrayList has ~50% waste on average)
         * - Optimized object layout
         * - For 1000 elements: ~20-40% less than ArrayList
         */
    }
    
    /**
     * Creation performance
     */
    @Benchmark
    public List<String> createArrayList() {
        List<String> list = new ArrayList<>();
        for (int i = 0; i < size; i++) {
            list.add("item" + i);
        }
        return list;
    }
    
    @Benchmark
    public List<String> createUnmodifiableList() {
        List<String> list = new ArrayList<>();
        for (int i = 0; i < size; i++) {
            list.add("item" + i);
        }
        return Collections.unmodifiableList(list);
    }
    
    @Benchmark
    public List<String> createJavaImmutable() {
        String[] items = new String[size];
        for (int i = 0; i < size; i++) {
            items[i] = "item" + i;
        }
        return List.of(items);
    }
    
    @Benchmark
    public ImmutableList<String> createGuavaImmutable() {
        ImmutableList.Builder<String> builder = ImmutableList.builder();
        for (int i = 0; i < size; i++) {
            builder.add("item" + i);
        }
        return builder.build();
    }
    
    /**
     * Creation results
     */
    public static void creationResults() {
        /**
         * CREATION BENCHMARKS:
         * 
         * Benchmark                      (size)  Mode  Cnt    Score   Error  Units
         * createArrayList                   100  avgt   20  1250.5 ± 25.3   ns/op
         * createUnmodifiableList            100  avgt   20  1285.2 ± 28.1   ns/op
         * createJavaImmutable               100  avgt   20  1320.8 ± 30.5   ns/op
         * createGuavaImmutable              100  avgt   20  1380.5 ± 32.8   ns/op
         * 
         * INSIGHTS:
         * - ArrayList: Fastest (amortized resize)
         * - Unmodifiable: +3% (wrapper creation)
         * - Java immutable: +6% (defensive copy)
         * - Guava immutable: +10% (builder overhead)
         * 
         * TRADE-OFF:
         * Slightly slower creation
         * Much better safety and memory
         */
    }
}
```

---

## 6. When to Use Immutability

### Decision Framework and Best Practices

```java
/**
 * WHEN TO USE IMMUTABILITY
 * 
 * Guidelines and decision trees
 */

public class WhenToUseImmutability {
    
    /**
     * Decision tree
     */
    public static void decisionTree() {
        /**
         * USE IMMUTABLE COLLECTIONS WHEN:
         * 
         * ✅ Data won't change after creation
         * ✅ Shared across threads
         * ✅ Returned from methods
         * ✅ Stored in fields
         * ✅ Used as map keys or set elements
         * ✅ Constants and configuration
         * ✅ Method parameters (prevent modification)
         * ✅ Building APIs
         * 
         * USE MUTABLE COLLECTIONS WHEN:
         * 
         * ✅ Building up data incrementally
         * ✅ Frequent modifications needed
         * ✅ Performance-critical hot path
         * ✅ Working with legacy code
         * ✅ Temporary local variables
         */
    }
    
    /**
     * Always immutable scenarios
     */
    public static void alwaysImmutable() {
        /**
         * 1. CONSTANTS:
         */
        public static final List<String> VALID_STATES = 
            List.of("PENDING", "APPROVED", "REJECTED");
        
        public static final Map<String, Integer> PRIORITY_LEVELS = 
            Map.of("LOW", 1, "MEDIUM", 2, "HIGH", 3);
        
        /**
         * 2. CONFIGURATION:
         */
        public class Config {
            private final Map<String, String> properties;
            
            public Config(Map<String, String> props) {
                this.properties = Map.copyOf(props);
            }
            
            public Map<String, String> getProperties() {
                return properties;  // Already immutable
            }
        }
        
        /**
         * 3. API RESPONSES:
         */
        public List<User> getUsers() {
            return ImmutableList.copyOf(users);  // Safe return
        }
        
        /**
         * 4. VALUE OBJECTS:
         */
        public class Address {
            private final List<String> addressLines;
            
            public Address(List<String> lines) {
                this.addressLines = List.copyOf(lines);
            }
            
            public List<String> getAddressLines() {
                return addressLines;
            }
        }
    }
    
    /**
     * Thread safety with immutability
     */
    public static void threadSafety() {
        /**
         * IMMUTABLE = THREAD-SAFE:
         * 
         * No synchronization needed
         * Safe to share across threads
         * No defensive copying
         */
        
        // Thread-safe without synchronization
        public class ThreadSafeCache {
            private volatile ImmutableMap<String, String> cache = 
                ImmutableMap.of();
            
            public void update(Map<String, String> newEntries) {
                // Create new immutable map
                ImmutableMap<String, String> newCache = 
                    ImmutableMap.<String, String>builder()
                        .putAll(cache)
                        .putAll(newEntries)
                        .build();
                
                // Atomic update (volatile write)
                cache = newCache;
            }
            
            public String get(String key) {
                return cache.get(key);  // No locking needed
            }
        }
        
        /**
         * BENEFITS:
         * - No locks (better performance)
         * - No race conditions
         * - No corruption
         * - Simple reasoning
         */
    }
    
    /**
     * Immutability for correctness
     */
    public static void correctness() {
        /**
         * PREVENTS BUGS:
         */
        
        // BAD: Mutable shared state
        public class BadService {
            private List<String> items = new ArrayList<>();
            
            public void process() {
                // Other code might modify items!
                helper(items);
            }
            
            private void helper(List<String> list) {
                // Is list the same as when passed?
            }
        }
        
        // GOOD: Immutable shared state
        public class GoodService {
            private ImmutableList<String> items = ImmutableList.of();
            
            public void process() {
                // items guaranteed unchanged
                helper(items);
            }
            
            private void helper(List<String> list) {
                // list is same as when passed ✓
            }
        }
        
        /**
         * PREVENTS:
         * - Unexpected modifications
         * - Temporal coupling
         * - Defensive copying overhead
         * - Hard-to-debug state changes
         */
    }
    
    /**
     * Builder pattern for complex immutables
     */
    public static void builderPattern() {
        /**
         * BUILDER FOR COMPLEX CONSTRUCTION:
         */
        
        public class User {
            private final String name;
            private final int age;
            private final ImmutableList<String> roles;
            private final ImmutableMap<String, String> metadata;
            
            private User(Builder builder) {
                this.name = builder.name;
                this.age = builder.age;
                this.roles = builder.roles.build();
                this.metadata = builder.metadata.build();
            }
            
            public static class Builder {
                private String name;
                private int age;
                private ImmutableList.Builder<String> roles = 
                    ImmutableList.builder();
                private ImmutableMap.Builder<String, String> metadata = 
                    ImmutableMap.builder();
                
                public Builder name(String name) {
                    this.name = name;
                    return this;
                }
                
                public Builder age(int age) {
                    this.age = age;
                    return this;
                }
                
                public Builder addRole(String role) {
                    roles.add(role);
                    return this;
                }
                
                public Builder putMetadata(String key, String value) {
                    metadata.put(key, value);
                    return this;
                }
                
                public User build() {
                    return new User(this);
                }
            }
        }
        
        // Usage
        User user = new User.Builder()
            .name("Alice")
            .age(30)
            .addRole("admin")
            .addRole("user")
            .putMetadata("department", "Engineering")
            .build();
        
        /**
         * BENEFITS:
         * - Fluent API
         * - Validation in build()
         * - Immutable result
         * - Complex construction simplified
         */
    }
    
    /**
     * Performance considerations
     */
    public static void performanceConsiderations() {
        /**
         * WHEN IMMUTABILITY COSTS:
         * 
         * 1. FREQUENT MODIFICATIONS:
         *    Building large collection element by element
         *    → Use mutable builder, then make immutable
         * 
         * 2. HOT PATH:
         *    Critical performance path
         *    → Profile first, then decide
         * 
         * 3. VERY LARGE COLLECTIONS:
         *    Copying millions of elements
         *    → Consider structural sharing (persistent DS)
         * 
         * 
         * OPTIMIZATION PATTERNS:
         * 
         * PATTERN 1: Build mutable, return immutable
         */
        public List<String> processData(List<String> input) {
            List<String> temp = new ArrayList<>();
            for (String item : input) {
                // Complex processing
                temp.add(transform(item));
            }
            return List.copyOf(temp);  // Immutable on return
        }
        
        /**
         * PATTERN 2: Batch updates
         */
        public class Cache {
            private ImmutableMap<String, String> data = ImmutableMap.of();
            
            public void batchUpdate(Map<String, String> updates) {
                // Build new map with all updates at once
                data = ImmutableMap.<String, String>builder()
                    .putAll(data)
                    .putAll(updates)
                    .build();
            }
        }
        
        /**
         * PATTERN 3: Lazy immutability
         */
        public class LazyImmutable {
            private List<String> mutableData;
            private List<String> immutableView;
            
            public void add(String item) {
                mutableData.add(item);
                immutableView = null;  // Invalidate cache
            }
            
            public List<String> getData() {
                if (immutableView == null) {
                    immutableView = List.copyOf(mutableData);
                }
                return immutableView;
            }
        }
    }
    
    /**
     * Best practices summary
     */
    public static void bestPractices() {
        /**
         * IMMUTABILITY BEST PRACTICES:
         * 
         * 1. DEFAULT TO IMMUTABLE:
         *    Use immutable unless you need mutable
         *    Easier to reason about
         *    Safer in concurrent code
         * 
         * 2. PREFER JAVA 9+ OR GUAVA:
         *    List.of(), Set.of(), Map.of()
         *    ImmutableList, ImmutableSet, ImmutableMap
         *    Better than Collections.unmodifiableXXX()
         * 
         * 3. MAKE CLASSES IMMUTABLE:
         *    final class
         *    final fields
         *    Defensive copy in constructor
         *    No setters
         * 
         * 4. DOCUMENT IMMUTABILITY:
         *    Javadoc: "@return immutable list"
         *    Makes contract clear
         * 
         * 5. USE BUILDERS FOR COMPLEXITY:
         *    Builder pattern for complex objects
         *    Mutable building, immutable result
         * 
         * 6. PROFILE BEFORE OPTIMIZING:
         *    Immutability rarely a bottleneck
         *    Measure before using mutable
         * 
         * 7. DEFENSIVE PROGRAMMING:
         *    Copy on input
         *    Return immutable or copy on output
         *    Never trust external code
         */
    }
}
```

---

## Summary

### Quick Reference

**Immutability Options:**

```java
// JDK Unmodifiable (view)
List<String> unmod = Collections.unmodifiableList(list);
// ⚠️ View, not copy - changes visible!

// Java 9+ (truly immutable)
List<String> immutable = List.of("a", "b", "c");
Set<Integer> immutableSet = Set.of(1, 2, 3);
Map<String, Integer> immutableMap = Map.of("a", 1, "b", 2);
// ✅ Truly immutable, null-hostile, optimized

// Guava (most features)
ImmutableList<String> guava = ImmutableList.of("a", "b", "c");
ImmutableSet<String> guavaSet = ImmutableSet.copyOf(list);
ImmutableMap<String, Integer> guavaMap = 
    ImmutableMap.<String, Integer>builder()
        .put("a", 1)
        .put("b", 2)
        .build();
// ✅ Rich API, builder pattern, Java 8 compatible
```

**Comparison Table:**

```
┌────────────────────┬─────────┬────────────┬─────────┬─────────┐
│ Feature            │ Unmod   │ List.of()  │ Guava   │ Mutable │
├────────────────────┼─────────┼────────────┼─────────┼─────────┤
│ Truly immutable    │ No ❌   │ Yes ✅     │ Yes ✅  │ No      │
│ Null support       │ Yes     │ No         │ No      │ Yes     │
│ Memory efficient   │ Yes     │ Yes ✅     │ Yes ✅  │ No      │
│ Thread-safe        │ Read ✅ │ Yes ✅     │ Yes ✅  │ No ❌   │
│ Builder pattern    │ No      │ No         │ Yes ✅  │ N/A     │
│ Java version       │ 1.2+    │ 9+         │ Any     │ Any     │
│ Creation cost      │ O(1)    │ O(n)       │ O(n)    │ O(1)    │
└────────────────────┴─────────┴────────────┴─────────┴─────────┘
```

**Performance:**

```
Read operations: Identical (all O(1) for get/contains)
Memory: Immutable 20-40% less than ArrayList
Creation: Immutable +5-10% slower than mutable
```

### Key Takeaways

**1. Prefer immutability:**

```java
// ✅ GOOD - Immutable by default
private final List<String> items = List.of("a", "b", "c");

// ❌ BAD - Mutable by default
private List<String> items = new ArrayList<>();
```

**2. Defensive copying:**

```java
// Constructor
public MyClass(List<String> items) {
    this.items = List.copyOf(items);  // Defensive copy
}

// Getter
public List<String> getItems() {
    return items;  // Already immutable, safe!
}
```

**3. Thread safety:**

```java
// ✅ Thread-safe without locks
private volatile ImmutableMap<K, V> cache = ImmutableMap.of();

// Update atomically
cache = ImmutableMap.<K, V>builder()
    .putAll(cache)
    .putAll(updates)
    .build();
```

**4. Use builders for complexity:**

```java
ImmutableList<String> list = ImmutableList.<String>builder()
    .add("a")
    .add("b")
    .addAll(otherList)
    .build();
```

**5. When NOT to use:**

```
- Building large collections incrementally
- Frequent modifications in hot path
- Working with legacy mutable APIs
→ Use mutable, then convert to immutable
```

---
