# Queue and Deque Implementations

## Overview

Java provides a rich set of Queue implementations for different use cases - from simple FIFO queues to priority queues, concurrent blocking queues, and double-ended queues. Understanding which implementation to use and their internal mechanics is crucial for writing efficient concurrent and algorithm code.


---

## 1. PriorityQueue - Heap Implementation

### Binary Heap for Priority-Based Ordering

```java
/**
 * PRIORITYQUEUE INTERNALS
 * 
 * Min-heap (or max-heap) using array-based binary heap
 */

import java.util.*;

public class PriorityQueueInternals {
    
    /**
     * Internal structure
     */
    public static void internalStructure() {
        /**
         * PRIORITYQUEUE ARCHITECTURE:
         * 
         * Backed by array-based binary min-heap
         * 
         * PriorityQueue:
         * ┌────────────────────┐
         * │ queue: Object[]    │ ─→ Heap array
         * │ size: int          │    Current size
         * │ comparator         │    Custom ordering (optional)
         * └────────────────────┘
         * 
         * BINARY HEAP STRUCTURE:
         * 
         * Logical tree:
         *           1
         *         /   \
         *        4     3
         *       / \   /
         *      9   7 5
         * 
         * Array representation:
         * [1, 4, 3, 9, 7, 5]
         *  0  1  2  3  4  5
         * 
         * PARENT-CHILD RELATIONSHIPS:
         * - Parent of index i: (i-1)/2
         * - Left child of i: 2*i + 1
         * - Right child of i: 2*i + 2
         * 
         * MIN-HEAP PROPERTY:
         * Every parent ≤ its children
         * Smallest element always at root (index 0)
         * 
         * OPERATIONS:
         * - offer(): Add at end, bubble up: O(log n)
         * - poll(): Remove root, move last to root, bubble down: O(log n)
         * - peek(): Return root: O(1)
         */
    }
    
    /**
     * Basic operations
     */
    public static void basicOperations() {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        
        // Add elements (any order)
        pq.offer(5);
        pq.offer(2);
        pq.offer(8);
        pq.offer(1);
        pq.offer(9);
        
        System.out.println("PriorityQueue: " + pq);
        System.out.println("peek(): " + pq.peek());  // Smallest
        
        // Remove in priority order
        System.out.println("Polling in order:");
        while (!pq.isEmpty()) {
            System.out.println("  " + pq.poll());
        }
        
        /**
         * OUTPUT:
         * PriorityQueue: [1, 2, 8, 5, 9]  (heap order, not sorted)
         * peek(): 1
         * Polling in order:
         *   1
         *   2
         *   5
         *   8
         *   9
         * 
         * ALWAYS EXTRACTS MIN (or max with comparator)
         */
    }
    
    /**
     * Heap operations visualization
     */
    public static void heapOperations() {
        /**
         * OFFER (INSERT) OPERATION:
         * 
         * Initial heap: [1, 4, 3, 9, 7, 5]
         *           1
         *         /   \
         *        4     3
         *       / \   /
         *      9   7 5
         * 
         * offer(2):
         * 
         * Step 1: Add at end
         * [1, 4, 3, 9, 7, 5, 2]
         *           1
         *         /   \
         *        4     3
         *       / \   / \
         *      9   7 5   2
         * 
         * Step 2: Bubble up (2 < 3)
         * [1, 4, 2, 9, 7, 5, 3]
         *           1
         *         /   \
         *        4     2
         *       / \   / \
         *      9   7 5   3
         * 
         * Done! (2 > 1, heap property satisfied)
         * 
         * 
         * POLL (REMOVE MIN) OPERATION:
         * 
         * Initial heap: [1, 4, 2, 9, 7, 5, 3]
         * 
         * Step 1: Save root (1), move last to root
         * [3, 4, 2, 9, 7, 5]
         *           3
         *         /   \
         *        4     2
         *       / \   /
         *      9   7 5
         * 
         * Step 2: Bubble down
         * Compare 3 with children (4, 2)
         * Swap with smaller child (2)
         * [2, 4, 3, 9, 7, 5]
         *           2
         *         /   \
         *        4     3
         *       / \   /
         *      9   7 5
         * 
         * Step 3: Continue bubbling
         * Compare 3 with children (5, none)
         * 3 < 5, done!
         * 
         * Return: 1
         */
    }
    
    /**
     * Custom comparator (max-heap)
     */
    public static void maxHeap() {
        // Max-heap (reverse natural order)
        PriorityQueue<Integer> maxHeap = 
            new PriorityQueue<>(Collections.reverseOrder());
        
        maxHeap.offer(5);
        maxHeap.offer(2);
        maxHeap.offer(8);
        maxHeap.offer(1);
        
        System.out.println("Max-heap polling:");
        while (!maxHeap.isEmpty()) {
            System.out.println("  " + maxHeap.poll());  // Largest first
        }
        
        /**
         * OUTPUT:
         * Max-heap polling:
         *   8
         *   5
         *   2
         *   1
         */
    }
    
    /**
     * Complex objects with priority
     */
    static class Task implements Comparable<Task> {
        String name;
        int priority;  // Lower number = higher priority
        
        Task(String name, int priority) {
            this.name = name;
            this.priority = priority;
        }
        
        @Override
        public int compareTo(Task other) {
            return Integer.compare(this.priority, other.priority);
        }
        
        @Override
        public String toString() {
            return name + "(p" + priority + ")";
        }
    }
    
    public static void taskScheduling() {
        PriorityQueue<Task> taskQueue = new PriorityQueue<>();
        
        taskQueue.offer(new Task("Low priority task", 5));
        taskQueue.offer(new Task("Critical bug fix", 1));
        taskQueue.offer(new Task("Feature development", 3));
        taskQueue.offer(new Task("Code review", 2));
        
        System.out.println("Processing tasks by priority:");
        while (!taskQueue.isEmpty()) {
            System.out.println("  " + taskQueue.poll());
        }
        
        /**
         * OUTPUT:
         * Processing tasks by priority:
         *   Critical bug fix(p1)
         *   Code review(p2)
         *   Feature development(p3)
         *   Low priority task(p5)
         * 
         * REAL-WORLD USES:
         * - Task scheduling
         * - Event processing
         * - Dijkstra's algorithm
         * - Huffman coding
         * - Median maintenance
         */
    }
    
    /**
     * Performance characteristics
     */
    public static void performanceCharacteristics() {
        /**
         * COMPLEXITY:
         * 
         * ┌─────────────────┬──────────┐
         * │ Operation       │ Time     │
         * ├─────────────────┼──────────┤
         * │ offer(e)        │ O(log n) │
         * │ poll()          │ O(log n) │
         * │ remove(e)       │ O(n)     │
         * │ peek()          │ O(1)     │
         * │ size()          │ O(1)     │
         * │ contains(e)     │ O(n)     │
         * └─────────────────┴──────────┘
         * 
         * SPACE: O(n)
         * 
         * NOT THREAD-SAFE!
         * Use PriorityBlockingQueue for concurrent access
         * 
         * ORDERING:
         * Internal array not sorted!
         * Only heap property maintained
         * Iterator order unpredictable
         * Must poll() to get sorted order
         */
    }
    
    /**
     * Common pitfall: Mutable objects
     */
    public static void mutableObjectPitfall() {
        PriorityQueue<MutableTask> pq = new PriorityQueue<>();
        
        MutableTask task = new MutableTask("Task", 5);
        pq.offer(task);
        pq.offer(new MutableTask("Other", 3));
        
        System.out.println("Before modification: " + pq.peek());
        
        // Modify priority after adding!
        task.priority = 1;
        
        System.out.println("After modification: " + pq.peek());
        // Still returns modified task, but heap property violated!
        
        /**
         * PROBLEM:
         * - Changed priority after insertion
         * - Heap property broken
         * - Undefined behavior!
         * 
         * SOLUTION:
         * - Use immutable objects
         * - Or remove and re-add after modification
         */
    }
    
    static class MutableTask implements Comparable<MutableTask> {
        String name;
        int priority;
        
        MutableTask(String name, int priority) {
            this.name = name;
            this.priority = priority;
        }
        
        @Override
        public int compareTo(MutableTask other) {
            return Integer.compare(this.priority, other.priority);
        }
        
        @Override
        public String toString() {
            return name + "(p" + priority + ")";
        }
    }
    
    public static void main(String[] args) {
        System.out.println("=== Basic Operations ===");
        basicOperations();
        
        System.out.println("\n=== Max Heap ===");
        maxHeap();
        
        System.out.println("\n=== Task Scheduling ===");
        taskScheduling();
        
        System.out.println("\n=== Mutable Object Pitfall ===");
        mutableObjectPitfall();
    }
}
```

---

## 2. ArrayDeque vs LinkedList as Deque

### Double-Ended Queue Showdown

```java
/**
 * ARRAYDEQUE VS LINKEDLIST
 * 
 * Performance comparison for deque operations
 */

import java.util.*;

public class DequeComparison {
    
    /**
     * ArrayDeque internal structure
     */
    public static void arrayDequeStructure() {
        /**
         * ARRAYDEQUE ARCHITECTURE:
         * 
         * Circular array with head and tail pointers
         * 
         * ArrayDeque:
         * ┌────────────────────┐
         * │ elements: Object[] │
         * │ head: int          │ ─→ Index of first element
         * │ tail: int          │ ─→ Index after last element
         * └────────────────────┘
         * 
         * CIRCULAR BUFFER:
         * 
         * Array: [null, null, C, D, E, null, A, B]
         *                           ↑           ↑
         *                         tail        head
         * 
         * Logical view: [A, B, C, D, E]
         * 
         * OPERATIONS:
         * - addFirst(): head = (head - 1) & (length - 1)
         * - addLast(): tail = (tail + 1) & (length - 1)
         * - removeFirst(): head = (head + 1) & (length - 1)
         * - removeLast(): tail = (tail - 1) & (length - 1)
         * 
         * All O(1) with circular indexing!
         * 
         * RESIZE:
         * When head catches tail, double array size
         * Copy elements to new array (linearize)
         */
    }
    
    /**
     * Basic Deque operations
     */
    public static void basicDequeOperations() {
        Deque<String> deque = new ArrayDeque<>();
        
        // Add at both ends
        deque.addLast("C");
        deque.addFirst("B");
        deque.addFirst("A");
        deque.addLast("D");
        
        System.out.println("Deque: " + deque);
        
        // Peek at both ends
        System.out.println("First: " + deque.peekFirst());
        System.out.println("Last: " + deque.peekLast());
        
        // Remove from both ends
        System.out.println("Remove first: " + deque.removeFirst());
        System.out.println("Remove last: " + deque.removeLast());
        System.out.println("After: " + deque);
        
        /**
         * OUTPUT:
         * Deque: [A, B, C, D]
         * First: A
         * Last: D
         * Remove first: A
         * Remove last: D
         * After: [B, C]
         */
    }
    
    /**
     * Performance comparison
     */
    public static void performanceComparison() {
        int operations = 100_000;
        
        // ArrayDeque - add at both ends
        Deque<Integer> arrayDeque = new ArrayDeque<>();
        long start = System.nanoTime();
        for (int i = 0; i < operations; i++) {
            arrayDeque.addFirst(i);
            arrayDeque.addLast(i);
        }
        for (int i = 0; i < operations; i++) {
            arrayDeque.removeFirst();
            arrayDeque.removeLast();
        }
        long arrayTime = System.nanoTime() - start;
        
        // LinkedList - add at both ends
        Deque<Integer> linkedList = new LinkedList<>();
        start = System.nanoTime();
        for (int i = 0; i < operations; i++) {
            linkedList.addFirst(i);
            linkedList.addLast(i);
        }
        for (int i = 0; i < operations; i++) {
            linkedList.removeFirst();
            linkedList.removeLast();
        }
        long linkedTime = System.nanoTime() - start;
        
        System.out.println("Deque operations (" + operations + " * 4):");
        System.out.println("ArrayDeque: " + arrayTime / 1_000_000 + "ms");
        System.out.println("LinkedList: " + linkedTime / 1_000_000 + "ms");
        System.out.println("ArrayDeque is " + 
            (double) linkedTime / arrayTime + "x faster");
        
        /**
         * OUTPUT (typical):
         * Deque operations (100000 * 4):
         * ArrayDeque: 25ms
         * LinkedList: 80ms
         * ArrayDeque is 3.2x faster
         * 
         * WHY ARRAYDEQUE WINS:
         * - Better cache locality (contiguous array)
         * - No node allocation overhead
         * - Simpler operations (index arithmetic)
         * - Less memory (no node objects)
         * 
         * ARRAYDEQUE ADVANTAGES:
         * - 3x faster than LinkedList
         * - 2x less memory
         * - Better cache performance
         * - Predictable performance
         * 
         * LINKEDLIST ADVANTAGES:
         * - None for Deque use case!
         * - Always use ArrayDeque for Deque
         */
    }
    
    /**
     * Stack operations
     */
    public static void stackOperations() {
        // ArrayDeque as Stack (better than Stack class!)
        Deque<Integer> stack = new ArrayDeque<>();
        
        // Push
        stack.push(1);
        stack.push(2);
        stack.push(3);
        
        System.out.println("Stack: " + stack);
        
        // Peek
        System.out.println("Top: " + stack.peek());
        
        // Pop
        System.out.println("Pop: " + stack.pop());
        System.out.println("Pop: " + stack.pop());
        System.out.println("After pops: " + stack);
        
        /**
         * OUTPUT:
         * Stack: [3, 2, 1]
         * Top: 3
         * Pop: 3
         * Pop: 2
         * After pops: [1]
         * 
         * STACK COMPARISON:
         * 
         * DON'T USE:
         * Stack<Integer> stack = new Stack<>();  // Legacy class!
         * - Extends Vector (synchronized, slow)
         * - Thread-safe but usually not needed
         * - Worse performance
         * 
         * USE:
         * Deque<Integer> stack = new ArrayDeque<>();
         * - Faster
         * - More flexible (Deque interface)
         * - Modern API
         */
    }
    
    /**
     * Queue operations
     */
    public static void queueOperations() {
        // ArrayDeque as Queue
        Queue<String> queue = new ArrayDeque<>();
        
        // Enqueue (offer)
        queue.offer("First");
        queue.offer("Second");
        queue.offer("Third");
        
        System.out.println("Queue: " + queue);
        
        // Peek
        System.out.println("Front: " + queue.peek());
        
        // Dequeue (poll)
        System.out.println("Poll: " + queue.poll());
        System.out.println("Poll: " + queue.poll());
        System.out.println("After polls: " + queue);
        
        /**
         * OUTPUT:
         * Queue: [First, Second, Third]
         * Front: First
         * Poll: First
         * Poll: Second
         * After polls: [Third]
         * 
         * FIFO behavior with ArrayDeque
         */
    }
    
    /**
     * Complexity comparison
     */
    public static void complexityComparison() {
        /**
         * COMPLEXITY TABLE:
         * 
         * ┌──────────────────┬──────────────┬──────────────┐
         * │ Operation        │ ArrayDeque   │ LinkedList   │
         * ├──────────────────┼──────────────┼──────────────┤
         * │ addFirst/Last    │ O(1)*        │ O(1)         │
         * │ removeFirst/Last │ O(1)         │ O(1)         │
         * │ peekFirst/Last   │ O(1)         │ O(1)         │
         * │ get(index)       │ O(n)         │ O(n)         │
         * │ size()           │ O(1)         │ O(1)         │
         * │ Memory per elem  │ 8 bytes      │ 40 bytes     │
         * │ Cache locality   │ Excellent    │ Poor         │
         * └──────────────────┴──────────────┴──────────────┘
         * 
         * * Amortized O(1) for ArrayDeque (occasional resize)
         * 
         * MEMORY COMPARISON (1000 elements):
         * ArrayDeque: ~8 KB + array overhead
         * LinkedList: ~40 KB + node overhead
         * 
         * ArrayDeque uses 5x less memory!
         * 
         * WINNER: ArrayDeque for all Deque use cases
         */
    }
    
    /**
     * Real-world use cases
     */
    public static void realWorldUseCases() {
        /**
         * USE ARRAYDEQUE FOR:
         * 
         * 1. STACK:
         * Deque<State> stack = new ArrayDeque<>();
         * stack.push(state);
         * State current = stack.pop();
         * 
         * 2. QUEUE:
         * Queue<Task> queue = new ArrayDeque<>();
         * queue.offer(task);
         * Task next = queue.poll();
         * 
         * 3. BREADTH-FIRST SEARCH:
         * Queue<Node> bfs = new ArrayDeque<>();
         * bfs.offer(root);
         * while (!bfs.isEmpty()) {
         *     Node node = bfs.poll();
         *     // Process and add children
         * }
         * 
         * 4. SLIDING WINDOW:
         * Deque<Integer> window = new ArrayDeque<>();
         * // Maintain window of elements
         * 
         * 5. UNDO/REDO:
         * Deque<Action> undoStack = new ArrayDeque<>();
         * Deque<Action> redoStack = new ArrayDeque<>();
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Basic Deque Operations ===");
        basicDequeOperations();
        
        System.out.println("\n=== Performance Comparison ===");
        performanceComparison();
        
        System.out.println("\n=== Stack Operations ===");
        stackOperations();
        
        System.out.println("\n=== Queue Operations ===");
        queueOperations();
    }
}
```

---

## 3. BlockingQueue for Producer-Consumer

### Thread-Safe Queues with Blocking Operations

```java
/**
 * BLOCKINGQUEUE
 * 
 * Thread-safe queues for producer-consumer patterns
 */

import java.util.concurrent.*;
import java.util.*;

public class BlockingQueueExamples {
    
    /**
     * BlockingQueue basics
     */
    public static void blockingQueueBasics() {
        /**
         * BLOCKINGQUEUE INTERFACE:
         * 
         * ┌──────────────────┬──────────┬─────────┬──────────┐
         * │ Operation        │ Throws   │ Special │ Blocks   │
         * │                  │ Exception│ Value   │          │
         * ├──────────────────┼──────────┼─────────┼──────────┤
         * │ Insert           │ add(e)   │ offer(e)│ put(e)   │
         * │ Remove           │ remove() │ poll()  │ take()   │
         * │ Examine          │ element()│ peek()  │ N/A      │
         * └──────────────────┴──────────┴─────────┴──────────┘
         * 
         * BLOCKING BEHAVIOR:
         * - put(e): Blocks if queue full
         * - take(): Blocks if queue empty
         * 
         * IMPLEMENTATIONS:
         * - ArrayBlockingQueue: Bounded array-based
         * - LinkedBlockingQueue: Optionally-bounded linked-based
         * - PriorityBlockingQueue: Unbounded priority queue
         * - SynchronousQueue: Zero capacity (direct handoff)
         * - DelayQueue: Delayed elements
         * - LinkedTransferQueue: TransferQueue implementation
         */
    }
    
    /**
     * Producer-Consumer pattern
     */
    public static void producerConsumerPattern() throws InterruptedException {
        BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(10);
        
        // Producer thread
        Thread producer = new Thread(() -> {
            try {
                for (int i = 1; i <= 20; i++) {
                    queue.put(i);  // Blocks if full
                    System.out.println("Produced: " + i);
                    Thread.sleep(50);  // Simulate work
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }, "Producer");
        
        // Consumer thread
        Thread consumer = new Thread(() -> {
            try {
                while (true) {
                    Integer item = queue.take();  // Blocks if empty
                    System.out.println("  Consumed: " + item);
                    Thread.sleep(100);  // Simulate processing
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }, "Consumer");
        
        producer.start();
        consumer.start();
        
        Thread.sleep(3000);  // Run for 3 seconds
        producer.interrupt();
        consumer.interrupt();
        
        /**
         * OUTPUT (typical):
         * Produced: 1
         * Produced: 2
         *   Consumed: 1
         * Produced: 3
         * Produced: 4
         *   Consumed: 2
         * ...
         * 
         * AUTOMATIC BLOCKING:
         * - Producer blocks when queue full
         * - Consumer blocks when queue empty
         * - No explicit synchronization needed!
         * - Clean separation of concerns
         */
    }
    
    /**
     * ArrayBlockingQueue vs LinkedBlockingQueue
     */
    public static void arrayVsLinkedBlocking() {
        /**
         * ARRAYBLOCKINGQUEUE:
         * 
         * Structure: Circular array
         * Capacity: Fixed (must specify at creation)
         * Locks: Single lock for put/take
         * Fairness: Optional fair access
         * Memory: Pre-allocated array
         * 
         * Example:
         * BlockingQueue<String> queue = new ArrayBlockingQueue<>(100);
         * 
         * Pros:
         * + Predictable memory usage
         * + Better for bounded scenarios
         * + Simpler structure
         * 
         * Cons:
         * - Single lock (contention)
         * - Fixed capacity
         * 
         * 
         * LINKEDBLOCKINGQUEUE:
         * 
         * Structure: Linked nodes
         * Capacity: Optional bound (default: Integer.MAX_VALUE)
         * Locks: Separate put/take locks
         * Fairness: FIFO
         * Memory: Allocates per element
         * 
         * Example:
         * BlockingQueue<String> queue = new LinkedBlockingQueue<>(100);
         * // Or unbounded:
         * BlockingQueue<String> queue = new LinkedBlockingQueue<>();
         * 
         * Pros:
         * + Two locks (less contention)
         * + Can be unbounded
         * + Better for high throughput
         * 
         * Cons:
         * - Memory allocation per element
         * - More complex structure
         * 
         * 
         * PERFORMANCE:
         * 
         * Low contention (1-2 threads):
         * - ArrayBlockingQueue slightly faster
         * 
         * High contention (many threads):
         * - LinkedBlockingQueue faster (dual locks)
         * 
         * RECOMMENDATION:
         * - Known bounded size → ArrayBlockingQueue
         * - High throughput → LinkedBlockingQueue
         * - Default choice → LinkedBlockingQueue
         */
    }
    
    /**
     * Multi-producer multi-consumer
     */
    public static void multiProducerConsumer() throws InterruptedException {
        BlockingQueue<String> queue = new LinkedBlockingQueue<>(20);
        int numProducers = 3;
        int numConsumers = 2;
        
        // Start producers
        for (int i = 0; i < numProducers; i++) {
            final int id = i;
            new Thread(() -> {
                try {
                    for (int j = 0; j < 10; j++) {
                        String item = "P" + id + "-" + j;
                        queue.put(item);
                        System.out.println("Producer " + id + " produced: " + item);
                        Thread.sleep(100);
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }, "Producer-" + i).start();
        }
        
        // Start consumers
        for (int i = 0; i < numConsumers; i++) {
            final int id = i;
            new Thread(() -> {
                try {
                    while (true) {
                        String item = queue.take();
                        System.out.println("  Consumer " + id + " consumed: " + item);
                        Thread.sleep(150);
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }, "Consumer-" + i).start();
        }
        
        Thread.sleep(2000);
        
        /**
         * OUTPUT (interleaved):
         * Producer 0 produced: P0-0
         * Producer 1 produced: P1-0
         * Producer 2 produced: P2-0
         *   Consumer 0 consumed: P0-0
         *   Consumer 1 consumed: P1-0
         * Producer 0 produced: P0-1
         * ...
         * 
         * THREAD-SAFE:
         * - Multiple producers/consumers safe
         * - No race conditions
         * - Automatic coordination
         */
    }
    
    /**
     * Timeout operations
     */
    public static void timeoutOperations() throws InterruptedException {
        BlockingQueue<String> queue = new ArrayBlockingQueue<>(5);
        
        // Fill queue
        for (int i = 0; i < 5; i++) {
            queue.put("Item" + i);
        }
        
        // Try to add with timeout (queue full)
        boolean added = queue.offer("Extra", 1, TimeUnit.SECONDS);
        System.out.println("Added with timeout: " + added);  // false
        
        // Take one item
        String item = queue.take();
        System.out.println("Took: " + item);
        
        // Now offer succeeds
        added = queue.offer("New", 1, TimeUnit.SECONDS);
        System.out.println("Added after take: " + added);  // true
        
        /**
         * TIMEOUT METHODS:
         * 
         * offer(e, timeout, unit):
         * - Wait up to timeout to insert
         * - Returns false if timeout
         * 
         * poll(timeout, unit):
         * - Wait up to timeout to retrieve
         * - Returns null if timeout
         * 
         * USE CASE:
         * - Prevent indefinite blocking
         * - Implement retry logic
         * - Set SLAs on operations
         */
    }
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== Producer-Consumer ===");
        producerConsumerPattern();
        
        System.out.println("\n=== Timeout Operations ===");
        timeoutOperations();
    }
}
```

---

## 4. DelayQueue for Scheduling

### Time-Based Task Execution

```java
/**
 * DELAYQUEUE
 * 
 * Queue for delayed elements - executes after delay expires
 */

import java.util.concurrent.*;
import java.util.*;

public class DelayQueueExamples {
    
    /**
     * DelayQueue basics
     */
    public static void delayQueueBasics() {
        /**
         * DELAYQUEUE:
         * 
         * - Unbounded BlockingQueue
         * - Elements must implement Delayed interface
         * - take() blocks until delay expires
         * - Elements ordered by delay (priority queue internally)
         * - Used for scheduled tasks
         * 
         * DELAYED INTERFACE:
         * 
         * public interface Delayed extends Comparable<Delayed> {
         *     long getDelay(TimeUnit unit);
         * }
         * 
         * - getDelay(): Returns remaining delay
         * - compareTo(): Orders by delay (shortest first)
         * 
         * INTERNAL STRUCTURE:
         * - Backed by PriorityQueue
         * - Elements sorted by delay
         * - take() blocks until head element ready
         */
    }
    
    /**
     * Delayed task implementation
     */
    static class DelayedTask implements Delayed {
        private final String name;
        private final long executeAt;  // Absolute time
        
        public DelayedTask(String name, long delayMs) {
            this.name = name;
            this.executeAt = System.currentTimeMillis() + delayMs;
        }
        
        @Override
        public long getDelay(TimeUnit unit) {
            long remaining = executeAt - System.currentTimeMillis();
            return unit.convert(remaining, TimeUnit.MILLISECONDS);
        }
        
        @Override
        public int compareTo(Delayed other) {
            long diff = this.executeAt - ((DelayedTask) other).executeAt;
            return Long.compare(diff, 0);
        }
        
        public String getName() {
            return name;
        }
        
        @Override
        public String toString() {
            return name + " (delay: " + getDelay(TimeUnit.MILLISECONDS) + "ms)";
        }
    }
    
    /**
     * Basic DelayQueue usage
     */
    public static void basicUsage() throws InterruptedException {
        DelayQueue<DelayedTask> queue = new DelayQueue<>();
        
        // Add tasks with different delays
        queue.put(new DelayedTask("Task-1s", 1000));
        queue.put(new DelayedTask("Task-3s", 3000));
        queue.put(new DelayedTask("Task-500ms", 500));
        queue.put(new DelayedTask("Task-2s", 2000));
        
        System.out.println("Tasks added. Taking in order...");
        
        // Take tasks as delays expire
        while (!queue.isEmpty()) {
            DelayedTask task = queue.take();  // Blocks until ready
            System.out.println("Executed: " + task.getName());
        }
        
        /**
         * OUTPUT:
         * Tasks added. Taking in order...
         * Executed: Task-500ms    (after 500ms)
         * Executed: Task-1s       (after 1s)
         * Executed: Task-2s       (after 2s)
         * Executed: Task-3s       (after 3s)
         * 
         * AUTOMATIC ORDERING:
         * Tasks execute in delay order, not insertion order
         */
    }
    
    /**
     * Scheduled task executor
     */
    static class ScheduledTaskExecutor {
        private final DelayQueue<DelayedTask> queue = new DelayQueue<>();
        private volatile boolean running = true;
        
        public void start() {
            Thread executor = new Thread(() -> {
                while (running) {
                    try {
                        DelayedTask task = queue.take();
                        System.out.println(Thread.currentThread().getName() + 
                            " executing: " + task.getName());
                        // Execute task logic here
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            }, "TaskExecutor");
            executor.start();
        }
        
        public void schedule(String taskName, long delayMs) {
            queue.put(new DelayedTask(taskName, delayMs));
            System.out.println("Scheduled: " + taskName + " in " + delayMs + "ms");
        }
        
        public void stop() {
            running = false;
        }
    }
    
    public static void scheduledExecutor() throws InterruptedException {
        ScheduledTaskExecutor executor = new ScheduledTaskExecutor();
        executor.start();
        
        // Schedule tasks
        executor.schedule("Email notification", 2000);
        executor.schedule("Cache refresh", 1000);
        executor.schedule("Log rotation", 3000);
        
        Thread.sleep(4000);
        executor.stop();
        
        /**
         * USE CASES:
         * 
         * 1. CACHE EXPIRATION:
         * - Add entries with TTL
         * - Automatically remove expired entries
         * 
         * 2. TASK SCHEDULING:
         * - Schedule tasks for future execution
         * - No need for external scheduler
         * 
         * 3. RATE LIMITING:
         * - Delay processing based on rate limits
         * - Automatic throttling
         * 
         * 4. RETRY MECHANISMS:
         * - Retry failed operations after delay
         * - Exponential backoff
         * 
         * 5. SESSION TIMEOUT:
         * - Expire inactive sessions
         * - Automatic cleanup
         */
    }
    
    /**
     * Cache with expiration
     */
    static class ExpiringCache<K, V> {
        private final Map<K, V> cache = new ConcurrentHashMap<>();
        private final DelayQueue<DelayedKey<K>> expiryQueue = new DelayQueue<>();
        
        static class DelayedKey<K> implements Delayed {
            private final K key;
            private final long expiryTime;
            
            DelayedKey(K key, long ttlMs) {
                this.key = key;
                this.expiryTime = System.currentTimeMillis() + ttlMs;
            }
            
            public K getKey() {
                return key;
            }
            
            @Override
            public long getDelay(TimeUnit unit) {
                return unit.convert(expiryTime - System.currentTimeMillis(), 
                    TimeUnit.MILLISECONDS);
            }
            
            @Override
            public int compareTo(Delayed other) {
                return Long.compare(this.expiryTime, 
                    ((DelayedKey<?>) other).expiryTime);
            }
        }
        
        public ExpiringCache() {
            // Start cleanup thread
            Thread cleanupThread = new Thread(() -> {
                while (!Thread.currentThread().isInterrupted()) {
                    try {
                        DelayedKey<K> delayedKey = expiryQueue.take();
                        cache.remove(delayedKey.getKey());
                        System.out.println("Expired: " + delayedKey.getKey());
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            }, "CacheCleanup");
            cleanupThread.setDaemon(true);
            cleanupThread.start();
        }
        
        public void put(K key, V value, long ttlMs) {
            cache.put(key, value);
            expiryQueue.put(new DelayedKey<>(key, ttlMs));
            System.out.println("Cached: " + key + " (TTL: " + ttlMs + "ms)");
        }
        
        public V get(K key) {
            return cache.get(key);
        }
    }
    
    public static void expiringCache() throws InterruptedException {
        ExpiringCache<String, String> cache = new ExpiringCache<>();
        
        cache.put("session1", "user_data1", 1000);  // 1 second TTL
        cache.put("session2", "user_data2", 2000);  // 2 seconds TTL
        
        System.out.println("Get session1: " + cache.get("session1"));
        
        Thread.sleep(1500);  // Wait 1.5 seconds
        
        System.out.println("Get session1: " + cache.get("session1"));  // null (expired)
        System.out.println("Get session2: " + cache.get("session2"));  // still valid
        
        Thread.sleep(1000);
        
        /**
         * OUTPUT:
         * Cached: session1 (TTL: 1000ms)
         * Cached: session2 (TTL: 2000ms)
         * Get session1: user_data1
         * Expired: session1
         * Get session1: null
         * Get session2: user_data2
         * Expired: session2
         */
    }
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== Basic Usage ===");
        basicUsage();
        
        System.out.println("\n=== Expiring Cache ===");
        expiringCache();
    }
}
```

---

## 5. TransferQueue Semantics

### Producer-Consumer with Handoff

```java
/**
 * TRANSFERQUEUE
 * 
 * BlockingQueue with transfer operation for direct handoff
 */

import java.util.concurrent.*;

public class TransferQueueExamples {
    
    /**
     * TransferQueue basics
     */
    public static void transferQueueBasics() {
        /**
         * TRANSFERQUEUE INTERFACE:
         * 
         * Extends BlockingQueue with additional methods:
         * 
         * - transfer(E e):
         *   Transfers element to consumer
         *   Blocks until element taken
         *   Direct handoff!
         * 
         * - tryTransfer(E e):
         *   Transfers if consumer waiting
         *   Returns false immediately if no consumer
         * 
         * - tryTransfer(E e, timeout, unit):
         *   Transfers with timeout
         * 
         * - hasWaitingConsumer():
         *   Returns true if consumer waiting
         * 
         * - getWaitingConsumerCount():
         *   Returns number of waiting consumers
         * 
         * 
         * IMPLEMENTATION:
         * LinkedTransferQueue (Java 7+)
         * - Unbounded
         * - Lock-free
         * - Very high performance
         * 
         * 
         * USE CASE:
         * When producer wants confirmation that
         * consumer received the item
         */
    }
    
    /**
     * Direct handoff example
     */
    public static void directHandoff() throws InterruptedException {
        TransferQueue<String> queue = new LinkedTransferQueue<>();
        
        // Consumer thread
        Thread consumer = new Thread(() -> {
            try {
                Thread.sleep(1000);  // Simulate startup delay
                System.out.println("Consumer ready, taking item...");
                String item = queue.take();
                System.out.println("Consumer received: " + item);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }, "Consumer");
        
        consumer.start();
        
        // Producer thread
        Thread producer = new Thread(() -> {
            try {
                System.out.println("Producer transferring item...");
                queue.transfer("Important Data");  // Blocks until taken!
                System.out.println("Producer: Item was received!");
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }, "Producer");
        
        producer.start();
        
        producer.join();
        consumer.join();
        
        /**
         * OUTPUT:
         * Producer transferring item...
         * (1 second pause)
         * Consumer ready, taking item...
         * Consumer received: Important Data
         * Producer: Item was received!
         * 
         * NOTICE:
         * Producer knows consumer received the item
         * Direct handoff guarantees delivery
         */
    }
    
    /**
     * tryTransfer example
     */
    public static void tryTransferExample() throws InterruptedException {
        TransferQueue<String> queue = new LinkedTransferQueue<>();
        
        // Try transfer without consumer
        boolean transferred = queue.tryTransfer("Item1");
        System.out.println("Transferred without consumer: " + transferred);  // false
        
        // Start consumer
        Thread consumer = new Thread(() -> {
            try {
                String item = queue.take();
                System.out.println("Consumer received: " + item);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }, "Consumer");
        
        consumer.start();
        Thread.sleep(100);  // Let consumer block on take()
        
        // Now try transfer
        transferred = queue.tryTransfer("Item2");
        System.out.println("Transferred with consumer: " + transferred);  // true
        
        consumer.join();
        
        /**
         * OUTPUT:
         * Transferred without consumer: false
         * Transferred with consumer: true
         * Consumer received: Item2
         * 
         * tryTransfer() returns immediately
         * Useful when you don't want to block
         */
    }
    
    /**
     * Performance comparison
     */
    public static void performanceComparison() throws InterruptedException {
        int operations = 100_000;
        
        // LinkedTransferQueue
        TransferQueue<Integer> transferQueue = new LinkedTransferQueue<>();
        CountDownLatch latch1 = new CountDownLatch(operations);
        
        Thread consumer1 = new Thread(() -> {
            for (int i = 0; i < operations; i++) {
                try {
                    transferQueue.take();
                    latch1.countDown();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        });
        
        consumer1.start();
        Thread.sleep(100);  // Let consumer start
        
        long start = System.nanoTime();
        for (int i = 0; i < operations; i++) {
            transferQueue.put(i);
        }
        latch1.await();
        long transferTime = System.nanoTime() - start;
        
        // LinkedBlockingQueue
        BlockingQueue<Integer> blockingQueue = new LinkedBlockingQueue<>();
        CountDownLatch latch2 = new CountDownLatch(operations);
        
        Thread consumer2 = new Thread(() -> {
            for (int i = 0; i < operations; i++) {
                try {
                    blockingQueue.take();
                    latch2.countDown();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        });
        
        consumer2.start();
        Thread.sleep(100);
        
        start = System.nanoTime();
        for (int i = 0; i < operations; i++) {
            blockingQueue.put(i);
        }
        latch2.await();
        long blockingTime = System.nanoTime() - start;
        
        System.out.println("Throughput test (" + operations + " operations):");
        System.out.println("LinkedTransferQueue: " + transferTime / 1_000_000 + "ms");
        System.out.println("LinkedBlockingQueue: " + blockingTime / 1_000_000 + "ms");
        
        /**
         * OUTPUT (typical):
         * Throughput test (100000 operations):
         * LinkedTransferQueue: 85ms
         * LinkedBlockingQueue: 120ms
         * 
         * LinkedTransferQueue often faster:
         * - Lock-free implementation
         * - Optimized for producer-consumer
         * - Better scalability
         */
    }
    
    /**
     * Real-world use case: Request-Response
     */
    static class RequestResponseSystem {
        private final TransferQueue<Request> requestQueue = 
            new LinkedTransferQueue<>();
        
        static class Request {
            String data;
            CompletableFuture<String> response;
            
            Request(String data) {
                this.data = data;
                this.response = new CompletableFuture<>();
            }
        }
        
        public void startServer() {
            new Thread(() -> {
                while (!Thread.currentThread().isInterrupted()) {
                    try {
                        Request request = requestQueue.take();
                        // Process request
                        String result = "Processed: " + request.data;
                        request.response.complete(result);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            }, "Server").start();
        }
        
        public String sendRequest(String data) throws Exception {
            Request request = new Request(data);
            requestQueue.transfer(request);  // Wait until server picks it up
            return request.response.get(5, TimeUnit.SECONDS);
        }
    }
    
    public static void requestResponseExample() throws Exception {
        RequestResponseSystem system = new RequestResponseSystem();
        system.startServer();
        
        Thread.sleep(100);  // Let server start
        
        String response = system.sendRequest("Hello");
        System.out.println("Response: " + response);
        
        /**
         * USE CASE:
         * - Request-response pattern
         * - RPC systems
         * - Message passing with confirmation
         * - Synchronous communication
         */
    }
    
    public static void main(String[] args) throws Exception {
        System.out.println("=== Direct Handoff ===");
        directHandoff();
        
        System.out.println("\n=== tryTransfer ===");
        tryTransferExample();
        
        System.out.println("\n=== Request-Response ===");
        requestResponseExample();
    }
}
```

---

## 6. Choosing the Right Queue

### Decision Guide

```java
/**
 * CHOOSING THE RIGHT QUEUE
 * 
 * Decision tree and recommendations
 */

public class ChoosingTheRightQueue {
    
    /**
     * Decision tree
     */
    public static void decisionTree() {
        /**
         * DECISION TREE:
         * 
         * Need priority ordering?
         * ├─ YES → PriorityQueue (or PriorityBlockingQueue if concurrent)
         * └─ NO ↓
         * 
         * Need thread-safety (concurrent access)?
         * ├─ YES ↓
         * │   Need delayed execution?
         * │   ├─ YES → DelayQueue
         * │   └─ NO ↓
         * │       Need direct handoff guarantee?
         * │       ├─ YES → LinkedTransferQueue
         * │       └─ NO ↓
         * │           Need bounded capacity?
         * │           ├─ YES → ArrayBlockingQueue
         * │           └─ NO → LinkedBlockingQueue
         * └─ NO ↓
         *     Need double-ended (Deque)?
         *     ├─ YES → ArrayDeque
         *     └─ NO → ArrayDeque (as Queue)
         */
    }
    
    /**
     * Comparison table
     */
    public static void comparisonTable() {
        /**
         * ┌─────────────────────┬─────────┬──────────┬────────────┬─────────────┐
         * │ Implementation      │ Order   │ Bounded  │ Thread-Safe│ Best For    │
         * ├─────────────────────┼─────────┼──────────┼────────────┼─────────────┤
         * │ ArrayDeque          │ FIFO    │ No       │ No         │ Stack/Queue │
         * │                     │         │          │            │ (default)   │
         * ├─────────────────────┼─────────┼──────────┼────────────┼─────────────┤
         * │ PriorityQueue       │ Priority│ No       │ No         │ Priority    │
         * │                     │         │          │            │ ordering    │
         * ├─────────────────────┼─────────┼──────────┼────────────┼─────────────┤
         * │ ArrayBlockingQueue  │ FIFO    │ Yes      │ Yes        │ Bounded     │
         * │                     │         │          │            │ producer-   │
         * │                     │         │          │            │ consumer    │
         * ├─────────────────────┼─────────┼──────────┼────────────┼─────────────┤
         * │ LinkedBlockingQueue │ FIFO    │ Optional │ Yes        │ High        │
         * │                     │         │          │            │ throughput  │
         * ├─────────────────────┼─────────┼──────────┼────────────┼─────────────┤
         * │ PriorityBlocking    │ Priority│ No       │ Yes        │ Concurrent  │
         * │ Queue               │         │          │            │ priority    │
         * ├─────────────────────┼─────────┼──────────┼────────────┼─────────────┤
         * │ DelayQueue          │ Delay   │ No       │ Yes        │ Scheduling  │
         * ├─────────────────────┼─────────┼──────────┼────────────┼─────────────┤
         * │ LinkedTransfer      │ FIFO    │ No       │ Yes        │ Direct      │
         * │ Queue               │         │          │            │ handoff     │
         * ├─────────────────────┼─────────┼──────────┼────────────┼─────────────┤
         * │ SynchronousQueue    │ N/A     │ 0        │ Yes        │ Thread      │
         * │                     │         │          │            │ handoff     │
         * └─────────────────────┴─────────┴──────────┴────────────┴─────────────┘
         */
    }
    
    /**
     * Use case matrix
     */
    public static void useCaseMatrix() {
        /**
         * USE CASES:
         * 
         * ARRAYDEQUE:
         * ✓ Stack operations
         * ✓ BFS/DFS traversal
         * ✓ Single-threaded queue
         * ✓ Sliding window problems
         * Example: Undo/redo, expression evaluation
         * 
         * PRIORITYQUEUE:
         * ✓ Heap operations
         * ✓ Top-K problems
         * ✓ Event scheduling (single-threaded)
         * ✓ Dijkstra's algorithm
         * Example: Task prioritization, huffman coding
         * 
         * ARRAYBLOCKINGQUEUE:
         * ✓ Fixed-size buffer
         * ✓ Backpressure control
         * ✓ Rate limiting
         * ✓ Thread pool work queue
         * Example: Connection pool, bounded cache
         * 
         * LINKEDBLOCKINGQUEUE:
         * ✓ Producer-consumer pattern
         * ✓ High throughput needed
         * ✓ Unbounded queue OK
         * ✓ Thread pool (Executors default)
         * Example: Task queue, message queue
         * 
         * PRIORITYBLOCKINGQUEUE:
         * ✓ Concurrent priority queue
         * ✓ Job scheduling
         * ✓ Event processing by priority
         * Example: Thread pool with priorities
         * 
         * DELAYQUEUE:
         * ✓ Scheduled tasks
         * ✓ Cache expiration
         * ✓ Rate limiting with delays
         * ✓ Retry mechanisms
         * Example: Session timeout, task scheduler
         * 
         * LINKEDTRANSFERQUEUE:
         * ✓ Request-response pattern
         * ✓ Direct producer-consumer handoff
         * ✓ High-performance messaging
         * Example: RPC, synchronous messaging
         * 
         * SYNCHRONOUSQUEUE:
         * ✓ Thread handoff
         * ✓ Zero buffering
         * ✓ Cached thread pool
         * Example: Direct thread communication
         */
    }
    
    /**
     * Performance summary
     */
    public static void performanceSummary() {
        /**
         * PERFORMANCE CHARACTERISTICS:
         * 
         * SINGLE-THREADED:
         * Speed: ArrayDeque > PriorityQueue
         * Memory: ArrayDeque < PriorityQueue
         * 
         * CONCURRENT (producer-consumer):
         * Throughput:
         * 1. LinkedTransferQueue (lock-free, best)
         * 2. LinkedBlockingQueue (dual locks)
         * 3. ArrayBlockingQueue (single lock)
         * 4. PriorityBlockingQueue (log n operations)
         * 
         * LATENCY:
         * 1. SynchronousQueue (no buffering)
         * 2. LinkedTransferQueue (direct handoff)
         * 3. ArrayBlockingQueue
         * 4. LinkedBlockingQueue
         * 
         * MEMORY:
         * Least: ArrayDeque, ArrayBlockingQueue
         * Most: LinkedBlockingQueue, PriorityQueue
         */
    }
    
    /**
     * Common mistakes
     */
    public static void commonMistakes() {
        /**
         * MISTAKE 1: Using LinkedList as Queue
         * 
         * BAD:
         * Queue<String> queue = new LinkedList<>();
         * 
         * GOOD:
         * Queue<String> queue = new ArrayDeque<>();
         * // 3x faster, 2x less memory
         * 
         * 
         * MISTAKE 2: Using Stack class
         * 
         * BAD:
         * Stack<Integer> stack = new Stack<>();  // Legacy!
         * 
         * GOOD:
         * Deque<Integer> stack = new ArrayDeque<>();
         * 
         * 
         * MISTAKE 3: Unbounded queue in production
         * 
         * BAD:
         * BlockingQueue<Task> queue = new LinkedBlockingQueue<>();
         * // Can grow indefinitely, OOM risk!
         * 
         * GOOD:
         * BlockingQueue<Task> queue = new LinkedBlockingQueue<>(1000);
         * // Bounded, backpressure
         * 
         * 
         * MISTAKE 4: Wrong queue for use case
         * 
         * BAD (need priorities):
         * Queue<Task> queue = new ArrayDeque<>();
         * 
         * GOOD:
         * Queue<Task> queue = new PriorityQueue<>();
         * 
         * 
         * MISTAKE 5: Modifying elements in PriorityQueue
         * 
         * BAD:
         * PriorityQueue<Task> pq = new PriorityQueue<>();
         * Task task = new Task(5);
         * pq.offer(task);
         * task.priority = 1;  // Heap property broken!
         * 
         * GOOD:
         * pq.remove(task);
         * task.priority = 1;
         * pq.offer(task);
         */
    }
    
    /**
     * Best practices
     */
    public static void bestPractices() {
        /**
         * BEST PRACTICES:
         * 
         * 1. DEFAULT TO ARRAYDEQUE:
         *    For single-threaded queue/stack
         * 
         * 2. USE BOUNDED QUEUES IN PRODUCTION:
         *    Prevent memory exhaustion
         *    Implement backpressure
         * 
         * 3. CHOOSE BASED ON CONTENTION:
         *    Low: ArrayBlockingQueue
         *    High: LinkedBlockingQueue
         * 
         * 4. SIZE APPROPRIATELY:
         *    Queue size = processing rate * latency
         *    Too small: blocking
         *    Too large: memory waste
         * 
         * 5. HANDLE INTERRUPTION:
         *    try {
         *        queue.take();
         *    } catch (InterruptedException e) {
         *        Thread.currentThread().interrupt();
         *        // Restore interrupt status
         *    }
         * 
         * 6. USE DRAIN METHODS:
         *    List<Task> batch = new ArrayList<>();
         *    queue.drainTo(batch, 100);
         *    // Process batch
         * 
         * 7. MONITOR QUEUE SIZE:
         *    int size = queue.size();
         *    if (size > threshold) {
         *        // Alert or throttle
         *    }
         * 
         * 8. CONSIDER ALTERNATIVES:
         *    For very high throughput:
         *    - Disruptor (ring buffer)
         *    - JCTools queues
         */
    }
}
```

---

## Summary

### Quick Reference

**ArrayDeque:**

```java
Deque<String> queue = new ArrayDeque<>();
// O(1) operations
// Best for: Stack, Queue, Deque
// 3x faster than LinkedList
```

**PriorityQueue:**

```java
Queue<Task> pq = new PriorityQueue<>();
// O(log n) operations
// Min-heap by default
// Best for: Priority ordering
```

**BlockingQueue:**

```java
BlockingQueue<Task> queue = new ArrayBlockingQueue<>(100);
queue.put(task);  // Blocks if full
Task t = queue.take();  // Blocks if empty
// Best for: Producer-consumer
```

**DelayQueue:**

```java
DelayQueue<DelayedTask> queue = new DelayQueue<>();
// Elements implement Delayed
// Best for: Scheduling, cache expiration
```

**LinkedTransferQueue:**

```java
TransferQueue<Data> queue = new LinkedTransferQueue<>();
queue.transfer(data);  // Direct handoff
// Best for: Request-response
```

### Comparison Table

```
┌───────────────────┬─────────┬──────────┬──────────┬──────────────┐
│ Queue             │ Order   │ Thread   │ Ops      │ Use Case     │
├───────────────────┼─────────┼──────────┼──────────┼──────────────┤
│ ArrayDeque        │ FIFO    │ No       │ O(1)     │ Default      │
│ PriorityQueue     │ Min-heap│ No       │ O(log n) │ Priority     │
│ ArrayBlocking     │ FIFO    │ Yes      │ O(1)     │ Bounded      │
│ LinkedBlocking    │ FIFO    │ Yes      │ O(1)     │ Throughput   │
│ DelayQueue        │ Delay   │ Yes      │ O(log n) │ Scheduling   │
│ LinkedTransfer    │ FIFO    │ Yes      │ O(1)     │ Handoff      │
└───────────────────┴─────────┴──────────┴──────────┴──────────────┘
```

### Decision Tree

```
Single-threaded?
├─ YES → ArrayDeque (default)
└─ NO ↓

Need priority?
├─ YES → PriorityBlockingQueue
└─ NO ↓

Need delays?
├─ YES → DelayQueue
└─ NO ↓

Need bounded?
├─ YES → ArrayBlockingQueue
└─ NO → LinkedBlockingQueue
```

### Key Takeaways

1. **ArrayDeque is the default** - Use for 90% of queue needs
2. **Always bound BlockingQueues** - Prevent OOM in production
3. **LinkedTransferQueue for performance** - Lock-free, very fast
4. **PriorityQueue for heap algorithms** - Dijkstra, top-K
5. **DelayQueue for scheduling** - Built-in time-based execution
6. **Never use LinkedList** - ArrayDeque is 3x faster

---
