# TreeMap, LinkedHashMap, and Specialized Maps

## Overview

Java provides several specialized Map implementations beyond HashMap, each optimized for specific use cases. Understanding when and how to use TreeMap, LinkedHashMap, WeakHashMap, IdentityHashMap, and EnumMap is crucial for writing efficient Java code.


---

## 1. TreeMap - Red-Black Tree Implementation

### Sorted Map with O(log n) Operations

```java
/**
 * TREEMAP INTERNALS
 * 
 * Red-Black tree implementation of SortedMap
 */

import java.util.*;

public class TreeMapInternals {
    
    /**
     * Internal structure
     */
    public static void internalStructure() {
        /**
         * TREEMAP ARCHITECTURE:
         * 
         * Based on Red-Black Tree (self-balancing binary search tree)
         * 
         * TreeMap:
         * ┌──────────────┐
         * │ root: Entry  │
         * │ size: int    │
         * │ comparator   │
         * └──────┬───────┘
         *        │
         *        v
         *     Entry (Black)
         *     key=5, value=v5
         *     /           \
         *  Entry         Entry (Red)
         *  key=3         key=7
         *  /    \        /    \
         * E(1)  E(4)   E(6)  E(9)
         * 
         * ENTRY STRUCTURE:
         * - key: K
         * - value: V
         * - left: Entry<K,V>
         * - right: Entry<K,V>
         * - parent: Entry<K,V>
         * - color: boolean (RED/BLACK)
         * 
         * RED-BLACK TREE PROPERTIES:
         * 1. Every node is RED or BLACK
         * 2. Root is BLACK
         * 3. Leaves (null) are BLACK
         * 4. RED node has BLACK children
         * 5. All paths from node to leaves have same # of BLACK nodes
         * 
         * GUARANTEES:
         * - Height ≤ 2 * log₂(n + 1)
         * - Balanced tree
         * - O(log n) operations
         */
    }
    
    /**
     * Basic operations
     */
    public static void basicOperations() {
        TreeMap<Integer, String> map = new TreeMap<>();
        
        // Insert (sorted by key)
        map.put(5, "five");
        map.put(2, "two");
        map.put(8, "eight");
        map.put(1, "one");
        map.put(9, "nine");
        
        System.out.println("TreeMap: " + map);
        
        // Iteration (sorted order)
        System.out.println("Keys in order:");
        for (Integer key : map.keySet()) {
            System.out.println(key);
        }
        
        /**
         * OUTPUT:
         * TreeMap: {1=one, 2=two, 5=five, 8=eight, 9=nine}
         * Keys in order:
         * 1
         * 2
         * 5
         * 8
         * 9
         * 
         * AUTOMATIC SORTING:
         * - Keys always in sorted order
         * - Uses Comparable or Comparator
         * - No need to sort afterwards
         */
    }
    
    /**
     * Custom comparator
     */
    public static void customComparator() {
        // Reverse order
        TreeMap<Integer, String> map = new TreeMap<>(Collections.reverseOrder());
        
        map.put(5, "five");
        map.put(2, "two");
        map.put(8, "eight");
        
        System.out.println("Reverse order: " + map);
        
        // Custom comparator
        TreeMap<String, Integer> lengthMap = new TreeMap<>(
            Comparator.comparingInt(String::length)
                      .thenComparing(String::compareTo)
        );
        
        lengthMap.put("apple", 1);
        lengthMap.put("pie", 2);
        lengthMap.put("banana", 3);
        lengthMap.put("a", 4);
        
        System.out.println("By length: " + lengthMap);
        
        /**
         * OUTPUT:
         * Reverse order: {8=eight, 5=five, 2=two}
         * By length: {a=4, pie=2, apple=1, banana=3}
         * 
         * COMPARATOR OPTIONS:
         * - Natural order (Comparable)
         * - Reverse order
         * - Custom logic
         * - Compound comparisons
         */
    }
    
    /**
     * Performance characteristics
     */
    public static void performanceAnalysis() {
        int n = 100000;
        
        // TreeMap vs HashMap - insertion
        long start = System.nanoTime();
        TreeMap<Integer, Integer> treeMap = new TreeMap<>();
        for (int i = 0; i < n; i++) {
            treeMap.put(i, i);
        }
        long treeTime = System.nanoTime() - start;
        
        start = System.nanoTime();
        HashMap<Integer, Integer> hashMap = new HashMap<>();
        for (int i = 0; i < n; i++) {
            hashMap.put(i, i);
        }
        long hashTime = System.nanoTime() - start;
        
        System.out.println("Insertion (" + n + " entries):");
        System.out.println("  TreeMap: " + treeTime / 1_000_000 + "ms");
        System.out.println("  HashMap: " + hashTime / 1_000_000 + "ms");
        System.out.println("  HashMap is " + (double)treeTime/hashTime + "x faster");
        
        /**
         * OUTPUT (typical):
         * Insertion (100000 entries):
         *   TreeMap: 85ms
         *   HashMap: 25ms
         *   HashMap is 3.4x faster
         * 
         * COMPLEXITY:
         * 
         * TreeMap:
         * - get/put/remove: O(log n)
         * - Sorted operations
         * - Comparison overhead
         * 
         * HashMap:
         * - get/put/remove: O(1) average
         * - No sorting
         * - Hash calculation overhead
         * 
         * MEMORY:
         * TreeMap: Higher (extra tree pointers)
         * HashMap: Lower (array + linked list/tree)
         */
    }
}
```

---

## 2. NavigableMap Operations

### Range Queries and Navigation

```java
/**
 * NAVIGABLEMAP OPERATIONS
 * 
 * TreeMap implements NavigableMap for range queries
 */

import java.util.*;

public class NavigableMapOperations {
    
    /**
     * Range operations
     */
    public static void rangeOperations() {
        TreeMap<Integer, String> map = new TreeMap<>();
        
        // Populate
        for (int i = 1; i <= 10; i++) {
            map.put(i, "value" + i);
        }
        
        System.out.println("Full map: " + map);
        
        // subMap: keys in [from, to)
        SortedMap<Integer, String> subMap = map.subMap(3, 7);
        System.out.println("subMap(3, 7): " + subMap);
        
        // headMap: keys < to
        SortedMap<Integer, String> headMap = map.headMap(5);
        System.out.println("headMap(5): " + headMap);
        
        // tailMap: keys >= from
        SortedMap<Integer, String> tailMap = map.tailMap(7);
        System.out.println("tailMap(7): " + tailMap);
        
        /**
         * OUTPUT:
         * Full map: {1=value1, 2=value2, ..., 10=value10}
         * subMap(3, 7): {3=value3, 4=value4, 5=value5, 6=value6}
         * headMap(5): {1=value1, 2=value2, 3=value3, 4=value4}
         * tailMap(7): {7=value7, 8=value8, 9=value9, 10=value10}
         * 
         * INCLUSIVE/EXCLUSIVE VARIANTS:
         * - subMap(from, true, to, false): [from, to)
         * - subMap(from, false, to, true): (from, to]
         * - headMap(to, true): keys <= to
         * - tailMap(from, false): keys > from
         */
    }
    
    /**
     * Navigation methods
     */
    public static void navigationMethods() {
        TreeMap<Integer, String> map = new TreeMap<>();
        map.put(1, "one");
        map.put(3, "three");
        map.put(5, "five");
        map.put(7, "seven");
        map.put(9, "nine");
        
        System.out.println("Map: " + map);
        
        // First and last
        System.out.println("firstKey(): " + map.firstKey());
        System.out.println("lastKey(): " + map.lastKey());
        System.out.println("firstEntry(): " + map.firstEntry());
        System.out.println("lastEntry(): " + map.lastEntry());
        
        // Floor and ceiling (≤ and ≥)
        System.out.println("\nfloorKey(4): " + map.floorKey(4));      // ≤ 4
        System.out.println("ceilingKey(4): " + map.ceilingKey(4));    // ≥ 4
        System.out.println("floorEntry(6): " + map.floorEntry(6));    // ≤ 6
        System.out.println("ceilingEntry(6): " + map.ceilingEntry(6));// ≥ 6
        
        // Lower and higher (< and >)
        System.out.println("\nlowerKey(5): " + map.lowerKey(5));      // < 5
        System.out.println("higherKey(5): " + map.higherKey(5));      // > 5
        System.out.println("lowerEntry(5): " + map.lowerEntry(5));    // < 5
        System.out.println("higherEntry(5): " + map.higherEntry(5));  // > 5
        
        /**
         * OUTPUT:
         * Map: {1=one, 3=three, 5=five, 7=seven, 9=nine}
         * firstKey(): 1
         * lastKey(): 9
         * firstEntry(): 1=one
         * lastEntry(): 9=nine
         * 
         * floorKey(4): 3     (largest ≤ 4)
         * ceilingKey(4): 5   (smallest ≥ 4)
         * floorEntry(6): 5=five
         * ceilingEntry(6): 7=seven
         * 
         * lowerKey(5): 3     (largest < 5)
         * higherKey(5): 7    (smallest > 5)
         * lowerEntry(5): 3=three
         * higherEntry(5): 7=seven
         * 
         * USE CASES:
         * - Finding closest values
         * - Range queries
         * - Time-series data
         * - Interval operations
         */
    }
    
    /**
     * Polling operations (remove + return)
     */
    public static void pollingOperations() {
        TreeMap<Integer, String> map = new TreeMap<>();
        map.put(1, "one");
        map.put(3, "three");
        map.put(5, "five");
        
        System.out.println("Initial: " + map);
        
        // Remove and return first
        Map.Entry<Integer, String> first = map.pollFirstEntry();
        System.out.println("pollFirstEntry(): " + first);
        System.out.println("After: " + map);
        
        // Remove and return last
        Map.Entry<Integer, String> last = map.pollLastEntry();
        System.out.println("pollLastEntry(): " + last);
        System.out.println("After: " + map);
        
        /**
         * OUTPUT:
         * Initial: {1=one, 3=three, 5=five}
         * pollFirstEntry(): 1=one
         * After: {3=three, 5=five}
         * pollLastEntry(): 5=five
         * After: {3=three}
         * 
         * USE CASES:
         * - Priority queue operations
         * - Processing in sorted order
         * - Task scheduling
         */
    }
    
    /**
     * Descending views
     */
    public static void descendingViews() {
        TreeMap<Integer, String> map = new TreeMap<>();
        map.put(1, "one");
        map.put(3, "three");
        map.put(5, "five");
        
        // Descending map (reverse order view)
        NavigableMap<Integer, String> descending = map.descendingMap();
        
        System.out.println("Ascending: " + map);
        System.out.println("Descending: " + descending);
        
        // Descending key set
        NavigableSet<Integer> descendingKeys = map.descendingKeySet();
        System.out.println("Descending keys: " + descendingKeys);
        
        /**
         * OUTPUT:
         * Ascending: {1=one, 3=three, 5=five}
         * Descending: {5=five, 3=three, 1=one}
         * Descending keys: [5, 3, 1]
         * 
         * NOTE:
         * - View backed by original map
         * - Changes in view affect original
         * - O(1) to create view
         * - Useful for reverse iteration
         */
    }
    
    /**
     * Real-world example: Time-series data
     */
    public static void timeSeriesExample() {
        // Stock prices by timestamp
        TreeMap<Long, Double> prices = new TreeMap<>();
        
        long now = System.currentTimeMillis();
        prices.put(now - 3600000, 100.0);  // 1 hour ago
        prices.put(now - 1800000, 105.0);  // 30 min ago
        prices.put(now - 900000, 103.0);   // 15 min ago
        prices.put(now, 107.0);             // now
        
        // Get price at specific time (or closest before)
        long queryTime = now - 1000000;  // ~16 min ago
        Double price = prices.floorEntry(queryTime).getValue();
        System.out.println("Price at query time: " + price);
        
        // Get all prices in last 30 minutes
        long thirtyMinAgo = now - 1800000;
        SortedMap<Long, Double> recent = prices.tailMap(thirtyMinAgo);
        System.out.println("Last 30 min prices: " + recent.values());
        
        /**
         * OUTPUT:
         * Price at query time: 105.0
         * Last 30 min prices: [105.0, 103.0, 107.0]
         * 
         * PERFECT FOR:
         * - Time-series data
         * - Event logs
         * - Scheduling systems
         * - Range queries on sorted data
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Range Operations ===");
        rangeOperations();
        
        System.out.println("\n=== Navigation Methods ===");
        navigationMethods();
        
        System.out.println("\n=== Time Series Example ===");
        timeSeriesExample();
    }
}
```

---

## 3. LinkedHashMap - Insertion and Access Order

### Predictable Iteration Order

```java
/**
 * LINKEDHASHMAP
 * 
 * HashMap with predictable iteration order
 */

import java.util.*;

public class LinkedHashMapExplained {
    
    /**
     * Internal structure
     */
    public static void internalStructure() {
        /**
         * LINKEDHASHMAP ARCHITECTURE:
         * 
         * Extends HashMap with doubly-linked list
         * 
         * HashMap array:
         * ┌───┬───┬───┬───┐
         * │ 0 │ 1 │ 2 │ 3 │
         * └─┬─┴───┴─┬─┴───┘
         *   │       │
         *   v       v
         * Entry   Entry
         * 
         * PLUS doubly-linked list:
         * 
         * head → Entry("a") ⇄ Entry("b") ⇄ Entry("c") ← tail
         *          ↓             ↓             ↓
         *        bucket 0      bucket 2      bucket 1
         * 
         * ENTRY STRUCTURE:
         * - All HashMap Entry fields
         * - before: Entry (previous in order)
         * - after: Entry (next in order)
         * 
         * MEMORY OVERHEAD:
         * - 2 extra references per entry
         * - ~16 bytes per entry
         * - Worth it for predictable iteration
         */
    }
    
    /**
     * Insertion order (default)
     */
    public static void insertionOrder() {
        Map<String, Integer> map = new LinkedHashMap<>();
        
        map.put("apple", 1);
        map.put("banana", 2);
        map.put("cherry", 3);
        map.put("apple", 10);  // Update existing
        
        System.out.println("LinkedHashMap: " + map);
        
        System.out.println("Iteration order:");
        for (String key : map.keySet()) {
            System.out.println(key);
        }
        
        // Compare with HashMap
        Map<String, Integer> hashMap = new HashMap<>();
        hashMap.put("apple", 1);
        hashMap.put("banana", 2);
        hashMap.put("cherry", 3);
        
        System.out.println("\nHashMap: " + hashMap);
        System.out.println("Order may vary!");
        
        /**
         * OUTPUT:
         * LinkedHashMap: {apple=10, banana=2, cherry=3}
         * Iteration order:
         * apple
         * banana
         * cherry
         * 
         * HashMap: {banana=2, apple=10, cherry=3}
         * Order may vary!
         * 
         * BENEFITS:
         * - Predictable iteration
         * - Preserves insertion order
         * - Useful for:
         *   - Maintaining order
         *   - Serialization
         *   - Testing (deterministic)
         */
    }
    
    /**
     * Access order mode
     */
    public static void accessOrder() {
        // accessOrder=true: LRU order
        Map<String, Integer> map = new LinkedHashMap<>(16, 0.75f, true);
        
        map.put("a", 1);
        map.put("b", 2);
        map.put("c", 3);
        
        System.out.println("Initial: " + map);
        
        // Access "a"
        map.get("a");
        System.out.println("After get('a'): " + map);
        
        // Access "b"
        map.get("b");
        System.out.println("After get('b'): " + map);
        
        // Put existing key
        map.put("c", 30);
        System.out.println("After put('c', 30): " + map);
        
        /**
         * OUTPUT:
         * Initial: {a=1, b=2, c=3}
         * After get('a'): {b=2, c=3, a=1}
         * After get('b'): {c=3, a=1, b=2}
         * After put('c', 30): {a=1, b=2, c=30}
         * 
         * ACCESS ORDER:
         * - Recently accessed moved to end
         * - Least recently used at beginning
         * - Perfect for LRU cache
         * 
         * OPERATIONS THAT COUNT AS ACCESS:
         * - get()
         * - put() of existing key
         * - replace()
         * - getOrDefault()
         * - compute()
         * - merge()
         * 
         * NOT ACCESS:
         * - put() of new key
         * - containsKey()
         * - size()
         */
    }
    
    /**
     * Performance comparison
     */
    public static void performanceComparison() {
        int n = 100000;
        
        // HashMap
        long start = System.nanoTime();
        Map<Integer, Integer> hashMap = new HashMap<>();
        for (int i = 0; i < n; i++) {
            hashMap.put(i, i);
        }
        for (Integer key : hashMap.keySet()) {
            int v = hashMap.get(key);
        }
        long hashTime = System.nanoTime() - start;
        
        // LinkedHashMap
        start = System.nanoTime();
        Map<Integer, Integer> linkedMap = new LinkedHashMap<>();
        for (int i = 0; i < n; i++) {
            linkedMap.put(i, i);
        }
        for (Integer key : linkedMap.keySet()) {
            int v = linkedMap.get(key);
        }
        long linkedTime = System.nanoTime() - start;
        
        System.out.println("HashMap: " + hashTime / 1_000_000 + "ms");
        System.out.println("LinkedHashMap: " + linkedTime / 1_000_000 + "ms");
        System.out.println("Overhead: " + 
            (double)(linkedTime - hashTime) / hashTime * 100 + "%");
        
        /**
         * OUTPUT (typical):
         * HashMap: 25ms
         * LinkedHashMap: 35ms
         * Overhead: 40%
         * 
         * PERFORMANCE:
         * - LinkedHashMap ~40% slower
         * - Extra pointer maintenance
         * - Still O(1) operations
         * - Iteration faster (ordered)
         * 
         * WHEN TO USE:
         * ✓ Need predictable order
         * ✓ Implementing cache
         * ✓ Deterministic testing
         * ✗ Maximum performance
         * ✗ Don't care about order
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Insertion Order ===");
        insertionOrder();
        
        System.out.println("\n=== Access Order ===");
        accessOrder();
        
        System.out.println("\n=== Performance ===");
        performanceComparison();
    }
}
```

---

## 4. LRU Cache Implementation

### Least Recently Used Cache

```java
/**
 * LRU CACHE
 * 
 * Using LinkedHashMap for efficient LRU cache
 */

import java.util.*;

public class LRUCacheImplementation {
    
    /**
     * Simple LRU cache with removeEldestEntry
     */
    static class SimpleLRUCache<K, V> extends LinkedHashMap<K, V> {
        private final int maxSize;
        
        public SimpleLRUCache(int maxSize) {
            super(maxSize, 0.75f, true);  // accessOrder=true
            this.maxSize = maxSize;
        }
        
        @Override
        protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
            return size() > maxSize;
        }
        
        /**
         * HOW IT WORKS:
         * 
         * 1. accessOrder=true: Moves accessed entries to end
         * 2. removeEldestEntry() called after each put()
         * 3. If size > maxSize, returns true
         * 4. Eldest entry (head of list) removed
         * 
         * RESULT: Automatic LRU eviction!
         */
    }
    
    public static void simpleLRUDemo() {
        SimpleLRUCache<String, Integer> cache = new SimpleLRUCache<>(3);
        
        cache.put("a", 1);
        cache.put("b", 2);
        cache.put("c", 3);
        System.out.println("After 3 puts: " + cache);
        
        // Access "a" (moves to end)
        cache.get("a");
        System.out.println("After get('a'): " + cache);
        
        // Add 4th entry (evicts "b")
        cache.put("d", 4);
        System.out.println("After put('d'): " + cache);
        
        /**
         * OUTPUT:
         * After 3 puts: {a=1, b=2, c=3}
         * After get('a'): {b=2, c=3, a=1}
         * After put('d'): {c=3, a=1, d=4}
         * 
         * "b" was evicted (least recently used)
         */
    }
    
    /**
     * Thread-safe LRU cache
     */
    static class ThreadSafeLRUCache<K, V> {
        private final Map<K, V> cache;
        private final int maxSize;
        
        public ThreadSafeLRUCache(int maxSize) {
            this.maxSize = maxSize;
            this.cache = Collections.synchronizedMap(
                new LinkedHashMap<K, V>(maxSize, 0.75f, true) {
                    @Override
                    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
                        return size() > ThreadSafeLRUCache.this.maxSize;
                    }
                }
            );
        }
        
        public V get(K key) {
            synchronized (cache) {
                return cache.get(key);
            }
        }
        
        public void put(K key, V value) {
            synchronized (cache) {
                cache.put(key, value);
            }
        }
        
        /**
         * THREAD SAFETY:
         * - Collections.synchronizedMap wraps LinkedHashMap
         * - All operations synchronized
         * - Safe for concurrent access
         * 
         * LIMITATION:
         * - Coarse-grained locking
         * - All operations block
         * - Better: use ConcurrentHashMap with manual LRU
         */
    }
    
    /**
     * Full-featured LRU cache
     */
    static class AdvancedLRUCache<K, V> {
        private final int maxSize;
        private final Map<K, CacheEntry<V>> cache;
        
        static class CacheEntry<V> {
            V value;
            long timestamp;
            long expiryTime;
            
            CacheEntry(V value, long ttl) {
                this.value = value;
                this.timestamp = System.currentTimeMillis();
                this.expiryTime = ttl > 0 ? timestamp + ttl : Long.MAX_VALUE;
            }
            
            boolean isExpired() {
                return System.currentTimeMillis() > expiryTime;
            }
        }
        
        public AdvancedLRUCache(int maxSize) {
            this.maxSize = maxSize;
            this.cache = new LinkedHashMap<K, CacheEntry<V>>(
                maxSize, 0.75f, true) {
                @Override
                protected boolean removeEldestEntry(
                        Map.Entry<K, CacheEntry<V>> eldest) {
                    return size() > AdvancedLRUCache.this.maxSize;
                }
            };
        }
        
        public V get(K key) {
            CacheEntry<V> entry = cache.get(key);
            if (entry == null) {
                return null;
            }
            
            if (entry.isExpired()) {
                cache.remove(key);
                return null;
            }
            
            return entry.value;
        }
        
        public void put(K key, V value, long ttlMillis) {
            cache.put(key, new CacheEntry<>(value, ttlMillis));
        }
        
        public void put(K key, V value) {
            put(key, value, 0);  // No expiry
        }
        
        /**
         * FEATURES:
         * - LRU eviction
         * - TTL (time-to-live)
         * - Expiry checking
         * - Size limit
         */
    }
    
    public static void advancedCacheDemo() throws InterruptedException {
        AdvancedLRUCache<String, String> cache = new AdvancedLRUCache<>(3);
        
        // Put with 1 second TTL
        cache.put("temp", "value", 1000);
        System.out.println("Immediately: " + cache.get("temp"));
        
        Thread.sleep(1100);
        System.out.println("After 1.1s: " + cache.get("temp"));
        
        /**
         * OUTPUT:
         * Immediately: value
         * After 1.1s: null
         * 
         * TTL expired, entry removed
         */
    }
    
    /**
     * Performance test
     */
    public static void performanceTest() {
        int cacheSize = 1000;
        int operations = 1_000_000;
        
        SimpleLRUCache<Integer, Integer> cache = new SimpleLRUCache<>(cacheSize);
        
        // Warm up cache
        for (int i = 0; i < cacheSize; i++) {
            cache.put(i, i);
        }
        
        long start = System.nanoTime();
        
        // Mix of gets and puts
        Random random = new Random(42);
        int hits = 0;
        for (int i = 0; i < operations; i++) {
            int key = random.nextInt(cacheSize * 2);
            
            Integer value = cache.get(key);
            if (value != null) {
                hits++;
            } else {
                cache.put(key, key);
            }
        }
        
        long elapsed = System.nanoTime() - start;
        
        System.out.println("Operations: " + operations);
        System.out.println("Cache size: " + cacheSize);
        System.out.println("Hit rate: " + (double) hits / operations * 100 + "%");
        System.out.println("Time: " + elapsed / 1_000_000 + "ms");
        System.out.println("Ops/sec: " + 
            (long)(operations / (elapsed / 1e9)));
        
        /**
         * OUTPUT (typical):
         * Operations: 1000000
         * Cache size: 1000
         * Hit rate: 49.5%
         * Time: 180ms
         * Ops/sec: 5555555
         * 
         * PERFORMANCE:
         * - ~5M ops/sec
         * - O(1) get and put
         * - Automatic eviction
         * - Excellent for caching
         */
    }
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== Simple LRU ===");
        simpleLRUDemo();
        
        System.out.println("\n=== Advanced Cache ===");
        advancedCacheDemo();
        
        System.out.println("\n=== Performance Test ===");
        performanceTest();
    }
}
```

---

## 5. WeakHashMap - Automatic Garbage Collection

### Memory-Sensitive Caching

```java
/**
 * WEAKHASHMAP
 * 
 * Map with weak references for keys
 */

import java.util.*;

public class WeakHashMapExplained {
    
    /**
     * How WeakHashMap works
     */
    public static void howItWorks() {
        /**
         * WEAKHASHMAP ARCHITECTURE:
         * 
         * Normal HashMap:
         * Key → [Strong reference] → Object
         * Map holds key, prevents GC
         * 
         * WeakHashMap:
         * Key → [Weak reference] → Object
         * Map doesn't prevent GC
         * If no other references, key can be GC'd
         * 
         * PROCESS:
         * 1. Put key-value in WeakHashMap
         * 2. WeakHashMap stores WeakReference to key
         * 3. If key only referenced by map, GC can collect it
         * 4. After GC, entry automatically removed from map
         * 
         * USE CASE: Caches that don't prevent GC
         */
    }
    
    /**
     * Basic demonstration
     */
    public static void basicDemo() throws InterruptedException {
        Map<Data, String> map = new WeakHashMap<>();
        
        Data key1 = new Data(1);
        Data key2 = new Data(2);
        Data key3 = new Data(3);
        
        map.put(key1, "value1");
        map.put(key2, "value2");
        map.put(key3, "value3");
        
        System.out.println("Initial size: " + map.size());
        
        // Remove strong reference
        key1 = null;
        
        // Suggest GC
        System.gc();
        Thread.sleep(100);
        
        System.out.println("After GC size: " + map.size());
        System.out.println("Remaining keys: " + map.keySet());
        
        /**
         * OUTPUT:
         * Initial size: 3
         * After GC size: 2
         * Remaining keys: [Data(2), Data(3)]
         * 
         * key1 was garbage collected!
         * Entry automatically removed from map
         */
    }
    
    static class Data {
        int id;
        
        Data(int id) {
            this.id = id;
        }
        
        @Override
        public String toString() {
            return "Data(" + id + ")";
        }
    }
    
    /**
     * Cache scenario
     */
    public static void cacheScenario() {
        WeakHashMap<Object, MetaData> metaDataCache = new WeakHashMap<>();
        
        // Store metadata for objects
        Object obj1 = new Object();
        Object obj2 = new Object();
        
        metaDataCache.put(obj1, new MetaData("metadata1"));
        metaDataCache.put(obj2, new MetaData("metadata2"));
        
        System.out.println("Cache size: " + metaDataCache.size());
        
        // When obj1 is no longer used, entry is removed
        obj1 = null;
        System.gc();
        
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        System.out.println("After GC: " + metaDataCache.size());
        
        /**
         * USE CASES:
         * - Canonical mappings (string interning)
         * - Metadata/properties for objects
         * - Caches that shouldn't prevent GC
         * - Registry of live objects
         * 
         * EXAMPLE:
         * GUI framework tracking listeners
         * When widget is GC'd, listeners auto-removed
         */
    }
    
    static class MetaData {
        String data;
        
        MetaData(String data) {
            this.data = data;
        }
    }
    
    /**
     * Comparison with HashMap
     */
    public static void comparisonWithHashMap() {
        System.out.println("=== HashMap ===");
        Map<Object, String> hashMap = new HashMap<>();
        
        Object key = new Object();
        hashMap.put(key, "value");
        
        System.out.println("Before: " + hashMap.size());
        
        key = null;  // Remove strong reference
        System.gc();
        
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        System.out.println("After GC: " + hashMap.size());
        System.out.println("HashMap still holds reference!\n");
        
        System.out.println("=== WeakHashMap ===");
        Map<Object, String> weakMap = new WeakHashMap<>();
        
        Object key2 = new Object();
        weakMap.put(key2, "value");
        
        System.out.println("Before: " + weakMap.size());
        
        key2 = null;
        System.gc();
        
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        System.out.println("After GC: " + weakMap.size());
        System.out.println("WeakHashMap entry removed!");
        
        /**
         * OUTPUT:
         * === HashMap ===
         * Before: 1
         * After GC: 1
         * HashMap still holds reference!
         * 
         * === WeakHashMap ===
         * Before: 1
         * After GC: 0
         * WeakHashMap entry removed!
         */
    }
    
    /**
     * Important notes
     */
    public static void importantNotes() {
        /**
         * IMPORTANT NOTES:
         * 
         * 1. WEAK REFERENCE IS FOR KEYS ONLY:
         *    - Keys are weakly referenced
         *    - Values are strongly referenced
         *    - If value holds reference to key, entry won't be GC'd!
         * 
         * 2. DON'T USE WITH STRING/INTEGER:
         *    WeakHashMap<String, V> map = new WeakHashMap<>();
         *    map.put("key", value);  // WON'T BE GC'd!
         *    
         *    Why? String literals are in string pool
         *    Always have strong reference
         *    Use new String("key") or custom objects
         * 
         * 3. NOT FOR ALL CACHES:
         *    - Good: Don't want to prevent GC
         *    - Bad: Need control over eviction
         *    - Better for cache: LRU cache with size limit
         * 
         * 4. PERFORMANCE:
         *    - Slightly slower than HashMap
         *    - GC overhead
         *    - Reference queue processing
         * 
         * 5. TIMING UNPREDICTABLE:
         *    - Entry removal depends on GC
         *    - GC timing unpredictable
         *    - Don't rely on immediate removal
         */
    }
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== Basic Demo ===");
        basicDemo();
        
        System.out.println("\n=== Comparison ===");
        comparisonWithHashMap();
    }
}
```

---

## 6. IdentityHashMap - Reference Equality

### Using == Instead of equals()

```java
/**
 * IDENTITYHASHMAP
 * 
 * Uses reference equality (==) instead of equals()
 */

import java.util.*;

public class IdentityHashMapExplained {
    
    /**
     * Reference equality vs value equality
     */
    public static void referenceVsValue() {
        // HashMap (uses equals)
        Map<String, Integer> hashMap = new HashMap<>();
        String s1 = new String("key");
        String s2 = new String("key");
        
        hashMap.put(s1, 1);
        hashMap.put(s2, 2);  // Overwrites!
        
        System.out.println("HashMap size: " + hashMap.size());
        System.out.println("s1 == s2: " + (s1 == s2));
        System.out.println("s1.equals(s2): " + s1.equals(s2));
        
        // IdentityHashMap (uses ==)
        Map<String, Integer> identityMap = new IdentityHashMap<>();
        
        identityMap.put(s1, 1);
        identityMap.put(s2, 2);  // Separate entry!
        
        System.out.println("\nIdentityHashMap size: " + identityMap.size());
        System.out.println("get(s1): " + identityMap.get(s1));
        System.out.println("get(s2): " + identityMap.get(s2));
        
        /**
         * OUTPUT:
         * HashMap size: 1
         * s1 == s2: false
         * s1.equals(s2): true
         * 
         * IdentityHashMap size: 2
         * get(s1): 1
         * get(s2): 2
         * 
         * DIFFERENCE:
         * - HashMap: s1.equals(s2) → same entry
         * - IdentityHashMap: s1 != s2 → different entries
         */
    }
    
    /**
     * Hash function difference
     */
    public static void hashFunctionDifference() {
        String s = "test";
        
        // HashMap hash
        int hashMapHash = s.hashCode();
        
        // IdentityHashMap hash
        int identityHash = System.identityHashCode(s);
        
        System.out.println("String: " + s);
        System.out.println("hashCode(): " + hashMapHash);
        System.out.println("identityHashCode(): " + identityHash);
        
        String s2 = new String("test");
        System.out.println("\nDifferent instance, same value:");
        System.out.println("s.hashCode(): " + s.hashCode());
        System.out.println("s2.hashCode(): " + s2.hashCode());
        System.out.println("System.identityHashCode(s): " + 
            System.identityHashCode(s));
        System.out.println("System.identityHashCode(s2): " + 
            System.identityHashCode(s2));
        
        /**
         * OUTPUT:
         * String: test
         * hashCode(): 3556498
         * identityHashCode(): 1234567890
         * 
         * Different instance, same value:
         * s.hashCode(): 3556498
         * s2.hashCode(): 3556498  (SAME - based on value)
         * System.identityHashCode(s): 1234567890
         * System.identityHashCode(s2): 9876543210  (DIFFERENT - based on ref)
         * 
         * HASH FUNCTION:
         * HashMap: Uses hashCode() (value-based)
         * IdentityHashMap: Uses System.identityHashCode() (memory address)
         */
    }
    
    /**
     * Use case: Proxy or wrapper tracking
     */
    public static void proxyTracking() {
        // Track proxies by identity, not value
        Map<Object, ProxyMetaData> proxyData = new IdentityHashMap<>();
        
        Object original1 = new Object();
        Object original2 = new Object();
        
        // Even if equals() is true, track separately
        proxyData.put(original1, new ProxyMetaData("proxy1"));
        proxyData.put(original2, new ProxyMetaData("proxy2"));
        
        System.out.println("Tracking " + proxyData.size() + " proxies");
        
        /**
         * USE CASES:
         * 
         * 1. PROXY TRACKING:
         *    - Track proxy objects
         *    - Need identity, not value equality
         * 
         * 2. OBJECT GRAPH TRAVERSAL:
         *    - Detect cycles
         *    - Track visited objects
         *    - Must distinguish instances
         * 
         * 3. SERIALIZATION:
         *    - Track serialized objects
         *    - Detect sharing
         * 
         * 4. MUTABLE KEYS:
         *    - When using mutable objects as keys
         *    - Don't want equals() to change behavior
         */
    }
    
    static class ProxyMetaData {
        String info;
        
        ProxyMetaData(String info) {
            this.info = info;
        }
    }
    
    /**
     * Cycle detection example
     */
    public static void cycleDetection() {
        Map<Object, Boolean> visited = new IdentityHashMap<>();
        
        Node a = new Node("A");
        Node b = new Node("B");
        Node c = new Node("C");
        
        a.next = b;
        b.next = c;
        c.next = a;  // Cycle!
        
        System.out.println("Has cycle: " + hasCycle(a, visited));
    }
    
    static boolean hasCycle(Node node, Map<Object, Boolean> visited) {
        if (node == null) return false;
        
        if (visited.containsKey(node)) {
            return true;  // Cycle detected!
        }
        
        visited.put(node, true);
        return hasCycle(node.next, visited);
    }
    
    static class Node {
        String name;
        Node next;
        
        Node(String name) {
            this.name = name;
        }
        
        @Override
        public boolean equals(Object obj) {
            if (!(obj instanceof Node)) return false;
            return name.equals(((Node) obj).name);
        }
        
        @Override
        public int hashCode() {
            return name.hashCode();
        }
    }
    
    /**
     * Performance notes
     */
    public static void performanceNotes() {
        /**
         * PERFORMANCE:
         * 
         * IdentityHashMap:
         * - Faster than HashMap
         * - No equals() call
         * - No hashCode() call
         * - Simple reference comparison
         * - System.identityHashCode() very fast
         * 
         * WHEN TO USE:
         * ✓ Need reference equality
         * ✓ Tracking object instances
         * ✓ Cycle detection
         * ✓ Serialization
         * ✓ Performance critical (if appropriate)
         * 
         * WHEN NOT TO USE:
         * ✗ Normal key-value mapping
         * ✗ String keys (use HashMap)
         * ✗ Need value equality
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Reference vs Value ===");
        referenceVsValue();
        
        System.out.println("\n=== Hash Function ===");
        hashFunctionDifference();
        
        System.out.println("\n=== Cycle Detection ===");
        cycleDetection();
    }
}
```

---

## 7. EnumMap - Optimal for Enum Keys

### Array-Based High-Performance Map

```java
/**
 * ENUMMAP
 * 
 * Specialized map for enum keys
 */

import java.util.*;

public class EnumMapExplained {
    
    enum Day {
        MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
    }
    
    /**
     * Internal structure
     */
    public static void internalStructure() {
        /**
         * ENUMMAP ARCHITECTURE:
         * 
         * Uses simple array indexed by enum ordinal
         * 
         * enum Day { MONDAY(0), TUESDAY(1), WEDNESDAY(2), ... }
         * 
         * EnumMap<Day, String>:
         * ┌──────────┬──────────┬──────────┬──────────┐
         * │ value[0] │ value[1] │ value[2] │ value[3] │ ...
         * │ "Mon"    │ "Tue"    │ null     │ "Thu"    │
         * └──────────┴──────────┴──────────┴──────────┘
         *     ↑          ↑          ↑          ↑
         *   MONDAY    TUESDAY   WEDNESDAY  THURSDAY
         * 
         * ACCESS:
         * get(TUESDAY) → value[TUESDAY.ordinal()] → value[1]
         * 
         * BENEFITS:
         * - O(1) access with no hash computation
         * - Compact (only array, no nodes)
         * - Type-safe
         * - Predictable iteration order (enum declaration order)
         * 
         * SIZE:
         * Array length = number of enum constants
         * Memory: minimal overhead
         */
    }
    
    /**
     * Basic usage
     */
    public static void basicUsage() {
        EnumMap<Day, String> schedule = new EnumMap<>(Day.class);
        
        schedule.put(Day.MONDAY, "Gym");
        schedule.put(Day.WEDNESDAY, "Yoga");
        schedule.put(Day.FRIDAY, "Swimming");
        
        System.out.println("Schedule: " + schedule);
        System.out.println("Monday: " + schedule.get(Day.MONDAY));
        System.out.println("Tuesday: " + schedule.get(Day.TUESDAY));
        
        // Iteration in enum declaration order
        System.out.println("\nIteration order:");
        for (Day day : schedule.keySet()) {
            System.out.println(day + ": " + schedule.get(day));
        }
        
        /**
         * OUTPUT:
         * Schedule: {MONDAY=Gym, WEDNESDAY=Yoga, FRIDAY=Swimming}
         * Monday: Gym
         * Tuesday: null
         * 
         * Iteration order:
         * MONDAY: Gym
         * WEDNESDAY: Yoga
         * FRIDAY: Swimming
         * 
         * ORDER:
         * - Always enum declaration order
         * - Not insertion order
         * - Predictable and consistent
         */
    }
    
    /**
     * Performance comparison
     */
    public static void performanceComparison() {
        int iterations = 10_000_000;
        
        // EnumMap
        EnumMap<Day, Integer> enumMap = new EnumMap<>(Day.class);
        for (Day day : Day.values()) {
            enumMap.put(day, day.ordinal());
        }
        
        long start = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            Day day = Day.values()[i % Day.values().length];
            int value = enumMap.get(day);
        }
        long enumTime = System.nanoTime() - start;
        
        // HashMap
        HashMap<Day, Integer> hashMap = new HashMap<>();
        for (Day day : Day.values()) {
            hashMap.put(day, day.ordinal());
        }
        
        start = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            Day day = Day.values()[i % Day.values().length];
            int value = hashMap.get(day);
        }
        long hashTime = System.nanoTime() - start;
        
        System.out.println("Get operations: " + iterations);
        System.out.println("EnumMap: " + enumTime / 1_000_000 + "ms");
        System.out.println("HashMap: " + hashTime / 1_000_000 + "ms");
        System.out.println("EnumMap is " + 
            (double) hashTime / enumTime + "x faster");
        
        /**
         * OUTPUT (typical):
         * Get operations: 10000000
         * EnumMap: 45ms
         * HashMap: 180ms
         * EnumMap is 4x faster
         * 
         * WHY FASTER:
         * - Direct array access
         * - No hash calculation
         * - No equals() call
         * - Better cache locality
         * - Smaller memory footprint
         */
    }
    
    /**
     * Memory comparison
     */
    public static void memoryComparison() {
        EnumMap<Day, String> enumMap = new EnumMap<>(Day.class);
        HashMap<Day, String> hashMap = new HashMap<>();
        
        for (Day day : Day.values()) {
            String value = "Value for " + day;
            enumMap.put(day, value);
            hashMap.put(day, value);
        }
        
        /**
         * MEMORY USAGE (approximate):
         * 
         * EnumMap:
         * - EnumMap object: ~24 bytes
         * - Array: 16 + (7 * 8) = 72 bytes
         * - Total: ~96 bytes
         * 
         * HashMap:
         * - HashMap object: ~48 bytes
         * - Array: 16 + (16 * 8) = 144 bytes (capacity 16)
         * - 7 Nodes: 7 * 40 = 280 bytes
         * - Total: ~472 bytes
         * 
         * EnumMap uses ~5x less memory!
         */
        
        System.out.println("EnumMap: ~96 bytes");
        System.out.println("HashMap: ~472 bytes");
        System.out.println("EnumMap uses 5x less memory");
    }
    
    /**
     * Real-world example: State machine
     */
    enum State {
        IDLE, PROCESSING, COMPLETED, FAILED
    }
    
    enum Event {
        START, FINISH, ERROR, RESET
    }
    
    public static void stateMachineExample() {
        // State transitions
        EnumMap<State, EnumMap<Event, State>> transitions = new EnumMap<>(State.class);
        
        // IDLE transitions
        EnumMap<Event, State> idleTransitions = new EnumMap<>(Event.class);
        idleTransitions.put(Event.START, State.PROCESSING);
        transitions.put(State.IDLE, idleTransitions);
        
        // PROCESSING transitions
        EnumMap<Event, State> processingTransitions = new EnumMap<>(Event.class);
        processingTransitions.put(Event.FINISH, State.COMPLETED);
        processingTransitions.put(Event.ERROR, State.FAILED);
        transitions.put(State.PROCESSING, processingTransitions);
        
        // COMPLETED/FAILED transitions
        EnumMap<Event, State> resetTransitions = new EnumMap<>(Event.class);
        resetTransitions.put(Event.RESET, State.IDLE);
        transitions.put(State.COMPLETED, resetTransitions);
        transitions.put(State.FAILED, resetTransitions);
        
        // Simulate state machine
        State current = State.IDLE;
        System.out.println("Initial state: " + current);
        
        current = transition(transitions, current, Event.START);
        System.out.println("After START: " + current);
        
        current = transition(transitions, current, Event.FINISH);
        System.out.println("After FINISH: " + current);
        
        current = transition(transitions, current, Event.RESET);
        System.out.println("After RESET: " + current);
        
        /**
         * OUTPUT:
         * Initial state: IDLE
         * After START: PROCESSING
         * After FINISH: COMPLETED
         * After RESET: IDLE
         * 
         * PERFECT FOR:
         * - State machines
         * - Lookup tables
         * - Configuration by enum
         * - Performance-critical enum mapping
         */
    }
    
    static State transition(EnumMap<State, EnumMap<Event, State>> transitions,
                           State current, Event event) {
        EnumMap<Event, State> stateTransitions = transitions.get(current);
        if (stateTransitions == null) {
            return current;
        }
        State next = stateTransitions.get(event);
        return next != null ? next : current;
    }
    
    /**
     * Best practices
     */
    public static void bestPractices() {
        /**
         * WHEN TO USE ENUMMAP:
         * 
         * ✓ Keys are enum constants
         * ✓ Performance critical
         * ✓ Memory constrained
         * ✓ Need predictable iteration order
         * 
         * EXAMPLES:
         * - State machines
         * - Configuration
         * - Lookup tables
         * - Enum-based registries
         * 
         * ADVANTAGES:
         * - 4x faster than HashMap
         * - 5x less memory
         * - Type-safe
         * - Predictable order
         * - Compact
         * 
         * LIMITATIONS:
         * - Only for enum keys
         * - Not extensible
         * - Fixed size
         * 
         * RULE:
         * If keys are enums, ALWAYS use EnumMap!
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Basic Usage ===");
        basicUsage();
        
        System.out.println("\n=== Performance Comparison ===");
        performanceComparison();
        
        System.out.println("\n=== Memory Comparison ===");
        memoryComparison();
        
        System.out.println("\n=== State Machine Example ===");
        stateMachineExample();
    }
}
```

---

## 8. Map Selection Guide

### Choosing the Right Map

```java
/**
 * MAP SELECTION GUIDE
 * 
 * When to use which Map implementation
 */

public class MapSelectionGuide {
    
    /**
     * Comparison table
     */
    public static void comparisonTable() {
        /**
         * ┌─────────────────┬─────────┬─────────┬────────────┬───────────────────┐
         * │ Map Type        │ Get/Put │ Sorted  │ Order      │ Best For          │
         * ├─────────────────┼─────────┼─────────┼────────────┼───────────────────┤
         * │ HashMap         │ O(1)    │ No      │ None       │ General purpose   │
         * │ LinkedHashMap   │ O(1)    │ No      │ Insertion  │ Ordered iteration │
         * │                 │         │         │ or Access  │ LRU cache         │
         * │ TreeMap         │ O(log n)│ Yes     │ Sorted     │ Sorted keys       │
         * │                 │         │         │            │ Range queries     │
         * │ WeakHashMap     │ O(1)    │ No      │ None       │ Memory-sensitive  │
         * │                 │         │         │            │ cache             │
         * │ IdentityHashMap │ O(1)    │ No      │ None       │ Identity equality │
         * │                 │         │         │            │ Cycle detection   │
         * │ EnumMap         │ O(1)    │ No      │ Enum order │ Enum keys         │
         * └─────────────────┴─────────┴─────────┴────────────┴───────────────────┘
         */
    }
    
    /**
     * Decision tree
     */
    public static void decisionTree() {
        /**
         * DECISION TREE:
         * 
         * Are keys enums?
         * ├─ YES → EnumMap ✓
         * └─ NO ↓
         * 
         * Need sorted keys?
         * ├─ YES → TreeMap ✓
         * └─ NO ↓
         * 
         * Need iteration order?
         * ├─ YES → LinkedHashMap ✓
         * └─ NO ↓
         * 
         * Need reference equality (==)?
         * ├─ YES → IdentityHashMap ✓
         * └─ NO ↓
         * 
         * Memory-sensitive cache?
         * ├─ YES → WeakHashMap ✓
         * └─ NO ↓
         * 
         * → HashMap ✓ (default choice)
         */
    }
    
    /**
     * Use case examples
     */
    public static void useCaseExamples() {
        /**
         * USE CASES:
         * 
         * HASHMAP:
         * - General key-value storage
         * - Cache with controlled eviction
         * - Frequency counting
         * - Indexing
         * Example: word count, user sessions
         * 
         * LINKEDHASHMAP:
         * - LRU cache
         * - Maintaining insertion order
         * - JSON serialization (order matters)
         * - Recent items list
         * Example: browser history, LRU cache
         * 
         * TREEMAP:
         * - Sorted iteration
         * - Range queries
         * - Floor/ceiling operations
         * - Time-series data
         * Example: leaderboard, scheduled tasks
         * 
         * WEAKHASHMAP:
         * - Object metadata
         * - Canonical mappings
         * - Memory-sensitive cache
         * Example: GUI listeners, string interning
         * 
         * IDENTITYHASHMAP:
         * - Proxy tracking
         * - Object graph traversal
         * - Serialization
         * - Cycle detection
         * Example: deep copy, object comparison
         * 
         * ENUMMAP:
         * - Enum-based configuration
         * - State machines
         * - Enum lookup tables
         * Example: day-of-week scheduling, state transitions
         */
    }
    
    /**
     * Performance summary
     */
    public static void performanceSummary() {
        /**
         * PERFORMANCE (relative):
         * 
         * Speed (get/put):
         * EnumMap > IdentityHashMap > HashMap > LinkedHashMap > TreeMap
         * 
         * Memory (per entry):
         * EnumMap < HashMap < IdentityHashMap < LinkedHashMap < TreeMap
         * 
         * BENCHMARKS (100K entries):
         * 
         * Insertion:
         * - EnumMap: N/A (7 enum values)
         * - HashMap: 25ms
         * - LinkedHashMap: 35ms
         * - TreeMap: 85ms
         * - IdentityHashMap: 20ms
         * 
         * Get:
         * - EnumMap: 2ms
         * - HashMap: 8ms
         * - LinkedHashMap: 12ms
         * - TreeMap: 45ms
         * - IdentityHashMap: 6ms
         * 
         * Iteration:
         * - EnumMap: 1ms (ordered)
         * - HashMap: 15ms (unordered)
         * - LinkedHashMap: 8ms (ordered)
         * - TreeMap: 12ms (sorted)
         */
    }
    
    /**
     * Common mistakes
     */
    public static void commonMistakes() {
        /**
         * COMMON MISTAKES:
         * 
         * 1. Using HashMap for enum keys
         *    ✗ Map<Day, String> map = new HashMap<>();
         *    ✓ Map<Day, String> map = new EnumMap<>(Day.class);
         *    Impact: 4x slower, 5x more memory
         * 
         * 2. Using TreeMap unnecessarily
         *    ✗ Map<String, Integer> map = new TreeMap<>();
         *    ✓ Map<String, Integer> map = new HashMap<>();
         *    Impact: 3x slower if sorting not needed
         * 
         * 3. Not using LinkedHashMap for LRU
         *    ✗ Implement LRU manually with HashMap
         *    ✓ Use LinkedHashMap with removeEldestEntry
         *    Impact: Simpler, bug-free, efficient
         * 
         * 4. WeakHashMap with String literals
         *    ✗ WeakHashMap<String, V> map = new WeakHashMap<>();
         *       map.put("key", value);  // Never GC'd!
         *    ✓ Use custom objects or new String()
         * 
         * 5. IdentityHashMap for normal mapping
         *    ✗ Using IdentityHashMap for general purpose
         *    ✓ Only when reference equality needed
         *    Impact: Confusing bugs with equal objects
         */
    }
}
```

---

## Summary

### Quick Reference

**TreeMap:**

```java
// Red-Black tree, O(log n), sorted keys
TreeMap<Integer, String> map = new TreeMap<>();
map.put(5, "five");
map.put(2, "two");
// Iteration: 2, 5 (sorted)

// NavigableMap operations
map.floorKey(4);    // 2 (largest ≤ 4)
map.ceilingKey(3);  // 5 (smallest ≥ 3)
map.subMap(2, 6);   // {2=two, 5=five}
```

**LinkedHashMap:**

```java
// Maintains insertion order
Map<String, Integer> map = new LinkedHashMap<>();

// Or access order (LRU)
Map<String, Integer> lru = new LinkedHashMap<>(16, 0.75f, true);
```

**LRU Cache:**

```java
class LRUCache<K, V> extends LinkedHashMap<K, V> {
    private int maxSize;
    
    public LRUCache(int maxSize) {
        super(maxSize, 0.75f, true);
        this.maxSize = maxSize;
    }
    
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
        return size() > maxSize;
    }
}
```

**WeakHashMap:**

```java
// Keys can be GC'd
Map<Object, String> map = new WeakHashMap<>();
Object key = new Object();
map.put(key, "value");
key = null;  // Entry will be GC'd
```

**IdentityHashMap:**

```java
// Uses == instead of equals()
Map<String, Integer> map = new IdentityHashMap<>();
String s1 = new String("key");
String s2 = new String("key");
map.put(s1, 1);
map.put(s2, 2);  // Two entries! (s1 != s2)
```

**EnumMap:**

```java
// Array-based, 4x faster for enums
enum Day { MON, TUE, WED }
Map<Day, String> map = new EnumMap<>(Day.class);
map.put(Day.MON, "Monday");
```

### Selection Guide

```
HashMap:          General purpose, fastest
LinkedHashMap:    Need insertion/access order
TreeMap:          Need sorted keys/range queries
WeakHashMap:      Memory-sensitive cache
IdentityHashMap:  Reference equality
EnumMap:          Enum keys (always use!)
```

### Performance Summary

```
Speed: EnumMap > Identity > Hash > Linked > Tree
Memory: EnumMap < Hash < Identity < Linked < Tree
```

---
