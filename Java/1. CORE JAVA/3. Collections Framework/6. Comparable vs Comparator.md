# Comparable vs Comparator

## Overview

Comparable and Comparator are fundamental interfaces for defining ordering in Java. Understanding when to use each, how to combine them, and their performance implications is crucial for writing clean, efficient code. This guide covers everything from basic usage to advanced techniques and common pitfalls.


---

## 1. Natural Ordering with Comparable

### Single, Natural Ordering

```java
/**
 * COMPARABLE INTERFACE
 * 
 * Defines natural ordering for a class
 */

import java.util.*;

public class ComparableExamples {
    
    /**
     * Comparable interface definition
     */
    public static void comparableInterface() {
        /**
         * COMPARABLE INTERFACE:
         * 
         * public interface Comparable<T> {
         *     int compareTo(T o);
         * }
         * 
         * RETURN VALUE:
         * - Negative: this < other
         * - Zero: this == other
         * - Positive: this > other
         * 
         * CONTRACT:
         * 1. sgn(x.compareTo(y)) == -sgn(y.compareTo(x))
         *    (Antisymmetry)
         * 
         * 2. x.compareTo(y) > 0 && y.compareTo(z) > 0 
         *    ‚Üí x.compareTo(z) > 0
         *    (Transitivity)
         * 
         * 3. x.compareTo(y) == 0 
         *    ‚Üí sgn(x.compareTo(z)) == sgn(y.compareTo(z))
         *    (Consistency)
         * 
         * 4. STRONGLY RECOMMENDED:
         *    (x.compareTo(y) == 0) == x.equals(y)
         *    (Consistent with equals)
         * 
         * WHEN TO USE:
         * - One obvious natural ordering
         * - Control over the class source code
         * - Want automatic sorting in TreeSet/TreeMap
         */
    }
    
    /**
     * Basic Comparable implementation
     */
    static class Person implements Comparable<Person> {
        String name;
        int age;
        
        Person(String name, int age) {
            this.name = name;
            this.age = age;
        }
        
        @Override
        public int compareTo(Person other) {
            // Natural order: by name
            return this.name.compareTo(other.name);
        }
        
        @Override
        public String toString() {
            return name + "(" + age + ")";
        }
    }
    
    public static void basicComparable() {
        List<Person> people = new ArrayList<>();
        people.add(new Person("Charlie", 35));
        people.add(new Person("Alice", 30));
        people.add(new Person("Bob", 25));
        
        System.out.println("Before sort: " + people);
        Collections.sort(people);  // Uses compareTo
        System.out.println("After sort: " + people);
        
        // Works automatically with TreeSet
        Set<Person> sortedSet = new TreeSet<>(people);
        System.out.println("TreeSet: " + sortedSet);
        
        /**
         * OUTPUT:
         * Before sort: [Charlie(35), Alice(30), Bob(25)]
         * After sort: [Alice(30), Bob(25), Charlie(35)]
         * TreeSet: [Alice(30), Bob(25), Charlie(35)]
         * 
         * AUTOMATIC SORTING:
         * Collections.sort() and TreeSet use compareTo
         */
    }
    
    /**
     * Implementing compareTo correctly
     */
    static class Employee implements Comparable<Employee> {
        String name;
        int salary;
        int id;
        
        Employee(String name, int salary, int id) {
            this.name = name;
            this.salary = salary;
            this.id = id;
        }
        
        @Override
        public int compareTo(Employee other) {
            // Method 1: Using Integer.compare (recommended)
            return Integer.compare(this.salary, other.salary);
            
            // DON'T USE: Subtraction method (overflow risk!)
            // return this.salary - other.salary;  // BAD!
            
            // For strings:
            // return this.name.compareTo(other.name);
            
            // For compound:
            // int salaryComp = Integer.compare(this.salary, other.salary);
            // if (salaryComp != 0) return salaryComp;
            // return this.name.compareTo(other.name);
        }
        
        @Override
        public String toString() {
            return name + "($" + salary + ")";
        }
    }
    
    public static void compareToImplementation() {
        /**
         * CORRECT WAYS TO IMPLEMENT COMPARETO:
         * 
         * 1. PRIMITIVES (int, long, etc):
         *    ‚úÖ return Integer.compare(this.value, other.value);
         *    ‚úÖ return Long.compare(this.value, other.value);
         *    ‚ùå return this.value - other.value;  // Overflow!
         * 
         * 2. OBJECTS (String, etc):
         *    ‚úÖ return this.name.compareTo(other.name);
         *    ‚úÖ return Objects.compare(this.obj, other.obj, comparator);
         * 
         * 3. BOOLEANS:
         *    ‚úÖ return Boolean.compare(this.flag, other.flag);
         * 
         * 4. DOUBLES/FLOATS:
         *    ‚úÖ return Double.compare(this.value, other.value);
         *    ‚ùå Don't use subtraction (NaN, precision issues)
         * 
         * 5. COMPOUND (multiple fields):
         *    int result = field1.compareTo(other.field1);
         *    if (result != 0) return result;
         *    result = field2.compareTo(other.field2);
         *    if (result != 0) return result;
         *    return field3.compareTo(other.field3);
         */
    }
    
    /**
     * Overflow pitfall
     */
    static class BadComparable implements Comparable<BadComparable> {
        int value;
        
        BadComparable(int value) {
            this.value = value;
        }
        
        @Override
        public int compareTo(BadComparable other) {
            // WRONG! Overflow possible
            return this.value - other.value;
        }
    }
    
    public static void overflowPitfall() {
        List<BadComparable> list = new ArrayList<>();
        list.add(new BadComparable(Integer.MAX_VALUE));
        list.add(new BadComparable(-1));
        
        Collections.sort(list);
        
        System.out.println("Values after sort:");
        for (BadComparable bc : list) {
            System.out.println("  " + bc.value);
        }
        
        /**
         * OUTPUT (WRONG!):
         * Values after sort:
         *   2147483647  (MAX_VALUE)
         *   -1
         * 
         * PROBLEM:
         * MAX_VALUE - (-1) = overflow ‚Üí negative
         * MAX_VALUE incorrectly considered "less than" -1
         * 
         * SOLUTION:
         * return Integer.compare(this.value, other.value);
         */
    }
    
    /**
     * Consistent with equals
     */
    static class Point implements Comparable<Point> {
        int x, y;
        
        Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
        
        @Override
        public int compareTo(Point other) {
            // Compare both x and y
            int xComp = Integer.compare(this.x, other.x);
            if (xComp != 0) return xComp;
            return Integer.compare(this.y, other.y);
        }
        
        @Override
        public boolean equals(Object obj) {
            if (!(obj instanceof Point)) return false;
            Point p = (Point) obj;
            return x == p.x && y == p.y;
        }
        
        @Override
        public int hashCode() {
            return Objects.hash(x, y);
        }
        
        @Override
        public String toString() {
            return "(" + x + "," + y + ")";
        }
    }
    
    public static void consistentWithEquals() {
        /**
         * CONSISTENT WITH EQUALS:
         * 
         * If x.equals(y), then x.compareTo(y) == 0
         * 
         * WHY IMPORTANT:
         * - TreeSet/TreeMap use compareTo for equality
         * - If inconsistent, objects considered equal by compareTo
         *   won't be added to TreeSet, even if equals says different
         * 
         * RULE:
         * Use same fields in compareTo, equals, and hashCode
         */
        
        Point p1 = new Point(1, 2);
        Point p2 = new Point(1, 2);
        
        System.out.println("p1.equals(p2): " + p1.equals(p2));
        System.out.println("p1.compareTo(p2): " + p1.compareTo(p2));
        
        // Both should agree (consistent)
    }
    
    public static void main(String[] args) {
        System.out.println("=== Basic Comparable ===");
        basicComparable();
        
        System.out.println("\n=== Overflow Pitfall ===");
        overflowPitfall();
        
        System.out.println("\n=== Consistent with Equals ===");
        consistentWithEquals();
    }
}
```

---

## 2. Custom Ordering with Comparator

### Multiple Orderings and External Control

```java
/**
 * COMPARATOR INTERFACE
 * 
 * Defines custom ordering separate from class
 */

import java.util.*;

public class ComparatorExamples {
    
    /**
     * Comparator interface definition
     */
    public static void comparatorInterface() {
        /**
         * COMPARATOR INTERFACE:
         * 
         * @FunctionalInterface
         * public interface Comparator<T> {
         *     int compare(T o1, T o2);
         *     
         *     // Default methods (Java 8+)
         *     default Comparator<T> reversed() { ... }
         *     default Comparator<T> thenComparing(...) { ... }
         *     
         *     // Static methods
         *     static <T> Comparator<T> naturalOrder() { ... }
         *     static <T> Comparator<T> reverseOrder() { ... }
         *     static <T, U> Comparator<T> comparing(...) { ... }
         *     static <T> Comparator<T> nullsFirst(...) { ... }
         *     static <T> Comparator<T> nullsLast(...) { ... }
         * }
         * 
         * RETURN VALUE (same as Comparable):
         * - Negative: o1 < o2
         * - Zero: o1 == o2
         * - Positive: o1 > o2
         * 
         * WHEN TO USE:
         * - Multiple orderings needed
         * - Don't control class source
         * - Temporary/context-specific ordering
         * - Override natural ordering
         */
    }
    
    /**
     * Basic Comparator usage
     */
    static class Book {
        String title;
        String author;
        int year;
        double rating;
        
        Book(String title, String author, int year, double rating) {
            this.title = title;
            this.author = author;
            this.year = year;
            this.rating = rating;
        }
        
        @Override
        public String toString() {
            return title + " by " + author + " (" + year + ", " + rating + "‚òÖ)";
        }
    }
    
    public static void basicComparator() {
        List<Book> books = new ArrayList<>();
        books.add(new Book("1984", "Orwell", 1949, 4.5));
        books.add(new Book("Dune", "Herbert", 1965, 4.7));
        books.add(new Book("Foundation", "Asimov", 1951, 4.6));
        
        System.out.println("Original: " + books);
        
        // Sort by title
        Collections.sort(books, new Comparator<Book>() {
            @Override
            public int compare(Book b1, Book b2) {
                return b1.title.compareTo(b2.title);
            }
        });
        System.out.println("By title: " + books);
        
        // Sort by year
        Collections.sort(books, new Comparator<Book>() {
            @Override
            public int compare(Book b1, Book b2) {
                return Integer.compare(b1.year, b2.year);
            }
        });
        System.out.println("By year: " + books);
        
        // Sort by rating (descending)
        Collections.sort(books, new Comparator<Book>() {
            @Override
            public int compare(Book b1, Book b2) {
                return Double.compare(b2.rating, b1.rating);  // Reversed
            }
        });
        System.out.println("By rating (desc): " + books);
        
        /**
         * OUTPUT:
         * Original: [1984 by Orwell (1949, 4.5‚òÖ), ...]
         * By title: [1984 by Orwell (...), Dune by Herbert (...), Foundation by Asimov (...)]
         * By year: [1984 by Orwell (1949, ...), Foundation by Asimov (1951, ...), ...]
         * By rating (desc): [Dune by Herbert (..., 4.7‚òÖ), Foundation (..., 4.6‚òÖ), ...]
         * 
         * MULTIPLE ORDERINGS:
         * Same list sorted different ways
         * Flexibility without modifying Book class
         */
    }
    
    /**
     * Lambda expressions (Java 8+)
     */
    public static void lambdaComparators() {
        List<Book> books = Arrays.asList(
            new Book("1984", "Orwell", 1949, 4.5),
            new Book("Dune", "Herbert", 1965, 4.7)
        );
        
        // Lambda syntax
        books.sort((b1, b2) -> b1.title.compareTo(b2.title));
        System.out.println("Lambda: " + books);
        
        /**
         * LAMBDA BENEFITS:
         * - Concise
         * - Readable
         * - No boilerplate
         * - Same performance
         */
    }
    
    /**
     * Comparing with extracted key
     */
    public static void keyExtractorComparators() {
        List<Book> books = Arrays.asList(
            new Book("1984", "Orwell", 1949, 4.5),
            new Book("Dune", "Herbert", 1965, 4.7),
            new Book("Foundation", "Asimov", 1951, 4.6)
        );
        
        // By author (cleaner than lambda)
        books.sort(Comparator.comparing(b -> b.author));
        System.out.println("By author: " + books);
        
        /**
         * COMPARING METHOD:
         * 
         * Comparator.comparing(Function<T, U> keyExtractor)
         * 
         * Extracts key and compares using natural order
         * Much cleaner than manual comparison
         */
    }
    
    /**
     * Reversed comparators
     */
    public static void reversedComparators() {
        List<Book> books = Arrays.asList(
            new Book("1984", "Orwell", 1949, 4.5),
            new Book("Dune", "Herbert", 1965, 4.7)
        );
        
        // Reverse order
        books.sort(Comparator.comparing((Book b) -> b.year).reversed());
        System.out.println("Year descending: " + books);
        
        // Natural reverse order
        List<Integer> numbers = Arrays.asList(3, 1, 4, 1, 5);
        numbers.sort(Comparator.reverseOrder());
        System.out.println("Reverse: " + numbers);
        
        /**
         * REVERSED:
         * - reversed(): Reverse any comparator
         * - reverseOrder(): Reverse natural order
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Basic Comparator ===");
        basicComparator();
        
        System.out.println("\n=== Lambda Comparators ===");
        lambdaComparators();
        
        System.out.println("\n=== Key Extractor ===");
        keyExtractorComparators();
        
        System.out.println("\n=== Reversed ===");
        reversedComparators();
    }
}
```

---

## 3. Comparator Chaining (thenComparing)

### Multi-Level Sorting

```java
/**
 * COMPARATOR CHAINING
 * 
 * Combining multiple comparators
 */

import java.util.*;

public class ComparatorChaining {
    
    static class Employee {
        String department;
        String name;
        int salary;
        int yearsExperience;
        
        Employee(String dept, String name, int salary, int years) {
            this.department = dept;
            this.name = name;
            this.salary = salary;
            this.yearsExperience = years;
        }
        
        @Override
        public String toString() {
            return String.format("%-12s %-10s $%-6d %dy", 
                department, name, salary, yearsExperience);
        }
    }
    
    /**
     * Basic chaining
     */
    public static void basicChaining() {
        List<Employee> employees = Arrays.asList(
            new Employee("Engineering", "Alice", 90000, 5),
            new Employee("Engineering", "Bob", 85000, 3),
            new Employee("Sales", "Charlie", 75000, 7),
            new Employee("Sales", "Diana", 80000, 4),
            new Employee("Engineering", "Eve", 90000, 2)
        );
        
        System.out.println("Original:");
        employees.forEach(System.out::println);
        
        // Sort by department, then by salary (descending)
        employees.sort(
            Comparator.comparing((Employee e) -> e.department)
                      .thenComparing(e -> e.salary, Comparator.reverseOrder())
        );
        
        System.out.println("\nBy dept, then salary desc:");
        employees.forEach(System.out::println);
        
        /**
         * OUTPUT:
         * Original:
         * Engineering  Alice      $90000 5y
         * Engineering  Bob        $85000 3y
         * Sales        Charlie    $75000 7y
         * Sales        Diana      $80000 4y
         * Engineering  Eve        $90000 2y
         * 
         * By dept, then salary desc:
         * Engineering  Alice      $90000 5y
         * Engineering  Eve        $90000 2y
         * Engineering  Bob        $85000 3y
         * Sales        Diana      $80000 4y
         * Sales        Charlie    $75000 7y
         * 
         * CHAINING:
         * Primary sort: department
         * Secondary sort: salary (descending)
         */
    }
    
    /**
     * Multiple levels
     */
    public static void multiLevelChaining() {
        List<Employee> employees = Arrays.asList(
            new Employee("Engineering", "Alice", 90000, 5),
            new Employee("Engineering", "Bob", 85000, 3),
            new Employee("Engineering", "Alice", 90000, 2),
            new Employee("Sales", "Alice", 75000, 7)
        );
        
        // Sort by: dept ‚Üí salary (desc) ‚Üí experience (desc) ‚Üí name
        employees.sort(
            Comparator.comparing((Employee e) -> e.department)
                      .thenComparingInt(e -> -e.salary)  // Negative for desc
                      .thenComparingInt(e -> -e.yearsExperience)
                      .thenComparing(e -> e.name)
        );
        
        System.out.println("Multi-level sort:");
        employees.forEach(System.out::println);
        
        /**
         * CHAINING METHODS:
         * 
         * thenComparing(Function):
         *   Chain by natural order of extracted key
         * 
         * thenComparing(Function, Comparator):
         *   Chain with custom comparator for key
         * 
         * thenComparingInt/Long/Double(ToIntFunction):
         *   Optimized for primitives
         * 
         * ORDER:
         * Later comparators only used if earlier ones return 0
         */
    }
    
    /**
     * Clean chaining with method references
     */
    public static void methodReferenceChaining() {
        List<Employee> employees = Arrays.asList(
            new Employee("Engineering", "Alice", 90000, 5),
            new Employee("Sales", "Bob", 85000, 3)
        );
        
        // Using method references (if we had getters)
        employees.sort(
            Comparator.comparing((Employee e) -> e.department)
                      .thenComparingInt(e -> e.salary)
                      .thenComparing(e -> e.name)
        );
        
        /**
         * WITH PROPER GETTERS:
         * 
         * employees.sort(
         *     Comparator.comparing(Employee::getDepartment)
         *               .thenComparingInt(Employee::getSalary)
         *               .thenComparing(Employee::getName)
         * );
         * 
         * BENEFITS:
         * - Very readable
         * - Type-safe
         * - Refactorable
         * - No magic strings
         */
    }
    
    /**
     * Complex example: Sort users by activity
     */
    static class User {
        String name;
        boolean isPremium;
        int postsCount;
        long lastActiveTime;
        
        User(String name, boolean premium, int posts, long lastActive) {
            this.name = name;
            this.isPremium = premium;
            this.postsCount = posts;
            this.lastActiveTime = lastActive;
        }
        
        @Override
        public String toString() {
            return String.format("%-10s %s posts:%-3d active:%d", 
                name, isPremium ? "üíé" : "  ", postsCount, lastActiveTime);
        }
    }
    
    public static void complexChaining() {
        List<User> users = Arrays.asList(
            new User("Alice", true, 100, 1000),
            new User("Bob", false, 50, 2000),
            new User("Charlie", true, 200, 1500),
            new User("Diana", false, 150, 1800),
            new User("Eve", true, 100, 1200)
        );
        
        // Sort by: Premium first ‚Üí posts (desc) ‚Üí last active (desc) ‚Üí name
        users.sort(
            Comparator.comparing((User u) -> !u.isPremium)  // Premium first
                      .thenComparingInt(u -> -u.postsCount)  // Most posts
                      .thenComparingLong(u -> -u.lastActiveTime)  // Recent
                      .thenComparing(u -> u.name)  // Alphabetical
        );
        
        System.out.println("Users sorted:");
        users.forEach(System.out::println);
        
        /**
         * OUTPUT:
         * Users sorted:
         * Charlie    üíé posts:200 active:1500
         * Eve        üíé posts:100 active:1200
         * Alice      üíé posts:100 active:1000
         * Diana         posts:150 active:1800
         * Bob           posts:50  active:2000
         * 
         * BOOLEAN SORTING TRICK:
         * !isPremium ‚Üí false (premium) sorts before true (non-premium)
         * 
         * DESCENDING TRICK:
         * Use negative for primitive descending
         * Or use .reversed()
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Basic Chaining ===");
        basicChaining();
        
        System.out.println("\n=== Multi-Level Chaining ===");
        multiLevelChaining();
        
        System.out.println("\n=== Complex Chaining ===");
        complexChaining();
    }
}
```

---

## 4. Comparator.comparing() Method References

### Modern, Readable Comparators

```java
/**
 * COMPARATOR.COMPARING
 * 
 * Factory methods for creating comparators
 */

import java.util.*;
import java.util.function.*;

public class ComparingMethods {
    
    static class Product {
        String name;
        String category;
        double price;
        int stockQuantity;
        double rating;
        
        Product(String name, String category, double price, int stock, double rating) {
            this.name = name;
            this.category = category;
            this.price = price;
            this.stockQuantity = stock;
            this.rating = rating;
        }
        
        // Getters for method references
        public String getName() { return name; }
        public String getCategory() { return category; }
        public double getPrice() { return price; }
        public int getStockQuantity() { return stockQuantity; }
        public double getRating() { return rating; }
        
        @Override
        public String toString() {
            return String.format("%-15s %-10s $%-6.2f stock:%-3d %.1f‚òÖ", 
                name, category, price, stockQuantity, rating);
        }
    }
    
    /**
     * Comparing methods overview
     */
    public static void comparingMethodsOverview() {
        /**
         * STATIC FACTORY METHODS:
         * 
         * 1. comparing(Function<T, U>):
         *    Compare by extracted Comparable key
         *    Comparator.comparing(Product::getName)
         * 
         * 2. comparing(Function<T, U>, Comparator<U>):
         *    Compare by extracted key with custom comparator
         *    Comparator.comparing(Product::getName, String.CASE_INSENSITIVE_ORDER)
         * 
         * 3. comparingInt/Long/Double(ToIntFunction<T>):
         *    Optimized for primitives (no boxing)
         *    Comparator.comparingInt(Product::getStockQuantity)
         * 
         * 4. naturalOrder():
         *    Natural ordering (requires Comparable)
         *    Comparator.<String>naturalOrder()
         * 
         * 5. reverseOrder():
         *    Reverse natural ordering
         *    Comparator.<Integer>reverseOrder()
         * 
         * 6. nullsFirst(Comparator):
         *    Nulls sort before non-nulls
         *    Comparator.nullsFirst(Comparator.naturalOrder())
         * 
         * 7. nullsLast(Comparator):
         *    Nulls sort after non-nulls
         *    Comparator.nullsLast(Comparator.naturalOrder())
         */
    }
    
    /**
     * Basic comparing
     */
    public static void basicComparing() {
        List<Product> products = Arrays.asList(
            new Product("Laptop", "Electronics", 999.99, 10, 4.5),
            new Product("Mouse", "Electronics", 29.99, 50, 4.2),
            new Product("Desk", "Furniture", 199.99, 5, 4.7)
        );
        
        // By name
        products.sort(Comparator.comparing(Product::getName));
        System.out.println("By name:");
        products.forEach(System.out::println);
        
        // By price
        products.sort(Comparator.comparingDouble(Product::getPrice));
        System.out.println("\nBy price:");
        products.forEach(System.out::println);
        
        // By rating (descending)
        products.sort(Comparator.comparingDouble(Product::getRating).reversed());
        System.out.println("\nBy rating (desc):");
        products.forEach(System.out::println);
        
        /**
         * METHOD REFERENCE BENEFITS:
         * - Type-safe
         * - Refactorable
         * - IDE support
         * - Clear intent
         * - No magic strings
         */
    }
    
    /**
     * Primitive comparators (performance optimization)
     */
    public static void primitiveComparators() {
        List<Product> products = Arrays.asList(
            new Product("Item1", "Cat", 10.0, 100, 4.0),
            new Product("Item2", "Cat", 10.0, 50, 4.0)
        );
        
        long start;
        
        // Generic comparing (with boxing)
        start = System.nanoTime();
        for (int i = 0; i < 100000; i++) {
            products.sort(Comparator.comparing(Product::getStockQuantity));
        }
        long genericTime = System.nanoTime() - start;
        
        // Primitive comparing (no boxing)
        start = System.nanoTime();
        for (int i = 0; i < 100000; i++) {
            products.sort(Comparator.comparingInt(Product::getStockQuantity));
        }
        long primitiveTime = System.nanoTime() - start;
        
        System.out.println("Generic comparing: " + genericTime / 1_000_000 + "ms");
        System.out.println("Primitive comparing: " + primitiveTime / 1_000_000 + "ms");
        System.out.println("Speedup: " + (double) genericTime / primitiveTime + "x");
        
        /**
         * OUTPUT (typical):
         * Generic comparing: 45ms
         * Primitive comparing: 30ms
         * Speedup: 1.5x
         * 
         * PRIMITIVE COMPARATORS:
         * - comparingInt()
         * - comparingLong()
         * - comparingDouble()
         * 
         * BENEFITS:
         * - No boxing/unboxing
         * - Faster
         * - Less garbage
         * 
         * USE WHEN:
         * Comparing primitive fields
         */
    }
    
    /**
     * Custom key comparators
     */
    public static void customKeyComparators() {
        List<Product> products = Arrays.asList(
            new Product("laptop", "Electronics", 999.99, 10, 4.5),
            new Product("Mouse", "Electronics", 29.99, 50, 4.2),
            new Product("DESK", "Furniture", 199.99, 5, 4.7)
        );
        
        // Case-insensitive name sort
        products.sort(Comparator.comparing(
            Product::getName, 
            String.CASE_INSENSITIVE_ORDER
        ));
        
        System.out.println("Case-insensitive:");
        products.forEach(System.out::println);
        
        /**
         * CUSTOM COMPARATOR FOR KEY:
         * 
         * Comparator.comparing(keyExtractor, keyComparator)
         * 
         * Extract key, then compare with custom logic
         */
    }
    
    /**
     * Real-world example: E-commerce sorting
     */
    public static void ecommerceSorting() {
        List<Product> products = Arrays.asList(
            new Product("Laptop Pro", "Electronics", 1299.99, 5, 4.8),
            new Product("Laptop Basic", "Electronics", 699.99, 15, 4.3),
            new Product("Mouse Wireless", "Electronics", 49.99, 100, 4.5),
            new Product("Desk Premium", "Furniture", 399.99, 3, 4.9),
            new Product("Desk Basic", "Furniture", 149.99, 20, 4.1)
        );
        
        // "Best Match" algorithm:
        // 1. Category (Electronics first)
        // 2. In stock (yes before no)
        // 3. Rating (high to low)
        // 4. Price (low to high)
        
        products.sort(
            Comparator.comparing((Product p) -> 
                    !p.category.equals("Electronics"))  // Electronics first
                      .thenComparing(p -> p.stockQuantity == 0)  // In stock first
                      .thenComparingDouble(Product::getRating).reversed()
                      .thenComparingDouble(Product::getPrice)
        );
        
        System.out.println("Best Match:");
        products.forEach(System.out::println);
        
        /**
         * OUTPUT:
         * Best Match:
         * Laptop Pro      Electronics $1299.99 stock:5   4.8‚òÖ
         * Mouse Wireless  Electronics $49.99   stock:100 4.5‚òÖ
         * Laptop Basic    Electronics $699.99  stock:15  4.3‚òÖ
         * Desk Premium    Furniture   $399.99  stock:3   4.9‚òÖ
         * Desk Basic      Furniture   $149.99  stock:20  4.1‚òÖ
         * 
         * COMPLEX BUSINESS LOGIC:
         * Expressed clearly with method chaining
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Basic Comparing ===");
        basicComparing();
        
        System.out.println("\n=== Primitive Comparators ===");
        primitiveComparators();
        
        System.out.println("\n=== Custom Key Comparators ===");
        customKeyComparators();
        
        System.out.println("\n=== E-commerce Sorting ===");
        ecommerceSorting();
    }
}
```

---

## 5. Null Handling in Comparisons

### Safe Null Comparisons

```java
/**
 * NULL HANDLING
 * 
 * Dealing with null values in sorting
 */

import java.util.*;

public class NullHandling {
    
    static class Task {
        String name;
        Integer priority;  // Can be null
        String assignee;   // Can be null
        
        Task(String name, Integer priority, String assignee) {
            this.name = name;
            this.priority = priority;
            this.assignee = assignee;
        }
        
        @Override
        public String toString() {
            return String.format("%-15s priority:%-5s assignee:%s", 
                name, priority, assignee);
        }
    }
    
    /**
     * The null problem
     */
    public static void nullProblem() {
        List<Task> tasks = Arrays.asList(
            new Task("Fix bug", 1, "Alice"),
            new Task("Write docs", null, "Bob"),
            new Task("Review code", 2, null),
            new Task("Deploy", null, null)
        );
        
        try {
            // This will throw NullPointerException!
            tasks.sort(Comparator.comparing(t -> t.priority));
        } catch (NullPointerException e) {
            System.out.println("NullPointerException: " + e.getMessage());
        }
        
        /**
         * PROBLEM:
         * Integer.compare(null, 1) ‚Üí NullPointerException
         * 
         * SOLUTIONS:
         * 1. nullsFirst()
         * 2. nullsLast()
         * 3. Manual null checks
         */
    }
    
    /**
     * nullsFirst and nullsLast
     */
    public static void nullsFirstLast() {
        List<Task> tasks = Arrays.asList(
            new Task("Fix bug", 1, "Alice"),
            new Task("Write docs", null, "Bob"),
            new Task("Review code", 2, null),
            new Task("Deploy", null, null)
        );
        
        // Nulls first
        tasks.sort(Comparator.comparing(
            (Task t) -> t.priority,
            Comparator.nullsFirst(Comparator.naturalOrder())
        ));
        
        System.out.println("Nulls first:");
        tasks.forEach(System.out::println);
        
        // Nulls last
        tasks.sort(Comparator.comparing(
            (Task t) -> t.priority,
            Comparator.nullsLast(Comparator.naturalOrder())
        ));
        
        System.out.println("\nNulls last:");
        tasks.forEach(System.out::println);
        
        /**
         * OUTPUT:
         * Nulls first:
         * Write docs      priority:null  assignee:Bob
         * Deploy          priority:null  assignee:null
         * Fix bug         priority:1     assignee:Alice
         * Review code     priority:2     assignee:null
         * 
         * Nulls last:
         * Fix bug         priority:1     assignee:Alice
         * Review code     priority:2     assignee:null
         * Write docs      priority:null  assignee:Bob
         * Deploy          priority:null  assignee:null
         */
    }
    
    /**
     * Chaining with nulls
     */
    public static void chainingWithNulls() {
        List<Task> tasks = Arrays.asList(
            new Task("Fix bug", 1, "Alice"),
            new Task("Write docs", null, "Bob"),
            new Task("Review code", 2, null),
            new Task("Deploy", 1, null),
            new Task("Test", null, "Alice")
        );
        
        // Sort by: priority (nulls last) ‚Üí assignee (nulls last)
        tasks.sort(
            Comparator.comparing(
                (Task t) -> t.priority,
                Comparator.nullsLast(Comparator.naturalOrder())
            )
            .thenComparing(
                t -> t.assignee,
                Comparator.nullsLast(Comparator.naturalOrder())
            )
        );
        
        System.out.println("Priority (nulls last), then assignee (nulls last):");
        tasks.forEach(System.out::println);
        
        /**
         * OUTPUT:
         * Priority (nulls last), then assignee (nulls last):
         * Fix bug         priority:1     assignee:Alice
         * Deploy          priority:1     assignee:null
         * Review code     priority:2     assignee:null
         * Test            priority:null  assignee:Alice
         * Write docs      priority:null  assignee:Bob
         * 
         * NULL HANDLING IN EACH LEVEL:
         * Each comparison handles nulls independently
         */
    }
    
    /**
     * Manual null handling
     */
    public static void manualNullHandling() {
        List<Task> tasks = Arrays.asList(
            new Task("Fix bug", 1, "Alice"),
            new Task("Write docs", null, "Bob")
        );
        
        // Custom null handling logic
        tasks.sort((t1, t2) -> {
            // Both null: equal
            if (t1.priority == null && t2.priority == null) return 0;
            
            // One null: null is "higher" priority (comes first)
            if (t1.priority == null) return -1;
            if (t2.priority == null) return 1;
            
            // Neither null: normal comparison
            return Integer.compare(t1.priority, t2.priority);
        });
        
        System.out.println("Custom null handling:");
        tasks.forEach(System.out::println);
        
        /**
         * WHEN TO USE MANUAL:
         * - Complex null semantics
         * - Nulls have special meaning
         * - Multiple null scenarios
         */
    }
    
    /**
     * Objects.compare utility
     */
    public static void objectsCompare() {
        /**
         * OBJECTS.COMPARE:
         * 
         * public static <T> int compare(T a, T b, Comparator<? super T> c) {
         *     return (a == b) ? 0 : c.compare(a, b);
         * }
         * 
         * Handles case where both are same object
         * Useful for custom compareTo implementations
         */
        
        List<Task> tasks = Arrays.asList(
            new Task("A", 1, "Alice"),
            new Task("B", 1, "Bob")
        );
        
        tasks.sort((t1, t2) -> 
            Objects.compare(t1.assignee, t2.assignee, 
                Comparator.nullsLast(Comparator.naturalOrder()))
        );
        
        System.out.println("Using Objects.compare:");
        tasks.forEach(System.out::println);
    }
    
    /**
     * Best practices
     */
    public static void bestPractices() {
        /**
         * NULL HANDLING BEST PRACTICES:
         * 
         * 1. DECIDE NULL SEMANTICS UPFRONT:
         *    - Should nulls sort first or last?
         *    - Are nulls valid data or errors?
         * 
         * 2. USE nullsFirst/nullsLast:
         *    - Clear intent
         *    - Handles all cases
         *    - Composable
         * 
         * 3. DOCUMENT NULL BEHAVIOR:
         *    // Sorts by priority (nulls = highest priority)
         *    comparator = Comparator.comparing(..., nullsFirst(...))
         * 
         * 4. CONSIDER USING OPTIONALS:
         *    Optional<Integer> priority;
         *    // No nulls to handle
         * 
         * 5. VALIDATE INPUTS:
         *    if (task.priority == null) {
         *        throw new IllegalArgumentException("Priority required");
         *    }
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Null Problem ===");
        nullProblem();
        
        System.out.println("\n=== nullsFirst/Last ===");
        nullsFirstLast();
        
        System.out.println("\n=== Chaining with Nulls ===");
        chainingWithNulls();
        
        System.out.println("\n=== Manual Null Handling ===");
        manualNullHandling();
    }
}
```

---

## 6. Sorting Stability

### Preserving Relative Order

```java
/**
 * SORTING STABILITY
 * 
 * Stable vs unstable sorting
 */

import java.util.*;

public class SortingStability {
    
    static class Card {
        String suit;  // Hearts, Diamonds, Clubs, Spades
        int rank;     // 1-13
        int originalPosition;
        
        Card(String suit, int rank, int position) {
            this.suit = suit;
            this.rank = rank;
            this.originalPosition = position;
        }
        
        @Override
        public String toString() {
            return String.format("%2d of %-8s (pos %d)", rank, suit, originalPosition);
        }
    }
    
    /**
     * What is stability?
     */
    public static void stabilityDefinition() {
        /**
         * STABLE SORT:
         * 
         * If two elements compare as equal,
         * they maintain their relative order
         * from the original input.
         * 
         * Example:
         * Input:  [3a, 1b, 3c, 2d]
         * Sort by value (stable):   [1b, 2d, 3a, 3c]
         * Sort by value (unstable): [1b, 2d, 3c, 3a]
         *                                      ^^^^^^
         *                                      Order reversed!
         * 
         * JAVA'S GUARANTEES:
         * - Collections.sort(): STABLE (Timsort)
         * - Arrays.sort(objects): STABLE (Timsort)
         * - Arrays.sort(primitives): UNSTABLE (Dual-Pivot Quicksort)
         * - list.sort(): STABLE (delegates to Arrays.sort with objects)
         */
    }
    
    /**
     * Demonstrating stability
     */
    public static void demonstrateStability() {
        List<Card> cards = new ArrayList<>();
        cards.add(new Card("Hearts", 3, 0));
        cards.add(new Card("Diamonds", 1, 1));
        cards.add(new Card("Hearts", 3, 2));
        cards.add(new Card("Clubs", 2, 3));
        cards.add(new Card("Spades", 3, 4));
        
        System.out.println("Original:");
        cards.forEach(System.out::println);
        
        // Sort by rank only (stable)
        cards.sort(Comparator.comparingInt(c -> c.rank));
        
        System.out.println("\nAfter sorting by rank (stable):");
        cards.forEach(System.out::println);
        
        /**
         * OUTPUT:
         * Original:
         *  3 of Hearts   (pos 0)
         *  1 of Diamonds (pos 1)
         *  3 of Hearts   (pos 2)
         *  2 of Clubs    (pos 3)
         *  3 of Spades   (pos 4)
         * 
         * After sorting by rank (stable):
         *  1 of Diamonds (pos 1)
         *  2 of Clubs    (pos 3)
         *  3 of Hearts   (pos 0)  ‚Üê Original order preserved
         *  3 of Hearts   (pos 2)  ‚Üê for equal ranks
         *  3 of Spades   (pos 4)  ‚Üê 
         * 
         * STABLE SORT:
         * Cards with rank=3 maintain relative order (0, 2, 4)
         */
    }
    
    /**
     * Multi-level sorting with stability
     */
    public static void multiLevelSorting() {
        List<Card> cards = new ArrayList<>();
        cards.add(new Card("Hearts", 3, 0));
        cards.add(new Card("Diamonds", 1, 1));
        cards.add(new Card("Hearts", 1, 2));
        cards.add(new Card("Clubs", 2, 3));
        
        System.out.println("Original:");
        cards.forEach(System.out::println);
        
        // METHOD 1: Chained comparator
        List<Card> cards1 = new ArrayList<>(cards);
        cards1.sort(
            Comparator.comparing((Card c) -> c.suit)
                      .thenComparingInt(c -> c.rank)
        );
        
        System.out.println("\nMethod 1 - Chained comparator:");
        cards1.forEach(System.out::println);
        
        // METHOD 2: Multiple stable sorts (reverse order)
        List<Card> cards2 = new ArrayList<>(cards);
        cards2.sort(Comparator.comparingInt(c -> c.rank));  // Secondary
        cards2.sort(Comparator.comparing(c -> c.suit));     // Primary
        
        System.out.println("\nMethod 2 - Multiple stable sorts:");
        cards2.forEach(System.out::println);
        
        /**
         * OUTPUT:
         * Both methods produce same result:
         *  2 of Clubs    (pos 3)
         *  1 of Diamonds (pos 1)
         *  1 of Hearts   (pos 2)
         *  3 of Hearts   (pos 0)
         * 
         * METHOD 2 WORKS BECAUSE:
         * 1. Sort by rank: [1‚ô¶, 1‚ô•, 2‚ô£, 3‚ô•]
         * 2. Sort by suit (stable): [2‚ô£, 1‚ô¶, 1‚ô•, 3‚ô•]
         *    Rank order preserved within each suit!
         * 
         * RECOMMENDATION:
         * Use Method 1 (chained) - clearer intent
         */
    }
    
    /**
     * Why stability matters
     */
    public static void whyStabilityMatters() {
        /**
         * USE CASES WHERE STABILITY CRITICAL:
         * 
         * 1. MULTI-LEVEL SORTING:
         *    Sort by secondary key, then primary key
         *    Stability preserves secondary ordering
         * 
         * 2. USER EXPECTATIONS:
         *    Users expect items to stay in order
         *    when re-sorting by same criteria
         * 
         * 3. MAINTAINING CONTEXT:
         *    Original order may have meaning
         *    (insertion time, priority, etc.)
         * 
         * 4. ALGORITHMS:
         *    Some algorithms rely on stability
         *    (e.g., radix sort)
         * 
         * EXAMPLE: Email inbox
         * - Originally sorted by time (newest first)
         * - User sorts by sender
         * - Stability preserves time order within each sender
         */
    }
    
    /**
     * Real-world example: Transaction sorting
     */
    static class Transaction {
        String account;
        String type;  // DEBIT or CREDIT
        double amount;
        long timestamp;
        
        Transaction(String account, String type, double amount, long timestamp) {
            this.account = account;
            this.type = type;
            this.amount = amount;
            this.timestamp = timestamp;
        }
        
        @Override
        public String toString() {
            return String.format("%-10s %-6s $%-7.2f time:%d", 
                account, type, amount, timestamp);
        }
    }
    
    public static void transactionSorting() {
        List<Transaction> txns = Arrays.asList(
            new Transaction("Alice", "DEBIT", 50.0, 1000),
            new Transaction("Bob", "CREDIT", 100.0, 1001),
            new Transaction("Alice", "CREDIT", 75.0, 1002),
            new Transaction("Bob", "DEBIT", 25.0, 1003),
            new Transaction("Alice", "DEBIT", 30.0, 1004)
        );
        
        System.out.println("Original (by timestamp):");
        txns.forEach(System.out::println);
        
        // Sort by account, type (stable - preserves timestamp order)
        txns.sort(
            Comparator.comparing((Transaction t) -> t.account)
                      .thenComparing(t -> t.type)
        );
        
        System.out.println("\nBy account, then type (timestamp order preserved):");
        txns.forEach(System.out::println);
        
        /**
         * OUTPUT:
         * Original (by timestamp):
         * Alice      DEBIT  $50.00  time:1000
         * Bob        CREDIT $100.00 time:1001
         * Alice      CREDIT $75.00  time:1002
         * Bob        DEBIT  $25.00  time:1003
         * Alice      DEBIT  $30.00  time:1004
         * 
         * By account, then type (timestamp order preserved):
         * Alice      CREDIT $75.00  time:1002  ‚Üê Only CREDIT
         * Alice      DEBIT  $50.00  time:1000  ‚Üê Chronological
         * Alice      DEBIT  $30.00  time:1004  ‚Üê within DEBIT
         * Bob        CREDIT $100.00 time:1001
         * Bob        DEBIT  $25.00  time:1003
         * 
         * STABILITY BENEFIT:
         * Within each account+type group,
         * transactions remain in chronological order
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Demonstrate Stability ===");
        demonstrateStability();
        
        System.out.println("\n=== Multi-Level Sorting ===");
        multiLevelSorting();
        
        System.out.println("\n=== Transaction Sorting ===");
        transactionSorting();
    }
}
```

---

## 7. Performance Considerations

### Efficiency and Optimization

```java
/**
 * PERFORMANCE CONSIDERATIONS
 * 
 * Optimizing comparisons and sorting
 */

import java.util.*;

public class PerformanceConsiderations {
    
    /**
     * Sorting complexity
     */
    public static void sortingComplexity() {
        /**
         * JAVA SORTING ALGORITHMS:
         * 
         * Collections.sort() / list.sort():
         * - Algorithm: Timsort (modified mergesort)
         * - Time: O(n log n) worst case
         * - Space: O(n) temporary array
         * - Stable: Yes
         * - Best case: O(n) for nearly sorted
         * 
         * Arrays.sort(Object[]):
         * - Algorithm: Timsort
         * - Same as above
         * 
         * Arrays.sort(primitive[]):
         * - Algorithm: Dual-Pivot Quicksort
         * - Time: O(n log n) average, O(n¬≤) worst
         * - Space: O(log n) stack
         * - Stable: NO
         * - Faster than object sort (no object overhead)
         * 
         * TreeSet/TreeMap insertion:
         * - Algorithm: Red-Black tree
         * - Time: O(log n) per insertion
         * - Total: O(n log n) for n insertions
         * - Space: O(n)
         * 
         * PriorityQueue:
         * - Algorithm: Binary heap
         * - Time: O(log n) per insertion/removal
         * - Space: O(n)
         */
    }
    
    /**
     * Comparator performance
     */
    public static void comparatorPerformance() {
        int n = 100_000;
        List<Integer> numbers = new ArrayList<>(n);
        Random random = new Random(42);
        for (int i = 0; i < n; i++) {
            numbers.add(random.nextInt());
        }
        
        // Natural order
        List<Integer> copy1 = new ArrayList<>(numbers);
        long start = System.nanoTime();
        copy1.sort(Comparator.naturalOrder());
        long naturalTime = System.nanoTime() - start;
        
        // Lambda comparator
        List<Integer> copy2 = new ArrayList<>(numbers);
        start = System.nanoTime();
        copy2.sort((a, b) -> Integer.compare(a, b));
        long lambdaTime = System.nanoTime() - start;
        
        // Method reference
        List<Integer> copy3 = new ArrayList<>(numbers);
        start = System.nanoTime();
        copy3.sort(Integer::compareTo);
        long methodRefTime = System.nanoTime() - start;
        
        System.out.println("Sorting " + n + " integers:");
        System.out.println("naturalOrder(): " + naturalTime / 1_000_000 + "ms");
        System.out.println("Lambda: " + lambdaTime / 1_000_000 + "ms");
        System.out.println("Method ref: " + methodRefTime / 1_000_000 + "ms");
        
        /**
         * OUTPUT (typical):
         * Sorting 100000 integers:
         * naturalOrder(): 45ms
         * Lambda: 48ms
         * Method ref: 46ms
         * 
         * DIFFERENCES MINIMAL:
         * JIT compiler optimizes all to similar code
         * Choose for readability, not performance
         */
    }
    
    /**
     * Expensive comparisons
     */
    static class ExpensiveObject {
        String data;
        
        ExpensiveObject(String data) {
            this.data = data;
        }
        
        // Expensive computation
        public int computeScore() {
            int score = 0;
            for (int i = 0; i < data.length(); i++) {
                score += data.charAt(i);
            }
            return score;
        }
    }
    
    public static void expensiveComparisons() {
        int n = 10_000;
        List<ExpensiveObject> objects = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            objects.add(new ExpensiveObject("data" + i));
        }
        
        // BAD: Compute score multiple times per object
        List<ExpensiveObject> copy1 = new ArrayList<>(objects);
        long start = System.nanoTime();
        copy1.sort(Comparator.comparingInt(ExpensiveObject::computeScore));
        long badTime = System.nanoTime() - start;
        
        // GOOD: Precompute scores (Schwartzian transform)
        List<ExpensiveObject> copy2 = new ArrayList<>(objects);
        start = System.nanoTime();
        
        // Create pairs of (object, score)
        List<Map.Entry<ExpensiveObject, Integer>> pairs = new ArrayList<>();
        for (ExpensiveObject obj : copy2) {
            pairs.add(Map.entry(obj, obj.computeScore()));
        }
        
        // Sort pairs by score
        pairs.sort(Comparator.comparingInt(Map.Entry::getValue));
        
        // Extract objects
        List<ExpensiveObject> sorted = new ArrayList<>();
        for (Map.Entry<ExpensiveObject, Integer> pair : pairs) {
            sorted.add(pair.getKey());
        }
        
        long goodTime = System.nanoTime() - start;
        
        System.out.println("Expensive comparisons (" + n + " objects):");
        System.out.println("Direct comparison: " + badTime / 1_000_000 + "ms");
        System.out.println("Precomputed: " + goodTime / 1_000_000 + "ms");
        System.out.println("Speedup: " + (double) badTime / goodTime + "x");
        
        /**
         * OUTPUT (typical):
         * Expensive comparisons (10000 objects):
         * Direct comparison: 350ms
         * Precomputed: 25ms
         * Speedup: 14x
         * 
         * EXPLANATION:
         * Sorting compares each element ~log(n) times
         * computeScore() called ~n*log(n) times = ~130K times
         * Precomputing: n calls = 10K times
         * 
         * RULE:
         * If comparison is expensive, precompute keys!
         */
    }
    
    /**
     * Primitive vs boxed comparisons
     */
    public static void primitiveVsBoxed() {
        int n = 100_000;
        
        // Boxed (Integer)
        List<Integer> boxed = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            boxed.add(i);
        }
        Collections.shuffle(boxed);
        
        long start = System.nanoTime();
        boxed.sort(Comparator.naturalOrder());
        long boxedTime = System.nanoTime() - start;
        
        // Primitive (int[])
        int[] primitive = new int[n];
        for (int i = 0; i < n; i++) {
            primitive[i] = i;
        }
        // Shuffle
        for (int i = n - 1; i > 0; i--) {
            int j = (int) (Math.random() * (i + 1));
            int temp = primitive[i];
            primitive[i] = primitive[j];
            primitive[j] = temp;
        }
        
        start = System.nanoTime();
        Arrays.sort(primitive);
        long primitiveTime = System.nanoTime() - start;
        
        System.out.println("Sorting " + n + " numbers:");
        System.out.println("Boxed (List<Integer>): " + boxedTime / 1_000_000 + "ms");
        System.out.println("Primitive (int[]): " + primitiveTime / 1_000_000 + "ms");
        System.out.println("Primitive is " + 
            (double) boxedTime / primitiveTime + "x faster");
        
        /**
         * OUTPUT (typical):
         * Sorting 100000 numbers:
         * Boxed (List<Integer>): 45ms
         * Primitive (int[]): 15ms
         * Primitive is 3x faster
         * 
         * PRIMITIVE ADVANTAGES:
         * - No boxing/unboxing
         * - Better cache locality
         * - Less memory
         * - Faster algorithm (Dual-Pivot Quicksort)
         * 
         * USE PRIMITIVES WHEN:
         * - Large arrays
         * - Performance critical
         * - Simple data types
         */
    }
    
    /**
     * Best practices
     */
    public static void bestPractices() {
        /**
         * PERFORMANCE BEST PRACTICES:
         * 
         * 1. CHOOSE RIGHT DATA STRUCTURE:
         *    - Need sorted? TreeSet/TreeMap
         *    - One-time sort? Collections.sort()
         *    - Priority queue? PriorityQueue
         * 
         * 2. PRECOMPUTE EXPENSIVE KEYS:
         *    If comparison involves computation,
         *    compute once, store, then sort
         * 
         * 3. USE PRIMITIVE ARRAYS:
         *    For large amounts of primitive data
         *    Arrays.sort(int[]) faster than List<Integer>
         * 
         * 4. USE SPECIALIZED COMPARATORS:
         *    comparingInt/Long/Double for primitives
         *    Avoids boxing
         * 
         * 5. AVOID REPEATED SORTS:
         *    Sort once, keep sorted
         *    Or use TreeSet/TreeMap for auto-sorting
         * 
         * 6. CACHE COMPARATORS:
         *    static final Comparator<T> BY_NAME = 
         *        Comparator.comparing(T::getName);
         *    Reuse, don't recreate
         * 
         * 7. PROFILE BEFORE OPTIMIZING:
         *    Measure actual performance
         *    Optimize bottlenecks only
         * 
         * 8. CONSIDER PARALLEL SORT:
         *    Arrays.parallelSort() for large arrays
         *    (Uses ForkJoinPool)
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Comparator Performance ===");
        comparatorPerformance();
        
        System.out.println("\n=== Expensive Comparisons ===");
        expensiveComparisons();
        
        System.out.println("\n=== Primitive vs Boxed ===");
        primitiveVsBoxed();
    }
}
```

---

## Summary

### Quick Reference

**Comparable (Natural Ordering):**

```java
class Person implements Comparable<Person> {
    String name;
    int age;
    
    @Override
    public int compareTo(Person other) {
        return this.name.compareTo(other.name);
    }
}

// Automatic sorting
Collections.sort(people);  // Uses compareTo
TreeSet<Person> set = new TreeSet<>(people);
```

**Comparator (Custom Ordering):**

```java
// Lambda
people.sort((p1, p2) -> Integer.compare(p1.age, p2.age));

// Method reference
people.sort(Comparator.comparing(Person::getName));

// Chaining
people.sort(
    Comparator.comparing(Person::getDept)
              .thenComparingInt(Person::getSalary)
              .thenComparing(Person::getName)
);

// Reversed
people.sort(Comparator.comparing(Person::getAge).reversed());

// Nulls
people.sort(Comparator.comparing(
    Person::getName,
    Comparator.nullsLast(Comparator.naturalOrder())
));
```

### Comparison Table

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Feature          ‚îÇ Comparable ‚îÇ Comparator     ‚îÇ Notes       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Orderings        ‚îÇ One        ‚îÇ Multiple       ‚îÇ             ‚îÇ
‚îÇ Class control    ‚îÇ Need       ‚îÇ Don't need     ‚îÇ             ‚îÇ
‚îÇ Method           ‚îÇ compareTo()‚îÇ compare()      ‚îÇ             ‚îÇ
‚îÇ Location         ‚îÇ In class   ‚îÇ Separate       ‚îÇ             ‚îÇ
‚îÇ Used by          ‚îÇ TreeSet    ‚îÇ sort(), TreeSet‚îÇ             ‚îÇ
‚îÇ Flexibility      ‚îÇ Low        ‚îÇ High           ‚îÇ             ‚îÇ
‚îÇ Chaining         ‚îÇ No         ‚îÇ Yes            ‚îÇ             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Key Takeaways

**1. When to use Comparable:**

```
‚úì One obvious natural ordering
‚úì Control class source code
‚úì Want automatic TreeSet/TreeMap sorting
Example: String, Integer, Date
```

**2. When to use Comparator:**

```
‚úì Multiple orderings
‚úì Don't control class
‚úì Context-specific sorting
‚úì Override natural order
Example: Sort Person by name OR age OR dept
```

**3. Implementation rules:**

```java
// ‚úÖ CORRECT compareTo
return Integer.compare(this.value, other.value);
return Double.compare(this.value, other.value);
return this.name.compareTo(other.name);

// ‚ùå WRONG compareTo
return this.value - other.value;  // Overflow risk!
```

**4. Modern patterns:**

```java
// Comparing with method reference
Comparator.comparing(Person::getName)

// Primitive specializations (faster)
Comparator.comparingInt(Person::getAge)
Comparator.comparingDouble(Person::getSalary)

// Chaining
Comparator.comparing(Person::getDept)
          .thenComparingInt(Person::getAge)
          .thenComparing(Person::getName)

// Null safety
Comparator.comparing(Person::getManager,
    Comparator.nullsLast(Comparator.naturalOrder()))
```

**5. Performance tips:**

```
- Use comparingInt/Long/Double (no boxing)
- Precompute expensive keys
- Use primitive arrays for large data
- Cache comparator instances
- Profile before optimizing
```

---
