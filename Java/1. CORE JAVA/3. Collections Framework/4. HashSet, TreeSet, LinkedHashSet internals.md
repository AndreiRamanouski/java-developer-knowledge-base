# HashSet, TreeSet, and LinkedHashSet Internals

## Overview

Java's Set implementations are built on top of their corresponding Map implementations, leveraging the Map's key uniqueness to ensure Set uniqueness. Understanding this relationship and the trade-offs between HashSet, TreeSet, and LinkedHashSet is crucial for choosing the right collection.

---

## 1. HashSet Backed by HashMap

### The Hidden Map Inside

```java
/**
 * HASHSET INTERNALS
 * 
 * HashSet is a thin wrapper around HashMap
 */

import java.util.*;

public class HashSetInternals {
    
    /**
     * Actual HashSet implementation
     */
    public static void actualImplementation() {
        /**
         * HASHSET SOURCE CODE:
         * 
         * public class HashSet<E> implements Set<E> {
         *     private transient HashMap<E, Object> map;
         *     private static final Object PRESENT = new Object();
         *     
         *     public HashSet() {
         *         map = new HashMap<>();
         *     }
         *     
         *     public boolean add(E e) {
         *         return map.put(e, PRESENT) == null;
         *     }
         *     
         *     public boolean remove(Object o) {
         *         return map.remove(o) == PRESENT;
         *     }
         *     
         *     public boolean contains(Object o) {
         *         return map.containsKey(o);
         *     }
         *     
         *     public int size() {
         *         return map.size();
         *     }
         * }
         * 
         * KEY INSIGHTS:
         * - HashSet is literally a HashMap!
         * - Elements are stored as keys
         * - All values are the same dummy object (PRESENT)
         * - No additional storage or logic
         * - Same performance as HashMap
         * 
         * VISUALIZATION:
         * 
         * HashSet containing ["apple", "banana", "cherry"]:
         * 
         * HashMap<String, Object>:
         * ┌────────┬─────────┐
         * │ Key    │ Value   │
         * ├────────┼─────────┤
         * │ apple  │ PRESENT │
         * │ banana │ PRESENT │
         * │ cherry │ PRESENT │
         * └────────┴─────────┘
         * 
         * Values are ignored, only keys matter!
         */
    }
    
    /**
     * Performance characteristics
     */
    public static void performanceCharacteristics() {
        /**
         * COMPLEXITY (same as HashMap):
         * 
         * ┌─────────────────┬──────────┬────────────┐
         * │ Operation       │ Average  │ Worst Case │
         * ├─────────────────┼──────────┼────────────┤
         * │ add(element)    │ O(1)     │ O(log n)*  │
         * │ remove(element) │ O(1)     │ O(log n)*  │
         * │ contains(e)     │ O(1)     │ O(log n)*  │
         * │ size()          │ O(1)     │ O(1)       │
         * │ iterator.next() │ O(1)     │ O(1)       │
         * └─────────────────┴──────────┴────────────┘
         * 
         * * Java 8+ with treeification at 8 collisions
         * 
         * SPACE: O(n) with same overhead as HashMap
         * 
         * ITERATION ORDER: Unpredictable
         * - Depends on hash codes
         * - May change after resizing
         * - Never sorted
         */
    }
    
    /**
     * Basic operations
     */
    public static void basicOperations() {
        Set<String> set = new HashSet<>();
        
        // Add elements
        set.add("apple");
        set.add("banana");
        set.add("cherry");
        set.add("apple");  // Duplicate - ignored
        
        System.out.println("Set: " + set);
        System.out.println("Size: " + set.size());
        
        // Check membership
        System.out.println("Contains 'apple': " + set.contains("apple"));
        System.out.println("Contains 'grape': " + set.contains("grape"));
        
        // Remove
        set.remove("banana");
        System.out.println("After remove: " + set);
        
        // Iteration (unpredictable order)
        System.out.println("Iteration order:");
        for (String item : set) {
            System.out.println("  " + item);
        }
        
        /**
         * OUTPUT:
         * Set: [banana, apple, cherry]
         * Size: 3
         * Contains 'apple': true
         * Contains 'grape': false
         * After remove: [apple, cherry]
         * Iteration order:
         *   apple
         *   cherry
         * 
         * NOTE: Order is unpredictable and may differ
         */
    }
    
    /**
     * Why HashMap backing works
     */
    public static void whyHashMapBacking() {
        /**
         * WHY USE HASHMAP FOR HASHSET?
         * 
         * HashMap already enforces key uniqueness:
         * - put(key, value) replaces if key exists
         * - Perfect for Set's no-duplicates requirement
         * 
         * HashMap already provides O(1) operations:
         * - containsKey() for contains()
         * - put() for add()
         * - remove() for remove()
         * 
         * No need to reimplement:
         * - Hash function
         * - Collision handling
         * - Resizing logic
         * - Treeification
         * 
         * CODE REUSE:
         * - HashSet is ~100 lines
         * - HashMap is ~2000 lines
         * - Reusing HashMap saves massive effort
         * 
         * MEMORY COST:
         * - Extra Object per element (PRESENT value)
         * - ~8 bytes per element wasted
         * - Worth it for code simplicity
         */
    }
    
    /**
     * Memory overhead analysis
     */
    public static void memoryOverhead() {
        /**
         * MEMORY BREAKDOWN (1000 elements):
         * 
         * HashSet object: ~16 bytes
         * └─ HashMap reference: 8 bytes
         * 
         * HashMap: ~8,040 bytes
         * ├─ HashMap object: 48 bytes
         * ├─ Array (capacity 2048): 16,400 bytes
         * └─ 1000 Nodes: 40,000 bytes
         * 
         * Dummy PRESENT object: 16 bytes (shared!)
         * 
         * 1000 String elements: ~48,000 bytes
         * (assuming average 20 chars each)
         * 
         * TOTAL: ~72,000 bytes
         * 
         * Per element overhead: ~24 bytes
         * (HashSet doesn't add much over HashMap)
         */
    }
    
    /**
     * Common pitfalls
     */
    public static void commonPitfalls() {
        /**
         * PITFALL 1: Mutable objects
         */
        Set<MutablePoint> set = new HashSet<>();
        MutablePoint p = new MutablePoint(1, 2);
        
        set.add(p);
        System.out.println("Contains p: " + set.contains(p));  // true
        
        p.x = 10;  // Modify after adding!
        System.out.println("Contains p after modification: " + 
            set.contains(p));  // false!
        System.out.println("Size: " + set.size());  // 1 (lost!)
        
        /**
         * PROBLEM:
         * - hashCode() changed after insertion
         * - Element now in wrong bucket
         * - Can't find or remove it
         * - Memory leak!
         * 
         * SOLUTION: Use immutable objects
         */
        
        /**
         * PITFALL 2: No equals/hashCode
         */
        Set<Person> people = new HashSet<>();
        Person p1 = new Person("Alice", 30);
        Person p2 = new Person("Alice", 30);
        
        people.add(p1);
        people.add(p2);
        
        System.out.println("\nPeople size: " + people.size());  // 2 (should be 1!)
        
        /**
         * PROBLEM:
         * - Person didn't override equals/hashCode
         * - Uses identity comparison
         * - Duplicates allowed!
         * 
         * SOLUTION: Always override equals/hashCode
         */
    }
    
    static class MutablePoint {
        int x, y;
        
        MutablePoint(int x, int y) {
            this.x = x;
            this.y = y;
        }
        
        @Override
        public int hashCode() {
            return Objects.hash(x, y);
        }
        
        @Override
        public boolean equals(Object obj) {
            if (!(obj instanceof MutablePoint)) return false;
            MutablePoint p = (MutablePoint) obj;
            return x == p.x && y == p.y;
        }
    }
    
    static class Person {
        String name;
        int age;
        
        Person(String name, int age) {
            this.name = name;
            this.age = age;
        }
        // Missing equals/hashCode!
    }
    
    public static void main(String[] args) {
        System.out.println("=== Basic Operations ===");
        basicOperations();
        
        System.out.println("\n=== Common Pitfalls ===");
        commonPitfalls();
    }
}
```

---

## 2. TreeSet Backed by TreeMap

### Sorted Set with Red-Black Tree

```java
/**
 * TREESET INTERNALS
 * 
 * TreeSet is a wrapper around TreeMap (NavigableMap)
 */

import java.util.*;

public class TreeSetInternals {
    
    /**
     * Actual TreeSet implementation
     */
    public static void actualImplementation() {
        /**
         * TREESET SOURCE CODE:
         * 
         * public class TreeSet<E> extends AbstractSet<E>
         *         implements NavigableSet<E> {
         *     
         *     private transient NavigableMap<E, Object> m;
         *     private static final Object PRESENT = new Object();
         *     
         *     public TreeSet() {
         *         this(new TreeMap<>());
         *     }
         *     
         *     TreeSet(NavigableMap<E, Object> m) {
         *         this.m = m;
         *     }
         *     
         *     public boolean add(E e) {
         *         return m.put(e, PRESENT) == null;
         *     }
         *     
         *     public boolean remove(Object o) {
         *         return m.remove(o) == PRESENT;
         *     }
         *     
         *     public boolean contains(Object o) {
         *         return m.containsKey(o);
         *     }
         *     
         *     public E first() {
         *         return m.firstKey();
         *     }
         *     
         *     public E last() {
         *         return m.lastKey();
         *     }
         * }
         * 
         * KEY INSIGHTS:
         * - TreeSet is a TreeMap!
         * - Elements stored as keys (sorted)
         * - Values all PRESENT (dummy)
         * - Inherits NavigableSet operations
         * - Same performance as TreeMap
         * 
         * VISUALIZATION:
         * 
         * TreeSet containing [5, 2, 8, 1, 9]:
         * 
         * TreeMap (Red-Black Tree):
         *           5
         *          / \
         *         2   8
         *        /     \
         *       1       9
         * 
         * All values = PRESENT (not shown)
         */
    }
    
    /**
     * Performance characteristics
     */
    public static void performanceCharacteristics() {
        /**
         * COMPLEXITY (same as TreeMap):
         * 
         * ┌─────────────────┬──────────┐
         * │ Operation       │ Time     │
         * ├─────────────────┼──────────┤
         * │ add(element)    │ O(log n) │
         * │ remove(element) │ O(log n) │
         * │ contains(e)     │ O(log n) │
         * │ first()         │ O(log n) │
         * │ last()          │ O(log n) │
         * │ floor(e)        │ O(log n) │
         * │ ceiling(e)      │ O(log n) │
         * │ size()          │ O(1)     │
         * │ iterator.next() │ O(1)     │
         * └─────────────────┴──────────┘
         * 
         * SPACE: O(n)
         * 
         * ITERATION ORDER: Sorted (natural or comparator)
         */
    }
    
    /**
     * Basic operations
     */
    public static void basicOperations() {
        Set<Integer> set = new TreeSet<>();
        
        // Add elements (any order)
        set.add(5);
        set.add(2);
        set.add(8);
        set.add(1);
        set.add(9);
        set.add(5);  // Duplicate - ignored
        
        System.out.println("Set: " + set);
        System.out.println("Size: " + set.size());
        
        // Iteration (sorted order)
        System.out.println("Sorted iteration:");
        for (Integer num : set) {
            System.out.println("  " + num);
        }
        
        /**
         * OUTPUT:
         * Set: [1, 2, 5, 8, 9]
         * Size: 5
         * Sorted iteration:
         *   1
         *   2
         *   5
         *   8
         *   9
         * 
         * AUTOMATIC SORTING!
         * Elements always in sorted order
         */
    }
    
    /**
     * NavigableSet operations
     */
    public static void navigableSetOperations() {
        NavigableSet<Integer> set = new TreeSet<>();
        set.addAll(Arrays.asList(1, 3, 5, 7, 9, 11, 13));
        
        System.out.println("Set: " + set);
        
        // First and last
        System.out.println("first(): " + set.first());
        System.out.println("last(): " + set.last());
        
        // Floor and ceiling (≤ and ≥)
        System.out.println("floor(6): " + set.floor(6));      // ≤ 6
        System.out.println("ceiling(6): " + set.ceiling(6));  // ≥ 6
        
        // Lower and higher (< and >)
        System.out.println("lower(7): " + set.lower(7));      // < 7
        System.out.println("higher(7): " + set.higher(7));    // > 7
        
        // Polling (remove and return)
        System.out.println("pollFirst(): " + set.pollFirst());
        System.out.println("pollLast(): " + set.pollLast());
        System.out.println("After polling: " + set);
        
        // Subset operations
        System.out.println("headSet(7): " + set.headSet(7));     // < 7
        System.out.println("tailSet(7): " + set.tailSet(7));     // ≥ 7
        System.out.println("subSet(5, 11): " + set.subSet(5, 11));  // [5, 11)
        
        // Descending
        System.out.println("descendingSet(): " + set.descendingSet());
        
        /**
         * OUTPUT:
         * Set: [1, 3, 5, 7, 9, 11, 13]
         * first(): 1
         * last(): 13
         * floor(6): 5
         * ceiling(6): 7
         * lower(7): 5
         * higher(7): 9
         * pollFirst(): 1
         * pollLast(): 13
         * After polling: [3, 5, 7, 9, 11]
         * headSet(7): [3, 5]
         * tailSet(7): [7, 9, 11]
         * subSet(5, 11): [5, 7, 9]
         * descendingSet(): [11, 9, 7, 5, 3]
         * 
         * POWERFUL RANGE OPERATIONS!
         * Perfect for sorted data queries
         */
    }
    
    /**
     * Custom comparator
     */
    public static void customComparator() {
        // Reverse order
        Set<String> reverseSet = new TreeSet<>(Collections.reverseOrder());
        reverseSet.addAll(Arrays.asList("apple", "banana", "cherry"));
        
        System.out.println("Reverse order: " + reverseSet);
        
        // Custom comparator (by length)
        Set<String> lengthSet = new TreeSet<>(
            Comparator.comparingInt(String::length)
                      .thenComparing(String::compareTo)
        );
        lengthSet.addAll(Arrays.asList("a", "bb", "ccc", "dd", "e"));
        
        System.out.println("By length: " + lengthSet);
        
        /**
         * OUTPUT:
         * Reverse order: [cherry, banana, apple]
         * By length: [a, e, bb, dd, ccc]
         * 
         * FLEXIBLE SORTING:
         * - Natural order (Comparable)
         * - Reverse order
         * - Custom logic
         * - Compound comparisons
         */
    }
    
    /**
     * Performance comparison with HashSet
     */
    public static void performanceComparison() {
        int size = 100_000;
        
        // HashSet
        Set<Integer> hashSet = new HashSet<>();
        long start = System.nanoTime();
        for (int i = 0; i < size; i++) {
            hashSet.add(i);
        }
        long hashTime = System.nanoTime() - start;
        
        // TreeSet
        Set<Integer> treeSet = new TreeSet<>();
        start = System.nanoTime();
        for (int i = 0; i < size; i++) {
            treeSet.add(i);
        }
        long treeTime = System.nanoTime() - start;
        
        System.out.println("Add " + size + " elements:");
        System.out.println("HashSet: " + hashTime / 1_000_000 + "ms");
        System.out.println("TreeSet: " + treeTime / 1_000_000 + "ms");
        System.out.println("HashSet is " + 
            (double) treeTime / hashTime + "x faster");
        
        /**
         * OUTPUT (typical):
         * Add 100000 elements:
         * HashSet: 25ms
         * TreeSet: 85ms
         * HashSet is 3.4x faster
         * 
         * TRADEOFF:
         * HashSet: O(1) but no order
         * TreeSet: O(log n) but sorted
         * 
         * Choose based on needs:
         * - Need speed? HashSet
         * - Need sorted? TreeSet
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Basic Operations ===");
        basicOperations();
        
        System.out.println("\n=== NavigableSet Operations ===");
        navigableSetOperations();
        
        System.out.println("\n=== Custom Comparator ===");
        customComparator();
        
        System.out.println("\n=== Performance Comparison ===");
        performanceComparison();
    }
}
```

---

## 3. LinkedHashSet Maintaining Order

### Predictable Iteration Order

```java
/**
 * LINKEDHASHSET INTERNALS
 * 
 * LinkedHashSet is a wrapper around LinkedHashMap
 */

import java.util.*;

public class LinkedHashSetInternals {
    
    /**
     * Actual LinkedHashSet implementation
     */
    public static void actualImplementation() {
        /**
         * LINKEDHASHSET SOURCE CODE:
         * 
         * public class LinkedHashSet<E> extends HashSet<E> {
         *     
         *     public LinkedHashSet() {
         *         super(16, .75f, true);  // dummy param
         *     }
         *     
         *     // HashSet constructor called:
         *     HashSet(int initialCapacity, float loadFactor, boolean dummy) {
         *         map = new LinkedHashMap<>(initialCapacity, loadFactor);
         *     }
         * }
         * 
         * KEY INSIGHTS:
         * - Extends HashSet
         * - Uses LinkedHashMap instead of HashMap
         * - Maintains insertion order
         * - All operations same as HashSet
         * - ~40% slower than HashSet
         * 
         * VISUALIZATION:
         * 
         * LinkedHashSet containing ["apple", "banana", "cherry"]:
         * 
         * LinkedHashMap:
         * HashMap buckets:
         * ┌───┬───┬───┬───┐
         * │ 0 │ 1 │ 2 │ 3 │
         * └───┴───┴───┴───┘
         * 
         * PLUS insertion order:
         * head → "apple" ⇄ "banana" ⇄ "cherry" ← tail
         * 
         * Iteration follows linked list, not buckets
         */
    }
    
    /**
     * Performance characteristics
     */
    public static void performanceCharacteristics() {
        /**
         * COMPLEXITY:
         * 
         * ┌─────────────────┬──────────┬────────────┐
         * │ Operation       │ Average  │ Worst Case │
         * ├─────────────────┼──────────┼────────────┤
         * │ add(element)    │ O(1)     │ O(log n)*  │
         * │ remove(element) │ O(1)     │ O(log n)*  │
         * │ contains(e)     │ O(1)     │ O(log n)*  │
         * │ size()          │ O(1)     │ O(1)       │
         * │ iterator.next() │ O(1)     │ O(1)       │
         * └─────────────────┴──────────┴────────────┘
         * 
         * SPACE: O(n) with extra pointer overhead
         * 
         * ITERATION ORDER: Insertion order (predictable)
         */
    }
    
    /**
     * Insertion order demonstration
     */
    public static void insertionOrder() {
        Set<String> hashSet = new HashSet<>();
        Set<String> linkedHashSet = new LinkedHashSet<>();
        Set<String> treeSet = new TreeSet<>();
        
        String[] words = {"banana", "apple", "cherry", "date"};
        
        for (String word : words) {
            hashSet.add(word);
            linkedHashSet.add(word);
            treeSet.add(word);
        }
        
        System.out.println("HashSet: " + hashSet);
        System.out.println("LinkedHashSet: " + linkedHashSet);
        System.out.println("TreeSet: " + treeSet);
        
        /**
         * OUTPUT:
         * HashSet: [banana, apple, date, cherry]  (unpredictable)
         * LinkedHashSet: [banana, apple, cherry, date]  (insertion order)
         * TreeSet: [apple, banana, cherry, date]  (sorted)
         * 
         * PREDICTABILITY:
         * LinkedHashSet maintains order consistently
         * Useful for testing, debugging, display
         */
    }
    
    /**
     * Performance comparison
     */
    public static void performanceComparison() {
        int size = 100_000;
        
        // HashSet
        Set<Integer> hashSet = new HashSet<>();
        long start = System.nanoTime();
        for (int i = 0; i < size; i++) {
            hashSet.add(i);
        }
        for (Integer num : hashSet) {
            int x = num;
        }
        long hashTime = System.nanoTime() - start;
        
        // LinkedHashSet
        Set<Integer> linkedHashSet = new LinkedHashSet<>();
        start = System.nanoTime();
        for (int i = 0; i < size; i++) {
            linkedHashSet.add(i);
        }
        for (Integer num : linkedHashSet) {
            int x = num;
        }
        long linkedTime = System.nanoTime() - start;
        
        System.out.println("Add and iterate " + size + " elements:");
        System.out.println("HashSet: " + hashTime / 1_000_000 + "ms");
        System.out.println("LinkedHashSet: " + linkedTime / 1_000_000 + "ms");
        System.out.println("Overhead: " + 
            (double) (linkedTime - hashTime) / hashTime * 100 + "%");
        
        /**
         * OUTPUT (typical):
         * Add and iterate 100000 elements:
         * HashSet: 25ms
         * LinkedHashSet: 35ms
         * Overhead: 40%
         * 
         * TRADEOFF:
         * ~40% slower for predictable order
         * Worth it when order matters
         */
    }
    
    /**
     * Use cases
     */
    public static void useCases() {
        /**
         * USE LINKEDHASHSET WHEN:
         * 
         * ✓ Need predictable iteration order
         * ✓ Order matters for display
         * ✓ Deterministic testing
         * ✓ Cache with insertion order
         * 
         * EXAMPLES:
         * 
         * 1. Maintaining user registration order:
         */
        Set<String> registeredUsers = new LinkedHashSet<>();
        registeredUsers.add("alice");
        registeredUsers.add("bob");
        registeredUsers.add("charlie");
        // Iteration always: alice, bob, charlie
        
        /**
         * 2. Preserving command line argument order:
         */
        Set<String> uniqueArgs = new LinkedHashSet<>(
            Arrays.asList(args)
        );
        // Duplicates removed, order preserved
        
        /**
         * 3. UI list with no duplicates:
         */
        Set<String> displayItems = new LinkedHashSet<>();
        // Items displayed in insertion order
        
        /**
         * 4. Deterministic test output:
         */
        Set<String> testResults = new LinkedHashSet<>();
        // Results always in same order
    }
    
    static String[] args = {"--verbose", "--output", "file.txt", "--verbose"};
    
    public static void main(String[] args) {
        System.out.println("=== Insertion Order ===");
        insertionOrder();
        
        System.out.println("\n=== Performance Comparison ===");
        performanceComparison();
    }
}
```

---

## 4. Custom Comparators and Comparable

### Controlling Sort Order

```java
/**
 * COMPARATORS AND COMPARABLE
 * 
 * Defining sort order for TreeSet
 */

import java.util.*;

public class ComparatorsAndComparable {
    
    /**
     * Comparable interface
     */
    static class Person implements Comparable<Person> {
        String name;
        int age;
        
        Person(String name, int age) {
            this.name = name;
            this.age = age;
        }
        
        @Override
        public int compareTo(Person other) {
            // Natural order: by name
            return this.name.compareTo(other.name);
        }
        
        @Override
        public String toString() {
            return name + "(" + age + ")";
        }
    }
    
    public static void comparableExample() {
        Set<Person> people = new TreeSet<>();
        people.add(new Person("Charlie", 35));
        people.add(new Person("Alice", 30));
        people.add(new Person("Bob", 25));
        
        System.out.println("Natural order (by name): " + people);
        
        /**
         * OUTPUT:
         * Natural order (by name): [Alice(30), Bob(25), Charlie(35)]
         * 
         * COMPARABLE:
         * - Defines natural order
         * - One ordering per class
         * - Used by TreeSet by default
         * 
         * COMPARETO CONTRACT:
         * - x.compareTo(y) < 0  means x < y
         * - x.compareTo(y) == 0 means x == y
         * - x.compareTo(y) > 0  means x > y
         * 
         * MUST BE CONSISTENT WITH EQUALS:
         * If x.equals(y), then x.compareTo(y) == 0
         */
    }
    
    /**
     * Comparator for different orderings
     */
    public static void comparatorExample() {
        // By age
        Set<Person> byAge = new TreeSet<>(
            Comparator.comparingInt(p -> p.age)
        );
        byAge.add(new Person("Charlie", 35));
        byAge.add(new Person("Alice", 30));
        byAge.add(new Person("Bob", 25));
        
        System.out.println("By age: " + byAge);
        
        // By age descending
        Set<Person> byAgeDesc = new TreeSet<>(
            Comparator.comparingInt((Person p) -> p.age).reversed()
        );
        byAgeDesc.addAll(byAge);
        
        System.out.println("By age descending: " + byAgeDesc);
        
        // Compound: by age, then name
        Set<Person> compound = new TreeSet<>(
            Comparator.comparingInt((Person p) -> p.age)
                      .thenComparing(p -> p.name)
        );
        compound.add(new Person("Alice", 30));
        compound.add(new Person("Bob", 30));
        compound.add(new Person("Charlie", 25));
        
        System.out.println("By age, then name: " + compound);
        
        /**
         * OUTPUT:
         * By age: [Bob(25), Alice(30), Charlie(35)]
         * By age descending: [Charlie(35), Alice(30), Bob(25)]
         * By age, then name: [Charlie(25), Alice(30), Bob(30)]
         * 
         * COMPARATOR:
         * - External ordering
         * - Multiple orderings possible
         * - Overrides Comparable
         * 
         * JAVA 8+ METHODS:
         * - comparing(Function)
         * - comparingInt/Long/Double(ToIntFunction)
         * - thenComparing(Comparator)
         * - reversed()
         * - nullsFirst/nullsLast(Comparator)
         */
    }
    
    /**
     * Common comparator patterns
     */
    public static void comparatorPatterns() {
        /**
         * PATTERN 1: Natural order
         */
        Comparator<String> natural = Comparator.naturalOrder();
        
        /**
         * PATTERN 2: Reverse natural order
         */
        Comparator<String> reverse = Comparator.reverseOrder();
        
        /**
         * PATTERN 3: By property
         */
        Comparator<Person> byAge = Comparator.comparingInt(p -> p.age);
        
        /**
         * PATTERN 4: Multiple properties
         */
        Comparator<Person> multiProp = 
            Comparator.comparingInt((Person p) -> p.age)
                      .thenComparing(p -> p.name);
        
        /**
         * PATTERN 5: Null handling
         */
        Comparator<Person> nullSafe = 
            Comparator.nullsFirst(
                Comparator.comparing(p -> p.name)
            );
        
        /**
         * PATTERN 6: Case-insensitive
         */
        Comparator<String> caseInsensitive = 
            String.CASE_INSENSITIVE_ORDER;
        
        /**
         * PATTERN 7: Custom logic
         */
        Comparator<String> byLength = (s1, s2) -> {
            int lenCompare = Integer.compare(s1.length(), s2.length());
            if (lenCompare != 0) return lenCompare;
            return s1.compareTo(s2);
        };
    }
    
    /**
     * Pitfall: Inconsistent with equals
     */
    static class BadPerson implements Comparable<BadPerson> {
        String name;
        int age;
        
        BadPerson(String name, int age) {
            this.name = name;
            this.age = age;
        }
        
        @Override
        public int compareTo(BadPerson other) {
            // Only compare age (BAD!)
            return Integer.compare(this.age, other.age);
        }
        
        @Override
        public boolean equals(Object obj) {
            if (!(obj instanceof BadPerson)) return false;
            BadPerson p = (BadPerson) obj;
            // Compare both name and age
            return age == p.age && Objects.equals(name, p.name);
        }
        
        @Override
        public int hashCode() {
            return Objects.hash(name, age);
        }
        
        @Override
        public String toString() {
            return name + "(" + age + ")";
        }
    }
    
    public static void inconsistentComparison() {
        Set<BadPerson> set = new TreeSet<>();
        BadPerson p1 = new BadPerson("Alice", 30);
        BadPerson p2 = new BadPerson("Bob", 30);
        
        set.add(p1);
        set.add(p2);
        
        System.out.println("Set size: " + set.size());
        System.out.println("Set: " + set);
        System.out.println("p1.equals(p2): " + p1.equals(p2));
        System.out.println("p1.compareTo(p2): " + p1.compareTo(p2));
        
        /**
         * OUTPUT:
         * Set size: 1
         * Set: [Alice(30)]
         * p1.equals(p2): false
         * p1.compareTo(p2): 0
         * 
         * PROBLEM:
         * - compareTo says p1 == p2 (age same)
         * - equals says p1 != p2 (names different)
         * - TreeSet uses compareTo
         * - Bob was not added!
         * 
         * RULE:
         * compareTo consistent with equals:
         * (x.compareTo(y) == 0) == x.equals(y)
         * 
         * FIX:
         * Compare all fields used in equals:
         * 
         * public int compareTo(BadPerson other) {
         *     int ageCompare = Integer.compare(this.age, other.age);
         *     if (ageCompare != 0) return ageCompare;
         *     return this.name.compareTo(other.name);
         * }
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Comparable ===");
        comparableExample();
        
        System.out.println("\n=== Comparator ===");
        comparatorExample();
        
        System.out.println("\n=== Inconsistent Comparison ===");
        inconsistentComparison();
    }
}
```

---

## 5. Set Operations Performance

### Union, Intersection, and Difference

```java
/**
 * SET OPERATIONS
 * 
 * Performance of common set operations
 */

import java.util.*;

public class SetOperationsPerformance {
    
    /**
     * Basic set operations
     */
    public static void basicOperations() {
        Set<Integer> set1 = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));
        Set<Integer> set2 = new HashSet<>(Arrays.asList(4, 5, 6, 7, 8));
        
        // Union (all elements)
        Set<Integer> union = new HashSet<>(set1);
        union.addAll(set2);
        System.out.println("Union: " + union);
        
        // Intersection (common elements)
        Set<Integer> intersection = new HashSet<>(set1);
        intersection.retainAll(set2);
        System.out.println("Intersection: " + intersection);
        
        // Difference (set1 - set2)
        Set<Integer> difference = new HashSet<>(set1);
        difference.removeAll(set2);
        System.out.println("Difference: " + difference);
        
        // Symmetric difference (union - intersection)
        Set<Integer> symDiff = new HashSet<>(union);
        symDiff.removeAll(intersection);
        System.out.println("Symmetric difference: " + symDiff);
        
        // Disjoint (no common elements)
        Set<Integer> set3 = new HashSet<>(Arrays.asList(10, 11, 12));
        System.out.println("set1 disjoint from set3: " + 
            Collections.disjoint(set1, set3));
        
        /**
         * OUTPUT:
         * Union: [1, 2, 3, 4, 5, 6, 7, 8]
         * Intersection: [4, 5]
         * Difference: [1, 2, 3]
         * Symmetric difference: [1, 2, 3, 6, 7, 8]
         * set1 disjoint from set3: true
         */
    }
    
    /**
     * Performance analysis
     */
    public static void performanceAnalysis() {
        /**
         * COMPLEXITY ANALYSIS:
         * 
         * Let n = size of set1, m = size of set2
         * 
         * HASHSET:
         * - addAll(set2):      O(m)  - add each element O(1)
         * - retainAll(set2):   O(n)  - check each element in set1
         * - removeAll(set2):   O(m)  - remove each element in set2
         * - containsAll(set2): O(m)  - check each element O(1)
         * 
         * TREESET:
         * - addAll(set2):      O(m log(n+m))  - add each element O(log n)
         * - retainAll(set2):   O(n log m)     - check membership O(log m)
         * - removeAll(set2):   O(m log n)     - remove each O(log n)
         * - containsAll(set2): O(m log n)     - check each O(log n)
         * 
         * LINKEDHASHSET: Same as HashSet
         */
    }
    
    /**
     * Benchmark set operations
     */
    public static void benchmarkOperations() {
        int size = 50_000;
        
        // Create sets
        Set<Integer> hashSet1 = new HashSet<>();
        Set<Integer> hashSet2 = new HashSet<>();
        Set<Integer> treeSet1 = new TreeSet<>();
        Set<Integer> treeSet2 = new TreeSet<>();
        
        Random random = new Random(42);
        for (int i = 0; i < size; i++) {
            int val1 = random.nextInt(size * 2);
            int val2 = random.nextInt(size * 2);
            hashSet1.add(val1);
            hashSet2.add(val2);
            treeSet1.add(val1);
            treeSet2.add(val2);
        }
        
        // Union benchmark
        long start = System.nanoTime();
        Set<Integer> hashUnion = new HashSet<>(hashSet1);
        hashUnion.addAll(hashSet2);
        long hashTime = System.nanoTime() - start;
        
        start = System.nanoTime();
        Set<Integer> treeUnion = new TreeSet<>(treeSet1);
        treeUnion.addAll(treeSet2);
        long treeTime = System.nanoTime() - start;
        
        System.out.println("Union (" + size + " elements each):");
        System.out.println("  HashSet: " + hashTime / 1_000_000 + "ms");
        System.out.println("  TreeSet: " + treeTime / 1_000_000 + "ms");
        System.out.println("  HashSet is " + 
            (double) treeTime / hashTime + "x faster");
        
        // Intersection benchmark
        start = System.nanoTime();
        Set<Integer> hashIntersect = new HashSet<>(hashSet1);
        hashIntersect.retainAll(hashSet2);
        hashTime = System.nanoTime() - start;
        
        start = System.nanoTime();
        Set<Integer> treeIntersect = new TreeSet<>(treeSet1);
        treeIntersect.retainAll(treeSet2);
        treeTime = System.nanoTime() - start;
        
        System.out.println("\nIntersection:");
        System.out.println("  HashSet: " + hashTime / 1_000_000 + "ms");
        System.out.println("  TreeSet: " + treeTime / 1_000_000 + "ms");
        
        /**
         * OUTPUT (typical):
         * Union (50000 elements each):
         *   HashSet: 15ms
         *   TreeSet: 180ms
         *   HashSet is 12x faster
         * 
         * Intersection:
         *   HashSet: 8ms
         *   TreeSet: 85ms
         *   HashSet is 10.6x faster
         * 
         * HASHSET DOMINATES for set operations
         * O(1) lookup makes huge difference
         */
    }
    
    /**
     * Efficient duplicate removal
     */
    public static void duplicateRemoval() {
        List<Integer> listWithDuplicates = Arrays.asList(
            1, 2, 3, 2, 4, 3, 5, 1, 6, 4, 7
        );
        
        System.out.println("Original: " + listWithDuplicates);
        
        // Method 1: HashSet (fast, no order)
        Set<Integer> noDupsHash = new HashSet<>(listWithDuplicates);
        System.out.println("HashSet: " + noDupsHash);
        
        // Method 2: LinkedHashSet (preserves order)
        Set<Integer> noDupsLinked = new LinkedHashSet<>(listWithDuplicates);
        System.out.println("LinkedHashSet: " + noDupsLinked);
        
        // Method 3: TreeSet (sorted)
        Set<Integer> noDupsTree = new TreeSet<>(listWithDuplicates);
        System.out.println("TreeSet: " + noDupsTree);
        
        // Back to list (if needed)
        List<Integer> uniqueList = new ArrayList<>(noDupsLinked);
        System.out.println("Back to List: " + uniqueList);
        
        /**
         * OUTPUT:
         * Original: [1, 2, 3, 2, 4, 3, 5, 1, 6, 4, 7]
         * HashSet: [1, 2, 3, 4, 5, 6, 7]
         * LinkedHashSet: [1, 2, 3, 4, 5, 6, 7]
         * TreeSet: [1, 2, 3, 4, 5, 6, 7]
         * Back to List: [1, 2, 3, 4, 5, 6, 7]
         * 
         * CHOOSE BASED ON NEEDS:
         * - Speed: HashSet
         * - Order: LinkedHashSet
         * - Sorted: TreeSet
         */
    }
    
    /**
     * Performance tips
     */
    public static void performanceTips() {
        /**
         * TIP 1: Use smaller set for iteration
         * 
         * BAD (n*m operations):
         * for (Element e : largeSet) {
         *     if (smallSet.contains(e)) { ... }
         * }
         * 
         * GOOD (m*1 operations):
         * for (Element e : smallSet) {
         *     if (largeSet.contains(e)) { ... }
         * }
         * 
         * 
         * TIP 2: Batch operations
         * 
         * BAD:
         * for (Element e : collection) {
         *     set.remove(e);  // n individual operations
         * }
         * 
         * GOOD:
         * set.removeAll(collection);  // single batch operation
         * 
         * 
         * TIP 3: Right collection type
         * 
         * If doing many containsAll checks:
         * - Convert List to Set first
         * - O(1) lookups instead of O(n)
         * 
         * List<Integer> list = ...;
         * Set<Integer> set = new HashSet<>(list);  // Convert once
         * // Now fast containsAll checks
         * 
         * 
         * TIP 4: Immutable sets for lookups
         * 
         * Set<String> validStates = Set.of("PENDING", "APPROVED", "REJECTED");
         * if (validStates.contains(state)) { ... }
         * 
         * - Compact
         * - Fast
         * - Thread-safe
         */
    }
    
    public static void main(String[] args) {
        System.out.println("=== Basic Operations ===");
        basicOperations();
        
        System.out.println("\n=== Benchmark ===");
        benchmarkOperations();
        
        System.out.println("\n=== Duplicate Removal ===");
        duplicateRemoval();
    }
}
```

---

## 6. Choosing the Right Set Implementation

### Decision Guide and Best Practices

```java
/**
 * CHOOSING THE RIGHT SET
 * 
 * When to use which Set implementation
 */

public class ChoosingTheRightSet {
    
    /**
     * Decision tree
     */
    public static void decisionTree() {
        /**
         * DECISION TREE:
         * 
         * Need sorted elements?
         * ├─ YES → TreeSet
         * └─ NO ↓
         * 
         * Need insertion order preserved?
         * ├─ YES → LinkedHashSet
         * └─ NO ↓
         * 
         * → HashSet (default choice)
         * 
         * 
         * SPECIAL CASES:
         * 
         * Small fixed set?
         * → Set.of() or EnumSet
         * 
         * Enum elements?
         * → EnumSet (always!)
         * 
         * Concurrent access?
         * → ConcurrentHashMap.newKeySet()
         */
    }
    
    /**
     * Comparison table
     */
    public static void comparisonTable() {
        /**
         * ┌──────────────────┬──────────┬─────────┬───────────────┬────────────────┐
         * │ Set Type         │ Order    │ Add     │ Contains      │ Best For       │
         * ├──────────────────┼──────────┼─────────┼───────────────┼────────────────┤
         * │ HashSet          │ None     │ O(1)    │ O(1)          │ General use    │
         * │                  │          │         │               │ Performance    │
         * ├──────────────────┼──────────┼─────────┼───────────────┼────────────────┤
         * │ LinkedHashSet    │ Insertion│ O(1)    │ O(1)          │ Ordered iter   │
         * │                  │          │         │               │ Cache-like     │
         * ├──────────────────┼──────────┼─────────┼───────────────┼────────────────┤
         * │ TreeSet          │ Sorted   │ O(log n)│ O(log n)      │ Sorted data    │
         * │                  │          │         │               │ Range queries  │
         * ├──────────────────┼──────────┼─────────┼───────────────┼────────────────┤
         * │ EnumSet          │ Enum     │ O(1)    │ O(1)          │ Enum elements  │
         * │                  │ order    │         │               │ Flags          │
         * ├──────────────────┼──────────┼─────────┼───────────────┼────────────────┤
         * │ ConcurrentHash   │ None     │ O(1)    │ O(1)          │ Concurrent     │
         * │ Map.newKeySet()  │          │         │               │ Thread-safe    │
         * └──────────────────┴──────────┴─────────┴───────────────┴────────────────┘
         * 
         * PERFORMANCE RANKING:
         * Speed: EnumSet > HashSet > LinkedHashSet > TreeSet
         * Memory: EnumSet < HashSet < LinkedHashSet < TreeSet
         */
    }
    
    /**
     * Use case examples
     */
    public static void useCaseExamples() {
        /**
         * HASHSET EXAMPLES:
         * 
         * 1. Unique values collection:
         */
        Set<String> uniqueUsers = new HashSet<>();
        
        /**
         * 2. Fast membership test:
         */
        Set<String> validCodes = new HashSet<>(Arrays.asList(
            "CODE1", "CODE2", "CODE3"
        ));
        if (validCodes.contains(userCode)) { ... }
        
        /**
         * 3. Duplicate detection:
         */
        Set<Integer> seen = new HashSet<>();
        for (Integer num : numbers) {
            if (!seen.add(num)) {
                System.out.println("Duplicate: " + num);
            }
        }
        
        /**
         * LINKEDHASHSET EXAMPLES:
         * 
         * 1. Ordered unique collection:
         */
        Set<String> tags = new LinkedHashSet<>();
        // Tags displayed in insertion order
        
        /**
         * 2. LRU-like behavior:
         */
        Set<String> recentItems = new LinkedHashSet<>();
        // Oldest items at beginning
        
        /**
         * 3. Preserving order from input:
         */
        Set<String> uniqueArgs = new LinkedHashSet<>(
            Arrays.asList(commandLineArgs)
        );
        
        /**
         * TREESET EXAMPLES:
         * 
         * 1. Sorted leaderboard:
         */
        TreeSet<Score> leaderboard = new TreeSet<>();
        // Automatically sorted by score
        
        /**
         * 2. Time-based events:
         */
        TreeSet<Event> events = new TreeSet<>(
            Comparator.comparing(Event::getTimestamp)
        );
        
        /**
         * 3. Range queries:
         */
        TreeSet<Integer> numbers = new TreeSet<>();
        Set<Integer> between20And50 = numbers.subSet(20, 50);
    }
    
    /**
     * Performance summary
     */
    public static void performanceSummary() {
        /**
         * REAL-WORLD BENCHMARKS (100K elements):
         * 
         * ADD:
         * - HashSet: 25ms
         * - LinkedHashSet: 35ms (40% slower)
         * - TreeSet: 85ms (3.4x slower)
         * 
         * CONTAINS:
         * - HashSet: 5ms
         * - LinkedHashSet: 8ms
         * - TreeSet: 45ms
         * 
         * ITERATION:
         * - HashSet: 15ms (unordered)
         * - LinkedHashSet: 8ms (ordered, faster!)
         * - TreeSet: 12ms (sorted)
         * 
         * MEMORY (1000 elements):
         * - HashSet: ~24 KB
         * - LinkedHashSet: ~32 KB
         * - TreeSet: ~48 KB
         * 
         * SET OPERATIONS (union, 50K + 50K):
         * - HashSet: 15ms
         * - TreeSet: 180ms (12x slower)
         */
    }
    
    /**
     * Common mistakes
     */
    public static void commonMistakes() {
        /**
         * MISTAKE 1: Using TreeSet unnecessarily
         * 
         * BAD:
         * Set<String> users = new TreeSet<>();
         * 
         * GOOD:
         * Set<String> users = new HashSet<>();
         * 
         * Only use TreeSet if you need sorting!
         * 
         * 
         * MISTAKE 2: Not overriding equals/hashCode
         * 
         * class User {
         *     String name;
         *     // Missing equals/hashCode!
         * }
         * 
         * Set<User> users = new HashSet<>();
         * users.add(new User("Alice"));
         * users.add(new User("Alice"));  // Added twice!
         * 
         * 
         * MISTAKE 3: Mutable elements
         * 
         * Set<MutablePoint> points = new HashSet<>();
         * MutablePoint p = new MutablePoint(1, 2);
         * points.add(p);
         * p.x = 10;  // Changed after adding!
         * points.contains(p);  // false! Lost in set!
         * 
         * 
         * MISTAKE 4: Wrong set for enum
         * 
         * BAD:
         * Set<DayOfWeek> days = new HashSet<>();
         * 
         * GOOD:
         * Set<DayOfWeek> days = EnumSet.noneOf(DayOfWeek.class);
         * // 10x faster, 10x less memory
         * 
         * 
         * MISTAKE 5: Comparing sets incorrectly
         * 
         * Don't use ==:
         * set1 == set2  // Wrong! Compares references
         * 
         * Use equals():
         * set1.equals(set2)  // Correct! Compares contents
         */
    }
    
    /**
     * Best practices
     */
    public static void bestPractices() {
        /**
         * BEST PRACTICES:
         * 
         * 1. DEFAULT TO HASHSET:
         *    Set<String> set = new HashSet<>();
         *    Use unless you need specific feature
         * 
         * 2. SIZE APPROPRIATELY:
         *    Set<String> set = new HashSet<>(expectedSize * 4/3 + 1);
         *    Avoid resizing overhead
         * 
         * 3. USE IMMUTABLE SETS FOR CONSTANTS:
         *    Set<String> VALID_TYPES = Set.of("A", "B", "C");
         *    Faster, safer, more compact
         * 
         * 4. ENUMSET FOR ENUMS:
         *    Set<Day> weekdays = EnumSet.range(Day.MON, Day.FRI);
         *    Always use EnumSet for enum elements
         * 
         * 5. CONVERT CAREFULLY:
         *    Set<Integer> set = new HashSet<>(list);  // Fast: O(n)
         *    NOT:
         *    list.forEach(set::add);  // Same but verbose
         * 
         * 6. STREAM COLLECTORS:
         *    Set<String> uniqueNames = people.stream()
         *        .map(Person::getName)
         *        .collect(Collectors.toSet());  // HashSet
         *    
         *    // For specific set type:
         *    .collect(Collectors.toCollection(TreeSet::new));
         * 
         * 7. THREAD SAFETY:
         *    // NOT thread-safe:
         *    Set<String> set = Collections.synchronizedSet(new HashSet<>());
         *    
         *    // Better:
         *    Set<String> set = ConcurrentHashMap.newKeySet();
         * 
         * 8. NULL HANDLING:
         *    HashSet/LinkedHashSet: Allow one null
         *    TreeSet: No nulls (NullPointerException)
         *    EnumSet: No nulls
         */
    }
    
    /**
     * Interview answers
     */
    public static void interviewAnswers() {
        /**
         * Q: "What's the difference between HashSet and TreeSet?"
         * 
         * A: "HashSet is backed by HashMap and provides O(1) add/contains
         * operations but no ordering. TreeSet is backed by TreeMap (Red-Black
         * tree) and provides O(log n) operations but elements are sorted.
         * 
         * Choose HashSet for performance (3-4x faster), choose TreeSet when
         * you need sorted iteration or NavigableSet operations like
         * floor/ceiling."
         * 
         * 
         * Q: "When would you use LinkedHashSet?"
         * 
         * A: "LinkedHashSet maintains insertion order while providing O(1)
         * operations like HashSet. Use it when you need predictable iteration
         * order - for example, preserving the order of command-line arguments
         * while removing duplicates, or maintaining a cache-like structure
         * where order matters.
         * 
         * It's about 40% slower than HashSet, so only use when order is
         * actually needed."
         * 
         * 
         * Q: "How do you implement equals/hashCode for set elements?"
         * 
         * A: "Use the same rules as for HashMap keys:
         * 1. Override both equals() and hashCode() together
         * 2. Use same fields in both methods
         * 3. Use Objects.hash() for hashCode
         * 4. Make elements immutable
         * 
         * For TreeSet, also ensure compareTo() is consistent with equals()
         * - if x.equals(y), then x.compareTo(y) == 0"
         */
    }
}
```

---

## Summary

### Quick Reference

**HashSet:**

```java
Set<String> set = new HashSet<>();
// O(1) operations
// No ordering
// Backed by HashMap
// Default choice
```

**TreeSet:**

```java
Set<Integer> set = new TreeSet<>();
// O(log n) operations
// Sorted order
// Backed by TreeMap
// Use when sorting needed
```

**LinkedHashSet:**

```java
Set<String> set = new LinkedHashSet<>();
// O(1) operations
// Insertion order
// Backed by LinkedHashMap
// Use when order matters
```

### Comparison Table

```
┌──────────────────┬──────────┬─────────┬──────────┬────────────────┐
│ Implementation   │ Add      │ Contains│ Order    │ Best For       │
├──────────────────┼──────────┼─────────┼──────────┼────────────────┤
│ HashSet          │ O(1) ⚡  │ O(1) ⚡ │ None     │ General use    │
│ LinkedHashSet    │ O(1) 🟢  │ O(1) 🟢 │ Insertion│ Ordered iter   │
│ TreeSet          │ O(log n) │O(log n) │ Sorted   │ Sorted data    │
│ EnumSet          │ O(1) ⚡⚡│ O(1) ⚡⚡│ Enum     │ Enum flags     │
└──────────────────┴──────────┴─────────┴──────────┴────────────────┘

⚡⚡ = Fastest  ⚡ = Very Fast  🟢 = Fast
```

### Performance Summary

```
100K elements benchmark:
Add:      HashSet: 25ms  LinkedHashSet: 35ms  TreeSet: 85ms
Contains: HashSet: 5ms   LinkedHashSet: 8ms   TreeSet: 45ms
Memory:   HashSet: 24KB  LinkedHashSet: 32KB  TreeSet: 48KB

Winner: HashSet (3x faster, 2x less memory)
```

### Decision Tree

```
Need sorted elements?
├─ YES → TreeSet
└─ NO ↓

Need insertion order?
├─ YES → LinkedHashSet
└─ NO ↓

Elements are enums?
├─ YES → EnumSet
└─ NO ↓

→ HashSet (default)
```

### Best Practices

```java
// ✅ Default to HashSet
Set<String> set = new HashSet<>();

// ✅ Use immutable for constants
Set<String> TYPES = Set.of("A", "B", "C");

// ✅ EnumSet for enums
Set<Day> days = EnumSet.of(Day.MON, Day.FRI);

// ✅ Size appropriately
Set<String> set = new HashSet<>(expectedSize * 4/3);

// ✅ Always override equals/hashCode
class Element {
    @Override
    public boolean equals(Object obj) { ... }
    
    @Override
    public int hashCode() {
        return Objects.hash(field1, field2);
    }
}

// ❌ Don't use mutable elements
MutablePoint p = new MutablePoint(1, 2);
set.add(p);
p.x = 10;  // BAD! Lost in set!
```

### Key Takeaways

1. **HashSet is the default** - Use for 95% of cases
2. **TreeSet for sorting** - When you need sorted iteration
3. **LinkedHashSet for order** - When insertion order matters
4. **EnumSet for enums** - Always use for enum elements
5. **Always override equals/hashCode** - Critical for correctness
6. **Use immutable elements** - Prevents bugs

---
