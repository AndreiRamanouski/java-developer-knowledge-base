# Java ThreadLocal and Context Propagation

## Overview

ThreadLocal provides thread-confined variables - each thread has its own independent copy. This guide covers ThreadLocal mechanics, memory leaks, context propagation in async code, and real-world patterns used in Spring and logging frameworks.


---

## 1. ThreadLocal Basics

### How ThreadLocal Works

```java
/**
 * THREADLOCAL FUNDAMENTALS
 * 
 * Thread-confined variables
 * Each thread has its own copy
 */

public class ThreadLocalBasics {
    
    /**
     * Basic usage
     */
    public static void basicDemo() throws InterruptedException {
        ThreadLocal<String> context = new ThreadLocal<>();
        
        // Thread 1
        Thread t1 = new Thread(() -> {
            context.set("Thread-1 data");
            System.out.println("T1 sees: " + context.get());
            
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            
            System.out.println("T1 still sees: " + context.get());
        });
        
        // Thread 2
        Thread t2 = new Thread(() -> {
            context.set("Thread-2 data");
            System.out.println("T2 sees: " + context.get());
            
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            
            System.out.println("T2 still sees: " + context.get());
        });
        
        t1.start();
        Thread.sleep(100);
        t2.start();
        
        t1.join();
        t2.join();
        
        /**
         * OUTPUT:
         * T1 sees: Thread-1 data
         * T2 sees: Thread-2 data
         * T1 still sees: Thread-1 data
         * T2 still sees: Thread-2 data
         * 
         * ISOLATION:
         * - Each thread has its own value
         * - No sharing between threads
         * - No synchronization needed
         */
    }
    
    /**
     * How ThreadLocal works internally
     */
    public static void internalStructure() {
        /**
         * THREADLOCAL INTERNALS:
         * 
         * Each Thread has a ThreadLocalMap:
         * 
         * class Thread {
         *     ThreadLocal.ThreadLocalMap threadLocals = null;
         * }
         * 
         * ThreadLocalMap is a custom hash map:
         * 
         * static class ThreadLocalMap {
         *     static class Entry extends WeakReference<ThreadLocal<?>> {
         *         Object value;
         *         
         *         Entry(ThreadLocal<?> k, Object v) {
         *             super(k);  // WeakReference to ThreadLocal
         *             value = v;
         *         }
         *     }
         *     
         *     private Entry[] table;
         * }
         * 
         * 
         * SET OPERATION:
         * 
         * public void set(T value) {
         *     Thread t = Thread.currentThread();
         *     ThreadLocalMap map = t.threadLocals;
         *     
         *     if (map != null)
         *         map.set(this, value);  // 'this' is the ThreadLocal
         *     else
         *         createMap(t, value);
         * }
         * 
         * 
         * GET OPERATION:
         * 
         * public T get() {
         *     Thread t = Thread.currentThread();
         *     ThreadLocalMap map = t.threadLocals;
         *     
         *     if (map != null) {
         *         Entry e = map.getEntry(this);
         *         if (e != null)
         *             return (T) e.value;
         *     }
         *     return setInitialValue();
         * }
         * 
         * 
         * KEY POINTS:
         * - Data stored IN the Thread object
         * - ThreadLocal is the key (WeakReference)
         * - Value is stored in Entry
         * - Each thread has its own ThreadLocalMap
         */
    }
    
    /**
     * initialValue() method
     */
    public static void initialValueDemo() {
        ThreadLocal<Integer> counter = new ThreadLocal<Integer>() {
            @Override
            protected Integer initialValue() {
                return 0;
            }
        };
        
        // Or with Java 8+
        ThreadLocal<Integer> counterLambda = ThreadLocal.withInitial(() -> 0);
        
        System.out.println("Initial value: " + counter.get());  // 0
        counter.set(counter.get() + 1);
        System.out.println("After increment: " + counter.get());  // 1
        
        /**
         * INITIAL VALUE:
         * - Called on first get() if no value set
         * - Per-thread initialization
         * - Useful for expensive objects
         */
    }
    
    /**
     * Common use cases
     */
    static class UseCases {
        // 1. SimpleDateFormat (not thread-safe)
        private static final ThreadLocal<java.text.SimpleDateFormat> DATE_FORMAT =
            ThreadLocal.withInitial(() -> new java.text.SimpleDateFormat("yyyy-MM-dd"));
        
        public static String formatDate(java.util.Date date) {
            return DATE_FORMAT.get().format(date);
        }
        
        // 2. Database connections (per-thread connection)
        private static final ThreadLocal<java.sql.Connection> CONNECTION =
            new ThreadLocal<>();
        
        public static java.sql.Connection getConnection() {
            return CONNECTION.get();
        }
        
        public static void setConnection(java.sql.Connection conn) {
            CONNECTION.set(conn);
        }
        
        // 3. User context
        private static final ThreadLocal<String> USER_CONTEXT = new ThreadLocal<>();
        
        public static void setCurrentUser(String userId) {
            USER_CONTEXT.set(userId);
        }
        
        public static String getCurrentUser() {
            return USER_CONTEXT.get();
        }
        
        /**
         * COMMON PATTERNS:
         * - Thread-safe formatting (SimpleDateFormat)
         * - Transaction management (per-thread connection)
         * - Security context (current user)
         * - Request context (web applications)
         */
    }
    
    public static void main(String[] args) throws InterruptedException {
        basicDemo();
        System.out.println();
        initialValueDemo();
    }
}
```

---

## 2. InheritableThreadLocal

### Parent-Child Thread Inheritance

```java
/**
 * INHERITABLETHREADLOCAL
 * 
 * Child threads inherit values from parent
 */

public class InheritableThreadLocalExample {
    
    /**
     * Basic inheritance
     */
    public static void basicInheritance() throws InterruptedException {
        InheritableThreadLocal<String> context = new InheritableThreadLocal<>();
        
        // Parent thread sets value
        context.set("Parent context");
        System.out.println("Parent: " + context.get());
        
        // Create child thread
        Thread child = new Thread(() -> {
            System.out.println("Child sees: " + context.get());  // Inherited!
            
            // Child can modify its own copy
            context.set("Child modified");
            System.out.println("Child after modify: " + context.get());
        });
        
        child.start();
        child.join();
        
        // Parent's value unchanged
        System.out.println("Parent after child: " + context.get());
        
        /**
         * OUTPUT:
         * Parent: Parent context
         * Child sees: Parent context
         * Child after modify: Child modified
         * Parent after child: Parent context
         * 
         * INHERITANCE:
         * - Child thread inherits parent's value
         * - Child gets a copy (not reference)
         * - Child modifications don't affect parent
         */
    }
    
    /**
     * How inheritance works
     */
    public static void inheritanceInternals() {
        /**
         * INHERITANCE MECHANISM:
         * 
         * When new Thread is created:
         * 
         * public Thread(...) {
         *     Thread parent = currentThread();
         *     
         *     if (parent.inheritableThreadLocals != null) {
         *         this.inheritableThreadLocals =
         *             ThreadLocal.createInheritedMap(
         *                 parent.inheritableThreadLocals);
         *     }
         * }
         * 
         * createInheritedMap():
         * - Copies all entries from parent's map
         * - Creates new ThreadLocalMap for child
         * - Child gets shallow copy of values
         * 
         * IMPORTANT:
         * - Inheritance happens at Thread creation time
         * - Changes after thread starts don't propagate
         * - Only works with direct child threads
         */
    }
    
    /**
     * childValue() customization
     */
    public static void childValueDemo() throws InterruptedException {
        InheritableThreadLocal<Integer> counter = new InheritableThreadLocal<Integer>() {
            @Override
            protected Integer childValue(Integer parentValue) {
                // Child starts with parent value + 100
                return parentValue + 100;
            }
        };
        
        counter.set(1);
        System.out.println("Parent value: " + counter.get());
        
        Thread child = new Thread(() -> {
            System.out.println("Child value: " + counter.get());
        });
        
        child.start();
        child.join();
        
        /**
         * OUTPUT:
         * Parent value: 1
         * Child value: 101
         * 
         * childValue():
         * - Customize inherited value
         * - Transform parent value
         * - Deep copy if needed
         */
    }
    
    /**
     * Limitations with thread pools
     */
    public static void threadPoolLimitation() throws InterruptedException {
        InheritableThreadLocal<String> context = new InheritableThreadLocal<>();
        java.util.concurrent.ExecutorService executor = 
            java.util.concurrent.Executors.newFixedThreadPool(2);
        
        context.set("Initial context");
        
        // Submit first task
        executor.submit(() -> {
            System.out.println("Task 1: " + context.get());
        });
        
        Thread.sleep(100);
        
        // Change context in main thread
        context.set("Modified context");
        
        // Submit second task (reuses thread)
        executor.submit(() -> {
            System.out.println("Task 2: " + context.get());
        });
        
        Thread.sleep(100);
        executor.shutdown();
        
        /**
         * OUTPUT:
         * Task 1: Initial context
         * Task 2: Initial context  (NOT Modified context!)
         * 
         * PROBLEM:
         * - Thread pool reuses threads
         * - Inheritance only at thread creation
         * - Stale values in reused threads
         * - Major pitfall!
         */
    }
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== Basic Inheritance ===");
        basicInheritance();
        
        System.out.println("\n=== Child Value ===");
        childValueDemo();
        
        System.out.println("\n=== Thread Pool Limitation ===");
        threadPoolLimitation();
    }
}
```

---

## 3. ThreadLocal Memory Leaks

### The Critical Problem

```java
/**
 * THREADLOCAL MEMORY LEAKS
 * 
 * CRITICAL: Most common ThreadLocal pitfall
 */

public class ThreadLocalMemoryLeaks {
    
    /**
     * Memory leak demonstration
     */
    public static void memoryLeakDemo() throws InterruptedException {
        java.util.concurrent.ExecutorService executor = 
            java.util.concurrent.Executors.newFixedThreadPool(2);
        
        ThreadLocal<byte[]> leakyThreadLocal = new ThreadLocal<>();
        
        // Submit 100 tasks
        for (int i = 0; i < 100; i++) {
            executor.submit(() -> {
                // Allocate 10MB per task
                byte[] largeObject = new byte[10 * 1024 * 1024];
                leakyThreadLocal.set(largeObject);
                
                // Do some work
                System.out.println("Task running on " + 
                    Thread.currentThread().getName());
                
                // PROBLEM: Never call remove()!
                // leakyThreadLocal.remove();  // SHOULD DO THIS
            });
        }
        
        Thread.sleep(2000);
        executor.shutdown();
        
        /**
         * MEMORY LEAK:
         * 
         * Problem:
         * 1. Thread pool keeps threads alive
         * 2. Each thread's ThreadLocalMap holds references
         * 3. Values (10MB byte arrays) never released
         * 4. Memory grows with each task
         * 
         * Result:
         * - 100 tasks × 10MB = 1GB allocated
         * - But only 2 threads (pool size 2)
         * - 2 × 10MB = 20MB should be used
         * - 980MB leaked!
         * 
         * In production:
         * - OutOfMemoryError
         * - Application crashes
         * - Subtle and hard to debug
         */
    }
    
    /**
     * Why the leak happens
     */
    public static void leakExplanation() {
        /**
         * THREADLOCAL REFERENCE CHAIN:
         * 
         * Thread (alive in pool)
         *   ↓ (strong reference)
         * ThreadLocalMap
         *   ↓ (strong reference)
         * Entry[] table
         *   ↓ (weak reference to ThreadLocal)
         *   ↓ (STRONG reference to value)
         * Value (your object)
         * 
         * 
         * Entry structure:
         * 
         * static class Entry extends WeakReference<ThreadLocal<?>> {
         *     Object value;  // STRONG reference!
         * }
         * 
         * 
         * What happens:
         * 
         * 1. ThreadLocal becomes unreachable (e.g., method ends)
         * 2. GC collects ThreadLocal (weak reference)
         * 3. Entry.key becomes null
         * 4. BUT Entry.value still strongly referenced!
         * 5. Thread (from pool) stays alive
         * 6. Value never collected → MEMORY LEAK
         * 
         * 
         * Why WeakReference to key?
         * - Prevent ThreadLocal itself from leaking
         * - Allow ThreadLocal to be GC'd
         * - BUT doesn't prevent value leak!
         */
    }
    
    /**
     * Correct usage - always remove
     */
    public static void correctUsage() throws InterruptedException {
        java.util.concurrent.ExecutorService executor = 
            java.util.concurrent.Executors.newFixedThreadPool(2);
        
        ThreadLocal<byte[]> properThreadLocal = new ThreadLocal<>();
        
        for (int i = 0; i < 100; i++) {
            executor.submit(() -> {
                try {
                    byte[] data = new byte[10 * 1024 * 1024];
                    properThreadLocal.set(data);
                    
                    // Do work
                    System.out.println("Task running");
                    
                } finally {
                    // ALWAYS remove in finally block
                    properThreadLocal.remove();
                }
            });
        }
        
        Thread.sleep(2000);
        executor.shutdown();
        
        /**
         * CORRECT PATTERN:
         * 
         * try {
         *     threadLocal.set(value);
         *     // use value
         * } finally {
         *     threadLocal.remove();  // CRITICAL!
         * }
         * 
         * remove():
         * - Removes entry from ThreadLocalMap
         * - Releases strong reference to value
         * - Allows GC to collect value
         * - Prevents memory leak
         */
    }
    
    /**
     * Real-world leak example
     */
    static class UserContext {
        private static final ThreadLocal<User> CURRENT_USER = new ThreadLocal<>();
        
        static class User {
            String name;
            byte[] sessionData;  // Could be large!
            
            User(String name) {
                this.name = name;
                this.sessionData = new byte[1024 * 1024];  // 1MB
            }
        }
        
        // DANGEROUS: No cleanup
        public static void setUser(User user) {
            CURRENT_USER.set(user);
        }
        
        public static User getUser() {
            return CURRENT_USER.get();
        }
        
        // SAFE: With cleanup
        public static void setUserSafe(User user) {
            CURRENT_USER.set(user);
        }
        
        public static void clearUser() {
            CURRENT_USER.remove();  // IMPORTANT!
        }
    }
    
    public static void realWorldLeakDemo() throws InterruptedException {
        java.util.concurrent.ExecutorService executor = 
            java.util.concurrent.Executors.newFixedThreadPool(10);
        
        // Simulate 1000 requests
        for (int i = 0; i < 1000; i++) {
            final int requestId = i;
            executor.submit(() -> {
                try {
                    // Set user context
                    UserContext.setUserSafe(new UserContext.User("User-" + requestId));
                    
                    // Process request
                    UserContext.User user = UserContext.getUser();
                    System.out.println("Processing request for " + user.name);
                    
                } finally {
                    // Clean up - CRITICAL!
                    UserContext.clearUser();
                }
            });
        }
        
        executor.shutdown();
        executor.awaitTermination(10, java.util.concurrent.TimeUnit.SECONDS);
        
        /**
         * WITHOUT cleanup:
         * - 1000 requests × 1MB = 1GB allocated
         * - 10 threads × 1MB = 10MB should remain
         * - 990MB leaked
         * 
         * WITH cleanup:
         * - 10MB max (one per thread)
         * - Values released after each request
         * - No leak!
         */
    }
    
    /**
     * Detecting ThreadLocal leaks
     */
    public static void detectingLeaks() {
        /**
         * DETECTION METHODS:
         * 
         * 1. Heap dumps:
         *    - Take heap dump: jmap -dump:format=b,file=heap.bin <pid>
         *    - Analyze with Eclipse MAT
         *    - Look for:
         *      - ThreadLocalMap with many entries
         *      - Large objects referenced by ThreadLocal
         *      - Thread pool threads with bloated ThreadLocalMap
         * 
         * 2. Memory profilers:
         *    - VisualVM, YourKit, JProfiler
         *    - Track allocations by ThreadLocal
         *    - Monitor thread-local storage growth
         * 
         * 3. JFR (Java Flight Recorder):
         *    - Enable: -XX:StartFlightRecording
         *    - Look for:
         *      - Growing heap after each request
         *      - ThreadLocalMap entries not cleaned
         * 
         * 4. Custom monitoring:
         *    - Wrap ThreadLocal.set() and remove()
         *    - Track set/remove ratio
         *    - Alert if ratio off
         * 
         * 5. Code review checklist:
         *    ✓ Every set() has corresponding remove()
         *    ✓ remove() in finally block
         *    ✓ Used with thread pools
         */
    }
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== Correct Usage ===");
        correctUsage();
        
        System.out.println("\n=== Real-World Example ===");
        realWorldLeakDemo();
    }
}
```

---

## 4. Context Propagation in Async Code

### The Problem and Solutions

```java
/**
 * CONTEXT PROPAGATION IN ASYNC CODE
 * 
 * ThreadLocal doesn't work across threads
 * Need explicit propagation
 */

import java.util.concurrent.*;

public class ContextPropagation {
    
    /**
     * The problem: Lost context
     */
    static class UserContext {
        private static final ThreadLocal<String> CURRENT_USER = new ThreadLocal<>();
        
        public static void setUser(String user) {
            CURRENT_USER.set(user);
        }
        
        public static String getUser() {
            return CURRENT_USER.get();
        }
        
        public static void clear() {
            CURRENT_USER.remove();
        }
    }
    
    public static void problemDemo() throws InterruptedException {
        // Set user in main thread
        UserContext.setUser("alice");
        System.out.println("Main thread user: " + UserContext.getUser());
        
        // Run async task
        CompletableFuture.runAsync(() -> {
            System.out.println("Async task user: " + UserContext.getUser());  // null!
        }).join();
        
        UserContext.clear();
        
        /**
         * OUTPUT:
         * Main thread user: alice
         * Async task user: null
         * 
         * PROBLEM:
         * - ThreadLocal is per-thread
         * - Async task runs on different thread
         * - Context not propagated
         */
    }
    
    /**
     * Solution 1: Manual propagation
     */
    public static void manualPropagation() throws InterruptedException {
        UserContext.setUser("bob");
        
        // Capture context before async
        String capturedUser = UserContext.getUser();
        
        CompletableFuture.runAsync(() -> {
            try {
                // Restore context in async thread
                UserContext.setUser(capturedUser);
                
                System.out.println("Async task user: " + UserContext.getUser());
                
            } finally {
                UserContext.clear();
            }
        }).join();
        
        UserContext.clear();
        
        /**
         * OUTPUT:
         * Async task user: bob
         * 
         * MANUAL PROPAGATION:
         * 1. Capture context before async
         * 2. Restore context in async thread
         * 3. Clean up in finally
         * 
         * DRAWBACKS:
         * - Verbose and error-prone
         * - Easy to forget cleanup
         * - Must remember for every async call
         */
    }
    
    /**
     * Solution 2: Context wrapper
     */
    static class ContextPropagatingRunnable implements Runnable {
        private final Runnable delegate;
        private final String capturedUser;
        
        public ContextPropagatingRunnable(Runnable delegate) {
            this.delegate = delegate;
            this.capturedUser = UserContext.getUser();
        }
        
        @Override
        public void run() {
            String previousUser = UserContext.getUser();
            try {
                UserContext.setUser(capturedUser);
                delegate.run();
            } finally {
                if (previousUser != null) {
                    UserContext.setUser(previousUser);
                } else {
                    UserContext.clear();
                }
            }
        }
    }
    
    public static void wrapperDemo() throws InterruptedException {
        ExecutorService executor = Executors.newFixedThreadPool(2);
        
        UserContext.setUser("charlie");
        
        // Wrap task to propagate context
        Runnable task = new ContextPropagatingRunnable(() -> {
            System.out.println("Async task user: " + UserContext.getUser());
        });
        
        executor.submit(task);
        
        Thread.sleep(100);
        executor.shutdown();
        UserContext.clear();
        
        /**
         * OUTPUT:
         * Async task user: charlie
         * 
         * WRAPPER APPROACH:
         * - Captures context on creation
         * - Restores context on execution
         * - Cleans up automatically
         * - Reusable pattern
         */
    }
    
    /**
     * Solution 3: Custom executor
     */
    static class ContextPropagatingExecutor implements ExecutorService {
        private final ExecutorService delegate;
        
        public ContextPropagatingExecutor(ExecutorService delegate) {
            this.delegate = delegate;
        }
        
        @Override
        public void execute(Runnable command) {
            delegate.execute(new ContextPropagatingRunnable(command));
        }
        
        @Override
        public Future<?> submit(Runnable task) {
            return delegate.submit(new ContextPropagatingRunnable(task));
        }
        
        @Override
        public <T> Future<T> submit(Callable<T> task) {
            String capturedUser = UserContext.getUser();
            return delegate.submit(() -> {
                String previousUser = UserContext.getUser();
                try {
                    UserContext.setUser(capturedUser);
                    return task.call();
                } finally {
                    if (previousUser != null) {
                        UserContext.setUser(previousUser);
                    } else {
                        UserContext.clear();
                    }
                }
            });
        }
        
        // Delegate other methods...
        @Override
        public void shutdown() { delegate.shutdown(); }
        
        @Override
        public java.util.List<Runnable> shutdownNow() { 
            return delegate.shutdownNow(); 
        }
        
        @Override
        public boolean isShutdown() { return delegate.isShutdown(); }
        
        @Override
        public boolean isTerminated() { return delegate.isTerminated(); }
        
        @Override
        public boolean awaitTermination(long timeout, TimeUnit unit) 
                throws InterruptedException {
            return delegate.awaitTermination(timeout, unit);
        }
        
        @Override
        public <T> java.util.List<Future<T>> invokeAll(
                java.util.Collection<? extends Callable<T>> tasks) 
                throws InterruptedException {
            return delegate.invokeAll(tasks);
        }
        
        @Override
        public <T> java.util.List<Future<T>> invokeAll(
                java.util.Collection<? extends Callable<T>> tasks,
                long timeout, TimeUnit unit) throws InterruptedException {
            return delegate.invokeAll(tasks, timeout, unit);
        }
        
        @Override
        public <T> T invokeAny(java.util.Collection<? extends Callable<T>> tasks) 
                throws InterruptedException, ExecutionException {
            return delegate.invokeAny(tasks);
        }
        
        @Override
        public <T> T invokeAny(java.util.Collection<? extends Callable<T>> tasks,
                long timeout, TimeUnit unit) 
                throws InterruptedException, ExecutionException, TimeoutException {
            return delegate.invokeAny(tasks, timeout, unit);
        }
        
        @Override
        public <T> Future<T> submit(Runnable task, T result) {
            return delegate.submit(new ContextPropagatingRunnable(task), result);
        }
    }
    
    public static void customExecutorDemo() throws InterruptedException {
        ExecutorService executor = new ContextPropagatingExecutor(
            Executors.newFixedThreadPool(2)
        );
        
        UserContext.setUser("dave");
        
        // Context automatically propagated
        executor.submit(() -> {
            System.out.println("Task 1 user: " + UserContext.getUser());
        });
        
        executor.submit(() -> {
            System.out.println("Task 2 user: " + UserContext.getUser());
        });
        
        Thread.sleep(100);
        executor.shutdown();
        UserContext.clear();
        
        /**
         * OUTPUT:
         * Task 1 user: dave
         * Task 2 user: dave
         * 
         * CUSTOM EXECUTOR:
         * - Transparent context propagation
         * - No code changes in tasks
         * - Centralized solution
         */
    }
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== Problem ===");
        problemDemo();
        
        System.out.println("\n=== Manual Propagation ===");
        manualPropagation();
        
        System.out.println("\n=== Wrapper ===");
        wrapperDemo();
        
        System.out.println("\n=== Custom Executor ===");
        customExecutorDemo();
    }
}
```

---

## 5. Spring RequestContextHolder

### Real-World Framework Usage

```java
/**
 * SPRING REQUESTCONTEXTHOLDER
 * 
 * Spring's ThreadLocal-based request context
 */

public class SpringRequestContextExample {
    
    /**
     * How RequestContextHolder works
     */
    public static void requestContextExplanation() {
        /**
         * SPRING REQUESTCONTEXTHOLDER:
         * 
         * public abstract class RequestContextHolder {
         *     private static final ThreadLocal<RequestAttributes> 
         *         requestAttributesHolder = new ThreadLocal<>();
         *     
         *     private static final ThreadLocal<RequestAttributes> 
         *         inheritableRequestAttributesHolder = 
         *             new InheritableThreadLocal<>();
         *     
         *     public static void setRequestAttributes(
         *             RequestAttributes attributes, boolean inheritable) {
         *         if (inheritable) {
         *             inheritableRequestAttributesHolder.set(attributes);
         *             requestAttributesHolder.remove();
         *         } else {
         *             requestAttributesHolder.set(attributes);
         *             inheritableRequestAttributesHolder.remove();
         *         }
         *     }
         *     
         *     public static RequestAttributes getRequestAttributes() {
         *         RequestAttributes attributes = requestAttributesHolder.get();
         *         if (attributes == null) {
         *             attributes = inheritableRequestAttributesHolder.get();
         *         }
         *         return attributes;
         *     }
         * }
         * 
         * 
         * REQUEST LIFECYCLE:
         * 
         * 1. Request arrives
         * 2. Filter/Interceptor sets RequestAttributes
         * 3. Controllers access via RequestContextHolder
         * 4. Services access via RequestContextHolder
         * 5. Filter/Interceptor clears RequestAttributes
         * 
         * 
         * USAGE:
         * 
         * // Get current request
         * ServletRequestAttributes attrs = 
         *     (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
         * HttpServletRequest request = attrs.getRequest();
         * 
         * // Get session
         * HttpSession session = request.getSession();
         * 
         * // Get request parameter
         * String param = request.getParameter("name");
         */
    }
    
    /**
     * Simulated Spring MVC flow
     */
    static class RequestAttributes {
        private final java.util.Map<String, Object> attributes = 
            new java.util.HashMap<>();
        
        public void setAttribute(String name, Object value) {
            attributes.put(name, value);
        }
        
        public Object getAttribute(String name) {
            return attributes.get(name);
        }
    }
    
    static class SimpleRequestContextHolder {
        private static final ThreadLocal<RequestAttributes> CONTEXT = 
            new ThreadLocal<>();
        
        public static void setRequestAttributes(RequestAttributes attrs) {
            CONTEXT.set(attrs);
        }
        
        public static RequestAttributes getRequestAttributes() {
            return CONTEXT.get();
        }
        
        public static void resetRequestAttributes() {
            CONTEXT.remove();
        }
    }
    
    static class RequestFilter {
        public void doFilter() {
            try {
                // Set request context at start
                RequestAttributes attrs = new RequestAttributes();
                attrs.setAttribute("userId", "user123");
                attrs.setAttribute("requestId", "req-" + 
                    System.currentTimeMillis());
                
                SimpleRequestContextHolder.setRequestAttributes(attrs);
                
                // Process request (call controller)
                new UserController().handleRequest();
                
            } finally {
                // Clean up at end
                SimpleRequestContextHolder.resetRequestAttributes();
            }
        }
    }
    
    static class UserController {
        public void handleRequest() {
            // Access request context
            RequestAttributes attrs = 
                SimpleRequestContextHolder.getRequestAttributes();
            
            String userId = (String) attrs.getAttribute("userId");
            System.out.println("Controller processing request for: " + userId);
            
            // Call service
            new UserService().processUser();
        }
    }
    
    static class UserService {
        public void processUser() {
            // Service also has access to request context
            RequestAttributes attrs = 
                SimpleRequestContextHolder.getRequestAttributes();
            
            String userId = (String) attrs.getAttribute("userId");
            String requestId = (String) attrs.getAttribute("requestId");
            
            System.out.println("Service processing:");
            System.out.println("  User: " + userId);
            System.out.println("  Request: " + requestId);
        }
    }
    
    public static void springFlowDemo() {
        RequestFilter filter = new RequestFilter();
        filter.doFilter();
        
        /**
         * OUTPUT:
         * Controller processing request for: user123
         * Service processing:
         *   User: user123
         *   Request: req-1234567890
         * 
         * BENEFITS:
         * - No need to pass request through call chain
         * - Clean service layer code
         * - Centralized request handling
         * 
         * IMPORTANT:
         * - Filter MUST clean up (finally block)
         * - Memory leak if not cleaned
         * - Works because Tomcat reuses threads
         */
    }
    
    /**
     * Async problem with Spring
     */
    public static void springAsyncProblem() throws InterruptedException {
        // Set context in main thread
        RequestAttributes attrs = new RequestAttributes();
        attrs.setAttribute("userId", "user456");
        SimpleRequestContextHolder.setRequestAttributes(attrs);
        
        // Async task (different thread)
        CompletableFuture.runAsync(() -> {
            RequestAttributes asyncAttrs = 
                SimpleRequestContextHolder.getRequestAttributes();
            System.out.println("Async context: " + asyncAttrs);  // null!
        }).join();
        
        SimpleRequestContextHolder.resetRequestAttributes();
        
        /**
         * OUTPUT:
         * Async context: null
         * 
         * PROBLEM:
         * - Context not propagated to async threads
         * - Common bug in Spring applications
         * 
         * SOLUTION:
         * - Use @Async with proper task executor
         * - Spring's TaskDecorator for context propagation
         * - Or use InheritableThreadLocal (limited)
         */
    }
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== Spring Flow ===");
        springFlowDemo();
        
        System.out.println("\n=== Async Problem ===");
        springAsyncProblem();
    }
}
```

---

## 6. MDC (Mapped Diagnostic Context)

### Logging with Context

```java
/**
 * MDC - MAPPED DIAGNOSTIC CONTEXT
 * 
 * Used by SLF4J/Logback for contextual logging
 */

public class MDCExample {
    
    /**
     * How MDC works
     */
    public static void mdcExplanation() {
        /**
         * MDC (org.slf4j.MDC):
         * 
         * public class MDC {
         *     static final ThreadLocal<Map<String, String>> 
         *         copyOnThreadLocal = new ThreadLocal<>();
         *     
         *     public static void put(String key, String val) {
         *         Map<String, String> map = copyOnThreadLocal.get();
         *         if (map == null) {
         *             map = new HashMap<>();
         *             copyOnThreadLocal.set(map);
         *         }
         *         map.put(key, val);
         *     }
         *     
         *     public static String get(String key) {
         *         Map<String, String> map = copyOnThreadLocal.get();
         *         return map != null ? map.get(key) : null;
         *     }
         *     
         *     public static void clear() {
         *         Map<String, String> map = copyOnThreadLocal.get();
         *         if (map != null) {
         *             map.clear();
         *             copyOnThreadLocal.remove();
         *         }
         *     }
         * }
         * 
         * 
         * LOGBACK PATTERN:
         * 
         * %d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} 
         * [userId=%X{userId}] [requestId=%X{requestId}] - %msg%n
         * 
         * %X{key} - Extracts MDC value
         * 
         * 
         * USAGE:
         * 
         * MDC.put("userId", "user123");
         * MDC.put("requestId", "req-456");
         * 
         * logger.info("Processing order");
         * // Log: 12:34:56.789 [main] INFO  [userId=user123] 
         * //      [requestId=req-456] - Processing order
         * 
         * MDC.clear();
         */
    }
    
    /**
     * Simulated MDC
     */
    static class SimpleMDC {
        private static final ThreadLocal<java.util.Map<String, String>> 
            CONTEXT = ThreadLocal.withInitial(java.util.HashMap::new);
        
        public static void put(String key, String value) {
            CONTEXT.get().put(key, value);
        }
        
        public static String get(String key) {
            return CONTEXT.get().get(key);
        }
        
        public static void remove(String key) {
            CONTEXT.get().remove(key);
        }
        
        public static void clear() {
            CONTEXT.get().clear();
            CONTEXT.remove();
        }
        
        public static java.util.Map<String, String> getCopyOfContextMap() {
            return new java.util.HashMap<>(CONTEXT.get());
        }
        
        public static void setContextMap(java.util.Map<String, String> map) {
            CONTEXT.get().clear();
            CONTEXT.get().putAll(map);
        }
    }
    
    /**
     * Basic MDC usage
     */
    public static void basicUsage() {
        SimpleMDC.put("requestId", "req-123");
        SimpleMDC.put("userId", "alice");
        
        log("User login");
        log("Fetching user data");
        log("User logout");
        
        SimpleMDC.clear();
    }
    
    private static void log(String message) {
        System.out.println(String.format("[requestId=%s] [userId=%s] %s",
            SimpleMDC.get("requestId"),
            SimpleMDC.get("userId"),
            message));
    }
    
    /**
     * Web application pattern
     */
    static class RequestLoggingFilter {
        public void doFilter(String requestId, String userId, Runnable request) {
            try {
                // Set context at start of request
                SimpleMDC.put("requestId", requestId);
                SimpleMDC.put("userId", userId);
                
                log("Request started");
                request.run();
                log("Request completed");
                
            } finally {
                // Clean up at end
                SimpleMDC.clear();
            }
        }
    }
    
    public static void webAppDemo() {
        RequestLoggingFilter filter = new RequestLoggingFilter();
        
        filter.doFilter("req-001", "bob", () -> {
            log("Processing controller");
            log("Calling service");
            log("Updating database");
        });
        
        /**
         * OUTPUT:
         * [requestId=req-001] [userId=bob] Request started
         * [requestId=req-001] [userId=bob] Processing controller
         * [requestId=req-001] [userId=bob] Calling service
         * [requestId=req-001] [userId=bob] Updating database
         * [requestId=req-001] [userId=bob] Request completed
         * 
         * BENEFITS:
         * - Correlation across log lines
         * - Easy debugging
         * - No need to pass context through methods
         */
    }
    
    /**
     * Async logging with MDC
     */
    public static void asyncLoggingDemo() throws InterruptedException {
        SimpleMDC.put("requestId", "req-002");
        
        log("Main thread");
        
        // PROBLEM: Lost in async thread
        CompletableFuture.runAsync(() -> {
            log("Async thread - LOST CONTEXT");
        }).join();
        
        // SOLUTION: Capture and restore
        java.util.Map<String, String> contextMap = SimpleMDC.getCopyOfContextMap();
        
        CompletableFuture.runAsync(() -> {
            try {
                SimpleMDC.setContextMap(contextMap);
                log("Async thread - RESTORED CONTEXT");
            } finally {
                SimpleMDC.clear();
            }
        }).join();
        
        SimpleMDC.clear();
        
        /**
         * OUTPUT:
         * [requestId=req-002] [userId=null] Main thread
         * [requestId=null] [userId=null] Async thread - LOST CONTEXT
         * [requestId=req-002] [userId=null] Async thread - RESTORED CONTEXT
         * 
         * PATTERN FOR ASYNC:
         * 1. Capture context before async: getCopyOfContextMap()
         * 2. Restore in async thread: setContextMap()
         * 3. Clear after use: clear()
         */
    }
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== Basic Usage ===");
        basicUsage();
        
        System.out.println("\n=== Web App ===");
        webAppDemo();
        
        System.out.println("\n=== Async Logging ===");
        asyncLoggingDemo();
    }
}
```

---

## 7. Cleaning Up ThreadLocal

### Best Practices

```java
/**
 * THREADLOCAL CLEANUP PATTERNS
 * 
 * Critical for preventing memory leaks
 */

public class ThreadLocalCleanup {
    
    /**
     * Pattern 1: Try-finally
     */
    static class TryFinallyPattern {
        private static final ThreadLocal<String> CONTEXT = new ThreadLocal<>();
        
        public void processRequest(String data) {
            try {
                CONTEXT.set(data);
                
                // Do work
                doSomething();
                
            } finally {
                // ALWAYS clean up
                CONTEXT.remove();
            }
        }
        
        private void doSomething() {
            String data = CONTEXT.get();
            System.out.println("Processing: " + data);
        }
    }
    
    /**
     * Pattern 2: AutoCloseable
     */
    static class AutoCloseableContext implements AutoCloseable {
        private static final ThreadLocal<String> CONTEXT = new ThreadLocal<>();
        
        public AutoCloseableContext(String value) {
            CONTEXT.set(value);
        }
        
        public static String get() {
            return CONTEXT.get();
        }
        
        @Override
        public void close() {
            CONTEXT.remove();
        }
        
        // Usage
        public static void demo() {
            try (AutoCloseableContext ctx = new AutoCloseableContext("data")) {
                System.out.println("Context: " + AutoCloseableContext.get());
                // Automatic cleanup!
            }
        }
    }
    
    /**
     * Pattern 3: Wrapper class
     */
    static class ThreadLocalWrapper<T> {
        private final ThreadLocal<T> threadLocal = new ThreadLocal<>();
        
        public void runWithContext(T value, Runnable task) {
            try {
                threadLocal.set(value);
                task.run();
            } finally {
                threadLocal.remove();
            }
        }
        
        public <R> R runWithContext(T value, java.util.function.Supplier<R> task) {
            try {
                threadLocal.set(value);
                return task.get();
            } finally {
                threadLocal.remove();
            }
        }
        
        public T get() {
            return threadLocal.get();
        }
    }
    
    public static void wrapperDemo() {
        ThreadLocalWrapper<String> wrapper = new ThreadLocalWrapper<>();
        
        wrapper.runWithContext("my-data", () -> {
            System.out.println("Running with: " + wrapper.get());
        });
        
        // Automatically cleaned up
        System.out.println("After: " + wrapper.get());  // null
    }
    
    /**
     * Pattern 4: Servlet Filter pattern
     */
    static class ContextFilter {
        private static final ThreadLocal<RequestContext> CONTEXT = 
            new ThreadLocal<>();
        
        static class RequestContext {
            String requestId;
            String userId;
        }
        
        public void doFilter(Runnable chain) {
            try {
                // Initialize context
                RequestContext ctx = new RequestContext();
                ctx.requestId = "req-" + System.currentTimeMillis();
                ctx.userId = "user123";
                
                CONTEXT.set(ctx);
                
                // Process request
                chain.run();
                
            } finally {
                // Always clean up
                CONTEXT.remove();
            }
        }
        
        public static RequestContext getContext() {
            return CONTEXT.get();
        }
    }
    
    /**
     * Pattern 5: Executor with cleanup
     */
    static class CleanupExecutor {
        private static final ThreadLocal<String> CONTEXT = new ThreadLocal<>();
        private final ExecutorService executor;
        
        public CleanupExecutor(ExecutorService executor) {
            this.executor = executor;
        }
        
        public void execute(Runnable task) {
            String capturedContext = CONTEXT.get();
            
            executor.execute(() -> {
                try {
                    if (capturedContext != null) {
                        CONTEXT.set(capturedContext);
                    }
                    task.run();
                } finally {
                    CONTEXT.remove();  // Clean up in worker thread
                }
            });
        }
        
        public void shutdown() {
            executor.shutdown();
        }
    }
    
    /**
     * Anti-pattern: No cleanup
     */
    static class BadPattern {
        private static final ThreadLocal<byte[]> CONTEXT = new ThreadLocal<>();
        
        public void processRequest() {
            // BAD: Set but never remove
            CONTEXT.set(new byte[1024 * 1024]);  // 1MB
            
            // Do work
            
            // Missing: CONTEXT.remove();
        }
        
        /**
         * PROBLEM:
         * - In thread pool, thread reused
         * - Context never cleared
         * - Memory accumulates
         * - OutOfMemoryError
         */
    }
    
    /**
     * Verification: Check for leaks
     */
    static class LeakDetector {
        private static final ThreadLocal<String> CONTEXT = new ThreadLocal<>();
        private static final java.util.concurrent.atomic.AtomicInteger 
            setCount = new java.util.concurrent.atomic.AtomicInteger();
        private static final java.util.concurrent.atomic.AtomicInteger 
            removeCount = new java.util.concurrent.atomic.AtomicInteger();
        
        public static void set(String value) {
            CONTEXT.set(value);
            setCount.incrementAndGet();
        }
        
        public static String get() {
            return CONTEXT.get();
        }
        
        public static void remove() {
            CONTEXT.remove();
            removeCount.incrementAndGet();
        }
        
        public static void printStats() {
            System.out.println("Sets: " + setCount.get());
            System.out.println("Removes: " + removeCount.get());
            System.out.println("Potential leaks: " + 
                (setCount.get() - removeCount.get()));
        }
    }
    
    public static void leakDetectionDemo() throws InterruptedException {
        ExecutorService executor = Executors.newFixedThreadPool(2);
        
        for (int i = 0; i < 10; i++) {
            executor.submit(() -> {
                try {
                    LeakDetector.set("data");
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    LeakDetector.remove();  // Good!
                }
            });
        }
        
        executor.shutdown();
        executor.awaitTermination(5, TimeUnit.SECONDS);
        
        LeakDetector.printStats();
        
        /**
         * OUTPUT:
         * Sets: 10
         * Removes: 10
         * Potential leaks: 0
         * 
         * MONITORING:
         * - Track set/remove ratio
         * - Should be 1:1
         * - Alert if diverges
         */
    }
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== Wrapper Demo ===");
        wrapperDemo();
        
        System.out.println("\n=== Leak Detection ===");
        leakDetectionDemo();
        
        System.out.println("\n=== AutoCloseable ===");
        AutoCloseableContext.demo();
    }
}
```

---

## Summary

### Quick Reference

**Basic ThreadLocal:**

```java
ThreadLocal<String> context = ThreadLocal.withInitial(() -> "default");

// Set value
context.set("my-value");

// Get value
String value = context.get();

// CRITICAL: Always clean up
context.remove();
```

**With try-finally:**

```java
try {
    threadLocal.set(value);
    // use value
} finally {
    threadLocal.remove();  // ALWAYS
}
```

**InheritableThreadLocal:**

```java
InheritableThreadLocal<String> context = new InheritableThreadLocal<>();
context.set("parent-value");

new Thread(() -> {
    System.out.println(context.get());  // Inherits parent-value
}).start();
```

**Context propagation:**

```java
// Capture before async
String captured = threadLocal.get();

CompletableFuture.runAsync(() -> {
    try {
        threadLocal.set(captured);  // Restore
        // work
    } finally {
        threadLocal.remove();  // Clean up
    }
});
```

**MDC pattern:**

```java
try {
    MDC.put("requestId", requestId);
    MDC.put("userId", userId);
    // logging will include context
} finally {
    MDC.clear();
}
```

### Memory Leak Prevention

**CRITICAL RULES:**

1. ✅ **ALWAYS call remove()** in finally block
2. ✅ **Use try-finally** pattern without exception
3. ✅ **Clean up in thread pools** (threads reused!)
4. ✅ **Propagate context** to async threads explicitly
5. ❌ **NEVER forget remove()** - leads to OutOfMemoryError
6. ❌ **Don't rely on GC** - strong reference keeps values alive
7. ❌ **Don't use InheritableThreadLocal** with thread pools

### Best Practices

**Pattern 1: Always clean up**

```java
// CORRECT
try {
    threadLocal.set(value);
    doWork();
} finally {
    threadLocal.remove();
}

// WRONG - Memory leak!
threadLocal.set(value);
doWork();
```

**Pattern 2: AutoCloseable**

```java
try (Context ctx = new Context(value)) {
    // work
}  // Auto cleanup
```

**Pattern 3: Wrapper**

```java
contextWrapper.runWithContext(value, () -> {
    // work
});  // Auto cleanup
```

**Pattern 4: Async propagation**

```java
Map<String, String> context = MDC.getCopyOfContextMap();

CompletableFuture.runAsync(() -> {
    try {
        MDC.setContextMap(context);
        work();
    } finally {
        MDC.clear();
    }
});
```

### Common Pitfalls

**❌ Pitfall 1: Forgetting remove()**

```java
// WRONG
public void handleRequest() {
    userContext.set(user);
    process();
    // Missing: userContext.remove();
}
// Result: Memory leak in thread pool
```

**❌ Pitfall 2: InheritableThreadLocal with thread pools**

```java
// WRONG
InheritableThreadLocal<String> ctx = new InheritableThreadLocal<>();
ctx.set("value");

executor.submit(() -> {
    // May see stale value from previous task!
});
```

**❌ Pitfall 3: Async without propagation**

```java
// WRONG
threadLocal.set("value");

CompletableFuture.runAsync(() -> {
    threadLocal.get();  // null!
});
```

---

