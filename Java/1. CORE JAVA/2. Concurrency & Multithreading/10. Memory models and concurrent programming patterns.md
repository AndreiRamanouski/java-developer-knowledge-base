# Java Memory Model and Concurrent Programming Patterns

## Overview

The Java Memory Model (JMM) defines how threads interact through memory and what behaviors are allowed in concurrent execution. Understanding the JMM is essential for writing correct concurrent code. This guide covers memory visibility, atomicity, ordering, and essential concurrent programming patterns.


---

## 1. Java Memory Model (JMM)

### Fundamental Concepts

```java
/**
 * JAVA MEMORY MODEL
 * 
 * Defines how threads interact through memory
 */

public class JavaMemoryModel {
    
    /**
     * The basic problem
     */
    public static void visibilityProblem() throws InterruptedException {
        VisibilityDemo demo = new VisibilityDemo();
        
        // Thread 1: Writer
        Thread writer = new Thread(() -> {
            try {
                Thread.sleep(100);
                demo.setValue(42);
                System.out.println("Writer: Set value to 42");
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        
        // Thread 2: Reader
        Thread reader = new Thread(() -> {
            while (demo.getValue() == 0) {
                // Spin waiting
            }
            System.out.println("Reader: Saw value " + demo.getValue());
        });
        
        reader.start();
        writer.start();
        
        reader.join(5000);
        writer.join();
        
        if (reader.isAlive()) {
            System.out.println("Reader still spinning - visibility problem!");
            reader.interrupt();
        }
        
        /**
         * POTENTIAL ISSUE:
         * - Writer updates value = 42
         * - Reader may NEVER see the update
         * - Reader spins forever
         * 
         * WHY?
         * - No synchronization between threads
         * - No happens-before relationship
         * - No visibility guarantee
         */
    }
    
    static class VisibilityDemo {
        private int value = 0;  // NOT volatile!
        
        public void setValue(int value) {
            this.value = value;
        }
        
        public int getValue() {
            return value;
        }
    }
    
    /**
     * How the JMM works
     */
    public static void jmmArchitecture() {
        /**
         * JAVA MEMORY MODEL ARCHITECTURE:
         * 
         * Main Memory (Heap)
         *       ↑
         *       ↓
         * ┌─────────────┐
         * │  Thread 1   │
         * │  ┌────────┐ │
         * │  │Working │ │  ← Each thread has its own working memory
         * │  │Memory  │ │  ← Caches, registers, CPU cache
         * │  └────────┘ │
         * └─────────────┘
         * 
         * ┌─────────────┐
         * │  Thread 2   │
         * │  ┌────────┐ │
         * │  │Working │ │
         * │  │Memory  │ │
         * │  └────────┘ │
         * └─────────────┘
         * 
         * 
         * PROBLEM:
         * 1. Thread writes to working memory
         * 2. Value may not be flushed to main memory
         * 3. Other thread reads from main memory
         * 4. Sees stale value!
         * 
         * SOLUTION: Happens-Before relationship
         */
    }
    
    /**
     * Happens-Before rules
     */
    public static void happensBeforeRules() {
        /**
         * HAPPENS-BEFORE RELATIONSHIP:
         * 
         * If A happens-before B, then:
         * - All memory writes by A are visible to B
         * - A is ordered before B
         * 
         * RULES:
         * 
         * 1. PROGRAM ORDER:
         *    - Each action in a thread happens-before every subsequent action
         *    - Within a single thread
         * 
         * 2. MONITOR LOCK (synchronized):
         *    - Unlock on monitor happens-before every subsequent lock
         *    - synchronized blocks create happens-before
         * 
         * 3. VOLATILE:
         *    - Write to volatile happens-before every subsequent read
         *    - volatile provides visibility guarantee
         * 
         * 4. THREAD START:
         *    - thread.start() happens-before any action in started thread
         * 
         * 5. THREAD JOIN:
         *    - All actions in thread happen-before thread.join() returns
         * 
         * 6. TRANSITIVITY:
         *    - If A happens-before B, and B happens-before C
         *    - Then A happens-before C
         * 
         * 7. INITIALIZATION:
         *    - Constructor finishes happens-before finalize() starts
         * 
         * 8. INTERRUPTION:
         *    - Thread.interrupt() happens-before interrupted thread detects it
         */
    }
    
    /**
     * volatile keyword
     */
    static class VolatileExample {
        private volatile boolean flag = false;  // volatile!
        private int value = 0;
        
        public void writer() {
            value = 42;        // 1. Write value
            flag = true;       // 2. Write volatile flag
            
            /**
             * HAPPENS-BEFORE:
             * - Write to value happens-before write to flag
             * - Write to flag happens-before any read of flag
             * - Therefore: value write visible to readers of flag
             */
        }
        
        public void reader() {
            if (flag) {        // 1. Read volatile flag
                int v = value; // 2. Read value
                System.out.println("Value: " + v);  // Always 42!
                
                /**
                 * GUARANTEE:
                 * - Read of flag happens-after write to flag
                 * - Therefore sees value = 42
                 * - volatile creates happens-before
                 */
            }
        }
    }
    
    /**
     * synchronized keyword
     */
    static class SynchronizedExample {
        private int value = 0;
        private final Object lock = new Object();
        
        public void writer() {
            synchronized (lock) {  // Acquire monitor
                value = 42;
            }  // Release monitor
            
            /**
             * HAPPENS-BEFORE:
             * - All writes before monitor release
             * - Are visible after monitor acquire
             */
        }
        
        public void reader() {
            synchronized (lock) {  // Acquire monitor
                int v = value;
                System.out.println("Value: " + v);  // Sees 42
            }
            
            /**
             * GUARANTEE:
             * - Monitor release happens-before monitor acquire
             * - Therefore sees value = 42
             */
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== Visibility Problem ===");
        visibilityProblem();
    }
}
```

---

## 2. Visibility, Atomicity, and Ordering

### Understanding the Three Properties

```java
/**
 * VISIBILITY, ATOMICITY, ORDERING
 * 
 * Three critical properties for concurrent code
 */

public class VisibilityAtomicityOrdering {
    
    /**
     * VISIBILITY: Can threads see each other's writes?
     */
    static class VisibilityExample {
        // WITHOUT visibility guarantee
        private int counter = 0;
        
        public void badIncrement() {
            counter++;  // Read-modify-write
            
            /**
             * PROBLEM:
             * Thread 1: Reads 0, increments to 1, writes to cache
             * Thread 2: Reads 0 (doesn't see Thread 1's write)
             * Result: Lost update!
             */
        }
        
        // WITH visibility guarantee
        private volatile int volatileCounter = 0;
        
        public void visibleWrite() {
            volatileCounter = 42;
            
            /**
             * GUARANTEE:
             * - Write visible to all threads
             * - But still not atomic!
             */
        }
    }
    
    /**
     * ATOMICITY: Is operation indivisible?
     */
    static class AtomicityExample {
        private long counter = 0;  // 64-bit value
        
        public void nonAtomicWrite() {
            counter = 0x0123456789ABCDEFL;
            
            /**
             * PROBLEM:
             * - long write NOT atomic on 32-bit JVM
             * - May write high 32 bits, then low 32 bits
             * - Reader may see:
             *   - Old high bits + new low bits
             *   - New high bits + old low bits
             * - Torn read/write!
             */
        }
        
        private volatile long volatileCounter = 0;
        
        public void atomicWrite() {
            volatileCounter = 0x0123456789ABCDEFL;
            
            /**
             * GUARANTEE:
             * - volatile long/double writes are atomic
             * - Reader sees complete value
             */
        }
        
        // Compound operation - NOT atomic even with volatile!
        private volatile int value = 0;
        
        public void nonAtomicIncrement() {
            value++;  // Read-modify-write
            
            /**
             * PROBLEM:
             * Even though value is volatile:
             * - Read is atomic
             * - Write is atomic
             * - But read-modify-write is NOT atomic!
             * 
             * Thread 1: Reads 0
             * Thread 2: Reads 0
             * Thread 1: Writes 1
             * Thread 2: Writes 1
             * Result: Lost update!
             */
        }
        
        private final java.util.concurrent.atomic.AtomicInteger atomicValue = 
            new java.util.concurrent.atomic.AtomicInteger(0);
        
        public void atomicIncrement() {
            atomicValue.incrementAndGet();
            
            /**
             * GUARANTEE:
             * - Entire operation is atomic
             * - Uses CAS (Compare-And-Swap)
             * - No lost updates
             */
        }
    }
    
    /**
     * ORDERING: Can operations be reordered?
     */
    static class OrderingExample {
        private int a = 0;
        private int b = 0;
        
        public void writer() {
            a = 1;  // 1
            b = 2;  // 2
            
            /**
             * COMPILER/CPU MAY REORDER:
             * - If no data dependency
             * - May execute: b = 2; then a = 1;
             * - Within single thread: No visible difference
             * - But other threads may see!
             */
        }
        
        public void reader() {
            if (b == 2) {           // Sees b = 2
                System.out.println("a = " + a);  // May see a = 0!
                
                /**
                 * PROBLEM:
                 * - Writer reordered: b = 2 before a = 1
                 * - Reader sees b = 2 but a still 0
                 * - Unexpected behavior!
                 */
            }
        }
        
        // WITH ordering guarantee
        private volatile int c = 0;
        private volatile int d = 0;
        
        public void orderedWriter() {
            c = 1;  // 1
            d = 2;  // 2
            
            /**
             * GUARANTEE:
             * - volatile prevents reordering
             * - c = 1 always happens before d = 2
             * - Readers see consistent order
             */
        }
        
        public void orderedReader() {
            if (d == 2) {           // Sees d = 2
                System.out.println("c = " + c);  // Always sees c = 1
            }
        }
    }
    
    /**
     * Summary table
     */
    public static void summary() {
        /**
         * ┌──────────────────┬────────────┬─────────────┬──────────────┐
         * │ Mechanism        │ Visibility │ Atomicity   │ Ordering     │
         * ├──────────────────┼────────────┼─────────────┼──────────────┤
         * │ volatile         │ YES        │ Read/Write  │ YES          │
         * │                  │            │ (NOT R-M-W) │              │
         * ├──────────────────┼────────────┼─────────────┼──────────────┤
         * │ synchronized     │ YES        │ YES         │ YES          │
         * ├──────────────────┼────────────┼─────────────┼──────────────┤
         * │ AtomicInteger    │ YES        │ YES         │ YES          │
         * ├──────────────────┼────────────┼─────────────┼──────────────┤
         * │ final            │ YES        │ N/A         │ YES          │
         * │                  │ (after     │ (immutable) │ (after       │
         * │                  │ construct) │             │ construct)   │
         * └──────────────────┴────────────┴─────────────┴──────────────┘
         * 
         * USE CASES:
         * 
         * volatile:
         * - Flags (boolean flag)
         * - Status (int status)
         * - Single writes (no compound operations)
         * 
         * synchronized:
         * - Compound operations
         * - Multiple related fields
         * - Blocking acceptable
         * 
         * AtomicInteger:
         * - Counter (incrementAndGet)
         * - Non-blocking required
         * - Single value updates
         * 
         * final:
         * - Immutable objects
         * - Safe publication
         * - No synchronization needed
         */
    }
    
    /**
     * Common mistakes
     */
    static class CommonMistakes {
        // MISTAKE 1: volatile for compound operations
        private volatile int counter = 0;
        
        public void wrongIncrement() {
            counter++;  // NOT ATOMIC! Race condition!
        }
        
        // CORRECT
        private final java.util.concurrent.atomic.AtomicInteger correctCounter = 
            new java.util.concurrent.atomic.AtomicInteger(0);
        
        public void correctIncrement() {
            correctCounter.incrementAndGet();  // Atomic
        }
        
        // MISTAKE 2: Missing volatile on flag
        private boolean done = false;  // NOT volatile!
        
        public void setDone() {
            done = true;  // May not be visible!
        }
        
        public void waitUntilDone() {
            while (!done) {
                // May spin forever!
            }
        }
        
        // CORRECT
        private volatile boolean correctDone = false;
        
        public void setCorrectDone() {
            correctDone = true;  // Visible to all threads
        }
        
        // MISTAKE 3: Assuming visibility without synchronization
        private int x = 0;
        private int y = 0;
        
        public void unsafeWrite() {
            x = 1;
            y = 2;
        }
        
        public void unsafeRead() {
            if (y == 2) {
                // May still see x = 0!
            }
        }
    }
}
```

---

## 3. Safe Publication Patterns

### Publishing Objects Safely

```java
/**
 * SAFE PUBLICATION
 * 
 * How to safely make objects visible to other threads
 */

import java.util.concurrent.*;

public class SafePublication {
    
    /**
     * UNSAFE publication
     */
    static class UnsafePublication {
        private Resource resource;
        
        public void initialize() {
            resource = new Resource();  // NOT thread-safe!
            
            /**
             * PROBLEM:
             * Other thread may see:
             * - resource != null
             * - But resource partially constructed!
             * - Can see default field values
             */
        }
        
        public Resource getResource() {
            return resource;
        }
        
        static class Resource {
            private final int value;
            private final String name;
            
            public Resource() {
                value = 42;
                name = "Resource";
                
                /**
                 * PROBLEM:
                 * - Constructor executes: value = 42, name = "Resource"
                 * - But reference may be visible before fields!
                 * - Other thread may see value = 0, name = null
                 */
            }
        }
    }
    
    /**
     * Pattern 1: Initialization with volatile
     */
    static class VolatilePublication {
        private volatile Resource resource;  // volatile!
        
        public void initialize() {
            resource = new Resource();
            
            /**
             * SAFE:
             * - volatile write happens-after constructor
             * - Readers see fully constructed object
             */
        }
        
        public Resource getResource() {
            return resource;
        }
        
        static class Resource {
            private final int value = 42;
            private final String name = "Resource";
        }
    }
    
    /**
     * Pattern 2: Initialization with synchronized
     */
    static class SynchronizedPublication {
        private Resource resource;
        
        public synchronized void initialize() {
            resource = new Resource();
            
            /**
             * SAFE:
             * - synchronized provides happens-before
             * - Monitor release happens-before next acquire
             */
        }
        
        public synchronized Resource getResource() {
            return resource;
        }
        
        static class Resource {
            private final int value = 42;
        }
    }
    
    /**
     * Pattern 3: Static initializer
     */
    static class StaticInitializerPublication {
        // Initialized by class loader
        private static final Resource INSTANCE = new Resource();
        
        public static Resource getInstance() {
            return INSTANCE;
        }
        
        /**
         * SAFE:
         * - Static initialization happens-before first use
         * - Class loader guarantees visibility
         * - Thread-safe by JVM
         */
        
        static class Resource {
            private final int value = 42;
        }
    }
    
    /**
     * Pattern 4: final fields
     */
    static class FinalFieldPublication {
        private final Resource resource;  // final!
        
        public FinalFieldPublication() {
            resource = new Resource();
            
            /**
             * SAFE:
             * - final field freeze guarantee
             * - Readers see fully constructed object
             * - After constructor completes
             */
        }
        
        public Resource getResource() {
            return resource;
        }
        
        static class Resource {
            private final int value = 42;
        }
    }
    
    /**
     * Pattern 5: Thread-safe collection
     */
    static class CollectionPublication {
        private final ConcurrentHashMap<String, Resource> resources = 
            new ConcurrentHashMap<>();
        
        public void publish(String key, Resource resource) {
            resources.put(key, resource);
            
            /**
             * SAFE:
             * - ConcurrentHashMap provides happens-before
             * - put() happens-before get()
             * - Safe publication guaranteed
             */
        }
        
        public Resource getResource(String key) {
            return resources.get(key);
        }
        
        static class Resource {
            private final int value = 42;
        }
    }
    
    /**
     * Pattern 6: Blocking queue
     */
    static class BlockingQueuePublication {
        private final BlockingQueue<Resource> queue = 
            new LinkedBlockingQueue<>();
        
        public void produce() throws InterruptedException {
            Resource resource = new Resource();
            queue.put(resource);
            
            /**
             * SAFE:
             * - put() happens-before take()
             * - BlockingQueue guarantees visibility
             */
        }
        
        public Resource consume() throws InterruptedException {
            return queue.take();
        }
        
        static class Resource {
            private final int value = 42;
        }
    }
    
    /**
     * Summary of safe publication
     */
    public static void safePublicationSummary() {
        /**
         * SAFE PUBLICATION IDIOMS:
         * 
         * 1. Initialize object from static initializer
         * 2. Store reference in volatile field
         * 3. Store reference in final field
         * 4. Store reference in field guarded by synchronized
         * 5. Store reference in concurrent collection
         * 6. Pass through BlockingQueue
         * 
         * IMMUTABLE OBJECTS:
         * - Final fields
         * - No setters
         * - Safe to publish without synchronization
         * - Once visible, always correct
         * 
         * EFFECTIVELY IMMUTABLE:
         * - No modification after construction
         * - Can be safely published
         * - Example: String, Integer
         */
    }
    
    /**
     * Double-checked locking (modern correct version)
     */
    static class DoubleCheckedLocking {
        private volatile Resource resource;  // MUST be volatile!
        
        public Resource getInstance() {
            Resource r = resource;  // Local copy
            
            if (r == null) {
                synchronized (this) {
                    r = resource;  // Re-check
                    if (r == null) {
                        r = new Resource();
                        resource = r;  // Publish via volatile
                    }
                }
            }
            
            return r;
            
            /**
             * WHY volatile is REQUIRED:
             * 
             * Without volatile:
             * - Thread 1: Creates Resource, assigns to resource
             * - Thread 2: Sees resource != null
             * - But may see partially constructed Resource!
             * 
             * With volatile:
             * - Write to volatile happens-before read
             * - Guarantees visibility of constructor
             * - Thread 2 sees fully constructed Resource
             * 
             * BROKEN before Java 5:
             * - JMM didn't guarantee ordering
             * - Even with volatile, could fail
             * - Now safe with Java 5+ JMM
             */
        }
        
        static class Resource {
            private final int value = 42;
        }
    }
}
```

---

## 4. Producer-Consumer Pattern

### Classic Concurrency Pattern

```java
/**
 * PRODUCER-CONSUMER PATTERN
 * 
 * Multiple implementations showing different techniques
 */

import java.util.concurrent.*;
import java.util.*;

public class ProducerConsumerPattern {
    
    /**
     * Version 1: wait/notify with synchronized
     */
    static class WaitNotifyQueue<T> {
        private final Queue<T> queue = new LinkedList<>();
        private final int capacity;
        
        public WaitNotifyQueue(int capacity) {
            this.capacity = capacity;
        }
        
        public synchronized void put(T item) throws InterruptedException {
            while (queue.size() == capacity) {
                wait();  // Wait for space
            }
            
            queue.add(item);
            notifyAll();  // Wake consumers
        }
        
        public synchronized T take() throws InterruptedException {
            while (queue.isEmpty()) {
                wait();  // Wait for items
            }
            
            T item = queue.remove();
            notifyAll();  // Wake producers
            return item;
        }
        
        /**
         * CHARACTERISTICS:
         * - Uses synchronized + wait/notify
         * - Manual coordination
         * - Bounded queue
         * - Blocking operations
         */
    }
    
    public static void waitNotifyDemo() throws InterruptedException {
        WaitNotifyQueue<Integer> queue = new WaitNotifyQueue<>(5);
        
        // Producer
        Thread producer = new Thread(() -> {
            try {
                for (int i = 0; i < 10; i++) {
                    queue.put(i);
                    System.out.println("Produced: " + i);
                    Thread.sleep(100);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        
        // Consumer
        Thread consumer = new Thread(() -> {
            try {
                for (int i = 0; i < 10; i++) {
                    int item = queue.take();
                    System.out.println("Consumed: " + item);
                    Thread.sleep(200);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        
        producer.start();
        consumer.start();
        producer.join();
        consumer.join();
    }
    
    /**
     * Version 2: BlockingQueue (recommended)
     */
    static class BlockingQueueProducerConsumer {
        private final BlockingQueue<Integer> queue;
        
        public BlockingQueueProducerConsumer(int capacity) {
            this.queue = new ArrayBlockingQueue<>(capacity);
        }
        
        public void produce(int item) throws InterruptedException {
            queue.put(item);  // Blocks if full
            System.out.println("Produced: " + item);
        }
        
        public int consume() throws InterruptedException {
            int item = queue.take();  // Blocks if empty
            System.out.println("Consumed: " + item);
            return item;
        }
        
        /**
         * ADVANTAGES:
         * - Built-in blocking
         * - Thread-safe
         * - Well-tested
         * - Multiple implementations available
         */
    }
    
    public static void blockingQueueDemo() throws InterruptedException {
        BlockingQueueProducerConsumer pc = new BlockingQueueProducerConsumer(5);
        
        Thread producer = new Thread(() -> {
            try {
                for (int i = 0; i < 10; i++) {
                    pc.produce(i);
                    Thread.sleep(100);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        
        Thread consumer = new Thread(() -> {
            try {
                for (int i = 0; i < 10; i++) {
                    pc.consume();
                    Thread.sleep(200);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        
        producer.start();
        consumer.start();
        producer.join();
        consumer.join();
    }
    
    /**
     * Version 3: Lock and Condition (explicit)
     */
    static class LockConditionQueue<T> {
        private final Queue<T> queue = new LinkedList<>();
        private final int capacity;
        private final java.util.concurrent.locks.Lock lock = 
            new java.util.concurrent.locks.ReentrantLock();
        private final java.util.concurrent.locks.Condition notFull = 
            lock.newCondition();
        private final java.util.concurrent.locks.Condition notEmpty = 
            lock.newCondition();
        
        public LockConditionQueue(int capacity) {
            this.capacity = capacity;
        }
        
        public void put(T item) throws InterruptedException {
            lock.lock();
            try {
                while (queue.size() == capacity) {
                    notFull.await();  // Wait for space
                }
                
                queue.add(item);
                notEmpty.signal();  // Wake one consumer
            } finally {
                lock.unlock();
            }
        }
        
        public T take() throws InterruptedException {
            lock.lock();
            try {
                while (queue.isEmpty()) {
                    notEmpty.await();  // Wait for items
                }
                
                T item = queue.remove();
                notFull.signal();  // Wake one producer
                return item;
            } finally {
                lock.unlock();
            }
        }
        
        /**
         * ADVANTAGES over wait/notify:
         * - Separate conditions (more efficient)
         * - signal() wakes one thread (not all)
         * - More control over locking
         * - Can use tryLock()
         */
    }
    
    /**
     * Version 4: Non-blocking (ConcurrentLinkedQueue)
     */
    static class NonBlockingProducerConsumer {
        private final ConcurrentLinkedQueue<Integer> queue = 
            new ConcurrentLinkedQueue<>();
        
        public void produce(int item) {
            queue.offer(item);  // Non-blocking
            System.out.println("Produced: " + item);
        }
        
        public Integer consume() {
            Integer item = queue.poll();  // Non-blocking, may return null
            if (item != null) {
                System.out.println("Consumed: " + item);
            }
            return item;
        }
        
        /**
         * CHARACTERISTICS:
         * - Non-blocking (lock-free)
         * - High throughput
         * - No capacity limit
         * - Consumer must handle null
         */
    }
    
    /**
     * Version 5: Multiple producers and consumers
     */
    static class MultiProducerConsumer {
        private final BlockingQueue<Integer> queue;
        private final int producers;
        private final int consumers;
        
        public MultiProducerConsumer(int capacity, int producers, int consumers) {
            this.queue = new LinkedBlockingQueue<>(capacity);
            this.producers = producers;
            this.consumers = consumers;
        }
        
        public void run() throws InterruptedException {
            // Poison pill to signal completion
            final Integer POISON_PILL = -1;
            
            // Start producers
            List<Thread> producerThreads = new ArrayList<>();
            for (int i = 0; i < producers; i++) {
                final int producerId = i;
                Thread t = new Thread(() -> {
                    try {
                        for (int j = 0; j < 10; j++) {
                            int value = producerId * 100 + j;
                            queue.put(value);
                            System.out.println("Producer-" + producerId + 
                                " produced: " + value);
                            Thread.sleep(100);
                        }
                        // Send poison pill
                        queue.put(POISON_PILL);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                });
                producerThreads.add(t);
                t.start();
            }
            
            // Start consumers
            List<Thread> consumerThreads = new ArrayList<>();
            for (int i = 0; i < consumers; i++) {
                final int consumerId = i;
                Thread t = new Thread(() -> {
                    try {
                        int poisonPillCount = 0;
                        while (poisonPillCount < producers) {
                            Integer item = queue.take();
                            if (item.equals(POISON_PILL)) {
                                poisonPillCount++;
                                queue.put(POISON_PILL);  // For other consumers
                            } else {
                                System.out.println("Consumer-" + consumerId + 
                                    " consumed: " + item);
                                Thread.sleep(150);
                            }
                        }
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                });
                consumerThreads.add(t);
                t.start();
            }
            
            // Wait for completion
            for (Thread t : producerThreads) {
                t.join();
            }
            for (Thread t : consumerThreads) {
                t.join();
            }
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== Wait/Notify ===");
        waitNotifyDemo();
        
        System.out.println("\n=== BlockingQueue ===");
        blockingQueueDemo();
        
        System.out.println("\n=== Multi Producer-Consumer ===");
        new MultiProducerConsumer(10, 2, 3).run();
    }
}
```

---

## 5. Thread-Safe Singleton Patterns

### Safe Singleton Implementations

```java
/**
 * THREAD-SAFE SINGLETON PATTERNS
 * 
 * Various ways to implement singleton safely
 */

public class SingletonPatterns {
    
    /**
     * Pattern 1: Eager initialization
     */
    static class EagerSingleton {
        private static final EagerSingleton INSTANCE = new EagerSingleton();
        
        private EagerSingleton() {
            // Private constructor
        }
        
        public static EagerSingleton getInstance() {
            return INSTANCE;
        }
        
        /**
         * CHARACTERISTICS:
         * - Thread-safe (class loading is thread-safe)
         * - Simple
         * - Eager initialization (created at class load)
         * - No lazy loading
         * 
         * USE WHEN:
         * - Instance always needed
         * - Construction is cheap
         * - No complex initialization
         */
    }
    
    /**
     * Pattern 2: Lazy initialization with synchronized
     */
    static class SynchronizedLazySingleton {
        private static SynchronizedLazySingleton instance;
        
        private SynchronizedLazySingleton() {
        }
        
        public static synchronized SynchronizedLazySingleton getInstance() {
            if (instance == null) {
                instance = new SynchronizedLazySingleton();
            }
            return instance;
        }
        
        /**
         * CHARACTERISTICS:
         * - Thread-safe
         * - Lazy initialization
         * - Poor performance (synchronized on every call)
         * 
         * PROBLEM:
         * - Synchronization overhead on every access
         * - Even after instance created
         */
    }
    
    /**
     * Pattern 3: Double-checked locking (modern, Java 5+)
     */
    static class DoubleCheckedLockingSingleton {
        private static volatile DoubleCheckedLockingSingleton instance;
        
        private DoubleCheckedLockingSingleton() {
        }
        
        public static DoubleCheckedLockingSingleton getInstance() {
            DoubleCheckedLockingSingleton result = instance;
            
            if (result == null) {  // First check (no locking)
                synchronized (DoubleCheckedLockingSingleton.class) {
                    result = instance;
                    if (result == null) {  // Second check (with locking)
                        result = new DoubleCheckedLockingSingleton();
                        instance = result;
                    }
                }
            }
            
            return result;
        }
        
        /**
         * CHARACTERISTICS:
         * - Thread-safe
         * - Lazy initialization
         * - Good performance (lock only on first access)
         * - MUST use volatile (or broken before Java 5)
         * 
         * WHY volatile REQUIRED:
         * - Without volatile, reordering possible
         * - Thread may see instance != null
         * - But object partially constructed
         * - volatile prevents reordering
         * 
         * CORRECT in Java 5+
         * BROKEN in Java 1.4 and earlier
         */
    }
    
    /**
     * Pattern 4: Initialization-on-demand holder
     */
    static class HolderSingleton {
        private HolderSingleton() {
        }
        
        private static class Holder {
            private static final HolderSingleton INSTANCE = new HolderSingleton();
        }
        
        public static HolderSingleton getInstance() {
            return Holder.INSTANCE;
        }
        
        /**
         * CHARACTERISTICS:
         * - Thread-safe (class loading is thread-safe)
         * - Lazy initialization (Holder loaded on first access)
         * - No synchronization overhead
         * - No volatile needed
         * - BEST PRACTICE for most cases
         * 
         * HOW IT WORKS:
         * - Holder class loaded only when getInstance() called
         * - Class loading is thread-safe by JVM
         * - Instance created during class loading
         * - Perfect lazy initialization!
         */
    }
    
    /**
     * Pattern 5: Enum singleton (Java 5+)
     */
    enum EnumSingleton {
        INSTANCE;
        
        public void doSomething() {
            System.out.println("Enum singleton");
        }
        
        /**
         * CHARACTERISTICS:
         * - Thread-safe
         * - Serialization-safe (prevents multiple instances)
         * - Reflection-proof
         * - Concise
         * - BEST PRACTICE when serialization needed
         * 
         * ADVANTAGES:
         * - Enum instances are inherently serializable
         * - JVM guarantees single instance
         * - Can't be instantiated via reflection
         * - Simplest code
         * 
         * RECOMMENDED by Joshua Bloch (Effective Java)
         */
    }
    
    /**
     * Pattern 6: Thread-local singleton
     */
    static class ThreadLocalSingleton {
        private static final ThreadLocal<ThreadLocalSingleton> INSTANCE = 
            ThreadLocal.withInitial(ThreadLocalSingleton::new);
        
        private ThreadLocalSingleton() {
        }
        
        public static ThreadLocalSingleton getInstance() {
            return INSTANCE.get();
        }
        
        /**
         * CHARACTERISTICS:
         * - One instance PER THREAD
         * - Not a true singleton!
         * - No synchronization needed
         * - Thread-safe by design
         * 
         * USE WHEN:
         * - Need per-thread instance
         * - Example: SimpleDateFormat per thread
         * - Not for true singleton pattern
         */
    }
    
    /**
     * Comparison
     */
    public static void comparison() {
        /**
         * ┌────────────────────┬────────┬────────┬─────────────┬──────────────┐
         * │ Pattern            │ Lazy   │ Thread │ Performance │ Recommended  │
         * │                    │        │ Safe   │             │              │
         * ├────────────────────┼────────┼────────┼─────────────┼──────────────┤
         * │ Eager Init         │ No     │ Yes    │ Best        │ Simple cases │
         * │ Synchronized Lazy  │ Yes    │ Yes    │ Poor        │ No           │
         * │ Double-checked     │ Yes    │ Yes    │ Good        │ No (complex) │
         * │ Holder             │ Yes    │ Yes    │ Best        │ YES (best)   │
         * │ Enum               │ No     │ Yes    │ Best        │ YES (serial) │
         * │ ThreadLocal        │ N/A    │ N/A    │ Best        │ Per-thread   │
         * └────────────────────┴────────┴────────┴─────────────┴──────────────┘
         * 
         * RECOMMENDATIONS:
         * 
         * 1. HOLDER PATTERN - Default choice
         *    - Lazy, thread-safe, fast
         *    - No synchronization overhead
         *    - Clean code
         * 
         * 2. ENUM - When serialization needed
         *    - Prevents deserialization attacks
         *    - Reflection-proof
         *    - Most secure
         * 
         * 3. EAGER - When always needed
         *    - Simple
         *    - Acceptable if instance always used
         * 
         * 4. AVOID:
         *    - Synchronized lazy (too slow)
         *    - Double-checked (complex, easy to get wrong)
         */
    }
    
    public static void main(String[] args) {
        // Test thread-safety of holder pattern
        Runnable task = () -> {
            HolderSingleton instance = HolderSingleton.getInstance();
            System.out.println(Thread.currentThread().getName() + ": " + 
                System.identityHashCode(instance));
        };
        
        for (int i = 0; i < 10; i++) {
            new Thread(task).start();
        }
        
        /**
         * OUTPUT:
         * Thread-0: 123456789
         * Thread-1: 123456789
         * Thread-2: 123456789
         * ...
         * (All threads see same instance hash code)
         */
    }
}
```

---

## 6. Immutability for Concurrency

### Using Immutable Objects

```java
/**
 * IMMUTABILITY FOR CONCURRENCY
 * 
 * Immutable objects are inherently thread-safe
 */

import java.util.*;

public class ImmutabilityPatterns {
    
    /**
     * Immutable class example
     */
    static final class ImmutablePoint {
        private final int x;
        private final int y;
        
        public ImmutablePoint(int x, int y) {
            this.x = x;
            this.y = y;
        }
        
        public int getX() {
            return x;
        }
        
        public int getY() {
            return y;
        }
        
        public ImmutablePoint move(int dx, int dy) {
            return new ImmutablePoint(x + dx, y + dy);
        }
        
        /**
         * IMMUTABILITY RULES:
         * 1. Class is final (can't be subclassed)
         * 2. All fields are final
         * 3. All fields are private
         * 4. No setters
         * 5. Methods return new instances (no mutation)
         * 
         * THREAD-SAFETY:
         * - No synchronization needed
         * - Safe to share between threads
         * - No visibility issues
         * - No race conditions
         */
    }
    
    /**
     * Immutable collection wrapper
     */
    static final class ImmutableCollection<T> {
        private final List<T> items;
        
        public ImmutableCollection(Collection<T> items) {
            // Defensive copy
            this.items = new ArrayList<>(items);
        }
        
        public List<T> getItems() {
            // Return unmodifiable view
            return Collections.unmodifiableList(items);
        }
        
        public int size() {
            return items.size();
        }
        
        public T get(int index) {
            return items.get(index);
        }
        
        /**
         * DEFENSIVE COPYING:
         * - Copy in constructor
         * - Return unmodifiable view
         * - Prevents external modification
         */
    }
    
    /**
     * Immutable with mutable fields (careful!)
     */
    static final class ImmutablePerson {
        private final String name;
        private final Date birthDate;  // Date is mutable!
        
        public ImmutablePerson(String name, Date birthDate) {
            this.name = name;
            // Defensive copy of mutable object
            this.birthDate = new Date(birthDate.getTime());
        }
        
        public String getName() {
            return name;
        }
        
        public Date getBirthDate() {
            // Return defensive copy
            return new Date(birthDate.getTime());
        }
        
        /**
         * MUTABLE FIELD HANDLING:
         * - Copy in constructor
         * - Copy in getter
         * - Never expose mutable field directly
         * 
         * BETTER: Use immutable types
         * - Use LocalDate instead of Date
         * - Use String, Integer, etc.
         */
    }
    
    /**
     * Builder pattern for immutable objects
     */
    static final class ImmutableUser {
        private final String username;
        private final String email;
        private final int age;
        private final List<String> roles;
        
        private ImmutableUser(Builder builder) {
            this.username = builder.username;
            this.email = builder.email;
            this.age = builder.age;
            this.roles = Collections.unmodifiableList(
                new ArrayList<>(builder.roles));
        }
        
        public static class Builder {
            private String username;
            private String email;
            private int age;
            private List<String> roles = new ArrayList<>();
            
            public Builder username(String username) {
                this.username = username;
                return this;
            }
            
            public Builder email(String email) {
                this.email = email;
                return this;
            }
            
            public Builder age(int age) {
                this.age = age;
                return this;
            }
            
            public Builder addRole(String role) {
                this.roles.add(role);
                return this;
            }
            
            public ImmutableUser build() {
                return new ImmutableUser(this);
            }
        }
        
        public String getUsername() { return username; }
        public String getEmail() { return email; }
        public int getAge() { return age; }
        public List<String> getRoles() { return roles; }
        
        /**
         * BUILDER ADVANTAGES:
         * - Clean construction of complex objects
         * - Optional parameters
         * - Validation in build()
         * - Thread-safe result
         */
    }
    
    /**
     * Effectively immutable
     */
    static class EffectivelyImmutable {
        private final int value;
        
        public EffectivelyImmutable(int value) {
            this.value = value;
        }
        
        public int getValue() {
            return value;
        }
        
        /**
         * EFFECTIVELY IMMUTABLE:
         * - No final keyword on class
         * - But never modified after construction
         * - Safe to publish without synchronization
         * - Once visible, always correct
         * 
         * EXAMPLES:
         * - Many third-party classes
         * - Legacy code
         * - Can treat as immutable if confident
         */
    }
    
    /**
     * Benefits of immutability
     */
    public static void benefits() {
        /**
         * BENEFITS:
         * 
         * 1. THREAD-SAFETY:
         *    - No synchronization needed
         *    - No race conditions
         *    - No visibility issues
         * 
         * 2. SIMPLICITY:
         *    - Easy to reason about
         *    - No temporal coupling
         *    - No defensive copying needed (after creation)
         * 
         * 3. CACHING:
         *    - Safe to cache
         *    - HashMap keys
         *    - No worry about modification
         * 
         * 4. PERFORMANCE:
         *    - No locking overhead
         *    - Can share freely
         *    - JVM optimizations
         * 
         * DRAWBACKS:
         * 
         * 1. OBJECT CREATION:
         *    - New object for each modification
         *    - More GC pressure
         *    - May need object pooling
         * 
         * 2. AWKWARD UPDATES:
         *    - Can't modify in-place
         *    - Need to create new instance
         *    - Builder pattern helps
         * 
         * WHEN TO USE:
         * - Value objects (Point, Money, Date)
         * - Configuration
         * - DTOs (Data Transfer Objects)
         * - Messages between threads
         * - Concurrent collections
         * 
         * WHEN NOT TO USE:
         * - Frequent modifications
         * - Large objects (expensive to copy)
         * - Performance-critical hot paths
         */
    }
    
    public static void main(String[] args) {
        // Immutable point
        ImmutablePoint p1 = new ImmutablePoint(0, 0);
        ImmutablePoint p2 = p1.move(10, 20);
        System.out.println("p1: (" + p1.getX() + ", " + p1.getY() + ")");
        System.out.println("p2: (" + p2.getX() + ", " + p2.getY() + ")");
        
        // Builder pattern
        ImmutableUser user = new ImmutableUser.Builder()
            .username("alice")
            .email("alice@example.com")
            .age(30)
            .addRole("admin")
            .addRole("user")
            .build();
        
        System.out.println("User: " + user.getUsername());
    }
}
```

---

## 7. Concurrent Design Principles

### Best Practices and Guidelines

```java
/**
 * CONCURRENT DESIGN PRINCIPLES
 * 
 * Core principles for designing concurrent systems
 */

public class ConcurrentDesignPrinciples {
    
    /**
     * Principle 1: Minimize shared mutable state
     */
    static class MinimizeSharedState {
        // BAD: Shared mutable state
        private int sharedCounter = 0;
        
        public synchronized void badIncrement() {
            sharedCounter++;  // Requires synchronization
        }
        
        // BETTER: Thread-local state
        private final ThreadLocal<Integer> threadLocalCounter = 
            ThreadLocal.withInitial(() -> 0);
        
        public void betterIncrement() {
            int current = threadLocalCounter.get();
            threadLocalCounter.set(current + 1);  // No synchronization needed
        }
        
        // BEST: Immutable or lock-free
        private final java.util.concurrent.atomic.AtomicInteger 
            atomicCounter = new java.util.concurrent.atomic.AtomicInteger(0);
        
        public void bestIncrement() {
            atomicCounter.incrementAndGet();  // Lock-free
        }
        
        /**
         * GUIDELINE:
         * 1. Prefer immutable objects
         * 2. Use thread-local when possible
         * 3. Use atomic classes for simple shared state
         * 4. Only synchronize when necessary
         */
    }
    
    /**
     * Principle 2: Encapsulate synchronization
     */
    static class EncapsulateSynchronization {
        // BAD: External synchronization
        public class BadCounter {
            public int value = 0;  // Exposed!
        }
        
        // Client must synchronize:
        // synchronized(counter) { counter.value++; }
        
        // GOOD: Internal synchronization
        public class GoodCounter {
            private int value = 0;
            
            public synchronized void increment() {
                value++;
            }
            
            public synchronized int getValue() {
                return value;
            }
        }
        
        /**
         * GUIDELINE:
         * - Encapsulate synchronization in class
         * - Don't expose mutable state
         * - Provide thread-safe methods
         * - Document synchronization policy
         */
    }
    
    /**
     * Principle 3: Use existing thread-safe collections
     */
    static class UseThreadSafeCollections {
        // BAD: Manual synchronization
        private final Map<String, String> badMap = new HashMap<>();
        
        public synchronized void badPut(String key, String value) {
            badMap.put(key, value);
        }
        
        // GOOD: Built-in thread-safe collection
        private final java.util.concurrent.ConcurrentHashMap<String, String> 
            goodMap = new java.util.concurrent.ConcurrentHashMap<>();
        
        public void goodPut(String key, String value) {
            goodMap.put(key, value);  // Already thread-safe
        }
        
        /**
         * AVAILABLE COLLECTIONS:
         * - ConcurrentHashMap
         * - CopyOnWriteArrayList
         * - ConcurrentLinkedQueue
         * - BlockingQueue implementations
         * - ConcurrentSkipListMap/Set
         * 
         * BENEFITS:
         * - Tested and optimized
         * - Better performance
         * - Less error-prone
         */
    }
    
    /**
     * Principle 4: Prefer executors to threads
     */
    static class PreferExecutors {
        // BAD: Manual thread creation
        public void badAsyncTask(Runnable task) {
            new Thread(task).start();  // Creates thread per task!
        }
        
        // GOOD: Use executor
        private final java.util.concurrent.ExecutorService executor = 
            java.util.concurrent.Executors.newFixedThreadPool(10);
        
        public void goodAsyncTask(Runnable task) {
            executor.submit(task);  // Reuses threads
        }
        
        /**
         * BENEFITS:
         * - Thread pooling
         * - Resource management
         * - Task scheduling
         * - Graceful shutdown
         */
    }
    
    /**
     * Principle 5: Use higher-level concurrency utilities
     */
    static class UseHighLevelUtilities {
        // AVOID: Low-level wait/notify
        private final Object lock = new Object();
        private boolean ready = false;
        
        public void lowLevelWait() throws InterruptedException {
            synchronized (lock) {
                while (!ready) {
                    lock.wait();
                }
            }
        }
        
        // PREFER: High-level utilities
        private final java.util.concurrent.CountDownLatch latch = 
            new java.util.concurrent.CountDownLatch(1);
        
        public void highLevelWait() throws InterruptedException {
            latch.await();
        }
        
        /**
         * HIGH-LEVEL UTILITIES:
         * - CountDownLatch, CyclicBarrier, Phaser
         * - Semaphore
         * - CompletableFuture
         * - BlockingQueue
         * - Atomic classes
         * 
         * BENEFITS:
         * - Less error-prone
         * - More expressive
         * - Better performance
         */
    }
    
    /**
     * Principle 6: Document synchronization policy
     */
    static class DocumentSynchronization {
        /**
         * Synchronization policy:
         * - accounts map guarded by accountsLock
         * - All access to accounts must hold accountsLock
         * - Operations are atomic per account
         */
        private final Object accountsLock = new Object();
        private final Map<String, Integer> accounts = new HashMap<>();
        
        public void transfer(String from, String to, int amount) {
            synchronized (accountsLock) {
                Integer fromBalance = accounts.get(from);
                Integer toBalance = accounts.get(to);
                
                accounts.put(from, fromBalance - amount);
                accounts.put(to, toBalance + amount);
            }
        }
        
        /**
         * DOCUMENTATION:
         * - Which fields are guarded by which locks
         * - Which methods must be called with locks held
         * - Invariants that must be maintained
         * - Thread-safety guarantees
         */
    }
    
    /**
     * Principle 7: Avoid holding locks during blocking operations
     */
    static class AvoidBlockingWithLocks {
        private final Object lock = new Object();
        
        // BAD: I/O while holding lock
        public void badMethod() throws java.io.IOException {
            synchronized (lock) {
                // Network call while holding lock!
                java.net.URL url = new java.net.URL("http://example.com");
                url.openStream();  // Blocks!
            }
        }
        
        // GOOD: Release lock before I/O
        public void goodMethod() throws java.io.IOException {
            Object data;
            synchronized (lock) {
                data = prepareData();  // Quick operation
            }
            
            // I/O without lock
            sendData(data);
        }
        
        private Object prepareData() {
            return new Object();
        }
        
        private void sendData(Object data) {
            // Network call
        }
        
        /**
         * GUIDELINE:
         * - Keep lock scope minimal
         * - Don't hold locks during:
         *   - I/O operations
         *   - Network calls
         *   - Long computations
         *   - Calling unknown code
         */
    }
    
    /**
     * Summary of principles
     */
    public static void summary() {
        /**
         * CONCURRENT DESIGN PRINCIPLES:
         * 
         * 1. Minimize shared mutable state
         *    - Prefer immutable objects
         *    - Use thread-local when appropriate
         *    - Limit scope of mutable state
         * 
         * 2. Encapsulate synchronization
         *    - Hide synchronization details
         *    - Provide thread-safe interface
         *    - Don't expose internals
         * 
         * 3. Use existing thread-safe collections
         *    - ConcurrentHashMap, BlockingQueue, etc.
         *    - Well-tested and optimized
         *    - Don't reinvent the wheel
         * 
         * 4. Prefer executors to threads
         *    - Thread pooling
         *    - Better resource management
         *    - Separation of task and execution
         * 
         * 5. Use higher-level utilities
         *    - CountDownLatch instead of wait/notify
         *    - CompletableFuture for async
         *    - Atomic classes for counters
         * 
         * 6. Document synchronization policy
         *    - What guards what
         *    - Invariants
         *    - Thread-safety guarantees
         * 
         * 7. Avoid blocking with locks
         *    - Keep lock scope minimal
         *    - No I/O while holding locks
         *    - No unknown code calls
         * 
         * 8. Fail fast
         *    - Validate early
         *    - Fail noisily
         *    - Don't hide concurrency bugs
         * 
         * 9. Test with concurrency
         *    - Stress tests
         *    - Multiple threads
         *    - Random delays
         * 
         * 10. Profile before optimizing
         *     - Measure contention
         *     - Find bottlenecks
         *     - Optimize hot paths only
         */
    }
}
```

---

## Summary

### Quick Reference

**Java Memory Model:**

```
Happens-Before Rules:
1. Program order within thread
2. Monitor lock (synchronized)
3. Volatile write → read
4. Thread start → thread actions
5. Thread actions → thread join
6. Transitivity

Guarantees:
- volatile: visibility + ordering
- synchronized: visibility + atomicity + ordering
- final: safe publication (after constructor)
```

**Safe Publication:**

```java
// 1. Static initializer
private static final Object INSTANCE = new Object();

// 2. volatile
private volatile Object instance;

// 3. final field
private final Object instance;

// 4. Synchronized
private Object instance;
public synchronized Object getInstance() { return instance; }

// 5. Concurrent collection
map.put(key, value);  // Safe publication
```

**Singleton (Best):**

```java
// Holder pattern
class Singleton {
    private Singleton() {}
    
    private static class Holder {
        static final Singleton INSTANCE = new Singleton();
    }
    
    public static Singleton getInstance() {
        return Holder.INSTANCE;
    }
}

// Or enum
enum Singleton {
    INSTANCE;
}
```

**Producer-Consumer:**

```java
BlockingQueue<T> queue = new ArrayBlockingQueue<>(capacity);

// Producer
queue.put(item);

// Consumer
T item = queue.take();
```

**Immutability:**

```java
final class Immutable {
    private final int value;
    
    public Immutable(int value) {
        this.value = value;
    }
    
    public int getValue() { return value; }
    
    // Return new instance
    public Immutable withValue(int newValue) {
        return new Immutable(newValue);
    }
}
```

### Best Practices

1. ✅ **Minimize shared mutable state**
2. ✅ **Use volatile for flags and status**
3. ✅ **Use AtomicInteger for counters**
4. ✅ **Use synchronized for compound operations**
5. ✅ **Prefer immutable objects**
6. ✅ **Use thread-safe collections**
7. ✅ **Document synchronization policy**
8. ✅ **Keep lock scope minimal**
9. ❌ **Don't use volatile for compound operations**
10. ❌ **Don't hold locks during I/O**

---
