# Java Thread Creation and Lifecycle

## Overview

Understanding thread creation and lifecycle is fundamental to Java concurrency. This guide covers thread creation mechanisms, state transitions, coordination patterns, and modern virtual threads introduced in Java 19+.


---

## 1. Thread vs Runnable vs Callable

### Thread Creation Methods

```java
/**
 * THREE WAYS TO CREATE THREADS IN JAVA
 */

public class ThreadCreationMethods {
    
    /**
     * METHOD 1: Extend Thread class
     * 
     * PROS:
     * - Simple and straightforward
     * - Direct access to Thread methods
     * 
     * CONS:
     * - Cannot extend another class (single inheritance)
     * - Tight coupling to Thread class
     * - Mixes task logic with thread management
     */
    static class MyThread extends Thread {
        private final String name;
        
        public MyThread(String name) {
            this.name = name;
        }
        
        @Override
        public void run() {
            System.out.println(name + " started on thread: " + 
                Thread.currentThread().getName());
            
            for (int i = 0; i < 5; i++) {
                System.out.println(name + ": " + i);
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    return;
                }
            }
            
            System.out.println(name + " finished");
        }
    }
    
    /**
     * METHOD 2: Implement Runnable interface
     * 
     * PROS:
     * - Can extend other classes
     * - Better separation of concerns (task vs thread)
     * - Can be reused with different executors
     * - Preferred approach in modern Java
     * 
     * CONS:
     * - Slightly more verbose
     * - No return value
     */
    static class MyRunnable implements Runnable {
        private final String name;
        
        public MyRunnable(String name) {
            this.name = name;
        }
        
        @Override
        public void run() {
            System.out.println(name + " executing");
            // Task logic here
        }
    }
    
    /**
     * METHOD 3: Implement Callable<V> interface
     * 
     * PROS:
     * - Can return a result
     * - Can throw checked exceptions
     * - Works with ExecutorService and Future
     * 
     * CONS:
     * - Requires ExecutorService (cannot use with Thread directly)
     * - More complex than Runnable
     */
    static class MyCallable implements java.util.concurrent.Callable<String> {
        private final String name;
        
        public MyCallable(String name) {
            this.name = name;
        }
        
        @Override
        public String call() throws Exception {
            System.out.println(name + " computing result");
            Thread.sleep(1000);
            return "Result from " + name;
        }
    }
    
    /**
     * USAGE EXAMPLES
     */
    public static void demonstrateThreadCreation() throws Exception {
        System.out.println("=== Method 1: Extending Thread ===");
        MyThread thread1 = new MyThread("Task-1");
        thread1.start();  // Start the thread
        // thread1.run();  // WRONG: This just calls run() method, doesn't start new thread
        
        System.out.println("\n=== Method 2: Implementing Runnable ===");
        MyRunnable task2 = new MyRunnable("Task-2");
        Thread thread2 = new Thread(task2);
        thread2.start();
        
        // Or with lambda (since Runnable is functional interface)
        Thread thread3 = new Thread(() -> {
            System.out.println("Lambda task executing");
        });
        thread3.start();
        
        System.out.println("\n=== Method 3: Implementing Callable ===");
        MyCallable task4 = new MyCallable("Task-4");
        
        // Callable requires ExecutorService
        java.util.concurrent.ExecutorService executor = 
            java.util.concurrent.Executors.newSingleThreadExecutor();
        
        java.util.concurrent.Future<String> future = executor.submit(task4);
        
        // Get result (blocks until complete)
        String result = future.get();
        System.out.println("Received: " + result);
        
        executor.shutdown();
        
        /**
         * OUTPUT:
         * === Method 1: Extending Thread ===
         * Task-1 started on thread: Thread-0
         * Task-1: 0
         * Task-1: 1
         * ...
         * 
         * === Method 2: Implementing Runnable ===
         * Task-2 executing
         * Lambda task executing
         * 
         * === Method 3: Implementing Callable ===
         * Task-4 computing result
         * Received: Result from Task-4
         */
    }
}
```

### Comparison and Best Practices

```java
/**
 * CHOOSING THE RIGHT APPROACH
 */

public class ThreadCreationComparison {
    
    /**
     * USE CASE 1: Fire-and-forget task (no result needed)
     * BEST: Runnable with Thread or ExecutorService
     */
    public static void fireAndForget() {
        // Simple approach
        new Thread(() -> {
            System.out.println("Background task running");
        }).start();
        
        // Better approach (production)
        java.util.concurrent.ExecutorService executor = 
            java.util.concurrent.Executors.newCachedThreadPool();
        
        executor.submit(() -> {
            System.out.println("Background task in pool");
        });
        
        executor.shutdown();
    }
    
    /**
     * USE CASE 2: Task with return value
     * BEST: Callable with ExecutorService
     */
    public static void taskWithResult() throws Exception {
        java.util.concurrent.ExecutorService executor = 
            java.util.concurrent.Executors.newSingleThreadExecutor();
        
        java.util.concurrent.Future<Integer> future = executor.submit(() -> {
            // Compute something
            Thread.sleep(1000);
            return 42;
        });
        
        Integer result = future.get();
        System.out.println("Result: " + result);
        
        executor.shutdown();
    }
    
    /**
     * USE CASE 3: Multiple related tasks
     * BEST: Runnable with shared state
     */
    static class Counter {
        private int count = 0;
        
        // Runnable that shares Counter instance
        class IncrementTask implements Runnable {
            @Override
            public void run() {
                synchronized (Counter.this) {
                    count++;
                    System.out.println(Thread.currentThread().getName() + 
                        ": count = " + count);
                }
            }
        }
        
        public void runTasks() {
            Thread t1 = new Thread(new IncrementTask(), "Thread-1");
            Thread t2 = new Thread(new IncrementTask(), "Thread-2");
            
            t1.start();
            t2.start();
        }
    }
    
    /**
     * MODERN APPROACH: ExecutorService + Lambda
     * 
     * This is the RECOMMENDED approach for production code
     */
    public static void modernApproach() {
        // Create thread pool (reuses threads)
        java.util.concurrent.ExecutorService executor = 
            java.util.concurrent.Executors.newFixedThreadPool(4);
        
        // Submit tasks
        for (int i = 0; i < 10; i++) {
            final int taskId = i;
            
            executor.submit(() -> {
                System.out.println("Task " + taskId + " on " + 
                    Thread.currentThread().getName());
            });
        }
        
        // Shutdown executor
        executor.shutdown();
        
        /**
         * BENEFITS:
         * - Thread pooling (efficient resource usage)
         * - Clean separation of task and execution
         * - Easy to change threading model
         * - Better error handling
         * - Cancellation support
         */
    }
    
    /**
     * ANTI-PATTERNS TO AVOID
     */
    public static void antiPatterns() {
        // ❌ DON'T: Call run() directly
        Thread thread = new Thread(() -> System.out.println("Task"));
        thread.run();  // WRONG: Executes in current thread, not new thread
        
        // ✅ DO: Call start()
        thread.start();  // CORRECT: Starts new thread
        
        // ❌ DON'T: Extend Thread just to override run()
        class BadThread extends Thread {
            @Override
            public void run() {
                System.out.println("Task");
            }
        }
        
        // ✅ DO: Use Runnable instead
        Runnable goodTask = () -> System.out.println("Task");
        new Thread(goodTask).start();
        
        // ❌ DON'T: Create unlimited threads
        for (int i = 0; i < 10000; i++) {
            new Thread(() -> {
                // Task
            }).start();
        }
        // Problem: Too many threads, resource exhaustion
        
        // ✅ DO: Use thread pool
        java.util.concurrent.ExecutorService executor = 
            java.util.concurrent.Executors.newFixedThreadPool(10);
        for (int i = 0; i < 10000; i++) {
            executor.submit(() -> {
                // Task
            });
        }
        executor.shutdown();
    }
}
```

---

## 2. Thread States and Lifecycle

### Thread State Machine

```java
/**
 * THREAD STATES IN JAVA
 * 
 * Thread lifecycle:
 * 
 *     NEW
 *      │
 *      │ start()
 *      ▼
 *  RUNNABLE ◄──────────────────┐
 *      │                       │
 *      │ waiting for monitor   │ notify()/notifyAll()
 *      ▼                       │ or lock released
 *   BLOCKED ───────────────────┘
 *      │
 *      │ wait()/join()/park()
 *      ▼
 *   WAITING ◄─────────────────┐
 *      │                      │ notify()/notifyAll()
 *      │ wait(timeout)/       │ or timeout/interrupt
 *      │ sleep()/join(timeout)│
 *      ▼                      │
 * TIMED_WAITING ──────────────┘
 *      │
 *      │ run() completes
 *      ▼
 *  TERMINATED
 */

public class ThreadStates {
    
    /**
     * Demonstrate all thread states
     */
    public static void demonstrateStates() throws InterruptedException {
        Object lock = new Object();
        
        // State 1: NEW
        Thread thread = new Thread(() -> {
            synchronized (lock) {
                try {
                    // State 4: WAITING
                    lock.wait();
                    
                    // State 5: TIMED_WAITING
                    Thread.sleep(1000);
                    
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });
        
        System.out.println("State after creation: " + thread.getState());
        // Output: NEW
        
        // State 2: RUNNABLE
        thread.start();
        Thread.sleep(100);  // Give thread time to start
        System.out.println("State after start: " + thread.getState());
        // Output: RUNNABLE or WAITING (if already waiting)
        
        // Wake up thread
        synchronized (lock) {
            lock.notify();
        }
        
        // State 6: TERMINATED
        thread.join();
        System.out.println("State after completion: " + thread.getState());
        // Output: TERMINATED
    }
    
    /**
     * Detailed state demonstration
     */
    public static void detailedStateDemo() throws InterruptedException {
        // NEW state
        Thread newThread = new Thread(() -> {});
        System.out.println("NEW: " + newThread.getState());
        
        // RUNNABLE state
        Thread runnableThread = new Thread(() -> {
            while (!Thread.currentThread().isInterrupted()) {
                // Busy work
                Math.random();
            }
        });
        runnableThread.start();
        Thread.sleep(10);
        System.out.println("RUNNABLE: " + runnableThread.getState());
        runnableThread.interrupt();
        
        // BLOCKED state
        Object lock = new Object();
        Thread blockedThread = new Thread(() -> {
            synchronized (lock) {
                System.out.println("Got lock");
            }
        });
        
        synchronized (lock) {
            blockedThread.start();
            Thread.sleep(100);  // Hold lock
            System.out.println("BLOCKED: " + blockedThread.getState());
        }
        
        // WAITING state
        Thread waitingThread = new Thread(() -> {
            synchronized (lock) {
                try {
                    lock.wait();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });
        waitingThread.start();
        Thread.sleep(100);
        System.out.println("WAITING: " + waitingThread.getState());
        
        synchronized (lock) {
            lock.notify();
        }
        
        // TIMED_WAITING state
        Thread timedWaitingThread = new Thread(() -> {
            try {
                Thread.sleep(10000);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        timedWaitingThread.start();
        Thread.sleep(100);
        System.out.println("TIMED_WAITING: " + timedWaitingThread.getState());
        timedWaitingThread.interrupt();
        
        // TERMINATED state
        Thread terminatedThread = new Thread(() -> {
            System.out.println("Task complete");
        });
        terminatedThread.start();
        terminatedThread.join();
        System.out.println("TERMINATED: " + terminatedThread.getState());
    }
}
```

### State Transitions in Detail

```java
/**
 * UNDERSTANDING STATE TRANSITIONS
 */

public class StateTransitions {
    
    /**
     * NEW → RUNNABLE
     * Triggered by: Thread.start()
     */
    public static void newToRunnable() {
        Thread thread = new Thread(() -> {
            System.out.println("Thread running");
        });
        
        System.out.println("Before start: " + thread.getState());  // NEW
        thread.start();
        System.out.println("After start: " + thread.getState());   // RUNNABLE
        
        /**
         * IMPORTANT:
         * - Can only call start() once
         * - Calling start() again throws IllegalThreadStateException
         * - After start(), JVM creates native thread
         * - Thread becomes eligible for CPU scheduling
         */
    }
    
    /**
     * RUNNABLE → BLOCKED
     * Triggered by: Waiting for synchronized lock
     */
    public static void runnableToBlocked() throws InterruptedException {
        Object lock = new Object();
        
        Thread thread1 = new Thread(() -> {
            synchronized (lock) {
                try {
                    System.out.println("Thread 1 has lock");
                    Thread.sleep(2000);  // Hold lock
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });
        
        Thread thread2 = new Thread(() -> {
            System.out.println("Thread 2 trying to acquire lock...");
            synchronized (lock) {
                System.out.println("Thread 2 got lock");
            }
        });
        
        thread1.start();
        Thread.sleep(100);  // Let thread1 acquire lock
        
        thread2.start();
        Thread.sleep(100);  // Let thread2 block
        
        System.out.println("Thread 2 state: " + thread2.getState());  // BLOCKED
        
        thread1.join();
        thread2.join();
        
        /**
         * BLOCKED vs WAITING:
         * 
         * BLOCKED:
         * - Waiting to acquire synchronized lock
         * - Cannot be interrupted
         * - Automatically unblocks when lock available
         * 
         * WAITING:
         * - Waiting for notification (wait(), join(), park())
         * - Can be interrupted
         * - Requires explicit notify() or unpark()
         */
    }
    
    /**
     * RUNNABLE → WAITING
     * Triggered by: Object.wait(), Thread.join(), LockSupport.park()
     */
    public static void runnableToWaiting() throws InterruptedException {
        Object lock = new Object();
        
        Thread waitingThread = new Thread(() -> {
            synchronized (lock) {
                try {
                    System.out.println("Thread entering WAITING state");
                    lock.wait();  // Release lock and wait
                    System.out.println("Thread resumed");
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });
        
        waitingThread.start();
        Thread.sleep(100);
        
        System.out.println("State: " + waitingThread.getState());  // WAITING
        
        // Wake up
        synchronized (lock) {
            lock.notify();
        }
        
        waitingThread.join();
        
        /**
         * CAUSES OF WAITING STATE:
         * 
         * 1. Object.wait() - without timeout
         * 2. Thread.join() - without timeout
         * 3. LockSupport.park() - park indefinitely
         * 
         * EXITING WAITING STATE:
         * 
         * 1. Object.notify() or notifyAll()
         * 2. Thread completes (for join())
         * 3. LockSupport.unpark()
         * 4. Thread.interrupt()
         */
    }
    
    /**
     * RUNNABLE → TIMED_WAITING
     * Triggered by: Thread.sleep(), Object.wait(timeout), Thread.join(timeout)
     */
    public static void runnableToTimedWaiting() throws InterruptedException {
        Thread sleepingThread = new Thread(() -> {
            try {
                System.out.println("Thread sleeping...");
                Thread.sleep(5000);  // TIMED_WAITING
                System.out.println("Thread awake");
            } catch (InterruptedException e) {
                System.out.println("Sleep interrupted");
                Thread.currentThread().interrupt();
            }
        });
        
        sleepingThread.start();
        Thread.sleep(100);
        
        System.out.println("State: " + sleepingThread.getState());  // TIMED_WAITING
        
        sleepingThread.interrupt();  // Wake up early
        sleepingThread.join();
        
        /**
         * CAUSES OF TIMED_WAITING STATE:
         * 
         * 1. Thread.sleep(millis)
         * 2. Object.wait(timeout)
         * 3. Thread.join(timeout)
         * 4. LockSupport.parkNanos()
         * 5. LockSupport.parkUntil()
         * 
         * EXITING TIMED_WAITING STATE:
         * 
         * 1. Timeout expires
         * 2. Thread.interrupt()
         * 3. notify()/notifyAll() (for wait())
         * 4. Thread completes (for join())
         */
    }
    
    /**
     * ANY_STATE → TERMINATED
     * Triggered by: run() method completes or exception
     */
    public static void toTerminated() throws InterruptedException {
        // Normal completion
        Thread normalThread = new Thread(() -> {
            System.out.println("Task complete");
        });
        normalThread.start();
        normalThread.join();
        System.out.println("Normal: " + normalThread.getState());  // TERMINATED
        
        // Exception
        Thread exceptionThread = new Thread(() -> {
            throw new RuntimeException("Oops");
        });
        exceptionThread.start();
        exceptionThread.join();
        System.out.println("Exception: " + exceptionThread.getState());  // TERMINATED
        
        /**
         * TERMINATED STATE:
         * 
         * - Thread cannot be restarted
         * - All resources cleaned up
         * - Thread object still exists (can query state, etc.)
         * - Stack trace preserved if exception occurred
         * 
         * IMPORTANT:
         * - Cannot call start() on TERMINATED thread
         * - Thread.join() returns immediately for TERMINATED thread
         */
    }
}
```

---

## 3. Thread Priorities and Scheduling

### Thread Priority Basics

```java
/**
 * THREAD PRIORITIES IN JAVA
 * 
 * Priority range: 1 (MIN_PRIORITY) to 10 (MAX_PRIORITY)
 * Default: 5 (NORM_PRIORITY)
 * 
 * IMPORTANT: Priority is only a HINT to the scheduler
 * Actual behavior is platform-dependent and not guaranteed
 */

public class ThreadPriorities {
    
    /**
     * Priority constants
     */
    public static void priorityConstants() {
        System.out.println("MIN_PRIORITY: " + Thread.MIN_PRIORITY);    // 1
        System.out.println("NORM_PRIORITY: " + Thread.NORM_PRIORITY);  // 5
        System.out.println("MAX_PRIORITY: " + Thread.MAX_PRIORITY);    // 10
    }
    
    /**
     * Setting and getting priorities
     */
    public static void basicPriorities() {
        Thread thread = new Thread(() -> {
            System.out.println("Thread priority: " + 
                Thread.currentThread().getPriority());
        });
        
        // Default priority (inherited from parent)
        System.out.println("Default: " + thread.getPriority());  // 5
        
        // Set priority
        thread.setPriority(Thread.MAX_PRIORITY);
        System.out.println("After set: " + thread.getPriority());  // 10
        
        thread.start();
    }
    
    /**
     * Priority inheritance
     */
    public static void priorityInheritance() {
        // Child threads inherit parent priority
        Thread parent = new Thread(() -> {
            System.out.println("Parent priority: " + 
                Thread.currentThread().getPriority());
            
            Thread child = new Thread(() -> {
                System.out.println("Child priority: " + 
                    Thread.currentThread().getPriority());
            });
            child.start();
        });
        
        parent.setPriority(8);
        parent.start();
        
        /**
         * OUTPUT:
         * Parent priority: 8
         * Child priority: 8  (inherited)
         */
    }
    
    /**
     * Priority demonstration (NOT RELIABLE)
     */
    public static void priorityDemo() throws InterruptedException {
        Counter counter = new Counter();
        
        Thread lowPriority = new Thread(() -> {
            for (int i = 0; i < 1000000; i++) {
                counter.incrementLow();
            }
        });
        
        Thread highPriority = new Thread(() -> {
            for (int i = 0; i < 1000000; i++) {
                counter.incrementHigh();
            }
        });
        
        lowPriority.setPriority(Thread.MIN_PRIORITY);
        highPriority.setPriority(Thread.MAX_PRIORITY);
        
        lowPriority.start();
        highPriority.start();
        
        lowPriority.join();
        highPriority.join();
        
        System.out.println("Low priority count: " + counter.lowCount);
        System.out.println("High priority count: " + counter.highCount);
        
        /**
         * EXPECTED: High priority completes more iterations
         * REALITY: Results vary by platform and JVM
         * 
         * On modern systems with multiple cores:
         * - Both threads likely run concurrently
         * - Priority has minimal effect
         * 
         * LESSON: Don't rely on thread priorities for correctness!
         */
    }
    
    static class Counter {
        int lowCount = 0;
        int highCount = 0;
        
        void incrementLow() {
            lowCount++;
        }
        
        void incrementHigh() {
            highCount++;
        }
    }
    
    /**
     * WHY PRIORITIES DON'T WORK RELIABLY:
     */
    public static void priorityLimitations() {
        /**
         * PLATFORM DIFFERENCES:
         * 
         * Windows:
         * - 7 priority levels (Java's 10 mapped to these)
         * - Priorities somewhat respected
         * 
         * Linux:
         * - Requires root for real-time priorities
         * - Normal threads all same priority
         * - Java priorities mostly ignored
         * 
         * macOS:
         * - Similar to Linux
         * - Priorities have minimal effect
         * 
         * MULTI-CORE SYSTEMS:
         * 
         * - Threads run on different cores simultaneously
         * - Priority differences don't matter
         * - All threads get CPU time
         * 
         * JVM IMPLEMENTATION:
         * 
         * - Java priority mapped to OS priority
         * - Mapping not standardized
         * - Some JVMs ignore priorities entirely
         * 
         * RECOMMENDATION:
         * 
         * ❌ Don't use priorities for correctness
         * ❌ Don't use priorities for critical ordering
         * ✅ Use proper synchronization instead
         * ✅ Use ExecutorService for resource management
         */
    }
}
```

### Thread Scheduling

```java
/**
 * THREAD SCHEDULING IN JVM
 */

public class ThreadScheduling {
    
    /**
     * Preemptive scheduling (modern JVMs)
     */
    public static void preemptiveScheduling() {
        /**
         * JVM uses preemptive scheduling:
         * - Scheduler can interrupt running thread
         * - Give CPU to another thread
         * - Based on time slices (time quantum)
         * - Prevents thread starvation
         * 
         * Time slice: Typically 10-20ms
         * 
         * RUNNABLE threads compete for CPU
         * Scheduler selects based on:
         * 1. Priority (hint only)
         * 2. Fairness (prevent starvation)
         * 3. OS scheduler policies
         */
    }
    
    /**
     * Yielding CPU
     */
    public static void yieldDemo() throws InterruptedException {
        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                System.out.println("Thread 1: " + i);
                Thread.yield();  // Hint to scheduler: willing to yield
            }
        });
        
        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                System.out.println("Thread 2: " + i);
                Thread.yield();
            }
        });
        
        thread1.start();
        thread2.start();
        
        thread1.join();
        thread2.join();
        
        /**
         * Thread.yield():
         * - Hint to scheduler that current thread is willing to yield
         * - Scheduler may ignore (not guaranteed)
         * - Thread remains RUNNABLE (doesn't block)
         * - Useful for cooperative multitasking
         * 
         * WHEN TO USE:
         * - Rarely! Modern JVMs handle scheduling well
         * - Maybe in tight loops to be cooperative
         * - Don't use for synchronization
         * 
         * BETTER ALTERNATIVES:
         * - Thread.sleep(1) if you want to pause
         * - Lock/synchronized for coordination
         * - ExecutorService for task management
         */
    }
    
    /**
     * Context switching
     */
    public static void contextSwitching() {
        /**
         * CONTEXT SWITCH COST:
         * 
         * When scheduler switches between threads:
         * 1. Save current thread state (registers, PC)
         * 2. Load new thread state
         * 3. Switch memory mappings
         * 4. Update TLB (Translation Lookaside Buffer)
         * 5. Warm up CPU cache
         * 
         * Time cost: 1-10 microseconds
         * 
         * PERFORMANCE IMPACT:
         * 
         * Too many threads:
         * - More context switches
         * - Less time doing actual work
         * - Cache thrashing
         * 
         * Rule of thumb:
         * - Thread count ≈ CPU cores × (1 + wait time / compute time)
         * - CPU-bound: threads = cores
         * - I/O-bound: threads = cores × 2 or more
         */
    }
    
    /**
     * Thread affinity (not in Java standard API)
     */
    public static void threadAffinity() {
        /**
         * Thread affinity: Bind thread to specific CPU core
         * 
         * NOT AVAILABLE in standard Java API
         * 
         * Why you might want it:
         * - Reduce context switch overhead
         * - Keep data in CPU cache
         * - Real-time requirements
         * 
         * How to get it:
         * - JNI with native code
         * - Libraries like JNA
         * - Process-level affinity (taskset on Linux)
         * 
         * In practice:
         * - OS scheduler usually good enough
         * - Thread pools manage resources well
         * - Affinity adds complexity
         */
    }
}
```

---

## 4. Daemon Threads vs User Threads

### Daemon Thread Basics

```java
/**
 * DAEMON THREADS VS USER THREADS
 * 
 * User Thread (default):
 * - JVM waits for all user threads to complete
 * - Keeps JVM alive
 * 
 * Daemon Thread:
 * - Background service thread
 * - JVM exits when only daemon threads remain
 * - Not guaranteed to complete finally blocks
 */

public class DaemonThreads {
    
    /**
     * Basic daemon thread
     */
    public static void basicDaemon() throws InterruptedException {
        Thread daemon = new Thread(() -> {
            while (true) {
                System.out.println("Daemon running...");
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    break;
                }
            }
        });
        
        // Must set before start()
        daemon.setDaemon(true);
        daemon.start();
        
        System.out.println("Is daemon: " + daemon.isDaemon());
        
        Thread.sleep(2000);
        System.out.println("Main ending");
        
        /**
         * OUTPUT:
         * Is daemon: true
         * Daemon running...
         * Daemon running...
         * Daemon running...
         * Main ending
         * 
         * JVM exits immediately after main thread
         * Daemon thread stops (even mid-execution)
         */
    }
    
    /**
     * User thread keeps JVM alive
     */
    public static void userThread() throws InterruptedException {
        Thread user = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                System.out.println("User thread: " + i);
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    break;
                }
            }
            System.out.println("User thread complete");
        });
        
        user.start();  // Default: user thread
        
        Thread.sleep(1000);
        System.out.println("Main ending");
        
        /**
         * OUTPUT:
         * User thread: 0
         * User thread: 1
         * Main ending
         * User thread: 2
         * User thread: 3
         * User thread: 4
         * User thread complete
         * 
         * JVM waits for user thread to complete
         */
    }
    
    /**
     * Daemon inheritance
     */
    public static void daemonInheritance() {
        Thread parent = new Thread(() -> {
            // Child inherits daemon status from parent
            Thread child = new Thread(() -> {
                System.out.println("Child is daemon: " + 
                    Thread.currentThread().isDaemon());
            });
            child.start();
        });
        
        parent.setDaemon(true);
        parent.start();
        
        /**
         * OUTPUT:
         * Child is daemon: true
         * 
         * Child threads inherit daemon status
         */
    }
    
    /**
     * Common daemon thread use cases
     */
    public static void daemonUseCases() {
        // 1. Garbage Collection (built-in daemon)
        // 2. Finalizer thread (built-in daemon)
        // 3. Signal dispatcher (built-in daemon)
        
        // Custom daemon: Monitoring
        Thread monitor = new Thread(() -> {
            while (true) {
                long freeMemory = Runtime.getRuntime().freeMemory();
                System.out.println("Free memory: " + freeMemory / (1024 * 1024) + " MB");
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    break;
                }
            }
        });
        monitor.setDaemon(true);
        monitor.start();
        
        // Custom daemon: Periodic cleanup
        Thread cleanup = new Thread(() -> {
            while (true) {
                // Clean up resources
                System.gc();
                try {
                    Thread.sleep(60000);
                } catch (InterruptedException e) {
                    break;
                }
            }
        });
        cleanup.setDaemon(true);
        cleanup.start();
        
        /**
         * GOOD USES FOR DAEMON THREADS:
         * 
         * ✓ Monitoring
         * ✓ Housekeeping
         * ✓ Cache maintenance
         * ✓ Log rotation
         * ✓ Connection keep-alive
         * 
         * BAD USES FOR DAEMON THREADS:
         * 
         * ✗ Writing to disk (might not complete)
         * ✗ Database transactions (might not commit)
         * ✗ Network requests (might not finish)
         * ✗ Any critical work
         */
    }
    
    /**
     * Daemon thread dangers
     */
    public static void daemonDangers() throws InterruptedException {
        Thread daemon = new Thread(() -> {
            try {
                System.out.println("Daemon: Opening file");
                java.io.FileWriter writer = new java.io.FileWriter("data.txt");
                
                for (int i = 0; i < 1000; i++) {
                    writer.write("Line " + i + "\n");
                    Thread.sleep(10);
                }
                
                writer.close();
                System.out.println("Daemon: File closed");
                
            } catch (Exception e) {
                e.printStackTrace();
            }
        });
        
        daemon.setDaemon(true);
        daemon.start();
        
        Thread.sleep(500);
        System.out.println("Main ending");
        
        /**
         * DANGER:
         * - Daemon thread may be killed mid-write
         * - File not fully written
         * - Resources not closed (no finally block execution)
         * - Data corruption possible
         * 
         * LESSON: Never use daemon threads for I/O operations!
         */
    }
}
```

### Daemon vs User Thread Comparison

```java
/**
 * COMPREHENSIVE COMPARISON
 */

public class DaemonVsUserComparison {
    
    public static void comparison() {
        /**
         * ┌──────────────────┬─────────────────────┬─────────────────────┐
         * │   Characteristic │   User Thread       │   Daemon Thread     │
         * ├──────────────────┼─────────────────────┼─────────────────────┤
         * │ JVM Shutdown     │ JVM waits           │ JVM doesn't wait    │
         * │ Default          │ Yes                 │ No                  │
         * │ Set Daemon       │ After start? No     │ Before start only   │
         * │ Finally Blocks   │ Guaranteed          │ Not guaranteed      │
         * │ Use Case         │ Main work           │ Background services │
         * │ Examples         │ Main thread,        │ GC, Finalizer,      │
         * │                  │ Worker threads      │ Monitoring          │
         * │ Thread Pools     │ Standard pools      │ Custom pools        │
         * └──────────────────┴─────────────────────┴─────────────────────┘
         */
    }
    
    /**
     * Setting daemon status
     */
    public static void settingDaemonStatus() {
        Thread thread = new Thread(() -> {});
        
        // ✓ CORRECT: Before start
        thread.setDaemon(true);
        thread.start();
        
        // ✗ WRONG: After start
        Thread thread2 = new Thread(() -> {});
        thread2.start();
        try {
            thread2.setDaemon(true);  // Throws IllegalThreadStateException
        } catch (IllegalThreadStateException e) {
            System.out.println("Cannot set daemon after start");
        }
    }
    
    /**
     * Thread pool with daemon threads
     */
    public static void daemonThreadPool() {
        // Create thread pool with daemon threads
        java.util.concurrent.ThreadFactory daemonFactory = r -> {
            Thread thread = new Thread(r);
            thread.setDaemon(true);
            return thread;
        };
        
        java.util.concurrent.ExecutorService executor = 
            java.util.concurrent.Executors.newFixedThreadPool(4, daemonFactory);
        
        executor.submit(() -> {
            System.out.println("Task in daemon pool");
        });
        
        executor.shutdown();
        
        /**
         * USE CASE:
         * - Background processing that can be interrupted
         * - Non-critical tasks
         * - JVM can exit without waiting
         */
    }
}
```

---

## 5. Thread.sleep() vs Object.wait()

### sleep() vs wait() Comparison

```java
/**
 * THREAD.SLEEP() VS OBJECT.WAIT()
 */

public class SleepVsWait {
    
    /**
     * Thread.sleep() - Pauses current thread
     */
    public static void sleepExample() {
        Object lock = new Object();
        
        Thread thread = new Thread(() -> {
            synchronized (lock) {
                System.out.println("Thread acquired lock");
                
                try {
                    System.out.println("Thread sleeping for 2 seconds...");
                    Thread.sleep(2000);  // KEEPS THE LOCK
                    System.out.println("Thread awake");
                    
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                
                System.out.println("Thread releasing lock");
            }
        });
        
        thread.start();
        
        /**
         * CHARACTERISTICS:
         * - Static method (Thread.sleep)
         * - Does NOT release locks
         * - Pauses for specified time
         * - Thread state: TIMED_WAITING
         * - Can be interrupted
         * - Does not need synchronized block
         */
    }
    
    /**
     * Object.wait() - Waits for notification
     */
    public static void waitExample() throws InterruptedException {
        Object lock = new Object();
        
        Thread thread = new Thread(() -> {
            synchronized (lock) {
                System.out.println("Thread acquired lock");
                
                try {
                    System.out.println("Thread waiting...");
                    lock.wait();  // RELEASES THE LOCK
                    System.out.println("Thread notified");
                    
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                
                System.out.println("Thread releasing lock");
            }
        });
        
        thread.start();
        Thread.sleep(1000);
        
        // Notify waiting thread
        synchronized (lock) {
            System.out.println("Main notifying");
            lock.notify();
        }
        
        thread.join();
        
        /**
         * CHARACTERISTICS:
         * - Instance method (object.wait)
         * - RELEASES locks (must be in synchronized)
         * - Waits until notified or timeout
         * - Thread state: WAITING or TIMED_WAITING
         * - Can be interrupted
         * - MUST be in synchronized block
         */
    }
    
    /**
     * Key differences demonstration
     */
    public static void demonstrateDifferences() throws InterruptedException {
        Object lock = new Object();
        
        // With sleep: Lock NOT released
        Thread sleeper = new Thread(() -> {
            synchronized (lock) {
                System.out.println("[Sleep] Got lock at " + System.currentTimeMillis());
                try {
                    Thread.sleep(2000);  // Other threads CANNOT acquire lock
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                System.out.println("[Sleep] Done at " + System.currentTimeMillis());
            }
        });
        
        Thread sleeperWaiter = new Thread(() -> {
            System.out.println("[Waiter] Trying to get lock...");
            synchronized (lock) {
                System.out.println("[Waiter] Got lock at " + System.currentTimeMillis());
            }
        });
        
        sleeper.start();
        Thread.sleep(100);
        sleeperWaiter.start();
        
        sleeper.join();
        sleeperWaiter.join();
        
        /**
         * OUTPUT:
         * [Sleep] Got lock at 1000
         * [Waiter] Trying to get lock...
         * [Sleep] Done at 3000
         * [Waiter] Got lock at 3000
         * 
         * Waiter had to wait 2 seconds because sleeper held lock
         */
        
        System.out.println("\n--- With wait ---\n");
        
        // With wait: Lock IS released
        Thread waiter = new Thread(() -> {
            synchronized (lock) {
                System.out.println("[Wait] Got lock at " + System.currentTimeMillis());
                try {
                    lock.wait(2000);  // Other threads CAN acquire lock
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                System.out.println("[Wait] Done at " + System.currentTimeMillis());
            }
        });
        
        Thread waiterHelper = new Thread(() -> {
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            System.out.println("[Helper] Trying to get lock...");
            synchronized (lock) {
                System.out.println("[Helper] Got lock at " + System.currentTimeMillis());
            }
        });
        
        waiter.start();
        waiterHelper.start();
        
        waiter.join();
        waiterHelper.join();
        
        /**
         * OUTPUT:
         * [Wait] Got lock at 5000
         * [Helper] Trying to get lock...
         * [Helper] Got lock at 5500  (only waited 500ms!)
         * [Wait] Done at 7000
         * 
         * Helper could acquire lock while waiter was waiting
         */
    }
    
    /**
     * Comparison table
     */
    public static void comparisonTable() {
        /**
         * ┌─────────────────────┬──────────────────┬──────────────────┐
         * │   Aspect            │  Thread.sleep()  │  Object.wait()   │
         * ├─────────────────────┼──────────────────┼──────────────────┤
         * │ Method Type         │ Static           │ Instance         │
         * │ Class               │ Thread           │ Object           │
         * │ Releases Lock       │ NO               │ YES              │
         * │ Synchronized Block  │ Not required     │ REQUIRED         │
         * │ Wakeup Mechanism    │ Timeout          │ notify()/timeout │
         * │ Purpose             │ Pause execution  │ Inter-thread     │
         * │                     │                  │ communication    │
         * │ Interrupted         │ Yes              │ Yes              │
         * │ Common Use          │ Delays, polling  │ Wait for signal  │
         * └─────────────────────┴──────────────────┴──────────────────┘
         */
    }
    
    /**
     * Common mistakes
     */
    public static void commonMistakes() {
        Object lock = new Object();
        
        // ❌ MISTAKE 1: wait() without synchronized
        try {
            lock.wait();  // IllegalMonitorStateException
        } catch (IllegalMonitorStateException e) {
            System.out.println("Error: wait() needs synchronized");
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // ✓ CORRECT
        synchronized (lock) {
            try {
                lock.wait();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        
        // ❌ MISTAKE 2: Using sleep instead of wait for coordination
        synchronized (lock) {
            try {
                Thread.sleep(1000);  // WRONG: Holds lock unnecessarily
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        
        // ✓ CORRECT: Use wait for coordination
        synchronized (lock) {
            try {
                lock.wait(1000);  // Releases lock while waiting
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        
        // ❌ MISTAKE 3: Not handling InterruptedException
        Thread.sleep(1000);  // Compilation error: unhandled exception
        
        // ✓ CORRECT
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();  // Restore interrupt status
        }
    }
}
```

---

## 6. Thread.join() and Thread Coordination

### join() Basics

```java
/**
 * THREAD.JOIN() - WAIT FOR THREAD COMPLETION
 */

public class ThreadJoin {
    
    /**
     * Basic join usage
     */
    public static void basicJoin() throws InterruptedException {
        Thread worker = new Thread(() -> {
            System.out.println("Worker started");
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            System.out.println("Worker done");
        });
        
        System.out.println("Main starting worker");
        worker.start();
        
        System.out.println("Main waiting for worker");
        worker.join();  // Block until worker completes
        
        System.out.println("Main continuing after worker");
        
        /**
         * OUTPUT:
         * Main starting worker
         * Main waiting for worker
         * Worker started
         * Worker done
         * Main continuing after worker
         * 
         * join() guarantees worker completes before main continues
         */
    }
    
    /**
     * join() with timeout
     */
    public static void joinWithTimeout() throws InterruptedException {
        Thread longTask = new Thread(() -> {
            try {
                Thread.sleep(5000);  // 5 seconds
                System.out.println("Long task done");
            } catch (InterruptedException e) {
                System.out.println("Long task interrupted");
                Thread.currentThread().interrupt();
            }
        });
        
        longTask.start();
        
        System.out.println("Waiting max 2 seconds...");
        longTask.join(2000);  // Wait max 2 seconds
        
        if (longTask.isAlive()) {
            System.out.println("Task still running after timeout");
            longTask.interrupt();  // Cancel the task
        } else {
            System.out.println("Task completed within timeout");
        }
        
        /**
         * join(timeout) variants:
         * - join() - Wait indefinitely
         * - join(millis) - Wait max millis milliseconds
         * - join(millis, nanos) - Wait max millis + nanos
         * 
         * Returns when:
         * 1. Thread completes
         * 2. Timeout expires
         * 3. Interrupted
         */
    }
    
    /**
     * Multiple thread coordination
     */
    public static void multipleThreadJoin() throws InterruptedException {
        Thread[] workers = new Thread[5];
        
        // Start all workers
        for (int i = 0; i < workers.length; i++) {
            final int taskId = i;
            workers[i] = new Thread(() -> {
                System.out.println("Worker " + taskId + " starting");
                try {
                    Thread.sleep((long) (Math.random() * 2000));
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                System.out.println("Worker " + taskId + " done");
            });
            workers[i].start();
        }
        
        // Wait for all workers
        for (Thread worker : workers) {
            worker.join();
        }
        
        System.out.println("All workers completed");
        
        /**
         * PATTERN: Fork-Join
         * 1. Fork: Start multiple threads
         * 2. Join: Wait for all to complete
         * 3. Continue: Process results
         */
    }
    
    /**
     * Producer-Consumer with join
     */
    public static void producerConsumerJoin() throws InterruptedException {
        final java.util.List<Integer> buffer = new java.util.ArrayList<>();
        final int MAX_SIZE = 10;
        
        Thread producer = new Thread(() -> {
            for (int i = 0; i < 20; i++) {
                synchronized (buffer) {
                    while (buffer.size() >= MAX_SIZE) {
                        try {
                            buffer.wait();
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                            return;
                        }
                    }
                    
                    buffer.add(i);
                    System.out.println("Produced: " + i);
                    buffer.notifyAll();
                }
                
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    return;
                }
            }
            System.out.println("Producer done");
        });
        
        Thread consumer = new Thread(() -> {
            for (int i = 0; i < 20; i++) {
                synchronized (buffer) {
                    while (buffer.isEmpty()) {
                        try {
                            buffer.wait();
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                            return;
                        }
                    }
                    
                    int value = buffer.remove(0);
                    System.out.println("Consumed: " + value);
                    buffer.notifyAll();
                }
                
                try {
                    Thread.sleep(150);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    return;
                }
            }
            System.out.println("Consumer done");
        });
        
        producer.start();
        consumer.start();
        
        producer.join();
        consumer.join();
        
        System.out.println("Both threads completed");
    }
}
```

### Advanced Thread Coordination

```java
/**
 * ADVANCED COORDINATION PATTERNS
 */

public class AdvancedCoordination {
    
    /**
     * Phased execution with join
     */
    public static void phasedExecution() throws InterruptedException {
        // Phase 1: Data collection
        Thread[] collectors = new Thread[3];
        for (int i = 0; i < collectors.length; i++) {
            final int id = i;
            collectors[i] = new Thread(() -> {
                System.out.println("Collector " + id + " collecting data");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                System.out.println("Collector " + id + " done");
            });
            collectors[i].start();
        }
        
        // Wait for all collectors
        for (Thread collector : collectors) {
            collector.join();
        }
        System.out.println("Phase 1 complete: Data collected\n");
        
        // Phase 2: Data processing
        Thread[] processors = new Thread[3];
        for (int i = 0; i < processors.length; i++) {
            final int id = i;
            processors[i] = new Thread(() -> {
                System.out.println("Processor " + id + " processing data");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                System.out.println("Processor " + id + " done");
            });
            processors[i].start();
        }
        
        // Wait for all processors
        for (Thread processor : processors) {
            processor.join();
        }
        System.out.println("Phase 2 complete: Data processed\n");
        
        // Phase 3: Result aggregation
        Thread aggregator = new Thread(() -> {
            System.out.println("Aggregating results");
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            System.out.println("Aggregation done");
        });
        aggregator.start();
        aggregator.join();
        
        System.out.println("All phases complete");
    }
    
    /**
     * Thread coordination with CountDownLatch (preview)
     */
    public static void countDownLatchPreview() throws InterruptedException {
        /**
         * CountDownLatch: More elegant than multiple join() calls
         * 
         * Benefits over join():
         * - One-time barrier for multiple threads
         * - Can count down from non-thread code
         * - More flexible coordination
         * - Better performance
         * 
         * Will be covered in detail in java.util.concurrent guide
         */
        
        int threadCount = 5;
        java.util.concurrent.CountDownLatch latch = 
            new java.util.concurrent.CountDownLatch(threadCount);
        
        for (int i = 0; i < threadCount; i++) {
            final int id = i;
            new Thread(() -> {
                System.out.println("Worker " + id + " starting");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                System.out.println("Worker " + id + " done");
                latch.countDown();  // Signal completion
            }).start();
        }
        
        latch.await();  // Wait for all threads
        System.out.println("All workers completed");
    }
    
    /**
     * Interrupt during join
     */
    public static void interruptDuringJoin() throws InterruptedException {
        Thread longTask = new Thread(() -> {
            try {
                Thread.sleep(10000);  // 10 seconds
            } catch (InterruptedException e) {
                System.out.println("Task interrupted");
                Thread.currentThread().interrupt();
            }
        });
        
        Thread waiter = new Thread(() -> {
            try {
                System.out.println("Waiter joining long task");
                longTask.join();
                System.out.println("Waiter done");
            } catch (InterruptedException e) {
                System.out.println("Waiter interrupted while joining");
                Thread.currentThread().interrupt();
            }
        });
        
        longTask.start();
        waiter.start();
        
        Thread.sleep(1000);
        
        // Interrupt waiter
        waiter.interrupt();
        
        waiter.join();
        longTask.interrupt();
        longTask.join();
        
        /**
         * join() can be interrupted:
         * - Throws InterruptedException
         * - join() returns
         * - Caller handles interruption
         * - Joined thread continues running
         */
    }
}
```

---

## 7. Virtual Threads (Project Loom - Java 19+)

### Virtual Thread Basics

```java
/**
 * VIRTUAL THREADS (Java 19+)
 * 
 * Revolutionary change in Java concurrency
 * Lightweight threads managed by JVM, not OS
 * 
 * Platform Thread (traditional):
 * - OS thread (heavy, 1-2MB stack)
 * - Limited by OS (thousands)
 * - Context switch expensive
 * 
 * Virtual Thread (new):
 * - JVM-managed (light, KB stack)
 * - Millions possible
 * - Cheap context switch
 * - Mounted on platform threads (carriers)
 */

public class VirtualThreads {
    
    /**
     * Creating virtual threads
     */
    public static void createVirtualThreads() throws InterruptedException {
        // Method 1: Thread.ofVirtual()
        Thread vt1 = Thread.ofVirtual().start(() -> {
            System.out.println("Virtual thread 1: " + Thread.currentThread());
        });
        
        // Method 2: Thread.startVirtualThread()
        Thread vt2 = Thread.startVirtualThread(() -> {
            System.out.println("Virtual thread 2: " + Thread.currentThread());
        });
        
        // Method 3: Executors.newVirtualThreadPerTaskExecutor()
        try (java.util.concurrent.ExecutorService executor = 
                java.util.concurrent.Executors.newVirtualThreadPerTaskExecutor()) {
            
            executor.submit(() -> {
                System.out.println("Virtual thread 3: " + Thread.currentThread());
            });
        }
        
        vt1.join();
        vt2.join();
        
        /**
         * OUTPUT:
         * Virtual thread 1: VirtualThread[#21]/runnable@ForkJoinPool-1-worker-1
         * Virtual thread 2: VirtualThread[#23]/runnable@ForkJoinPool-1-worker-2
         * Virtual thread 3: VirtualThread[#25]/runnable@ForkJoinPool-1-worker-1
         * 
         * Note: Virtual threads run on carrier threads (ForkJoinPool workers)
         */
    }
    
    /**
     * Virtual vs Platform threads
     */
    public static void virtualVsPlatform() throws InterruptedException {
        // Platform thread (traditional)
        Thread platform = Thread.ofPlatform().start(() -> {
            System.out.println("Platform: " + Thread.currentThread());
            System.out.println("  - isVirtual: " + Thread.currentThread().isVirtual());
        });
        
        // Virtual thread
        Thread virtual = Thread.ofVirtual().start(() -> {
            System.out.println("Virtual: " + Thread.currentThread());
            System.out.println("  - isVirtual: " + Thread.currentThread().isVirtual());
        });
        
        platform.join();
        virtual.join();
        
        /**
         * OUTPUT:
         * Platform: Thread[#21,Thread-0,5,main]
         *   - isVirtual: false
         * Virtual: VirtualThread[#23]/runnable@ForkJoinPool-1-worker-1
         *   - isVirtual: true
         */
    }
    
    /**
     * Scalability demonstration
     */
    public static void scalabilityDemo() throws InterruptedException {
        int threadCount = 100_000;  // 100K threads!
        
        System.out.println("Creating " + threadCount + " virtual threads...");
        long start = System.currentTimeMillis();
        
        try (java.util.concurrent.ExecutorService executor = 
                java.util.concurrent.Executors.newVirtualThreadPerTaskExecutor()) {
            
            java.util.concurrent.CountDownLatch latch = 
                new java.util.concurrent.CountDownLatch(threadCount);
            
            for (int i = 0; i < threadCount; i++) {
                executor.submit(() -> {
                    try {
                        Thread.sleep(1000);  // Simulate I/O
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    } finally {
                        latch.countDown();
                    }
                });
            }
            
            latch.await();
        }
        
        long elapsed = System.currentTimeMillis() - start;
        System.out.println("Completed in: " + elapsed + "ms");
        
        /**
         * RESULTS:
         * 
         * Platform threads (100K):
         * - Would need 100-200GB memory (2MB stack each)
         * - OS limits (typically 4K-8K threads max)
         * - IMPOSSIBLE on most systems
         * 
         * Virtual threads (100K):
         * - ~1GB memory total
         * - Completes in ~1 second
         * - EASY on modern systems
         * 
         * Virtual threads enable massive concurrency!
         */
    }
    
    /**
     * Virtual thread lifecycle
     */
    public static void virtualThreadLifecycle() throws InterruptedException {
        Thread vt = Thread.ofVirtual().unstarted(() -> {
            System.out.println("Task running");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        
        System.out.println("State: " + vt.getState());  // NEW
        
        vt.start();
        Thread.sleep(100);
        System.out.println("State: " + vt.getState());  // RUNNABLE
        
        vt.join();
        System.out.println("State: " + vt.getState());  // TERMINATED
        
        /**
         * Virtual threads have same states as platform threads:
         * NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED
         * 
         * But transitions are cheaper (no OS involvement)
         */
    }
}
```

### Virtual Thread Mechanics

```java
/**
 * HOW VIRTUAL THREADS WORK
 */

public class VirtualThreadMechanics {
    
    /**
     * Carrier threads (platform threads that run virtual threads)
     */
    public static void carrierThreads() throws InterruptedException {
        Thread vt = Thread.ofVirtual().start(() -> {
            System.out.println("Virtual thread: " + Thread.currentThread());
            System.out.println("Carrier thread: " + 
                Thread.currentThread().toString());
        });
        
        vt.join();
        
        /**
         * CARRIER THREAD MECHANISM:
         * 
         * Virtual threads are mounted on carrier threads (platform threads)
         * Default: ForkJoinPool with #CPUs threads
         * 
         * When virtual thread:
         * - Runs: Mounted on carrier thread
         * - Blocks (I/O, sleep): Unmounted from carrier
         * - Resumes: Remounted (possibly different carrier)
         * 
         * This is called "M:N threading"
         * M virtual threads → N carrier threads
         * N typically = #CPUs
         */
    }
    
    /**
     * Blocking operations
     */
    public static void blockingOperations() throws InterruptedException {
        // I/O operations (virtual thread-friendly)
        Thread vt1 = Thread.ofVirtual().start(() -> {
            try {
                // These operations unmount virtual thread from carrier
                Thread.sleep(1000);              // ✓ Virtual thread-friendly
                java.nio.file.Files.readString(  // ✓ Virtual thread-friendly
                    java.nio.file.Path.of("data.txt"));
                
            } catch (Exception e) {
                // Handle
            }
        });
        
        // Synchronized blocks (potential issue)
        Object lock = new Object();
        Thread vt2 = Thread.ofVirtual().start(() -> {
            synchronized (lock) {  // ⚠ Pins virtual thread to carrier
                try {
                    Thread.sleep(1000);  // Virtual thread pinned!
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });
        
        vt1.join();
        vt2.join();
        
        /**
         * PINNING:
         * 
         * Some operations "pin" virtual thread to carrier:
         * 1. synchronized blocks
         * 2. Native methods
         * 3. Foreign function calls
         * 
         * While pinned:
         * - Virtual thread cannot unmount
         * - Carrier thread blocked
         * - Reduces scalability
         * 
         * SOLUTION:
         * - Use ReentrantLock instead of synchronized
         * - Keep synchronized blocks short
         * - Avoid blocking in synchronized
         */
    }
    
    /**
     * Best practices for virtual threads
     */
    public static void bestPractices() {
        // ✓ DO: Use for I/O-bound tasks
        Thread.ofVirtual().start(() -> {
            try {
                // Read file
                java.nio.file.Files.readString(
                    java.nio.file.Path.of("data.txt"));
            } catch (Exception e) {
                // Handle
            }
        });
        
        // ✓ DO: Use ReentrantLock instead of synchronized
        java.util.concurrent.locks.ReentrantLock lock = 
            new java.util.concurrent.locks.ReentrantLock();
        
        Thread.ofVirtual().start(() -> {
            lock.lock();
            try {
                // Critical section
                Thread.sleep(1000);  // Virtual thread can unmount
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } finally {
                lock.unlock();
            }
        });
        
        // ✗ DON'T: Use for CPU-bound tasks
        // Virtual threads don't help CPU-bound work
        // Use platform threads or parallel streams instead
        
        // ✗ DON'T: Pool virtual threads
        // Virtual threads are cheap - create per task
        // Don't use traditional thread pools
        
        // ✗ DON'T: Use ThreadLocal extensively
        // Each virtual thread has its own ThreadLocal
        // Millions of threads = millions of ThreadLocal copies
        // Can cause memory issues
    }
    
    /**
     * Migration from platform to virtual threads
     */
    public static void migrationExample() {
        // BEFORE: Platform thread pool
        java.util.concurrent.ExecutorService oldExecutor = 
            java.util.concurrent.Executors.newFixedThreadPool(100);
        
        oldExecutor.submit(() -> {
            // I/O task
        });
        
        oldExecutor.shutdown();
        
        // AFTER: Virtual thread per task
        try (java.util.concurrent.ExecutorService newExecutor = 
                java.util.concurrent.Executors.newVirtualThreadPerTaskExecutor()) {
            
            newExecutor.submit(() -> {
                // Same I/O task
            });
            
            // No shutdown needed with try-with-resources
        }
        
        /**
         * MIGRATION BENEFITS:
         * 
         * 1. Remove thread pool sizing concerns
         * 2. Scale to millions of concurrent tasks
         * 3. Simpler code (no tuning needed)
         * 4. Better throughput for I/O-bound apps
         * 
         * WHEN TO MIGRATE:
         * 
         * ✓ I/O-bound applications
         * ✓ Web servers, APIs
         * ✓ Database-heavy apps
         * ✓ Microservices
         * 
         * ✗ CPU-bound applications
         * ✗ Code using lots of synchronized
         * ✗ Code relying on ThreadLocal
         */
    }
}
```

### Virtual Thread Examples

```java
/**
 * PRACTICAL VIRTUAL THREAD EXAMPLES
 */

public class VirtualThreadExamples {
    
    /**
     * Web server simulation
     */
    public static void webServerSimulation() throws InterruptedException {
        // Simulate 10,000 concurrent requests
        int requestCount = 10_000;
        
        try (java.util.concurrent.ExecutorService executor = 
                java.util.concurrent.Executors.newVirtualThreadPerTaskExecutor()) {
            
            java.util.concurrent.CountDownLatch latch = 
                new java.util.concurrent.CountDownLatch(requestCount);
            
            long start = System.currentTimeMillis();
            
            for (int i = 0; i < requestCount; i++) {
                final int requestId = i;
                executor.submit(() -> {
                    handleRequest(requestId);
                    latch.countDown();
                });
            }
            
            latch.await();
            long elapsed = System.currentTimeMillis() - start;
            
            System.out.println("Handled " + requestCount + " requests in " + 
                elapsed + "ms");
            System.out.println("Throughput: " + (requestCount * 1000 / elapsed) + 
                " req/sec");
        }
        
        /**
         * RESULTS (typical):
         * 
         * Platform threads (pool of 200):
         * - Handled 10,000 requests in ~50,000ms
         * - Throughput: 200 req/sec
         * 
         * Virtual threads:
         * - Handled 10,000 requests in ~1,000ms
         * - Throughput: 10,000 req/sec
         * 
         * 50x improvement!
         */
    }
    
    private static void handleRequest(int requestId) {
        try {
            // Simulate database query
            Thread.sleep(100);
            
            // Simulate external API call
            Thread.sleep(50);
            
            // Simulate response generation
            Thread.sleep(50);
            
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    /**
     * Structured concurrency (preview - Java 19+)
     */
    public static void structuredConcurrency() throws Exception {
        /**
         * Structured Concurrency: Parent-child relationship for tasks
         * 
         * Benefits:
         * - Automatic cancellation of child tasks
         * - Exception propagation
         * - Clear scope and lifecycle
         * 
         * Note: Preview feature, API may change
         */
        
        /*
        try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {
            // Submit subtasks
            Future<String> user = scope.fork(() -> fetchUser());
            Future<String> order = scope.fork(() -> fetchOrder());
            
            // Wait for both (or first failure)
            scope.join();
            scope.throwIfFailed();
            
            // Use results
            System.out.println("User: " + user.resultNow());
            System.out.println("Order: " + order.resultNow());
        }
        
        // If scope exits (exception/completion):
        // - All subtasks automatically cancelled
        // - Resources cleaned up
        // - No leaked threads
        */
    }
}
```

---

## Summary

### Thread Creation Methods

|Method|Pros|Cons|Use When|
|---|---|---|---|
|Extend Thread|Simple|Single inheritance, tight coupling|Simple scripts, learning|
|Implement Runnable|Flexible, reusable|No return value|Most production code|
|Implement Callable|Returns result, throws exceptions|Needs ExecutorService|Tasks with results|
|Virtual Thread|Massively scalable, cheap|Java 19+, pinning issues|I/O-bound apps|

### Thread States

```
NEW → start() → RUNNABLE ⇄ BLOCKED (waiting for lock)
                   ↕
              WAITING (wait(), join(), park())
                   ↕
         TIMED_WAITING (sleep(), wait(timeout))
                   ↓
              TERMINATED
```

### Key Differences

**sleep() vs wait():**

- sleep(): Pauses thread, keeps lock, static method
- wait(): Releases lock, instance method, needs synchronized

**join() vs wait():**

- join(): Wait for thread completion
- wait(): Wait for notification

**Daemon vs User:**

- Daemon: Background, JVM can exit
- User: Foreground, JVM waits

**Platform vs Virtual:**

- Platform: OS thread, heavy (MB), thousands
- Virtual: JVM thread, light (KB), millions

### Best Practices

**Thread Creation:**

1. ✅ Prefer Runnable/Callable over extending Thread
2. ✅ Use ExecutorService for thread management
3. ✅ Use virtual threads for I/O-bound tasks (Java 19+)
4. ✅ Use lambdas for simple tasks
5. ❌ Don't create unlimited threads
6. ❌ Don't call run() directly

**Thread Coordination:**

1. ✅ Always handle InterruptedException
2. ✅ Use join() to wait for completion
3. ✅ Use wait()/notify() for communication
4. ✅ Consider CountDownLatch for multiple threads
5. ❌ Don't use Thread.yield() for coordination
6. ❌ Don't rely on thread priorities

**Virtual Threads:**

1. ✅ Use for I/O-bound workloads
2. ✅ Use ReentrantLock instead of synchronized
3. ✅ Create per-task (don't pool)
4. ✅ Keep synchronized blocks short
5. ❌ Don't use for CPU-bound work
6. ❌ Don't use ThreadLocal extensively

---
