# Java Lock Implementations

## Overview

Java provides sophisticated lock implementations beyond the basic `synchronized` keyword. This guide covers ReentrantLock, ReadWriteLock, StampedLock, Condition variables, and lock-free programming techniques for building high-performance concurrent applications.

---

## 1. Lock vs synchronized

### Basic Comparison

```java
/**
 * LOCK VS SYNCHRONIZED
 * 
 * synchronized: Built-in, simple, automatic unlock
 * Lock: Explicit, flexible, manual unlock
 */

import java.util.concurrent.locks.*;

public class LockVsSynchronized {
    
    private int count = 0;
    private final Object syncLock = new Object();
    private final Lock explicitLock = new ReentrantLock();
    
    /**
     * synchronized - Built-in locking
     */
    public void incrementSynchronized() {
        synchronized (syncLock) {
            count++;
        }  // Automatic unlock
    }
    
    /**
     * Lock - Explicit locking
     */
    public void incrementLock() {
        explicitLock.lock();
        try {
            count++;
        } finally {
            explicitLock.unlock();  // Manual unlock
        }
    }
    
    /**
     * CRITICAL: Always use try-finally with Lock
     */
    public void incorrectLockUsage() {
        explicitLock.lock();
        count++;  // If exception here, lock never released!
        explicitLock.unlock();  // Never reached if exception
        
        // ❌ WRONG: Lock leak if exception occurs
    }
    
    public void correctLockUsage() {
        explicitLock.lock();
        try {
            count++;  // Exception safe
        } finally {
            explicitLock.unlock();  // ALWAYS unlocks
        }
        
        // ✅ CORRECT: Lock always released
    }
    
    /**
     * Comparison table
     */
    public void comparisonTable() {
        /**
         * ┌──────────────────────┬─────────────────┬──────────────────────┐
         * │ Feature              │ synchronized    │ Lock (ReentrantLock) │
         * ├──────────────────────┼─────────────────┼──────────────────────┤
         * │ Locking mechanism    │ Implicit        │ Explicit             │
         * │ Unlock               │ Automatic       │ Manual (finally)     │
         * │ Try lock             │ No              │ Yes (tryLock)        │
         * │ Timeout              │ No              │ Yes                  │
         * │ Interruptible        │ No              │ Yes                  │
         * │ Fairness option      │ No              │ Yes                  │
         * │ Condition variables  │ wait/notify     │ Multiple Conditions  │
         * │ Lock status check    │ No              │ Yes (isLocked)       │
         * │ Performance          │ Good            │ Better (sometimes)   │
         * │ Ease of use          │ Simple          │ More complex         │
         * │ Error-prone          │ Less            │ More (forget unlock) │
         * └──────────────────────┴─────────────────┴──────────────────────┘
         */
    }
    
    /**
     * When to use synchronized
     */
    public void useSynchronized() {
        /**
         * USE synchronized WHEN:
         * 
         * ✓ Simple locking needs
         * ✓ Want automatic unlock
         * ✓ Built-in language feature preferred
         * ✓ No special features needed (tryLock, timeout, etc.)
         * ✓ Monitor pattern (wait/notify sufficient)
         * 
         * EXAMPLES:
         * - Simple counter
         * - Cache updates
         * - Thread-safe collections
         * - Basic critical sections
         */
        
        synchronized (this) {
            // Simple critical section
        }
    }
    
    /**
     * When to use Lock
     */
    public void useLock() {
        /**
         * USE Lock WHEN:
         * 
         * ✓ Need tryLock (non-blocking acquire)
         * ✓ Need timeout on lock acquisition
         * ✓ Need interruptible locking
         * ✓ Need fairness guarantees
         * ✓ Need multiple condition variables
         * ✓ Need hand-over-hand locking
         * ✓ More complex coordination
         * 
         * EXAMPLES:
         * - Database connection pools
         * - Resource pools with timeout
         * - Lock-ordering to prevent deadlock
         * - Multiple wait conditions
         * - Advanced synchronization patterns
         */
        
        Lock lock = new ReentrantLock();
        if (lock.tryLock()) {
            try {
                // Critical section
            } finally {
                lock.unlock();
            }
        } else {
            // Lock not available, do something else
        }
    }
}
```

### Performance Comparison

```java
/**
 * PERFORMANCE: synchronized vs Lock
 */

public class PerformanceComparison {
    
    private int sharedCounter = 0;
    private final Object syncLock = new Object();
    private final Lock explicitLock = new ReentrantLock();
    
    /**
     * Benchmark: synchronized
     */
    public void benchmarkSynchronized() {
        long start = System.nanoTime();
        
        for (int i = 0; i < 10_000_000; i++) {
            synchronized (syncLock) {
                sharedCounter++;
            }
        }
        
        long elapsed = System.nanoTime() - start;
        System.out.println("synchronized: " + elapsed / 1_000_000 + "ms");
    }
    
    /**
     * Benchmark: ReentrantLock
     */
    public void benchmarkLock() {
        long start = System.nanoTime();
        
        for (int i = 0; i < 10_000_000; i++) {
            explicitLock.lock();
            try {
                sharedCounter++;
            } finally {
                explicitLock.unlock();
            }
        }
        
        long elapsed = System.nanoTime() - start;
        System.out.println("ReentrantLock: " + elapsed / 1_000_000 + "ms");
    }
    
    /**
     * Run comparison
     */
    public static void main(String[] args) {
        PerformanceComparison benchmark = new PerformanceComparison();
        
        // Warm up JIT
        for (int i = 0; i < 5; i++) {
            benchmark.benchmarkSynchronized();
            benchmark.benchmarkLock();
        }
        
        // Actual benchmark
        System.out.println("\n=== Performance Test ===");
        benchmark.sharedCounter = 0;
        benchmark.benchmarkSynchronized();
        
        benchmark.sharedCounter = 0;
        benchmark.benchmarkLock();
        
        /**
         * TYPICAL RESULTS (single thread, no contention):
         * 
         * synchronized:   ~150ms
         * ReentrantLock:  ~180ms
         * 
         * synchronized slightly faster (less overhead)
         * 
         * TYPICAL RESULTS (high contention, multiple threads):
         * 
         * synchronized:   ~800ms
         * ReentrantLock:  ~600ms
         * 
         * ReentrantLock faster under contention (better lock algorithm)
         * 
         * CONCLUSION:
         * - Low contention: synchronized faster
         * - High contention: Lock faster
         * - Difference usually small
         * - Choose based on features needed, not just performance
         */
    }
}
```

---

## 2. ReentrantLock Features

### Basic Usage and Reentrancy

```java
/**
 * REENTRANTLOCK BASICS
 */

public class ReentrantLockBasics {
    
    private final ReentrantLock lock = new ReentrantLock();
    
    /**
     * Reentrancy - same thread can acquire lock multiple times
     */
    public void demonstrateReentrancy() {
        lock.lock();
        try {
            System.out.println("Lock acquired, hold count: " + lock.getHoldCount());
            
            // Same thread can acquire again (reentrant)
            lock.lock();
            try {
                System.out.println("Lock re-acquired, hold count: " + lock.getHoldCount());
            } finally {
                lock.unlock();
                System.out.println("First unlock, hold count: " + lock.getHoldCount());
            }
        } finally {
            lock.unlock();
            System.out.println("Second unlock, hold count: " + lock.getHoldCount());
        }
        
        /**
         * OUTPUT:
         * Lock acquired, hold count: 1
         * Lock re-acquired, hold count: 2
         * First unlock, hold count: 1
         * Second unlock, hold count: 0
         * 
         * Reentrancy allows:
         * - Recursive calls
         * - Method calling another synchronized method
         * - Flexible lock acquisition
         * 
         * Each lock() must have matching unlock()!
         */
    }
    
    /**
     * Reentrancy example: Recursive method
     */
    public void processRecursive(int n) {
        lock.lock();
        try {
            System.out.println("Processing: " + n);
            
            if (n > 0) {
                processRecursive(n - 1);  // Reentrant lock acquisition
            }
        } finally {
            lock.unlock();
        }
    }
    
    /**
     * Lock status methods
     */
    public void lockStatusMethods() {
        System.out.println("Is locked: " + lock.isLocked());
        System.out.println("Is held by current thread: " + lock.isHeldByCurrentThread());
        System.out.println("Queue length: " + lock.getQueueLength());
        System.out.println("Has queued threads: " + lock.hasQueuedThreads());
        
        lock.lock();
        try {
            System.out.println("\nAfter lock:");
            System.out.println("Is locked: " + lock.isLocked());
            System.out.println("Is held by current thread: " + lock.isHeldByCurrentThread());
            System.out.println("Hold count: " + lock.getHoldCount());
        } finally {
            lock.unlock();
        }
        
        /**
         * USEFUL FOR:
         * - Debugging
         * - Monitoring
         * - Assertions
         * - Diagnostics
         */
    }
}
```

### Fairness

```java
/**
 * LOCK FAIRNESS
 */

public class LockFairness {
    
    /**
     * Non-fair lock (default)
     */
    public static void nonFairLock() throws InterruptedException {
        ReentrantLock lock = new ReentrantLock(false);  // Non-fair
        
        Runnable task = () -> {
            for (int i = 0; i < 5; i++) {
                lock.lock();
                try {
                    System.out.println(Thread.currentThread().getName() + 
                        " acquired lock");
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                } finally {
                    lock.unlock();
                }
            }
        };
        
        Thread t1 = new Thread(task, "Thread-1");
        Thread t2 = new Thread(task, "Thread-2");
        Thread t3 = new Thread(task, "Thread-3");
        
        t1.start();
        t2.start();
        t3.start();
        
        t1.join();
        t2.join();
        t3.join();
        
        /**
         * OUTPUT (typical):
         * Thread-1 acquired lock
         * Thread-1 acquired lock
         * Thread-1 acquired lock
         * Thread-2 acquired lock
         * Thread-3 acquired lock
         * Thread-2 acquired lock
         * ...
         * 
         * No ordering guarantee
         * Thread-1 may acquire multiple times in a row
         * Better throughput, possible starvation
         */
    }
    
    /**
     * Fair lock
     */
    public static void fairLock() throws InterruptedException {
        ReentrantLock lock = new ReentrantLock(true);  // Fair
        
        Runnable task = () -> {
            for (int i = 0; i < 5; i++) {
                lock.lock();
                try {
                    System.out.println(Thread.currentThread().getName() + 
                        " acquired lock");
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                } finally {
                    lock.unlock();
                }
            }
        };
        
        Thread t1 = new Thread(task, "Thread-1");
        Thread t2 = new Thread(task, "Thread-2");
        Thread t3 = new Thread(task, "Thread-3");
        
        t1.start();
        t2.start();
        t3.start();
        
        t1.join();
        t2.join();
        t3.join();
        
        /**
         * OUTPUT (typical):
         * Thread-1 acquired lock
         * Thread-2 acquired lock
         * Thread-3 acquired lock
         * Thread-1 acquired lock
         * Thread-2 acquired lock
         * Thread-3 acquired lock
         * ...
         * 
         * FIFO ordering (first-in-first-out)
         * Threads acquire in order they requested
         * Prevents starvation, lower throughput
         */
    }
    
    /**
     * Fairness comparison
     */
    public void fairnessComparison() {
        /**
         * NON-FAIR (default):
         * 
         * PROS:
         * ✓ Higher throughput (~10x faster under high contention)
         * ✓ Better CPU cache utilization
         * ✓ Less overhead
         * 
         * CONS:
         * ✗ Possible thread starvation
         * ✗ Unpredictable ordering
         * ✗ Unfair to waiting threads
         * 
         * USE WHEN:
         * - Throughput critical
         * - Short critical sections
         * - Starvation not a concern
         * 
         * 
         * FAIR:
         * 
         * PROS:
         * ✓ No starvation (FIFO)
         * ✓ Predictable ordering
         * ✓ Fair to all threads
         * 
         * CONS:
         * ✗ Lower throughput (~10x slower)
         * ✗ More context switches
         * ✗ Higher overhead
         * 
         * USE WHEN:
         * - Fairness required
         * - Prevent starvation
         * - Latency-sensitive (consistent response times)
         * 
         * 
         * RECOMMENDATION:
         * - Default: Use non-fair (better performance)
         * - Use fair only if starvation is a real problem
         */
    }
}
```

### tryLock() with Timeout

```java
/**
 * TRYLOCK - NON-BLOCKING LOCK ACQUISITION
 */

public class TryLockExamples {
    
    private final ReentrantLock lock = new ReentrantLock();
    
    /**
     * tryLock() - Immediate attempt
     */
    public void tryLockImmediate() {
        if (lock.tryLock()) {
            try {
                System.out.println("Lock acquired");
                // Critical section
            } finally {
                lock.unlock();
            }
        } else {
            System.out.println("Lock not available, doing something else");
            // Alternative action
        }
        
        /**
         * tryLock():
         * - Returns immediately
         * - true if lock acquired
         * - false if lock held by another thread
         * - Non-blocking
         * 
         * USE CASES:
         * - Optional optimization
         * - Graceful degradation
         * - Avoid blocking
         */
    }
    
    /**
     * tryLock(timeout) - Wait for limited time
     */
    public void tryLockWithTimeout() throws InterruptedException {
        if (lock.tryLock(2, java.util.concurrent.TimeUnit.SECONDS)) {
            try {
                System.out.println("Lock acquired within timeout");
                // Critical section
            } finally {
                lock.unlock();
            }
        } else {
            System.out.println("Timeout: Lock not acquired");
            // Timeout handling
        }
        
        /**
         * tryLock(timeout, unit):
         * - Waits up to timeout
         * - true if lock acquired
         * - false if timeout expires
         * - InterruptedException if interrupted
         * 
         * USE CASES:
         * - Prevent indefinite blocking
         * - Deadlock prevention
         * - Timeout guarantees
         */
    }
    
    /**
     * Real-world example: Database connection pool
     */
    static class ConnectionPool {
        private final java.util.Queue<Connection> pool = 
            new java.util.concurrent.ConcurrentLinkedQueue<>();
        private final ReentrantLock lock = new ReentrantLock();
        
        public Connection getConnection(long timeout, 
                java.util.concurrent.TimeUnit unit) throws InterruptedException {
            
            if (lock.tryLock(timeout, unit)) {
                try {
                    if (!pool.isEmpty()) {
                        return pool.poll();
                    }
                    // Create new connection
                    return new Connection();
                } finally {
                    lock.unlock();
                }
            }
            
            throw new RuntimeException("Timeout waiting for connection");
        }
        
        public void releaseConnection(Connection conn) {
            lock.lock();
            try {
                pool.offer(conn);
            } finally {
                lock.unlock();
            }
        }
        
        static class Connection {}
    }
    
    /**
     * Deadlock prevention with tryLock
     */
    static class Account {
        private final String id;
        private int balance;
        private final ReentrantLock lock = new ReentrantLock();
        
        public Account(String id, int balance) {
            this.id = id;
            this.balance = balance;
        }
        
        /**
         * Transfer with deadlock prevention
         */
        public boolean transfer(Account target, int amount) 
                throws InterruptedException {
            
            // Try to acquire both locks
            while (true) {
                boolean gotThis = this.lock.tryLock();
                boolean gotTarget = false;
                
                try {
                    if (gotThis) {
                        gotTarget = target.lock.tryLock();
                        
                        if (gotTarget) {
                            // Both locks acquired
                            if (this.balance >= amount) {
                                this.balance -= amount;
                                target.balance += amount;
                                System.out.println("Transfer successful: " + 
                                    this.id + " -> " + target.id + ": " + amount);
                                return true;
                            }
                            return false;  // Insufficient funds
                        }
                    }
                } finally {
                    if (gotTarget) {
                        target.lock.unlock();
                    }
                    if (gotThis) {
                        this.lock.unlock();
                    }
                }
                
                // Failed to get both locks, retry after small delay
                Thread.sleep(10);
            }
            
            /**
             * DEADLOCK PREVENTION:
             * 
             * Traditional locking:
             * Thread 1: Lock A -> Lock B
             * Thread 2: Lock B -> Lock A
             * → DEADLOCK
             * 
             * With tryLock:
             * Thread 1: tryLock A -> tryLock B (fail) -> unlock A -> retry
             * Thread 2: tryLock B -> tryLock A (fail) -> unlock B -> retry
             * → Eventually one succeeds
             * 
             * No deadlock possible!
             */
        }
    }
    
    /**
     * Demo: Deadlock prevention
     */
    public static void deadlockPreventionDemo() throws InterruptedException {
        Account account1 = new Account("A1", 1000);
        Account account2 = new Account("A2", 1000);
        
        Thread t1 = new Thread(() -> {
            try {
                for (int i = 0; i < 5; i++) {
                    account1.transfer(account2, 100);
                    Thread.sleep(50);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        
        Thread t2 = new Thread(() -> {
            try {
                for (int i = 0; i < 5; i++) {
                    account2.transfer(account1, 100);
                    Thread.sleep(50);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        
        System.out.println("All transfers completed (no deadlock!)");
    }
}
```

---

## 3. Condition Variables

### await() and signal()

```java
/**
 * CONDITION VARIABLES
 * 
 * Like wait()/notify() but more powerful
 * Multiple conditions per lock
 */

public class ConditionVariables {
    
    private final ReentrantLock lock = new ReentrantLock();
    private final Condition condition = lock.newCondition();
    
    /**
     * Basic await/signal pattern
     */
    public void basicAwaitSignal() throws InterruptedException {
        // Thread 1: Wait for condition
        new Thread(() -> {
            lock.lock();
            try {
                System.out.println("Thread 1: Waiting for signal");
                condition.await();  // Release lock and wait
                System.out.println("Thread 1: Received signal");
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } finally {
                lock.unlock();
            }
        }).start();
        
        Thread.sleep(1000);
        
        // Thread 2: Signal condition
        lock.lock();
        try {
            System.out.println("Thread 2: Sending signal");
            condition.signal();  // Wake up one waiting thread
        } finally {
            lock.unlock();
        }
        
        Thread.sleep(100);
        
        /**
         * OUTPUT:
         * Thread 1: Waiting for signal
         * Thread 2: Sending signal
         * Thread 1: Received signal
         * 
         * await():
         * - Must hold lock
         * - Releases lock and waits
         * - Reacquires lock when signaled
         * 
         * signal():
         * - Must hold lock
         * - Wakes one waiting thread
         * - signalAll() wakes all waiting threads
         */
    }
    
    /**
     * Producer-Consumer with Condition
     */
    static class BoundedBuffer<T> {
        private final java.util.Queue<T> queue = new java.util.LinkedList<>();
        private final int capacity;
        
        private final ReentrantLock lock = new ReentrantLock();
        private final Condition notFull = lock.newCondition();
        private final Condition notEmpty = lock.newCondition();
        
        public BoundedBuffer(int capacity) {
            this.capacity = capacity;
        }
        
        public void put(T item) throws InterruptedException {
            lock.lock();
            try {
                // Wait while queue is full
                while (queue.size() == capacity) {
                    System.out.println("Queue full, producer waiting");
                    notFull.await();
                }
                
                queue.offer(item);
                System.out.println("Produced: " + item + 
                    " (size: " + queue.size() + ")");
                
                // Signal that queue is not empty
                notEmpty.signal();
            } finally {
                lock.unlock();
            }
        }
        
        public T take() throws InterruptedException {
            lock.lock();
            try {
                // Wait while queue is empty
                while (queue.isEmpty()) {
                    System.out.println("Queue empty, consumer waiting");
                    notEmpty.await();
                }
                
                T item = queue.poll();
                System.out.println("Consumed: " + item + 
                    " (size: " + queue.size() + ")");
                
                // Signal that queue is not full
                notFull.signal();
                
                return item;
            } finally {
                lock.unlock();
            }
        }
    }
    
    /**
     * Demo: Producer-Consumer
     */
    public static void producerConsumerDemo() throws InterruptedException {
        BoundedBuffer<Integer> buffer = new BoundedBuffer<>(5);
        
        // Producer thread
        Thread producer = new Thread(() -> {
            try {
                for (int i = 0; i < 10; i++) {
                    buffer.put(i);
                    Thread.sleep(100);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        
        // Consumer thread
        Thread consumer = new Thread(() -> {
            try {
                for (int i = 0; i < 10; i++) {
                    buffer.take();
                    Thread.sleep(150);  // Slower than producer
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        
        producer.start();
        consumer.start();
        
        producer.join();
        consumer.join();
        
        /**
         * OUTPUT:
         * Produced: 0 (size: 1)
         * Consumed: 0 (size: 0)
         * Produced: 1 (size: 1)
         * Produced: 2 (size: 2)
         * Consumed: 1 (size: 1)
         * Produced: 3 (size: 2)
         * ...
         * Queue full, producer waiting
         * Consumed: 4 (size: 4)
         * Produced: 5 (size: 5)
         * ...
         */
    }
    
    /**
     * Multiple conditions example
     */
    static class PriorityQueue {
        private final java.util.Queue<String> highPriority = 
            new java.util.LinkedList<>();
        private final java.util.Queue<String> lowPriority = 
            new java.util.LinkedList<>();
        
        private final ReentrantLock lock = new ReentrantLock();
        private final Condition hasHighPriority = lock.newCondition();
        private final Condition hasLowPriority = lock.newCondition();
        
        public void putHigh(String item) {
            lock.lock();
            try {
                highPriority.offer(item);
                hasHighPriority.signal();  // Signal high priority available
            } finally {
                lock.unlock();
            }
        }
        
        public void putLow(String item) {
            lock.lock();
            try {
                lowPriority.offer(item);
                hasLowPriority.signal();  // Signal low priority available
            } finally {
                lock.unlock();
            }
        }
        
        public String takeHigh() throws InterruptedException {
            lock.lock();
            try {
                while (highPriority.isEmpty()) {
                    hasHighPriority.await();
                }
                return highPriority.poll();
            } finally {
                lock.unlock();
            }
        }
        
        public String takeLow() throws InterruptedException {
            lock.lock();
            try {
                while (lowPriority.isEmpty()) {
                    hasLowPriority.await();
                }
                return lowPriority.poll();
            } finally {
                lock.unlock();
            }
        }
        
        /**
         * Multiple conditions allow:
         * - Different wait conditions
         * - Targeted signaling
         * - Better performance (less spurious wakeups)
         */
    }
}
```

---

## 4. ReadWriteLock for Read-Heavy Scenarios

### Basic ReadWriteLock

```java
/**
 * READWRITELOCK
 * 
 * Separates read and write locks
 * Multiple readers OR single writer
 */

public class ReadWriteLockExample {
    
    private final java.util.Map<String, String> cache = 
        new java.util.HashMap<>();
    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();
    private final Lock readLock = rwLock.readLock();
    private final Lock writeLock = rwLock.writeLock();
    
    /**
     * Read operation (shared lock)
     */
    public String get(String key) {
        readLock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + 
                " reading: " + key);
            return cache.get(key);
        } finally {
            readLock.unlock();
        }
    }
    
    /**
     * Write operation (exclusive lock)
     */
    public void put(String key, String value) {
        writeLock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + 
                " writing: " + key + " = " + value);
            cache.put(key, value);
        } finally {
            writeLock.unlock();
        }
    }
    
    /**
     * How ReadWriteLock works
     */
    public void howItWorks() {
        /**
         * LOCKING RULES:
         * 
         * 1. Multiple readers can hold read lock simultaneously
         * 2. Only one writer can hold write lock
         * 3. Readers block writers (read lock held)
         * 4. Writers block readers (write lock held)
         * 5. Writers block writers (write lock is exclusive)
         * 
         * CONCURRENCY:
         * 
         * Readers:  R1 R2 R3 R4 ... (all concurrent)
         * Writer:   W1             (exclusive)
         * 
         * Timeline:
         * 
         * R1 ─────────────────
         * R2 ─────────────────
         * R3 ─────────────────  All reading concurrently
         *                   └──── W1 ───┘  Writer waits for readers
         *                              └──── R4 ─────  Reader waits for writer
         */
    }
    
    /**
     * Demo: Multiple readers
     */
    public static void multipleReadersDemo() throws InterruptedException {
        ReadWriteLockExample cache = new ReadWriteLockExample();
        cache.put("key1", "value1");
        
        // Start 5 readers
        Thread[] readers = new Thread[5];
        for (int i = 0; i < 5; i++) {
            readers[i] = new Thread(() -> {
                for (int j = 0; j < 3; j++) {
                    cache.get("key1");
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            }, "Reader-" + i);
            readers[i].start();
        }
        
        for (Thread reader : readers) {
            reader.join();
        }
        
        /**
         * OUTPUT:
         * Reader-0 reading: key1
         * Reader-1 reading: key1
         * Reader-2 reading: key1  (All concurrent!)
         * Reader-3 reading: key1
         * Reader-4 reading: key1
         * ...
         * 
         * All readers execute concurrently
         * No blocking between readers
         */
    }
}
```

### Performance Comparison

```java
/**
 * PERFORMANCE: ReadWriteLock vs synchronized
 */

public class ReadWriteLockPerformance {
    
    private final java.util.Map<String, String> data = 
        new java.util.HashMap<>();
    
    // synchronized approach
    public synchronized String getSynchronized(String key) {
        return data.get(key);
    }
    
    public synchronized void putSynchronized(String key, String value) {
        data.put(key, value);
    }
    
    // ReadWriteLock approach
    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();
    
    public String getReadWriteLock(String key) {
        rwLock.readLock().lock();
        try {
            return data.get(key);
        } finally {
            rwLock.readLock().unlock();
        }
    }
    
    public void putReadWriteLock(String key, String value) {
        rwLock.writeLock().lock();
        try {
            data.put(key, value);
        } finally {
            rwLock.writeLock().unlock();
        }
    }
    
    /**
     * Benchmark: Read-heavy workload (90% reads, 10% writes)
     */
    public static void benchmarkReadHeavy() throws InterruptedException {
        ReadWriteLockPerformance cache = new ReadWriteLockPerformance();
        
        // Initialize data
        for (int i = 0; i < 100; i++) {
            cache.data.put("key" + i, "value" + i);
        }
        
        int threadCount = 10;
        int iterations = 100_000;
        
        // Test synchronized
        long start = System.currentTimeMillis();
        Thread[] threads1 = new Thread[threadCount];
        
        for (int i = 0; i < threadCount; i++) {
            threads1[i] = new Thread(() -> {
                java.util.Random rand = new java.util.Random();
                for (int j = 0; j < iterations; j++) {
                    if (rand.nextInt(10) < 9) {  // 90% reads
                        cache.getSynchronized("key" + rand.nextInt(100));
                    } else {  // 10% writes
                        cache.putSynchronized("key" + rand.nextInt(100), "value");
                    }
                }
            });
            threads1[i].start();
        }
        
        for (Thread t : threads1) {
            t.join();
        }
        
        long syncTime = System.currentTimeMillis() - start;
        
        // Test ReadWriteLock
        start = System.currentTimeMillis();
        Thread[] threads2 = new Thread[threadCount];
        
        for (int i = 0; i < threadCount; i++) {
            threads2[i] = new Thread(() -> {
                java.util.Random rand = new java.util.Random();
                for (int j = 0; j < iterations; j++) {
                    if (rand.nextInt(10) < 9) {  // 90% reads
                        cache.getReadWriteLock("key" + rand.nextInt(100));
                    } else {  // 10% writes
                        cache.putReadWriteLock("key" + rand.nextInt(100), "value");
                    }
                }
            });
            threads2[i].start();
        }
        
        for (Thread t : threads2) {
            t.join();
        }
        
        long rwLockTime = System.currentTimeMillis() - start;
        
        System.out.println("=== Read-Heavy Workload (90% reads) ===");
        System.out.println("synchronized:    " + syncTime + "ms");
        System.out.println("ReadWriteLock:   " + rwLockTime + "ms");
        System.out.println("Speedup:         " + 
            String.format("%.2f", (double)syncTime / rwLockTime) + "x");
        
        /**
         * TYPICAL RESULTS:
         * 
         * synchronized:    3500ms
         * ReadWriteLock:   800ms
         * Speedup:         4.4x
         * 
         * ReadWriteLock 4-5x faster for read-heavy workloads!
         * 
         * WHY:
         * - synchronized: Only one thread at a time (reads OR writes)
         * - ReadWriteLock: Multiple concurrent readers
         */
    }
    
    /**
     * Benchmark: Write-heavy workload (50% reads, 50% writes)
     */
    public static void benchmarkWriteHeavy() throws InterruptedException {
        ReadWriteLockPerformance cache = new ReadWriteLockPerformance();
        
        for (int i = 0; i < 100; i++) {
            cache.data.put("key" + i, "value" + i);
        }
        
        int threadCount = 10;
        int iterations = 100_000;
        
        // Test synchronized
        long start = System.currentTimeMillis();
        Thread[] threads1 = new Thread[threadCount];
        
        for (int i = 0; i < threadCount; i++) {
            threads1[i] = new Thread(() -> {
                java.util.Random rand = new java.util.Random();
                for (int j = 0; j < iterations; j++) {
                    if (rand.nextBoolean()) {  // 50% reads
                        cache.getSynchronized("key" + rand.nextInt(100));
                    } else {  // 50% writes
                        cache.putSynchronized("key" + rand.nextInt(100), "value");
                    }
                }
            });
            threads1[i].start();
        }
        
        for (Thread t : threads1) {
            t.join();
        }
        
        long syncTime = System.currentTimeMillis() - start;
        
        // Test ReadWriteLock
        start = System.currentTimeMillis();
        Thread[] threads2 = new Thread[threadCount];
        
        for (int i = 0; i < threadCount; i++) {
            threads2[i] = new Thread(() -> {
                java.util.Random rand = new java.util.Random();
                for (int j = 0; j < iterations; j++) {
                    if (rand.nextBoolean()) {  // 50% reads
                        cache.getReadWriteLock("key" + rand.nextInt(100));
                    } else {  // 50% writes
                        cache.putReadWriteLock("key" + rand.nextInt(100), "value");
                    }
                }
            });
            threads2[i].start();
        }
        
        for (Thread t : threads2) {
            t.join();
        }
        
        long rwLockTime = System.currentTimeMillis() - start;
        
        System.out.println("\n=== Write-Heavy Workload (50% writes) ===");
        System.out.println("synchronized:    " + syncTime + "ms");
        System.out.println("ReadWriteLock:   " + rwLockTime + "ms");
        System.out.println("Speedup:         " + 
            String.format("%.2f", (double)syncTime / rwLockTime) + "x");
        
        /**
         * TYPICAL RESULTS:
         * 
         * synchronized:    4000ms
         * ReadWriteLock:   3500ms
         * Speedup:         1.1x
         * 
         * Only ~10% improvement with 50% writes
         * 
         * CONCLUSION:
         * - ReadWriteLock best for read-heavy (>80% reads)
         * - Little benefit for write-heavy workloads
         * - Use synchronized for write-heavy (simpler)
         */
    }
    
    public static void main(String[] args) throws InterruptedException {
        benchmarkReadHeavy();
        benchmarkWriteHeavy();
    }
}
```

---

## 5. StampedLock (Optimistic Reads)

### Basic StampedLock

```java
/**
 * STAMPEDLOCK - OPTIMISTIC LOCKING
 * 
 * Java 8+ feature
 * Three modes: read, write, optimistic read
 * Best performance for read-heavy workloads
 */

import java.util.concurrent.locks.StampedLock;

public class StampedLockExample {
    
    private double x, y;
    private final StampedLock lock = new StampedLock();
    
    /**
     * Write with exclusive lock
     */
    public void move(double deltaX, double deltaY) {
        long stamp = lock.writeLock();  // Exclusive lock
        try {
            x += deltaX;
            y += deltaY;
        } finally {
            lock.unlockWrite(stamp);
        }
    }
    
    /**
     * Read with pessimistic read lock
     */
    public double distanceFromOriginPessimistic() {
        long stamp = lock.readLock();  // Shared read lock
        try {
            return Math.sqrt(x * x + y * y);
        } finally {
            lock.unlockRead(stamp);
        }
    }
    
    /**
     * Read with optimistic lock (NO BLOCKING!)
     */
    public double distanceFromOriginOptimistic() {
        long stamp = lock.tryOptimisticRead();  // Optimistic read (no lock!)
        
        // Read values
        double currentX = x;
        double currentY = y;
        
        // Validate: Were values modified during read?
        if (!lock.validate(stamp)) {
            // Values changed, need real lock
            stamp = lock.readLock();  // Acquire read lock
            try {
                currentX = x;
                currentY = y;
            } finally {
                lock.unlockRead(stamp);
            }
        }
        
        return Math.sqrt(currentX * currentX + currentY * currentY);
        
        /**
         * OPTIMISTIC READ:
         * 
         * 1. tryOptimisticRead() - Get stamp (NO lock acquired!)
         * 2. Read values
         * 3. validate(stamp) - Check if modified
         * 4. If valid: Use values (fast path, no locking!)
         * 5. If invalid: Acquire real lock and retry
         * 
         * BENEFITS:
         * - No blocking on reads (if no writes)
         * - Zero contention for pure readers
         * - Fastest possible reads
         * 
         * WHEN TO USE:
         * - Very read-heavy (>95% reads)
         * - Short read operations
         * - Low write frequency
         */
    }
    
    /**
     * Lock upgrade: Read to Write
     */
    public void moveIfAtOrigin(double newX, double newY) {
        long stamp = lock.readLock();
        try {
            while (x == 0.0 && y == 0.0) {
                // Try to upgrade to write lock
                long writeStamp = lock.tryConvertToWriteLock(stamp);
                
                if (writeStamp != 0L) {
                    // Upgrade successful
                    stamp = writeStamp;
                    x = newX;
                    y = newY;
                    break;
                } else {
                    // Upgrade failed, release read lock and acquire write lock
                    lock.unlockRead(stamp);
                    stamp = lock.writeLock();
                }
            }
        } finally {
            lock.unlock(stamp);
        }
        
        /**
         * Lock conversion:
         * 
         * tryConvertToWriteLock():
         * - Try to upgrade read → write
         * - Returns new stamp if successful
         * - Returns 0 if failed
         * 
         * tryConvertToReadLock():
         * - Try to downgrade write → read
         * 
         * tryConvertToOptimisticRead():
         * - Try to convert to optimistic
         */
    }
    
    /**
     * Demonstration
     */
    public static void demo() throws InterruptedException {
        StampedLockExample point = new StampedLockExample();
        
        // Writer thread
        Thread writer = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                point.move(0.1, 0.1);
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });
        
        // Reader threads (optimistic)
        Thread[] readers = new Thread[5];
        for (int i = 0; i < readers.length; i++) {
            readers[i] = new Thread(() -> {
                for (int j = 0; j < 10000; j++) {
                    double distance = point.distanceFromOriginOptimistic();
                    if (j % 1000 == 0) {
                        System.out.println("Distance: " + distance);
                    }
                }
            });
        }
        
        writer.start();
        for (Thread reader : readers) {
            reader.start();
        }
        
        writer.join();
        for (Thread reader : readers) {
            reader.join();
        }
    }
}
```

### StampedLock Performance

```java
/**
 * PERFORMANCE COMPARISON: ReadWriteLock vs StampedLock
 */

public class StampedLockPerformance {
    
    private int value = 0;
    
    // ReadWriteLock
    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();
    
    public int getReadWriteLock() {
        rwLock.readLock().lock();
        try {
            return value;
        } finally {
            rwLock.readLock().unlock();
        }
    }
    
    public void setReadWriteLock(int value) {
        rwLock.writeLock().lock();
        try {
            this.value = value;
        } finally {
            rwLock.writeLock().unlock();
        }
    }
    
    // StampedLock (optimistic)
    private final StampedLock stampedLock = new StampedLock();
    
    public int getStampedLock() {
        long stamp = stampedLock.tryOptimisticRead();
        int currentValue = value;
        
        if (!stampedLock.validate(stamp)) {
            stamp = stampedLock.readLock();
            try {
                currentValue = value;
            } finally {
                stampedLock.unlockRead(stamp);
            }
        }
        
        return currentValue;
    }
    
    public void setStampedLock(int value) {
        long stamp = stampedLock.writeLock();
        try {
            this.value = value;
        } finally {
            stampedLock.unlockWrite(stamp);
        }
    }
    
    /**
     * Benchmark
     */
    public static void benchmark() throws InterruptedException {
        StampedLockPerformance obj = new StampedLockPerformance();
        
        int threads = 10;
        int iterations = 10_000_000;
        
        // ReadWriteLock benchmark
        long start = System.currentTimeMillis();
        Thread[] rwThreads = new Thread[threads];
        
        for (int i = 0; i < threads; i++) {
            rwThreads[i] = new Thread(() -> {
                java.util.Random rand = new java.util.Random();
                for (int j = 0; j < iterations; j++) {
                    if (rand.nextInt(100) < 99) {  // 99% reads
                        obj.getReadWriteLock();
                    } else {  // 1% writes
                        obj.setReadWriteLock(j);
                    }
                }
            });
            rwThreads[i].start();
        }
        
        for (Thread t : rwThreads) {
            t.join();
        }
        
        long rwTime = System.currentTimeMillis() - start;
        
        // StampedLock benchmark
        start = System.currentTimeMillis();
        Thread[] stampedThreads = new Thread[threads];
        
        for (int i = 0; i < threads; i++) {
            stampedThreads[i] = new Thread(() -> {
                java.util.Random rand = new java.util.Random();
                for (int j = 0; j < iterations; j++) {
                    if (rand.nextInt(100) < 99) {  // 99% reads
                        obj.getStampedLock();
                    } else {  // 1% writes
                        obj.setStampedLock(j);
                    }
                }
            });
            stampedThreads[i].start();
        }
        
        for (Thread t : stampedThreads) {
            t.join();
        }
        
        long stampedTime = System.currentTimeMillis() - start;
        
        System.out.println("=== StampedLock vs ReadWriteLock ===");
        System.out.println("ReadWriteLock:  " + rwTime + "ms");
        System.out.println("StampedLock:    " + stampedTime + "ms");
        System.out.println("Speedup:        " + 
            String.format("%.2f", (double)rwTime / stampedTime) + "x");
        
        /**
         * TYPICAL RESULTS (99% reads, 1% writes):
         * 
         * ReadWriteLock:  2500ms
         * StampedLock:    800ms
         * Speedup:        3.1x
         * 
         * StampedLock 3x faster for very read-heavy workloads!
         * 
         * WHY:
         * - Optimistic reads don't acquire lock
         * - Zero contention for pure readers
         * - Only acquire lock on validation failure
         */
    }
    
    /**
     * When to use each
     */
    public void whenToUseEach() {
        /**
         * USE STAMPEDLOCK WHEN:
         * 
         * ✓ Very read-heavy (>95% reads)
         * ✓ Short read operations
         * ✓ Low write frequency
         * ✓ Maximum performance critical
         * 
         * USE READWRITELOCK WHEN:
         * 
         * ✓ Read-heavy (>80% reads)
         * ✓ Moderate write frequency
         * ✓ Need Condition variables
         * ✓ Need fairness
         * 
         * USE SYNCHRONIZED WHEN:
         * 
         * ✓ Write-heavy (>50% writes)
         * ✓ Simple locking needs
         * ✓ Ease of use important
         * 
         * PERFORMANCE RANKING (read-heavy):
         * 1. StampedLock (optimistic) - Fastest
         * 2. ReadWriteLock
         * 3. synchronized - Slowest
         */
    }
    
    public static void main(String[] args) throws InterruptedException {
        benchmark();
    }
}
```

---

## 6. Lock-Free Algorithms

### Compare-And-Swap (CAS)

```java
/**
 * LOCK-FREE PROGRAMMING
 * 
 * Use atomic operations instead of locks
 * Non-blocking algorithms
 */

import java.util.concurrent.atomic.*;

public class LockFreeAlgorithms {
    
    /**
     * Problem: Counter with lock
     */
    static class LockedCounter {
        private int count = 0;
        private final Object lock = new Object();
        
        public void increment() {
            synchronized (lock) {
                count++;
            }
        }
        
        public int get() {
            synchronized (lock) {
                return count;
            }
        }
        
        /**
         * PROBLEMS:
         * - Thread blocking
         * - Contention
         * - Possible deadlock
         * - Context switching overhead
         */
    }
    
    /**
     * Solution: Lock-free counter
     */
    static class LockFreeCounter {
        private final AtomicInteger count = new AtomicInteger(0);
        
        public void increment() {
            count.incrementAndGet();  // Lock-free CAS operation
        }
        
        public int get() {
            return count.get();
        }
        
        /**
         * BENEFITS:
         * - No thread blocking
         * - No locks
         * - No deadlock possible
         * - Better performance under high contention
         */
    }
    
    /**
     * How CAS works
     */
    public void howCASWorks() {
        AtomicInteger value = new AtomicInteger(10);
        
        // compareAndSet(expected, new)
        boolean success1 = value.compareAndSet(10, 20);
        System.out.println("CAS(10, 20): " + success1);  // true
        System.out.println("Value: " + value.get());     // 20
        
        boolean success2 = value.compareAndSet(10, 30);
        System.out.println("CAS(10, 30): " + success2);  // false (value is 20, not 10)
        System.out.println("Value: " + value.get());     // 20 (unchanged)
        
        /**
         * COMPARE-AND-SWAP ALGORITHM:
         * 
         * 1. Read current value
         * 2. Compute new value
         * 3. compareAndSet(current, new):
         *    - If value == current: Update to new, return true
         *    - Else: Return false (value changed by another thread)
         * 4. If false, retry from step 1
         * 
         * Implemented in hardware (single CPU instruction)
         * Atomic and lock-free
         */
    }
    
    /**
     * Lock-free stack
     */
    static class LockFreeStack<T> {
        private static class Node<T> {
            final T value;
            Node<T> next;
            
            Node(T value) {
                this.value = value;
            }
        }
        
        private final AtomicReference<Node<T>> head = 
            new AtomicReference<>(null);
        
        public void push(T value) {
            Node<T> newHead = new Node<>(value);
            Node<T> oldHead;
            
            do {
                oldHead = head.get();
                newHead.next = oldHead;
            } while (!head.compareAndSet(oldHead, newHead));
            
            /**
             * CAS loop:
             * 1. Read current head
             * 2. Set new node's next to current head
             * 3. Try to swap head with new node
             * 4. If fails (head changed), retry
             * 
             * Lock-free: At least one thread makes progress
             */
        }
        
        public T pop() {
            Node<T> oldHead;
            Node<T> newHead;
            
            do {
                oldHead = head.get();
                if (oldHead == null) {
                    return null;
                }
                newHead = oldHead.next;
            } while (!head.compareAndSet(oldHead, newHead));
            
            return oldHead.value;
        }
    }
    
    /**
     * Lock-free queue (simplified)
     */
    static class LockFreeQueue<T> {
        private static class Node<T> {
            final T value;
            final AtomicReference<Node<T>> next = new AtomicReference<>(null);
            
            Node(T value) {
                this.value = value;
            }
        }
        
        private final AtomicReference<Node<T>> head;
        private final AtomicReference<Node<T>> tail;
        
        public LockFreeQueue() {
            Node<T> dummy = new Node<>(null);
            head = new AtomicReference<>(dummy);
            tail = new AtomicReference<>(dummy);
        }
        
        public void enqueue(T value) {
            Node<T> newNode = new Node<>(value);
            
            while (true) {
                Node<T> currentTail = tail.get();
                Node<T> tailNext = currentTail.next.get();
                
                if (currentTail == tail.get()) {  // Still valid?
                    if (tailNext != null) {
                        // Tail behind, try to advance it
                        tail.compareAndSet(currentTail, tailNext);
                    } else {
                        // Try to link new node
                        if (currentTail.next.compareAndSet(null, newNode)) {
                            // Success, try to advance tail
                            tail.compareAndSet(currentTail, newNode);
                            return;
                        }
                    }
                }
            }
        }
        
        public T dequeue() {
            while (true) {
                Node<T> currentHead = head.get();
                Node<T> currentTail = tail.get();
                Node<T> headNext = currentHead.next.get();
                
                if (currentHead == head.get()) {  // Still valid?
                    if (currentHead == currentTail) {
                        if (headNext == null) {
                            return null;  // Queue empty
                        }
                        // Tail behind, advance it
                        tail.compareAndSet(currentTail, headNext);
                    } else {
                        T value = headNext.value;
                        if (head.compareAndSet(currentHead, headNext)) {
                            return value;  // Success
                        }
                    }
                }
            }
        }
        
        /**
         * Lock-free queue algorithm (Michael-Scott)
         * 
         * Complex but:
         * - No locks
         * - No blocking
         * - Always makes progress
         * - Used in java.util.concurrent.ConcurrentLinkedQueue
         */
    }
    
    /**
     * Performance comparison
     */
    public static void performanceComparison() throws InterruptedException {
        int threads = 10;
        int iterations = 1_000_000;
        
        // Locked counter
        LockedCounter locked = new LockedCounter();
        long start = System.currentTimeMillis();
        
        Thread[] lockedThreads = new Thread[threads];
        for (int i = 0; i < threads; i++) {
            lockedThreads[i] = new Thread(() -> {
                for (int j = 0; j < iterations; j++) {
                    locked.increment();
                }
            });
            lockedThreads[i].start();
        }
        
        for (Thread t : lockedThreads) {
            t.join();
        }
        
        long lockedTime = System.currentTimeMillis() - start;
        
        // Lock-free counter
        LockFreeCounter lockFree = new LockFreeCounter();
        start = System.currentTimeMillis();
        
        Thread[] lockFreeThreads = new Thread[threads];
        for (int i = 0; i < threads; i++) {
            lockFreeThreads[i] = new Thread(() -> {
                for (int j = 0; j < iterations; j++) {
                    lockFree.increment();
                }
            });
            lockFreeThreads[i].start();
        }
        
        for (Thread t : lockFreeThreads) {
            t.join();
        }
        
        long lockFreeTime = System.currentTimeMillis() - start;
        
        System.out.println("=== Lock vs Lock-Free ===");
        System.out.println("Locked:    " + lockedTime + "ms");
        System.out.println("Lock-free: " + lockFreeTime + "ms");
        System.out.println("Speedup:   " + 
            String.format("%.2f", (double)lockedTime / lockFreeTime) + "x");
        
        /**
         * TYPICAL RESULTS:
         * 
         * Locked:    2500ms
         * Lock-free: 1200ms
         * Speedup:   2.1x
         * 
         * Lock-free 2x faster under high contention!
         */
    }
    
    public static void main(String[] args) throws InterruptedException {
        LockFreeAlgorithms demo = new LockFreeAlgorithms();
        demo.howCASWorks();
        System.out.println();
        performanceComparison();
    }
}
```

---

## Summary

### Lock Type Comparison

```
┌─────────────────┬──────────────┬──────────────┬──────────────┬──────────────┐
│ Lock Type       │ Complexity   │ Performance  │ Use Case     │ Features     │
├─────────────────┼──────────────┼──────────────┼──────────────┼──────────────┤
│ synchronized    │ Simple       │ Good         │ General      │ Automatic    │
│ ReentrantLock   │ Medium       │ Good-Better  │ Advanced     │ tryLock,     │
│                 │              │              │ needs        │ timeout      │
│ ReadWriteLock   │ Medium       │ Better       │ Read-heavy   │ Read/write   │
│                 │              │              │ (>80% read)  │ separation   │
│ StampedLock     │ Complex      │ Best         │ Very read-   │ Optimistic   │
│                 │              │              │ heavy (>95%) │ reads        │
│ Lock-free (CAS) │ Very Complex │ Best         │ High         │ Non-blocking │
│                 │              │              │ contention   │              │
└─────────────────┴──────────────┴──────────────┴──────────────┴──────────────┘
```

### Quick Reference

**ReentrantLock:**

```java
Lock lock = new ReentrantLock();
lock.lock();
try {
    // Critical section
} finally {
    lock.unlock();  // Always in finally!
}

// Try lock with timeout
if (lock.tryLock(2, TimeUnit.SECONDS)) {
    try {
        // Got lock
    } finally {
        lock.unlock();
    }
}
```

**ReadWriteLock:**

```java
ReadWriteLock rwLock = new ReentrantReadWriteLock();

// Read
rwLock.readLock().lock();
try {
    // Read data (multiple readers OK)
} finally {
    rwLock.readLock().unlock();
}

// Write
rwLock.writeLock().lock();
try {
    // Write data (exclusive)
} finally {
    rwLock.writeLock().unlock();
}
```

**StampedLock:**

```java
StampedLock lock = new StampedLock();

// Optimistic read (fastest)
long stamp = lock.tryOptimisticRead();
// Read data
if (!lock.validate(stamp)) {
    // Validation failed, get real lock
    stamp = lock.readLock();
    try {
        // Re-read data
    } finally {
        lock.unlockRead(stamp);
    }
}
```

**Lock-Free:**

```java
AtomicInteger counter = new AtomicInteger(0);
counter.incrementAndGet();  // Lock-free

AtomicReference<Node> head = new AtomicReference<>();
head.compareAndSet(expected, newValue);  // CAS
```

### Performance Summary

**Read-Heavy Workload (95% reads):**

- synchronized: Baseline
- ReadWriteLock: 4-5x faster
- StampedLock: 8-10x faster
- **Winner: StampedLock**

**Write-Heavy Workload (50% writes):**

- synchronized: Baseline
- ReadWriteLock: 1.1x faster
- ReentrantLock: 1.2x faster
- **Winner: synchronized (simplicity)**

**High Contention:**

- synchronized: Baseline
- Lock-free (CAS): 2-3x faster
- **Winner: Lock-free**

### Best Practices

1. ✅ Default to `synchronized` for simplicity
2. ✅ Use `ReentrantLock` when need tryLock, timeout, or fairness
3. ✅ Use `ReadWriteLock` for read-heavy (>80% reads)
4. ✅ Use `StampedLock` for very read-heavy (>95% reads)
5. ✅ Use lock-free (AtomicXxx) for simple counters/flags
6. ✅ Always unlock in `finally` block
7. ❌ Don't forget to unlock (use try-finally)
8. ❌ Don't use fair locks unless necessary (10x slower)
9. ❌ Don't use `StampedLock` with `Condition` (not supported)
10. ❌ Don't optimize prematurely - measure first!

---
