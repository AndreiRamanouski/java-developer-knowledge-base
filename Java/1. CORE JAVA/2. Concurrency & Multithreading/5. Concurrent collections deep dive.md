# Java Concurrent Collections Deep Dive

## Overview

Java's concurrent collections provide thread-safe data structures optimized for concurrent access. This guide covers implementation details, use cases, performance characteristics, and decision criteria for choosing the right collection.


---

## 1. ConcurrentHashMap Implementation

### Java 7 vs Java 8+ Architecture

```java
/**
 * CONCURRENTHASHMAP EVOLUTION
 * 
 * Java 7: Segment-based locking
 * Java 8+: CAS + synchronized on nodes
 */

import java.util.concurrent.*;
import java.util.Map;

public class ConcurrentHashMapArchitecture {
    
    /**
     * Java 7 Architecture (Segments)
     */
    public void java7Architecture() {
        /**
         * JAVA 7 STRUCTURE:
         * 
         * ConcurrentHashMap
         * ├── Segment[0]  (ReentrantLock)
         * │   └── HashEntry[] buckets
         * ├── Segment[1]  (ReentrantLock)
         * │   └── HashEntry[] buckets
         * ├── Segment[2]  (ReentrantLock)
         * │   └── HashEntry[] buckets
         * └── ...
         * 
         * - 16 segments by default (concurrencyLevel)
         * - Each segment is a ReentrantLock
         * - put() locks one segment
         * - Up to 16 concurrent writers
         * 
         * PROS:
         * ✓ Good concurrency (16 parallel writes)
         * ✓ Lower contention than single lock
         * 
         * CONS:
         * ✗ Fixed segment count
         * ✗ Memory overhead (16 locks)
         * ✗ size() requires locking all segments
         */
    }
    
    /**
     * Java 8+ Architecture (CAS + Node locks)
     */
    public void java8Architecture() {
        /**
         * JAVA 8+ STRUCTURE:
         * 
         * ConcurrentHashMap
         * └── Node[] table (array of buckets)
         *     ├── Node (single entry)
         *     ├── Node → Node → Node (linked list)
         *     └── TreeNode (red-black tree if >8 entries)
         * 
         * - Array of buckets (like HashMap)
         * - Each bucket independently synchronized
         * - Uses CAS for lock-free updates
         * - Synchronized only when needed
         * 
         * LOCKING STRATEGY:
         * 
         * 1. Empty bucket: CAS to add first node (lock-free)
         * 2. Existing bucket: synchronized on first node
         * 3. Tree conversion: synchronized on tree root
         * 
         * PROS:
         * ✓ Better concurrency (fine-grained locking)
         * ✓ Lower memory overhead
         * ✓ Better size() performance
         * ✓ Tree structure for hash collisions
         * 
         * CONS:
         * ✗ More complex implementation
         */
    }
}
```

### ConcurrentHashMap Operations

```java
/**
 * CONCURRENTHASHMAP INTERNALS
 */

public class ConcurrentHashMapOperations {
    
    private final ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
    
    /**
     * put() - How it works
     */
    public void putOperation() {
        map.put("key", 42);
        
        /**
         * PUT ALGORITHM (Java 8+):
         * 
         * 1. Compute hash of key
         * 2. Find bucket index: hash & (table.length - 1)
         * 3. If bucket empty:
         *    - Use CAS to add node (lock-free!)
         * 4. If bucket has entries:
         *    - synchronized (first node) {
         *        - Traverse list/tree
         *        - Update existing or add new
         *      }
         * 5. If bucket size > 8:
         *    - Convert to red-black tree (O(log n) lookup)
         * 
         * CONCURRENCY:
         * - Different buckets: Fully concurrent
         * - Same bucket: Synchronized (one writer at a time)
         * - Empty bucket: Lock-free CAS
         */
    }
    
    /**
     * get() - Lock-free reads
     */
    public void getOperation() {
        Integer value = map.get("key");
        
        /**
         * GET ALGORITHM:
         * 
         * 1. Compute hash of key
         * 2. Find bucket index
         * 3. Traverse linked list or tree
         * 4. Return value if found
         * 
         * IMPORTANT: No locking!
         * - Uses volatile reads
         * - Always sees most recent write
         * - Fully concurrent with writes
         * 
         * PERFORMANCE:
         * - O(1) average case (good hash distribution)
         * - O(log n) worst case (tree bucket)
         * - Never blocks
         */
    }
    
    /**
     * putIfAbsent() - Atomic operation
     */
    public void putIfAbsentOperation() {
        Integer oldValue = map.putIfAbsent("key", 42);
        
        if (oldValue == null) {
            System.out.println("Key was absent, added 42");
        } else {
            System.out.println("Key exists with value: " + oldValue);
        }
        
        /**
         * ATOMIC OPERATIONS:
         * 
         * putIfAbsent(key, value)   - Add only if absent
         * remove(key, value)        - Remove only if matches
         * replace(key, old, new)    - Replace only if matches
         * compute(key, function)    - Compute atomically
         * merge(key, value, function) - Merge atomically
         * 
         * All atomic (no race conditions)
         * Locking is internal and automatic
         */
    }
    
    /**
     * size() and isEmpty()
     */
    public void sizeOperations() {
        int size = map.size();
        boolean empty = map.isEmpty();
        
        /**
         * SIZE IN JAVA 8+:
         * 
         * - Uses baseCount field + counterCells array
         * - Each thread updates its own cell
         * - size() sums all cells
         * - Lock-free counting!
         * 
         * JAVA 7:
         * - Had to lock all segments
         * - Expensive operation
         * - Could retry without locking if count stable
         * 
         * IMPORTANT:
         * - size() is approximate (concurrent modifications)
         * - Use for monitoring, not synchronization
         */
    }
    
    /**
     * Bulk operations (Java 8+)
     */
    public void bulkOperations() {
        // forEach - parallel iteration
        map.forEach(4, (key, value) -> {
            System.out.println(key + " = " + value);
        });
        
        // search - parallel search
        String result = map.search(4, (key, value) -> {
            return value > 100 ? key : null;
        });
        
        // reduce - parallel reduction
        Integer sum = map.reduce(4, 
            (key, value) -> value,
            (v1, v2) -> v1 + v2);
        
        /**
         * PARALLEL BULK OPERATIONS:
         * 
         * First parameter: parallelismThreshold
         * - If map.size() >= threshold: Use ForkJoinPool
         * - If map.size() < threshold: Sequential
         * 
         * METHODS:
         * - forEach(threshold, action)
         * - search(threshold, function)
         * - reduce(threshold, transformer, reducer)
         * - reduceKeys, reduceValues, reduceEntries
         * 
         * BENEFITS:
         * - Automatic parallelization
         * - Efficient for large maps
         * - Uses ForkJoinPool
         */
    }
    
    /**
     * Demonstration of concurrency
     */
    public static void concurrencyDemo() throws InterruptedException {
        ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
        
        // 10 writer threads
        Thread[] writers = new Thread[10];
        for (int i = 0; i < 10; i++) {
            final int threadId = i;
            writers[i] = new Thread(() -> {
                for (int j = 0; j < 1000; j++) {
                    map.put("key-" + (threadId * 1000 + j), j);
                }
            });
            writers[i].start();
        }
        
        // 10 reader threads
        Thread[] readers = new Thread[10];
        for (int i = 0; i < 10; i++) {
            readers[i] = new Thread(() -> {
                for (int j = 0; j < 10000; j++) {
                    map.get("key-" + j);
                }
            });
            readers[i].start();
        }
        
        // Wait for completion
        for (Thread writer : writers) writer.join();
        for (Thread reader : readers) reader.join();
        
        System.out.println("Final size: " + map.size());
        
        /**
         * OUTPUT:
         * Final size: 10000
         * 
         * All operations thread-safe
         * No ConcurrentModificationException
         * No data loss
         */
    }
}
```

### Performance Characteristics

```java
/**
 * CONCURRENTHASHMAP PERFORMANCE
 */

public class ConcurrentHashMapPerformance {
    
    /**
     * Benchmark: ConcurrentHashMap vs Hashtable vs synchronized HashMap
     */
    public static void benchmark() throws InterruptedException {
        int threads = 10;
        int iterations = 100_000;
        
        // Test 1: ConcurrentHashMap
        ConcurrentHashMap<Integer, Integer> concurrentMap = new ConcurrentHashMap<>();
        long start = System.currentTimeMillis();
        
        Thread[] chThreads = new Thread[threads];
        for (int i = 0; i < threads; i++) {
            chThreads[i] = new Thread(() -> {
                java.util.Random rand = new java.util.Random();
                for (int j = 0; j < iterations; j++) {
                    if (rand.nextBoolean()) {
                        concurrentMap.put(j, j);
                    } else {
                        concurrentMap.get(j);
                    }
                }
            });
            chThreads[i].start();
        }
        for (Thread t : chThreads) t.join();
        long chTime = System.currentTimeMillis() - start;
        
        // Test 2: Hashtable (synchronized)
        java.util.Hashtable<Integer, Integer> hashtable = new java.util.Hashtable<>();
        start = System.currentTimeMillis();
        
        Thread[] htThreads = new Thread[threads];
        for (int i = 0; i < threads; i++) {
            htThreads[i] = new Thread(() -> {
                java.util.Random rand = new java.util.Random();
                for (int j = 0; j < iterations; j++) {
                    if (rand.nextBoolean()) {
                        hashtable.put(j, j);
                    } else {
                        hashtable.get(j);
                    }
                }
            });
            htThreads[i].start();
        }
        for (Thread t : htThreads) t.join();
        long htTime = System.currentTimeMillis() - start;
        
        // Test 3: Collections.synchronizedMap
        Map<Integer, Integer> syncMap = 
            java.util.Collections.synchronizedMap(new java.util.HashMap<>());
        start = System.currentTimeMillis();
        
        Thread[] smThreads = new Thread[threads];
        for (int i = 0; i < threads; i++) {
            smThreads[i] = new Thread(() -> {
                java.util.Random rand = new java.util.Random();
                for (int j = 0; j < iterations; j++) {
                    if (rand.nextBoolean()) {
                        syncMap.put(j, j);
                    } else {
                        syncMap.get(j);
                    }
                }
            });
            smThreads[i].start();
        }
        for (Thread t : smThreads) t.join();
        long smTime = System.currentTimeMillis() - start;
        
        System.out.println("=== Performance Comparison ===");
        System.out.println("ConcurrentHashMap:     " + chTime + "ms");
        System.out.println("Hashtable:             " + htTime + "ms");
        System.out.println("SynchronizedMap:       " + smTime + "ms");
        System.out.println("\nConcurrentHashMap speedup:");
        System.out.println("  vs Hashtable:        " + 
            String.format("%.2f", (double)htTime / chTime) + "x");
        System.out.println("  vs SynchronizedMap:  " + 
            String.format("%.2f", (double)smTime / chTime) + "x");
        
        /**
         * TYPICAL RESULTS:
         * 
         * ConcurrentHashMap:     800ms
         * Hashtable:             3500ms
         * SynchronizedMap:       3800ms
         * 
         * Speedup:
         *   vs Hashtable:        4.4x
         *   vs SynchronizedMap:  4.8x
         * 
         * ConcurrentHashMap 4-5x faster!
         * 
         * WHY:
         * - Fine-grained locking (per bucket)
         * - Lock-free reads
         * - CAS for empty buckets
         * - Hashtable/SyncMap: Single lock for entire map
         */
    }
    
    public static void main(String[] args) throws InterruptedException {
        benchmark();
    }
}
```

---

## 2. CopyOnWriteArrayList

### Implementation and Use Cases

```java
/**
 * COPYONWRITEARRAYLIST
 * 
 * Thread-safe ArrayList variant
 * Write operations copy entire array
 */

import java.util.concurrent.CopyOnWriteArrayList;
import java.util.List;

public class CopyOnWriteArrayListExample {
    
    private final CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();
    
    /**
     * How it works
     */
    public void howItWorks() {
        /**
         * INTERNAL STRUCTURE:
         * 
         * private volatile Object[] array;
         * private final ReentrantLock lock = new ReentrantLock();
         * 
         * READ OPERATIONS:
         * - No locking
         * - Read from current array
         * - Snapshot isolation (iterator sees snapshot)
         * 
         * WRITE OPERATIONS:
         * 1. Acquire lock
         * 2. Copy entire array
         * 3. Modify copy
         * 4. Replace array reference (volatile write)
         * 5. Release lock
         * 
         * Example: add()
         * 
         * lock.lock();
         * try {
         *     Object[] elements = getArray();
         *     int len = elements.length;
         *     Object[] newElements = Arrays.copyOf(elements, len + 1);
         *     newElements[len] = element;
         *     setArray(newElements);  // volatile write
         * } finally {
         *     lock.unlock();
         * }
         */
    }
    
    /**
     * add() operation
     */
    public void addOperation() {
        list.add("A");
        list.add("B");
        list.add("C");
        
        /**
         * EACH ADD:
         * 1. Lock acquired
         * 2. Array copied (entire array!)
         * 3. Element added to copy
         * 4. Array reference updated
         * 5. Lock released
         * 
         * EXPENSIVE for large lists or frequent writes!
         */
    }
    
    /**
     * get() operation
     */
    public void getOperation() {
        String element = list.get(0);
        
        /**
         * GET:
         * - No locking
         * - Direct array access
         * - Very fast
         * - Lock-free
         */
    }
    
    /**
     * Iterator (snapshot)
     */
    public void iteratorBehavior() {
        list.add("A");
        list.add("B");
        
        // Get iterator
        java.util.Iterator<String> iterator = list.iterator();
        
        // Modify list
        list.add("C");
        list.remove("A");
        
        // Iterator still sees original snapshot
        System.out.println("Iterator contents:");
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
        
        System.out.println("\nCurrent list:");
        System.out.println(list);
        
        /**
         * OUTPUT:
         * Iterator contents:
         * A
         * B
         * 
         * Current list:
         * [B, C]
         * 
         * SNAPSHOT ISOLATION:
         * - Iterator sees array at creation time
         * - No ConcurrentModificationException
         * - Modifications don't affect iterator
         * 
         * IMPORTANT:
         * - iterator.remove() throws UnsupportedOperationException
         * - Iterator is read-only snapshot
         */
    }
    
    /**
     * Use cases
     */
    public void useCases() {
        /**
         * IDEAL FOR:
         * 
         * ✓ Read-heavy workloads (>99% reads)
         * ✓ Small lists (< 1000 elements)
         * ✓ Infrequent writes
         * ✓ Iteration more common than modification
         * ✓ Snapshot semantics desired
         * 
         * EXAMPLES:
         * - Event listeners list
         * - Observer pattern
         * - Configuration settings
         * - Cache of rarely-changing data
         * - UI component list
         * 
         * 
         * AVOID FOR:
         * 
         * ✗ Write-heavy workloads
         * ✗ Large lists
         * ✗ Frequent modifications
         * ✗ Memory-constrained environments
         * 
         * WHY:
         * - Each write copies entire array
         * - O(n) for add/remove
         * - High memory overhead
         */
    }
    
    /**
     * Real-world example: Event listeners
     */
    static class Button {
        private final CopyOnWriteArrayList<java.util.function.Consumer<String>> 
            listeners = new CopyOnWriteArrayList<>();
        
        public void addClickListener(java.util.function.Consumer<String> listener) {
            listeners.add(listener);
        }
        
        public void removeClickListener(java.util.function.Consumer<String> listener) {
            listeners.remove(listener);
        }
        
        public void click() {
            // Iterate over listeners (lock-free, snapshot)
            for (java.util.function.Consumer<String> listener : listeners) {
                listener.accept("Button clicked");
            }
        }
        
        /**
         * BENEFITS:
         * - Listeners can be added/removed during iteration
         * - No ConcurrentModificationException
         * - Iteration is lock-free (fast)
         * - Writes (add/remove listener) are rare
         * 
         * Perfect use case for CopyOnWriteArrayList!
         */
    }
    
    /**
     * Performance characteristics
     */
    public static void performanceDemo() throws InterruptedException {
        // Read-heavy workload
        CopyOnWriteArrayList<Integer> cowList = new CopyOnWriteArrayList<>();
        java.util.List<Integer> syncList = 
            java.util.Collections.synchronizedList(new java.util.ArrayList<>());
        
        // Initialize
        for (int i = 0; i < 100; i++) {
            cowList.add(i);
            syncList.add(i);
        }
        
        int threads = 10;
        int iterations = 100_000;
        
        // Test CopyOnWriteArrayList
        long start = System.currentTimeMillis();
        Thread[] cowThreads = new Thread[threads];
        
        for (int i = 0; i < threads; i++) {
            cowThreads[i] = new Thread(() -> {
                java.util.Random rand = new java.util.Random();
                for (int j = 0; j < iterations; j++) {
                    if (rand.nextInt(100) < 99) {  // 99% reads
                        cowList.get(rand.nextInt(100));
                    } else {  // 1% writes
                        cowList.add(rand.nextInt());
                    }
                }
            });
            cowThreads[i].start();
        }
        for (Thread t : cowThreads) t.join();
        long cowTime = System.currentTimeMillis() - start;
        
        // Test synchronized ArrayList
        start = System.currentTimeMillis();
        Thread[] syncThreads = new Thread[threads];
        
        for (int i = 0; i < threads; i++) {
            syncThreads[i] = new Thread(() -> {
                java.util.Random rand = new java.util.Random();
                for (int j = 0; j < iterations; j++) {
                    synchronized (syncList) {
                        if (rand.nextInt(100) < 99) {  // 99% reads
                            syncList.get(rand.nextInt(100));
                        } else {  // 1% writes
                            syncList.add(rand.nextInt());
                        }
                    }
                }
            });
            syncThreads[i].start();
        }
        for (Thread t : syncThreads) t.join();
        long syncTime = System.currentTimeMillis() - start;
        
        System.out.println("=== Read-Heavy (99% reads) ===");
        System.out.println("CopyOnWriteArrayList:  " + cowTime + "ms");
        System.out.println("Synchronized List:     " + syncTime + "ms");
        System.out.println("Speedup:               " + 
            String.format("%.2f", (double)syncTime / cowTime) + "x");
        
        /**
         * TYPICAL RESULTS:
         * 
         * CopyOnWriteArrayList:  600ms
         * Synchronized List:     2500ms
         * Speedup:               4.2x
         * 
         * CopyOnWriteArrayList 4x faster for read-heavy!
         */
    }
}
```

---

## 3. BlockingQueue Implementations

### Queue Comparison

```java
/**
 * BLOCKINGQUEUE IMPLEMENTATIONS
 */

import java.util.concurrent.*;

public class BlockingQueueComparison {
    
    /**
     * Overview of implementations
     */
    public void overview() {
        /**
         * ┌────────────────────────┬──────────┬─────────┬───────────┬─────────────┐
         * │ Implementation         │ Bounded  │ Ordered │ Locking   │ Performance │
         * ├────────────────────────┼──────────┼─────────┼───────────┼─────────────┤
         * │ ArrayBlockingQueue     │ Yes      │ FIFO    │ 1 lock    │ Good        │
         * │ LinkedBlockingQueue    │ Optional │ FIFO    │ 2 locks   │ Better      │
         * │ PriorityBlockingQueue  │ No       │ Priority│ 1 lock    │ Good        │
         * │ SynchronousQueue       │ N/A      │ N/A     │ CAS/spin  │ Best        │
         * │ DelayQueue             │ No       │ Delay   │ 1 lock    │ Good        │
         * │ LinkedTransferQueue    │ No       │ FIFO    │ CAS       │ Best        │
         * └────────────────────────┴──────────┴─────────┴───────────┴─────────────┘
         */
    }
}
```

### ArrayBlockingQueue

```java
/**
 * ARRAYBLOCKINGQUEUE
 * 
 * Bounded FIFO queue backed by array
 */

public class ArrayBlockingQueueExample {
    
    /**
     * Basic usage
     */
    public static void basicUsage() throws InterruptedException {
        BlockingQueue<String> queue = new ArrayBlockingQueue<>(5);
        
        // Producer
        new Thread(() -> {
            try {
                for (int i = 0; i < 10; i++) {
                    System.out.println("Putting: " + i);
                    queue.put("Item-" + i);  // Blocks if full
                    Thread.sleep(100);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
        
        // Consumer
        Thread.sleep(500);  // Let queue fill up
        
        for (int i = 0; i < 10; i++) {
            String item = queue.take();  // Blocks if empty
            System.out.println("Took: " + item);
            Thread.sleep(200);
        }
        
        /**
         * OUTPUT:
         * Putting: 0
         * Putting: 1
         * Putting: 2
         * Putting: 3
         * Putting: 4
         * (producer blocks - queue full)
         * Took: Item-0
         * Putting: 5
         * Took: Item-1
         * ...
         * 
         * CHARACTERISTICS:
         * - Fixed capacity (specified at construction)
         * - FIFO ordering
         * - Single lock for both put and take
         * - Fair/non-fair option
         */
    }
    
    /**
     * Internal structure
     */
    public void internalStructure() {
        /**
         * ARRAYBLOCKINGQUEUE INTERNALS:
         * 
         * final Object[] items;      // Array storage
         * int takeIndex;             // Index for next take
         * int putIndex;              // Index for next put
         * int count;                 // Number of elements
         * 
         * final ReentrantLock lock;  // Main lock
         * final Condition notEmpty;  // For blocking take
         * final Condition notFull;   // For blocking put
         * 
         * PUT ALGORITHM:
         * lock.lock();
         * try {
         *     while (count == items.length)
         *         notFull.await();
         *     items[putIndex] = e;
         *     putIndex = (putIndex + 1) % items.length;  // Circular
         *     count++;
         *     notEmpty.signal();
         * } finally {
         *     lock.unlock();
         * }
         * 
         * TAKE ALGORITHM:
         * lock.lock();
         * try {
         *     while (count == 0)
         *         notEmpty.await();
         *     E x = items[takeIndex];
         *     items[takeIndex] = null;
         *     takeIndex = (takeIndex + 1) % items.length;
         *     count--;
         *     notFull.signal();
         *     return x;
         * } finally {
         *     lock.unlock();
         * }
         */
    }
}
```

### LinkedBlockingQueue

```java
/**
 * LINKEDBLOCKINGQUEUE
 * 
 * Optionally bounded FIFO queue backed by linked nodes
 */

public class LinkedBlockingQueueExample {
    
    /**
     * Basic usage
     */
    public static void basicUsage() throws InterruptedException {
        // Unbounded
        BlockingQueue<String> unbounded = new LinkedBlockingQueue<>();
        
        // Bounded
        BlockingQueue<String> bounded = new LinkedBlockingQueue<>(10);
        
        /**
         * CHARACTERISTICS:
         * - Optionally bounded (Integer.MAX_VALUE if not specified)
         * - FIFO ordering
         * - Linked nodes (not array)
         * - Two locks: takeLock and putLock (better concurrency!)
         */
    }
    
    /**
     * Internal structure
     */
    public void internalStructure() {
        /**
         * LINKEDBLOCKINGQUEUE INTERNALS:
         * 
         * static class Node<E> {
         *     E item;
         *     Node<E> next;
         * }
         * 
         * private final int capacity;
         * private final AtomicInteger count = new AtomicInteger();
         * 
         * transient Node<E> head;     // Dummy head node
         * private transient Node<E> last;  // Tail node
         * 
         * private final ReentrantLock takeLock = new ReentrantLock();
         * private final Condition notEmpty = takeLock.newCondition();
         * 
         * private final ReentrantLock putLock = new ReentrantLock();
         * private final Condition notFull = putLock.newCondition();
         * 
         * TWO LOCKS:
         * - takeLock: For take operations
         * - putLock: For put operations
         * - Allows concurrent put and take!
         * 
         * ArrayBlockingQueue: One lock (put blocks take)
         * LinkedBlockingQueue: Two locks (put doesn't block take)
         */
    }
    
    /**
     * Comparison: ArrayBlockingQueue vs LinkedBlockingQueue
     */
    public static void performanceComparison() throws InterruptedException {
        int capacity = 100;
        int producers = 5;
        int consumers = 5;
        int itemsPerThread = 100_000;
        
        // Test ArrayBlockingQueue
        BlockingQueue<Integer> arrayQueue = new ArrayBlockingQueue<>(capacity);
        long start = System.currentTimeMillis();
        
        Thread[] arrayProducers = new Thread[producers];
        Thread[] arrayConsumers = new Thread[consumers];
        
        for (int i = 0; i < producers; i++) {
            arrayProducers[i] = new Thread(() -> {
                for (int j = 0; j < itemsPerThread; j++) {
                    try {
                        arrayQueue.put(j);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            });
            arrayProducers[i].start();
        }
        
        for (int i = 0; i < consumers; i++) {
            arrayConsumers[i] = new Thread(() -> {
                for (int j = 0; j < itemsPerThread; j++) {
                    try {
                        arrayQueue.take();
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            });
            arrayConsumers[i].start();
        }
        
        for (Thread t : arrayProducers) t.join();
        for (Thread t : arrayConsumers) t.join();
        
        long arrayTime = System.currentTimeMillis() - start;
        
        // Test LinkedBlockingQueue
        BlockingQueue<Integer> linkedQueue = new LinkedBlockingQueue<>(capacity);
        start = System.currentTimeMillis();
        
        Thread[] linkedProducers = new Thread[producers];
        Thread[] linkedConsumers = new Thread[consumers];
        
        for (int i = 0; i < producers; i++) {
            linkedProducers[i] = new Thread(() -> {
                for (int j = 0; j < itemsPerThread; j++) {
                    try {
                        linkedQueue.put(j);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            });
            linkedProducers[i].start();
        }
        
        for (int i = 0; i < consumers; i++) {
            linkedConsumers[i] = new Thread(() -> {
                for (int j = 0; j < itemsPerThread; j++) {
                    try {
                        linkedQueue.take();
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            });
            linkedConsumers[i].start();
        }
        
        for (Thread t : linkedProducers) t.join();
        for (Thread t : linkedConsumers) t.join();
        
        long linkedTime = System.currentTimeMillis() - start;
        
        System.out.println("=== BlockingQueue Performance ===");
        System.out.println("ArrayBlockingQueue:   " + arrayTime + "ms");
        System.out.println("LinkedBlockingQueue:  " + linkedTime + "ms");
        System.out.println("Speedup:              " + 
            String.format("%.2f", (double)arrayTime / linkedTime) + "x");
        
        /**
         * TYPICAL RESULTS:
         * 
         * ArrayBlockingQueue:   3500ms
         * LinkedBlockingQueue:  2200ms
         * Speedup:              1.6x
         * 
         * LinkedBlockingQueue 1.6x faster!
         * 
         * WHY:
         * - Two locks (put doesn't block take)
         * - Better concurrency
         * - Producers and consumers don't contend
         */
    }
}
```

### PriorityBlockingQueue and DelayQueue

```java
/**
 * PRIORITYBLOCKINGQUEUE - Priority ordering
 * DELAYQUEUE - Delayed elements
 */

public class SpecializedQueues {
    
    /**
     * PriorityBlockingQueue
     */
    public static void priorityQueueDemo() throws InterruptedException {
        BlockingQueue<Integer> queue = new PriorityBlockingQueue<>();
        
        // Add in random order
        queue.put(5);
        queue.put(1);
        queue.put(3);
        queue.put(2);
        queue.put(4);
        
        // Take in priority order (natural ordering)
        while (!queue.isEmpty()) {
            System.out.println(queue.take());
        }
        
        /**
         * OUTPUT:
         * 1
         * 2
         * 3
         * 4
         * 5
         * 
         * CHARACTERISTICS:
         * - Unbounded (grows as needed)
         * - Elements ordered by Comparable or Comparator
         * - Min-heap implementation
         * - take() returns smallest element
         * - No blocking on put (unbounded)
         * - Blocks on take if empty
         * 
         * USE CASES:
         * - Task scheduling (priority-based)
         * - Event processing (priority queues)
         * - Job queues with priorities
         */
    }
    
    /**
     * DelayQueue
     */
    static class DelayedTask implements Delayed {
        private final String name;
        private final long executeAt;  // Timestamp when ready
        
        public DelayedTask(String name, long delayMs) {
            this.name = name;
            this.executeAt = System.currentTimeMillis() + delayMs;
        }
        
        @Override
        public long getDelay(java.util.concurrent.TimeUnit unit) {
            long diff = executeAt - System.currentTimeMillis();
            return unit.convert(diff, java.util.concurrent.TimeUnit.MILLISECONDS);
        }
        
        @Override
        public int compareTo(Delayed o) {
            return Long.compare(this.executeAt, ((DelayedTask)o).executeAt);
        }
        
        @Override
        public String toString() {
            return name;
        }
    }
    
    public static void delayQueueDemo() throws InterruptedException {
        BlockingQueue<DelayedTask> queue = new DelayQueue<>();
        
        // Add tasks with different delays
        queue.put(new DelayedTask("Task-3s", 3000));
        queue.put(new DelayedTask("Task-1s", 1000));
        queue.put(new DelayedTask("Task-2s", 2000));
        
        System.out.println("Tasks added at: " + System.currentTimeMillis());
        
        // Take tasks (blocks until delay expires)
        while (!queue.isEmpty()) {
            DelayedTask task = queue.take();
            System.out.println("Executed " + task + " at: " + 
                System.currentTimeMillis());
        }
        
        /**
         * OUTPUT:
         * Tasks added at: 1234567890000
         * Executed Task-1s at: 1234567891000  (1 second later)
         * Executed Task-2s at: 1234567892000  (2 seconds later)
         * Executed Task-3s at: 1234567893000  (3 seconds later)
         * 
         * CHARACTERISTICS:
         * - Unbounded
         * - Elements ordered by delay (getDelay())
         * - take() blocks until element's delay expires
         * - Elements must implement Delayed
         * 
         * USE CASES:
         * - Scheduled tasks
         * - Cache expiration
         * - Retry mechanisms with backoff
         * - Timeout handling
         */
    }
}
```

---

## 4. ConcurrentLinkedQueue

### Lock-Free Implementation

```java
/**
 * CONCURRENTLINKEDQUEUE
 * 
 * Lock-free unbounded FIFO queue
 * Michael-Scott algorithm
 */

public class ConcurrentLinkedQueueExample {
    
    /**
     * Basic usage
     */
    public static void basicUsage() {
        ConcurrentLinkedQueue<String> queue = new ConcurrentLinkedQueue<>();
        
        // Add elements
        queue.offer("A");
        queue.offer("B");
        queue.offer("C");
        
        // Poll elements
        System.out.println(queue.poll());  // A
        System.out.println(queue.poll());  // B
        System.out.println(queue.poll());  // C
        System.out.println(queue.poll());  // null (empty)
        
        /**
         * CHARACTERISTICS:
         * - Unbounded (grows as needed)
         * - FIFO ordering
         * - Lock-free (CAS-based)
         * - No blocking operations
         * - poll() returns null if empty (doesn't block)
         * 
         * VS BlockingQueue:
         * - ConcurrentLinkedQueue: Non-blocking
         * - LinkedBlockingQueue: Blocking (take() blocks)
         */
    }
    
    /**
     * How it works (Michael-Scott algorithm)
     */
    public void howItWorks() {
        /**
         * CONCURRENTLINKEDQUEUE INTERNALS:
         * 
         * private static class Node<E> {
         *     volatile E item;
         *     volatile Node<E> next;
         * }
         * 
         * private transient volatile Node<E> head;
         * private transient volatile Node<E> tail;
         * 
         * OFFER ALGORITHM (simplified):
         * 
         * Node<E> newNode = new Node<>(e);
         * while (true) {
         *     Node<E> t = tail;
         *     Node<E> s = t.next;
         *     if (t == tail) {  // Consistent read
         *         if (s == null) {
         *             // Try to link new node
         *             if (t.casNext(null, newNode)) {
         *                 casTail(t, newNode);
         *                 return true;
         *             }
         *         } else {
         *             // Tail behind, advance it
         *             casTail(t, s);
         *         }
         *     }
         * }
         * 
         * POLL ALGORITHM (simplified):
         * 
         * while (true) {
         *     Node<E> h = head;
         *     Node<E> t = tail;
         *     Node<E> first = h.next;
         *     if (h == head) {
         *         if (h == t) {
         *             if (first == null)
         *                 return null;  // Empty
         *             casTail(t, first);
         *         } else {
         *             E item = first.item;
         *             if (casHead(h, first)) {
         *                 return item;
         *             }
         *         }
         *     }
         * }
         * 
         * LOCK-FREE:
         * - Uses CAS (compareAndSet) operations
         * - No locks
         * - At least one thread makes progress
         * - May retry on contention
         */
    }
    
    /**
     * Performance comparison
     */
    public static void performanceComparison() throws InterruptedException {
        int threads = 10;
        int iterations = 100_000;
        
        // ConcurrentLinkedQueue
        ConcurrentLinkedQueue<Integer> clq = new ConcurrentLinkedQueue<>();
        long start = System.currentTimeMillis();
        
        Thread[] clqThreads = new Thread[threads];
        for (int i = 0; i < threads; i++) {
            clqThreads[i] = new Thread(() -> {
                for (int j = 0; j < iterations; j++) {
                    clq.offer(j);
                    clq.poll();
                }
            });
            clqThreads[i].start();
        }
        for (Thread t : clqThreads) t.join();
        
        long clqTime = System.currentTimeMillis() - start;
        
        // LinkedBlockingQueue (non-blocking operations)
        LinkedBlockingQueue<Integer> lbq = new LinkedBlockingQueue<>();
        start = System.currentTimeMillis();
        
        Thread[] lbqThreads = new Thread[threads];
        for (int i = 0; i < threads; i++) {
            lbqThreads[i] = new Thread(() -> {
                for (int j = 0; j < iterations; j++) {
                    lbq.offer(j);
                    lbq.poll();
                }
            });
            lbqThreads[i].start();
        }
        for (Thread t : lbqThreads) t.join();
        
        long lbqTime = System.currentTimeMillis() - start;
        
        System.out.println("=== Non-Blocking Queue Performance ===");
        System.out.println("ConcurrentLinkedQueue:  " + clqTime + "ms");
        System.out.println("LinkedBlockingQueue:    " + lbqTime + "ms");
        System.out.println("Speedup:                " + 
            String.format("%.2f", (double)lbqTime / clqTime) + "x");
        
        /**
         * TYPICAL RESULTS:
         * 
         * ConcurrentLinkedQueue:  1200ms
         * LinkedBlockingQueue:    1800ms
         * Speedup:                1.5x
         * 
         * ConcurrentLinkedQueue faster!
         * 
         * WHY:
         * - Lock-free (no blocking)
         * - No lock contention
         * - Better scalability
         */
    }
    
    /**
     * When to use
     */
    public void whenToUse() {
        /**
         * USE CONCURRENTLINKEDQUEUE WHEN:
         * 
         * ✓ Need non-blocking operations
         * ✓ Unbounded queue acceptable
         * ✓ High throughput required
         * ✓ poll() returning null is acceptable
         * 
         * USE LINKEDBLOCKINGQUEUE WHEN:
         * 
         * ✓ Need blocking operations (take() blocks)
         * ✓ Want bounded queue
         * ✓ Producer-consumer with backpressure
         * ✓ Thread coordination needed
         */
    }
}
```

---

## 5. ConcurrentSkipListMap

### Skip List Structure

```java
/**
 * CONCURRENTSKIPLISTMAP
 * 
 * Concurrent sorted map
 * Skip list data structure
 */

import java.util.concurrent.ConcurrentSkipListMap;

public class ConcurrentSkipListMapExample {
    
    /**
     * Basic usage
     */
    public static void basicUsage() {
        ConcurrentSkipListMap<Integer, String> map = new ConcurrentSkipListMap<>();
        
        // Add in random order
        map.put(5, "Five");
        map.put(1, "One");
        map.put(3, "Three");
        map.put(2, "Two");
        map.put(4, "Four");
        
        // Iterate in sorted order
        map.forEach((key, value) -> {
            System.out.println(key + " = " + value);
        });
        
        /**
         * OUTPUT:
         * 1 = One
         * 2 = Two
         * 3 = Three
         * 4 = Four
         * 5 = Five
         * 
         * CHARACTERISTICS:
         * - Sorted by key (natural order or Comparator)
         * - Concurrent and thread-safe
         * - Lock-free reads
         * - O(log n) for get/put/remove
         * - NavigableMap operations
         */
    }
    
    /**
     * Skip list structure
     */
    public void skipListStructure() {
        /**
         * SKIP LIST:
         * 
         * Multi-level linked list with "express lanes"
         * 
         * Level 3: 1 ----------------> 9
         * Level 2: 1 ------> 5 ------> 9
         * Level 1: 1 -> 3 -> 5 -> 7 -> 9
         * Level 0: 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9
         * 
         * Search for 7:
         * 1. Start at top level (3)
         * 2. Follow pointers: 1 -> 9 (too far)
         * 3. Drop to level 2: 1 -> 5 -> 9 (still too far)
         * 4. Drop to level 1: 5 -> 7 (found!)
         * 
         * O(log n) expected time
         * 
         * VS TREE MAP:
         * - TreeMap: Red-black tree (balanced tree)
         * - ConcurrentSkipListMap: Skip list
         * - Skip list easier to make lock-free
         * - TreeMap needs tree rotations (complex to synchronize)
         */
    }
    
    /**
     * NavigableMap operations
     */
    public static void navigableOperations() {
        ConcurrentSkipListMap<Integer, String> map = new ConcurrentSkipListMap<>();
        
        map.put(1, "One");
        map.put(5, "Five");
        map.put(10, "Ten");
        map.put(15, "Fifteen");
        map.put(20, "Twenty");
        
        // Range queries
        System.out.println("First entry: " + map.firstEntry());
        System.out.println("Last entry: " + map.lastEntry());
        
        // Lower/higher
        System.out.println("Lower than 10: " + map.lowerEntry(10));
        System.out.println("Higher than 10: " + map.higherEntry(10));
        
        // Floor/ceiling
        System.out.println("Floor of 7: " + map.floorEntry(7));
        System.out.println("Ceiling of 7: " + map.ceilingEntry(7));
        
        // Sub-map
        System.out.println("Sub-map [5, 15): " + map.subMap(5, 15));
        
        /**
         * OUTPUT:
         * First entry: 1=One
         * Last entry: 20=Twenty
         * Lower than 10: 5=Five
         * Higher than 10: 15=Fifteen
         * Floor of 7: 5=Five
         * Ceiling of 7: 10=Ten
         * Sub-map [5, 15): {5=Five, 10=Ten}
         * 
         * NAVIGABLE OPERATIONS:
         * - firstEntry(), lastEntry()
         * - lowerEntry(), higherEntry()
         * - floorEntry(), ceilingEntry()
         * - subMap(), headMap(), tailMap()
         * - descendingMap()
         * 
         * All thread-safe and concurrent!
         */
    }
    
    /**
     * Performance comparison
     */
    public static void performanceComparison() throws InterruptedException {
        int threads = 10;
        int iterations = 100_000;
        
        // ConcurrentSkipListMap
        ConcurrentSkipListMap<Integer, Integer> skipListMap = 
            new ConcurrentSkipListMap<>();
        
        long start = System.currentTimeMillis();
        Thread[] skipListThreads = new Thread[threads];
        
        for (int i = 0; i < threads; i++) {
            skipListThreads[i] = new Thread(() -> {
                java.util.Random rand = new java.util.Random();
                for (int j = 0; j < iterations; j++) {
                    int key = rand.nextInt(10000);
                    if (rand.nextBoolean()) {
                        skipListMap.put(key, key);
                    } else {
                        skipListMap.get(key);
                    }
                }
            });
            skipListThreads[i].start();
        }
        for (Thread t : skipListThreads) t.join();
        
        long skipListTime = System.currentTimeMillis() - start;
        
        // TreeMap with synchronization
        java.util.TreeMap<Integer, Integer> treeMap = new java.util.TreeMap<>();
        
        start = System.currentTimeMillis();
        Thread[] treeMapThreads = new Thread[threads];
        
        for (int i = 0; i < threads; i++) {
            treeMapThreads[i] = new Thread(() -> {
                java.util.Random rand = new java.util.Random();
                for (int j = 0; j < iterations; j++) {
                    int key = rand.nextInt(10000);
                    synchronized (treeMap) {
                        if (rand.nextBoolean()) {
                            treeMap.put(key, key);
                        } else {
                            treeMap.get(key);
                        }
                    }
                }
            });
            treeMapThreads[i].start();
        }
        for (Thread t : treeMapThreads) t.join();
        
        long treeMapTime = System.currentTimeMillis() - start;
        
        System.out.println("=== Sorted Map Performance ===");
        System.out.println("ConcurrentSkipListMap:  " + skipListTime + "ms");
        System.out.println("Synchronized TreeMap:   " + treeMapTime + "ms");
        System.out.println("Speedup:                " + 
            String.format("%.2f", (double)treeMapTime / skipListTime) + "x");
        
        /**
         * TYPICAL RESULTS:
         * 
         * ConcurrentSkipListMap:  1500ms
         * Synchronized TreeMap:   5000ms
         * Speedup:                3.3x
         * 
         * ConcurrentSkipListMap 3x faster!
         */
    }
    
    /**
     * When to use
     */
    public void whenToUse() {
        /**
         * USE CONCURRENTSKIPLISTMAP WHEN:
         * 
         * ✓ Need sorted, concurrent map
         * ✓ Range queries needed
         * ✓ NavigableMap operations
         * ✓ Concurrent reads and writes
         * 
         * USE TREEMAP WHEN:
         * 
         * ✓ Single-threaded
         * ✓ Simpler implementation
         * 
         * USE CONCURRENTHASHMAP WHEN:
         * 
         * ✓ Don't need sorting
         * ✓ Just need concurrent map
         * ✓ Better performance (O(1) vs O(log n))
         */
    }
}
```

---

## 6. When to Use Each Collection

### Decision Guide

```java
/**
 * COLLECTION SELECTION GUIDE
 */

public class CollectionSelectionGuide {
    
    public void decisionTree() {
        /**
         * QUESTION 1: What type of collection?
         * 
         * Map → Go to MAP section
         * List → Go to LIST section
         * Queue → Go to QUEUE section
         * Set → Go to SET section
         * 
         * 
         * ═══════════════════════════════════════════════════════════════
         * MAP SELECTION
         * ═══════════════════════════════════════════════════════════════
         * 
         * Need sorting?
         * ├─ YES → ConcurrentSkipListMap
         * │        - O(log n) operations
         * │        - NavigableMap operations
         * │        - Sorted iteration
         * │
         * └─ NO → ConcurrentHashMap
         *          - O(1) operations (faster!)
         *          - Best general-purpose concurrent map
         *          - 4-5x faster than synchronized alternatives
         * 
         * 
         * ═══════════════════════════════════════════════════════════════
         * LIST SELECTION
         * ═══════════════════════════════════════════════════════════════
         * 
         * Read percentage?
         * ├─ >99% reads → CopyOnWriteArrayList
         * │               - Lock-free reads
         * │               - Snapshot iterators
         * │               - Great for event listeners
         * │               - WARNING: Expensive writes!
         * │
         * └─ <99% reads → Collections.synchronizedList(ArrayList)
         *                 - Better for write-heavy
         *                 - Simpler implementation
         *                 - Lower memory overhead
         * 
         * 
         * ═══════════════════════════════════════════════════════════════
         * QUEUE SELECTION
         * ═══════════════════════════════════════════════════════════════
         * 
         * Need blocking?
         * ├─ YES (BlockingQueue) → Need ordering?
         * │  ├─ FIFO → Need bounded?
         * │  │  ├─ YES → ArrayBlockingQueue (simple)
         * │  │  │        OR LinkedBlockingQueue (better concurrency)
         * │  │  └─ NO → LinkedBlockingQueue
         * │  │
         * │  ├─ Priority → PriorityBlockingQueue
         * │  ├─ Delay → DelayQueue
         * │  └─ Direct handoff → SynchronousQueue
         * │
         * └─ NO (non-blocking) → ConcurrentLinkedQueue
         *                       - Lock-free
         *                       - Unbounded
         *                       - Best throughput
         * 
         * 
         * ═══════════════════════════════════════════════════════════════
         * SET SELECTION
         * ═══════════════════════════════════════════════════════════════
         * 
         * Need sorting?
         * ├─ YES → ConcurrentSkipListSet
         * │        - Concurrent sorted set
         * │        - O(log n) operations
         * │
         * └─ NO → ConcurrentHashMap.newKeySet()
         *          - O(1) operations
         *          - Or Collections.newSetFromMap(new ConcurrentHashMap<>())
         */
    }
    
    /**
     * Use case matrix
     */
    public void useCaseMatrix() {
        /**
         * ┌─────────────────────────┬───────────────────┬──────────────────┐
         * │ Use Case                │ Collection        │ Why              │
         * ├─────────────────────────┼───────────────────┼──────────────────┤
         * │ General cache           │ ConcurrentHashMap │ Fast, concurrent │
         * │ Sorted cache            │ ConcurrentSkipList│ Sorted, ranges   │
         * │ Event listeners         │ CopyOnWriteArray  │ Read-heavy       │
         * │ Producer-consumer       │ LinkedBlocking    │ Blocking, FIFO   │
         * │ Task queue              │ PriorityBlocking  │ Priority order   │
         * │ Work queue              │ ConcurrentLinked  │ Non-blocking     │
         * │ Thread pool queue       │ LinkedBlocking    │ Bounded, blocking│
         * │ Scheduled tasks         │ DelayQueue        │ Delayed elements │
         * │ Shared counter          │ AtomicInteger     │ Lock-free        │
         * │ Leaderboard             │ ConcurrentSkipList│ Sorted scores    │
         * └─────────────────────────┴───────────────────┴──────────────────┘
         */
    }
}
```

---

## 7. Performance Benchmarks

### Comprehensive Comparison

```java
/**
 * COMPREHENSIVE PERFORMANCE BENCHMARKS
 */

public class ComprehensiveBenchmarks {
    
    /**
     * Map benchmark: High contention
     */
    public static void mapBenchmark() throws InterruptedException {
        int threads = 20;
        int iterations = 100_000;
        
        System.out.println("=== Map Performance (20 threads, 100K ops each) ===\n");
        
        // 1. ConcurrentHashMap
        ConcurrentHashMap<Integer, Integer> chm = new ConcurrentHashMap<>();
        long start = System.currentTimeMillis();
        runMapTest(chm, threads, iterations);
        long chmTime = System.currentTimeMillis() - start;
        
        // 2. Hashtable
        java.util.Hashtable<Integer, Integer> ht = new java.util.Hashtable<>();
        start = System.currentTimeMillis();
        runMapTest(ht, threads, iterations);
        long htTime = System.currentTimeMillis() - start;
        
        // 3. ConcurrentSkipListMap
        ConcurrentSkipListMap<Integer, Integer> cslm = new ConcurrentSkipListMap<>();
        start = System.currentTimeMillis();
        runMapTest(cslm, threads, iterations);
        long cslmTime = System.currentTimeMillis() - start;
        
        System.out.println("ConcurrentHashMap:      " + chmTime + "ms  (baseline)");
        System.out.println("Hashtable:              " + htTime + "ms  (" + 
            String.format("%.2fx slower", (double)htTime / chmTime) + ")");
        System.out.println("ConcurrentSkipListMap:  " + cslmTime + "ms  (" + 
            String.format("%.2fx slower", (double)cslmTime / chmTime) + ")");
        
        /**
         * TYPICAL RESULTS:
         * ConcurrentHashMap:      900ms   (baseline)
         * Hashtable:              4200ms  (4.7x slower)
         * ConcurrentSkipListMap:  1800ms  (2.0x slower)
         * 
         * ConcurrentHashMap is the winner!
         */
    }
    
    private static void runMapTest(java.util.Map<Integer, Integer> map, 
            int threads, int iterations) throws InterruptedException {
        Thread[] ts = new Thread[threads];
        for (int i = 0; i < threads; i++) {
            ts[i] = new Thread(() -> {
                java.util.Random rand = new java.util.Random();
                for (int j = 0; j < iterations; j++) {
                    int key = rand.nextInt(1000);
                    if (rand.nextBoolean()) {
                        map.put(key, key);
                    } else {
                        map.get(key);
                    }
                }
            });
            ts[i].start();
        }
        for (Thread t : ts) t.join();
    }
    
    /**
     * Queue benchmark: Producer-Consumer
     */
    public static void queueBenchmark() throws InterruptedException {
        int producers = 5;
        int consumers = 5;
        int items = 100_000;
        
        System.out.println("\n=== Queue Performance (5 producers, 5 consumers, 100K items) ===\n");
        
        // 1. ConcurrentLinkedQueue (non-blocking)
        ConcurrentLinkedQueue<Integer> clq = new ConcurrentLinkedQueue<>();
        long start = System.currentTimeMillis();
        runQueueTest(clq, producers, consumers, items);
        long clqTime = System.currentTimeMillis() - start;
        
        // 2. LinkedBlockingQueue
        LinkedBlockingQueue<Integer> lbq = new LinkedBlockingQueue<>();
        start = System.currentTimeMillis();
        runBlockingQueueTest(lbq, producers, consumers, items);
        long lbqTime = System.currentTimeMillis() - start;
        
        // 3. ArrayBlockingQueue
        ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(1000);
        start = System.currentTimeMillis();
        runBlockingQueueTest(abq, producers, consumers, items);
        long abqTime = System.currentTimeMillis() - start;
        
        System.out.println("ConcurrentLinkedQueue:  " + clqTime + "ms  (baseline)");
        System.out.println("LinkedBlockingQueue:    " + lbqTime + "ms  (" + 
            String.format("%.2fx slower", (double)lbqTime / clqTime) + ")");
        System.out.println("ArrayBlockingQueue:     " + abqTime + "ms  (" + 
            String.format("%.2fx slower", (double)abqTime / clqTime) + ")");
        
        /**
         * TYPICAL RESULTS:
         * ConcurrentLinkedQueue:  1200ms  (baseline)
         * LinkedBlockingQueue:    1800ms  (1.5x slower)
         * ArrayBlockingQueue:     2500ms  (2.1x slower)
         * 
         * ConcurrentLinkedQueue fastest (lock-free)
         * LinkedBlockingQueue good balance
         * ArrayBlockingQueue slowest (single lock)
         */
    }
    
    private static void runQueueTest(java.util.Queue<Integer> queue, 
            int producers, int consumers, int items) throws InterruptedException {
        
        java.util.concurrent.CountDownLatch latch = 
            new java.util.concurrent.CountDownLatch(producers + consumers);
        
        // Producers
        for (int i = 0; i < producers; i++) {
            new Thread(() -> {
                for (int j = 0; j < items; j++) {
                    queue.offer(j);
                }
                latch.countDown();
            }).start();
        }
        
        // Consumers
        for (int i = 0; i < consumers; i++) {
            new Thread(() -> {
                for (int j = 0; j < items; j++) {
                    while (queue.poll() == null) {
                        Thread.yield();
                    }
                }
                latch.countDown();
            }).start();
        }
        
        latch.await();
    }
    
    private static void runBlockingQueueTest(BlockingQueue<Integer> queue, 
            int producers, int consumers, int items) throws InterruptedException {
        
        java.util.concurrent.CountDownLatch latch = 
            new java.util.concurrent.CountDownLatch(producers + consumers);
        
        // Producers
        for (int i = 0; i < producers; i++) {
            new Thread(() -> {
                try {
                    for (int j = 0; j < items; j++) {
                        queue.put(j);
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                latch.countDown();
            }).start();
        }
        
        // Consumers
        for (int i = 0; i < consumers; i++) {
            new Thread(() -> {
                try {
                    for (int j = 0; j < items; j++) {
                        queue.take();
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                latch.countDown();
            }).start();
        }
        
        latch.await();
    }
    
    /**
     * List benchmark: Read-heavy
     */
    public static void listBenchmark() throws InterruptedException {
        int threads = 10;
        int iterations = 100_000;
        
        System.out.println("\n=== List Performance (10 threads, 100K ops, 95% reads) ===\n");
        
        // Initialize
        java.util.List<Integer> baseList = new java.util.ArrayList<>();
        for (int i = 0; i < 100; i++) {
            baseList.add(i);
        }
        
        // 1. CopyOnWriteArrayList
        CopyOnWriteArrayList<Integer> cowal = new CopyOnWriteArrayList<>(baseList);
        long start = System.currentTimeMillis();
        runListTest(cowal, threads, iterations);
        long cowalTime = System.currentTimeMillis() - start;
        
        // 2. Synchronized ArrayList
        java.util.List<Integer> syncList = 
            java.util.Collections.synchronizedList(new java.util.ArrayList<>(baseList));
        start = System.currentTimeMillis();
        runSyncListTest(syncList, threads, iterations);
        long syncTime = System.currentTimeMillis() - start;
        
        System.out.println("CopyOnWriteArrayList:   " + cowalTime + "ms  (baseline)");
        System.out.println("Synchronized ArrayList: " + syncTime + "ms  (" + 
            String.format("%.2fx slower", (double)syncTime / cowalTime) + ")");
        
        /**
         * TYPICAL RESULTS (95% reads):
         * CopyOnWriteArrayList:   700ms   (baseline)
         * Synchronized ArrayList: 2800ms  (4.0x slower)
         * 
         * CopyOnWriteArrayList 4x faster for read-heavy!
         */
    }
    
    private static void runListTest(java.util.List<Integer> list, 
            int threads, int iterations) throws InterruptedException {
        Thread[] ts = new Thread[threads];
        for (int i = 0; i < threads; i++) {
            ts[i] = new Thread(() -> {
                java.util.Random rand = new java.util.Random();
                for (int j = 0; j < iterations; j++) {
                    if (rand.nextInt(100) < 95) {  // 95% reads
                        list.get(rand.nextInt(list.size()));
                    } else {  // 5% writes
                        list.add(rand.nextInt());
                    }
                }
            });
            ts[i].start();
        }
        for (Thread t : ts) t.join();
    }
    
    private static void runSyncListTest(java.util.List<Integer> list, 
            int threads, int iterations) throws InterruptedException {
        Thread[] ts = new Thread[threads];
        for (int i = 0; i < threads; i++) {
            ts[i] = new Thread(() -> {
                java.util.Random rand = new java.util.Random();
                for (int j = 0; j < iterations; j++) {
                    synchronized (list) {
                        if (rand.nextInt(100) < 95) {  // 95% reads
                            list.get(rand.nextInt(list.size()));
                        } else {  // 5% writes
                            list.add(rand.nextInt());
                        }
                    }
                }
            });
            ts[i].start();
        }
        for (Thread t : ts) t.join();
    }
    
    public static void main(String[] args) throws InterruptedException {
        mapBenchmark();
        queueBenchmark();
        listBenchmark();
    }
}
```

---

## Summary

### Quick Reference

**Maps:**

```java
// General purpose, best performance
ConcurrentHashMap<K, V> map = new ConcurrentHashMap<>();

// Sorted, range queries
ConcurrentSkipListMap<K, V> sorted = new ConcurrentSkipListMap<>();
```

**Lists:**

```java
// Read-heavy (>95% reads), small lists
CopyOnWriteArrayList<E> list = new CopyOnWriteArrayList<>();

// Write-heavy or large lists
List<E> list = Collections.synchronizedList(new ArrayList<>());
```

**Queues:**

```java
// Blocking, producer-consumer
BlockingQueue<E> queue = new LinkedBlockingQueue<>();

// Non-blocking, high throughput
ConcurrentLinkedQueue<E> queue = new ConcurrentLinkedQueue<>();

// Priority ordering
PriorityBlockingQueue<E> queue = new PriorityBlockingQueue<>();

// Delayed elements
DelayQueue<E> queue = new DelayQueue<>();
```

### Performance Summary

**ConcurrentHashMap:**

- 4-5x faster than Hashtable/SynchronizedMap
- O(1) operations
- Best general-purpose concurrent map

**CopyOnWriteArrayList:**

- 4x faster than SynchronizedList (read-heavy)
- Lock-free reads
- Expensive writes (copies entire array)

**LinkedBlockingQueue:**

- 1.6x faster than ArrayBlockingQueue
- Two locks (better concurrency)
- Good for producer-consumer

**ConcurrentLinkedQueue:**

- 1.5x faster than LinkedBlockingQueue
- Lock-free (CAS-based)
- Best for non-blocking scenarios

**ConcurrentSkipListMap:**

- 3x faster than synchronized TreeMap
- O(log n) operations
- Best for sorted concurrent access

### Best Practices

1. ✅ Use ConcurrentHashMap for general maps (not Hashtable)
2. ✅ Use CopyOnWriteArrayList for event listeners
3. ✅ Use LinkedBlockingQueue for producer-consumer
4. ✅ Use ConcurrentLinkedQueue for non-blocking queues
5. ✅ Use ConcurrentSkipListMap for sorted maps
6. ❌ Don't use Hashtable or Vector (legacy, slow)
7. ❌ Don't use CopyOnWriteArrayList for write-heavy
8. ❌ Don't synchronize HashMap manually (use ConcurrentHashMap)

---
