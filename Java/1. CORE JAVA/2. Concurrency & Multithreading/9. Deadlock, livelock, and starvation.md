# Java Deadlock, Livelock, and Starvation

## Overview

Understanding and debugging deadlocks, livelocks, and starvation is critical for production Java applications. This guide covers detection, prevention, and real-world debugging scenarios.


---

## 1. Deadlock Fundamentals

### The Four Necessary Conditions

```java
/**
 * DEADLOCK - FOUR NECESSARY CONDITIONS
 * 
 * All four must be present for deadlock to occur
 */

public class DeadlockConditions {
    
    /**
     * The four conditions
     */
    public static void explanation() {
        /**
         * DEADLOCK OCCURS WHEN ALL FOUR CONDITIONS ARE MET:
         * 
         * 1. MUTUAL EXCLUSION:
         *    - Resource can be held by only one thread at a time
         *    - Example: synchronized block, Lock
         * 
         * 2. HOLD AND WAIT:
         *    - Thread holds resource while waiting for another
         *    - Example: Thread holds Lock A, waiting for Lock B
         * 
         * 3. NO PREEMPTION:
         *    - Resource cannot be forcibly taken from thread
         *    - Thread must voluntarily release
         *    - Example: Can't force thread to release lock
         * 
         * 4. CIRCULAR WAIT:
         *    - Circular chain of threads waiting for resources
         *    - Example: T1 waits for T2, T2 waits for T3, T3 waits for T1
         * 
         * 
         * BREAK ANY ONE CONDITION → NO DEADLOCK
         */
    }
    
    /**
     * Classic deadlock example
     */
    static class Account {
        private final String id;
        private int balance;
        
        public Account(String id, int balance) {
            this.id = id;
            this.balance = balance;
        }
        
        public String getId() {
            return id;
        }
        
        public int getBalance() {
            return balance;
        }
        
        public void deposit(int amount) {
            balance += amount;
        }
        
        public void withdraw(int amount) {
            balance -= amount;
        }
    }
    
    /**
     * DEADLOCK: Transfer money between accounts
     */
    public static void deadlockTransfer() throws InterruptedException {
        Account acc1 = new Account("ACC-1", 1000);
        Account acc2 = new Account("ACC-2", 2000);
        
        // Thread 1: Transfer from acc1 to acc2
        Thread t1 = new Thread(() -> {
            synchronized (acc1) {
                System.out.println("T1: Locked " + acc1.getId());
                
                try {
                    Thread.sleep(100);  // Simulate work
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                
                System.out.println("T1: Waiting for " + acc2.getId());
                synchronized (acc2) {
                    acc1.withdraw(100);
                    acc2.deposit(100);
                    System.out.println("T1: Transfer complete");
                }
            }
        }, "Transfer-1");
        
        // Thread 2: Transfer from acc2 to acc1
        Thread t2 = new Thread(() -> {
            synchronized (acc2) {
                System.out.println("T2: Locked " + acc2.getId());
                
                try {
                    Thread.sleep(100);  // Simulate work
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                
                System.out.println("T2: Waiting for " + acc1.getId());
                synchronized (acc1) {
                    acc2.withdraw(200);
                    acc1.deposit(200);
                    System.out.println("T2: Transfer complete");
                }
            }
        }, "Transfer-2");
        
        t1.start();
        t2.start();
        
        // Wait a bit, then interrupt
        Thread.sleep(2000);
        
        /**
         * OUTPUT:
         * T1: Locked ACC-1
         * T2: Locked ACC-2
         * T1: Waiting for ACC-2
         * T2: Waiting for ACC-1
         * (DEADLOCK - threads never proceed)
         * 
         * ANALYSIS:
         * 
         * 1. Mutual Exclusion: ✓
         *    - synchronized blocks are mutually exclusive
         * 
         * 2. Hold and Wait: ✓
         *    - T1 holds acc1, waits for acc2
         *    - T2 holds acc2, waits for acc1
         * 
         * 3. No Preemption: ✓
         *    - Can't force release of synchronized lock
         * 
         * 4. Circular Wait: ✓
         *    - T1 → acc2 → T2 → acc1 → T1
         * 
         * ALL FOUR CONDITIONS MET → DEADLOCK!
         */
        
        System.out.println("\nDeadlock occurred. Threads are stuck.");
        System.out.println("T1 state: " + t1.getState());
        System.out.println("T2 state: " + t2.getState());
    }
    
    public static void main(String[] args) throws InterruptedException {
        deadlockTransfer();
    }
}
```

### More Deadlock Examples

```java
/**
 * ADDITIONAL DEADLOCK SCENARIOS
 */

public class DeadlockExamples {
    
    /**
     * Example 1: Nested locks
     */
    static class Resource {
        private final String name;
        
        public Resource(String name) {
            this.name = name;
        }
        
        public String getName() {
            return name;
        }
    }
    
    public static void nestedLocksDeadlock() throws InterruptedException {
        Resource r1 = new Resource("Resource-1");
        Resource r2 = new Resource("Resource-2");
        
        Thread t1 = new Thread(() -> {
            synchronized (r1) {
                System.out.println("T1: Got " + r1.getName());
                sleep(50);
                synchronized (r2) {
                    System.out.println("T1: Got " + r2.getName());
                }
            }
        });
        
        Thread t2 = new Thread(() -> {
            synchronized (r2) {
                System.out.println("T2: Got " + r2.getName());
                sleep(50);
                synchronized (r1) {
                    System.out.println("T2: Got " + r1.getName());
                }
            }
        });
        
        t1.start();
        t2.start();
        t1.join(1000);
        t2.join(1000);
        
        if (t1.isAlive() || t2.isAlive()) {
            System.out.println("DEADLOCK detected!");
        }
    }
    
    /**
     * Example 2: Lock ordering deadlock
     */
    static class Node {
        private final int id;
        private Node next;
        
        public Node(int id) {
            this.id = id;
        }
        
        public synchronized void linkTo(Node other) {
            synchronized (other) {
                this.next = other;
                System.out.println("Linked " + this.id + " -> " + other.id);
            }
        }
    }
    
    public static void lockOrderingDeadlock() throws InterruptedException {
        Node n1 = new Node(1);
        Node n2 = new Node(2);
        
        Thread t1 = new Thread(() -> n1.linkTo(n2));
        Thread t2 = new Thread(() -> n2.linkTo(n1));
        
        t1.start();
        t2.start();
        
        t1.join(1000);
        t2.join(1000);
        
        /**
         * DEADLOCK:
         * - T1: locks n1, waits for n2
         * - T2: locks n2, waits for n1
         */
    }
    
    /**
     * Example 3: ReentrantLock deadlock
     */
    public static void reentrantLockDeadlock() throws InterruptedException {
        java.util.concurrent.locks.ReentrantLock lock1 = 
            new java.util.concurrent.locks.ReentrantLock();
        java.util.concurrent.locks.ReentrantLock lock2 = 
            new java.util.concurrent.locks.ReentrantLock();
        
        Thread t1 = new Thread(() -> {
            lock1.lock();
            try {
                System.out.println("T1: Got lock1");
                sleep(50);
                
                lock2.lock();
                try {
                    System.out.println("T1: Got lock2");
                } finally {
                    lock2.unlock();
                }
            } finally {
                lock1.unlock();
            }
        });
        
        Thread t2 = new Thread(() -> {
            lock2.lock();
            try {
                System.out.println("T2: Got lock2");
                sleep(50);
                
                lock1.lock();
                try {
                    System.out.println("T2: Got lock1");
                } finally {
                    lock1.unlock();
                }
            } finally {
                lock2.unlock();
            }
        });
        
        t1.start();
        t2.start();
        t1.join(1000);
        t2.join(1000);
        
        /**
         * DEADLOCK with ReentrantLock:
         * - Same pattern as synchronized
         * - Can use tryLock() to prevent
         */
    }
    
    private static void sleep(long ms) {
        try {
            Thread.sleep(ms);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== Nested Locks ===");
        nestedLocksDeadlock();
        
        System.out.println("\n=== Lock Ordering ===");
        lockOrderingDeadlock();
        
        System.out.println("\n=== ReentrantLock ===");
        reentrantLockDeadlock();
    }
}
```

---

## 2. Detecting Deadlocks

### Using jstack and Thread Dumps

```java
/**
 * DEADLOCK DETECTION TOOLS
 * 
 * Using jstack, VisualVM, and programmatic detection
 */

public class DeadlockDetection {
    
    /**
     * Create a detectable deadlock
     */
    static class DeadlockDemo {
        private final Object lock1 = new Object();
        private final Object lock2 = new Object();
        
        public void createDeadlock() throws InterruptedException {
            Thread t1 = new Thread(() -> {
                synchronized (lock1) {
                    System.out.println("Thread-1: Holding lock1");
                    sleep(100);
                    System.out.println("Thread-1: Waiting for lock2");
                    synchronized (lock2) {
                        System.out.println("Thread-1: Got both locks");
                    }
                }
            }, "Worker-1");
            
            Thread t2 = new Thread(() -> {
                synchronized (lock2) {
                    System.out.println("Thread-2: Holding lock2");
                    sleep(100);
                    System.out.println("Thread-2: Waiting for lock1");
                    synchronized (lock1) {
                        System.out.println("Thread-2: Got both locks");
                    }
                }
            }, "Worker-2");
            
            t1.start();
            t2.start();
            
            // Let deadlock occur
            Thread.sleep(500);
            
            System.out.println("\nDEADLOCK CREATED!");
            System.out.println("Run: jstack " + 
                java.lang.management.ManagementFactory.getRuntimeMXBean().getName().split("@")[0]);
            
            // Keep running so jstack can be used
            t1.join();
            t2.join();
        }
        
        private void sleep(long ms) {
            try {
                Thread.sleep(ms);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
    
    /**
     * Thread dump analysis
     */
    public static void threadDumpAnalysis() {
        /**
         * USING JSTACK:
         * 
         * 1. Get process ID:
         *    jps
         *    
         * 2. Take thread dump:
         *    jstack <pid>
         *    
         * 3. Or send SIGQUIT:
         *    kill -3 <pid>  (Unix/Linux)
         *    Ctrl+Break      (Windows)
         * 
         * 
         * THREAD DUMP OUTPUT:
         * 
         * Found one Java-level deadlock:
         * =============================
         * "Worker-2":
         *   waiting to lock monitor 0x00007f8a4c004e00 (object 0x00000007d5f5e3a0, a java.lang.Object),
         *   which is held by "Worker-1"
         * "Worker-1":
         *   waiting to lock monitor 0x00007f8a4c0073c0 (object 0x00000007d5f5e3b0, a java.lang.Object),
         *   which is held by "Worker-2"
         * 
         * Java stack information for the threads listed above:
         * ===================================================
         * "Worker-2":
         *         at DeadlockDemo.lambda$createDeadlock$1(DeadlockDetection.java:29)
         *         - waiting to lock <0x00000007d5f5e3a0> (a java.lang.Object)
         *         - locked <0x00000007d5f5e3b0> (a java.lang.Object)
         * 
         * "Worker-1":
         *         at DeadlockDemo.lambda$createDeadlock$0(DeadlockDetection.java:17)
         *         - waiting to lock <0x00000007d5f5e3b0> (a java.lang.Object)
         *         - locked <0x00000007d5f5e3a0> (a java.lang.Object)
         * 
         * Found 1 deadlock.
         * 
         * 
         * KEY INFORMATION:
         * - Which threads are deadlocked
         * - What objects they're waiting for
         * - Which thread holds each lock
         * - Stack traces showing where
         */
    }
    
    /**
     * Programmatic deadlock detection
     */
    public static void programmaticDetection() {
        java.lang.management.ThreadMXBean threadMXBean = 
            java.lang.management.ManagementFactory.getThreadMXBean();
        
        // Detect deadlocks
        long[] deadlockedThreads = threadMXBean.findDeadlockedThreads();
        
        if (deadlockedThreads != null) {
            System.out.println("DEADLOCK DETECTED!");
            System.out.println("Deadlocked threads: " + deadlockedThreads.length);
            
            java.lang.management.ThreadInfo[] threadInfos = 
                threadMXBean.getThreadInfo(deadlockedThreads);
            
            for (java.lang.management.ThreadInfo info : threadInfos) {
                System.out.println("\nThread: " + info.getThreadName());
                System.out.println("  State: " + info.getThreadState());
                System.out.println("  Locked on: " + info.getLockName());
                System.out.println("  Locked by: " + info.getLockOwnerName());
                
                System.out.println("  Stack trace:");
                for (StackTraceElement element : info.getStackTrace()) {
                    System.out.println("    " + element);
                }
            }
        } else {
            System.out.println("No deadlock detected");
        }
    }
    
    /**
     * Monitoring for deadlocks
     */
    static class DeadlockMonitor extends Thread {
        private final long checkInterval;
        
        public DeadlockMonitor(long checkInterval) {
            this.checkInterval = checkInterval;
            setDaemon(true);
            setName("DeadlockMonitor");
        }
        
        @Override
        public void run() {
            while (true) {
                try {
                    Thread.sleep(checkInterval);
                    
                    java.lang.management.ThreadMXBean bean = 
                        java.lang.management.ManagementFactory.getThreadMXBean();
                    long[] deadlocks = bean.findDeadlockedThreads();
                    
                    if (deadlocks != null) {
                        System.err.println("DEADLOCK DETECTED AT " + 
                            new java.util.Date());
                        
                        java.lang.management.ThreadInfo[] infos = 
                            bean.getThreadInfo(deadlocks);
                        
                        for (java.lang.management.ThreadInfo info : infos) {
                            System.err.println("Thread " + info.getThreadName() + 
                                " waiting for " + info.getLockName() +
                                " held by " + info.getLockOwnerName());
                        }
                        
                        // Alert operations, log, take thread dump, etc.
                    }
                } catch (InterruptedException e) {
                    break;
                }
            }
        }
    }
    
    /**
     * VisualVM detection
     */
    public static void visualVMDetection() {
        /**
         * USING VISUALVM:
         * 
         * 1. Start VisualVM:
         *    jvisualvm
         * 
         * 2. Connect to application
         * 
         * 3. Go to "Threads" tab
         * 
         * 4. Look for:
         *    - Red threads (blocked)
         *    - "Detect Deadlock" button
         *    - Visual representation of lock dependencies
         * 
         * 5. Take thread dump:
         *    - "Thread Dump" button
         *    - Shows full call stacks
         *    - Highlights deadlocked threads
         * 
         * ADVANTAGES:
         * - Visual representation
         * - Real-time monitoring
         * - Historical view
         * - Easy to identify patterns
         */
    }
    
    public static void main(String[] args) throws InterruptedException {
        // Start deadlock monitor
        new DeadlockMonitor(1000).start();
        
        // Create deadlock
        DeadlockDemo demo = new DeadlockDemo();
        new Thread(() -> {
            try {
                demo.createDeadlock();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
        
        // Wait and detect
        Thread.sleep(2000);
        
        System.out.println("\n=== Programmatic Detection ===");
        programmaticDetection();
        
        // Keep running for manual jstack
        Thread.sleep(60000);
    }
}
```

---

## 3. Deadlock Prevention Strategies

### Breaking the Four Conditions

```java
/**
 * DEADLOCK PREVENTION
 * 
 * Strategies to prevent deadlock by breaking one or more conditions
 */

import java.util.concurrent.locks.*;

public class DeadlockPrevention {
    
    /**
     * Strategy 1: Lock Ordering (breaks circular wait)
     */
    static class LockOrdering {
        static class Account {
            private final int id;
            private int balance;
            
            public Account(int id, int balance) {
                this.id = id;
                this.balance = balance;
            }
            
            public int getId() {
                return id;
            }
            
            public void deposit(int amount) {
                balance += amount;
            }
            
            public void withdraw(int amount) {
                balance -= amount;
            }
        }
        
        // SOLUTION: Always acquire locks in same order
        public static void transfer(Account from, Account to, int amount) {
            Account first, second;
            
            // Order by account ID
            if (from.getId() < to.getId()) {
                first = from;
                second = to;
            } else {
                first = to;
                second = from;
            }
            
            synchronized (first) {
                synchronized (second) {
                    from.withdraw(amount);
                    to.deposit(amount);
                    System.out.println("Transferred " + amount + 
                        " from " + from.getId() + " to " + to.getId());
                }
            }
        }
        
        public static void demo() throws InterruptedException {
            Account acc1 = new Account(1, 1000);
            Account acc2 = new Account(2, 2000);
            
            Thread t1 = new Thread(() -> transfer(acc1, acc2, 100));
            Thread t2 = new Thread(() -> transfer(acc2, acc1, 200));
            
            t1.start();
            t2.start();
            t1.join();
            t2.join();
            
            System.out.println("Completed without deadlock!");
            
            /**
             * WHY IT WORKS:
             * - Breaks circular wait condition
             * - Both threads acquire locks in same order
             * - Thread acquiring first lock will complete
             * - No cycle possible
             */
        }
    }
    
    /**
     * Strategy 2: tryLock with timeout (breaks hold and wait)
     */
    static class TryLockStrategy {
        static class Account {
            private final ReentrantLock lock = new ReentrantLock();
            private int balance;
            
            public Account(int balance) {
                this.balance = balance;
            }
            
            public boolean tryLock(long timeout, java.util.concurrent.TimeUnit unit) 
                    throws InterruptedException {
                return lock.tryLock(timeout, unit);
            }
            
            public void unlock() {
                lock.unlock();
            }
            
            public void deposit(int amount) {
                balance += amount;
            }
            
            public void withdraw(int amount) {
                balance -= amount;
            }
        }
        
        public static boolean transfer(Account from, Account to, int amount) 
                throws InterruptedException {
            
            // Try to acquire both locks with timeout
            if (from.tryLock(1, java.util.concurrent.TimeUnit.SECONDS)) {
                try {
                    if (to.tryLock(1, java.util.concurrent.TimeUnit.SECONDS)) {
                        try {
                            from.withdraw(amount);
                            to.deposit(amount);
                            System.out.println("Transfer successful");
                            return true;
                        } finally {
                            to.unlock();
                        }
                    } else {
                        System.out.println("Couldn't acquire second lock, aborting");
                        return false;
                    }
                } finally {
                    from.unlock();
                }
            } else {
                System.out.println("Couldn't acquire first lock, aborting");
                return false;
            }
        }
        
        /**
         * WHY IT WORKS:
         * - tryLock() doesn't block indefinitely
         * - If can't acquire lock, release held locks
         * - Breaks hold-and-wait condition
         * - May retry after backoff
         */
    }
    
    /**
     * Strategy 3: Lock-free algorithms (breaks mutual exclusion)
     */
    static class LockFreeStrategy {
        static class Counter {
            private final java.util.concurrent.atomic.AtomicInteger value = 
                new java.util.concurrent.atomic.AtomicInteger(0);
            
            public void increment() {
                value.incrementAndGet();  // Lock-free!
            }
            
            public int get() {
                return value.get();
            }
        }
        
        /**
         * WHY IT WORKS:
         * - No locks, no deadlock
         * - Uses CAS (Compare-And-Swap)
         * - Breaks mutual exclusion requirement
         * - Limited to specific data structures
         */
    }
    
    /**
     * Strategy 4: Single lock (simplifies, breaks circular wait)
     */
    static class SingleLockStrategy {
        private static final Object GLOBAL_LOCK = new Object();
        
        static class Account {
            private int balance;
            
            public Account(int balance) {
                this.balance = balance;
            }
            
            public void deposit(int amount) {
                balance += amount;
            }
            
            public void withdraw(int amount) {
                balance -= amount;
            }
        }
        
        public static void transfer(Account from, Account to, int amount) {
            synchronized (GLOBAL_LOCK) {
                from.withdraw(amount);
                to.deposit(amount);
            }
        }
        
        /**
         * WHY IT WORKS:
         * - Only one lock, no circular wait
         * - Simple but reduces concurrency
         * - Use when operations are fast
         */
    }
    
    /**
     * Strategy 5: Request all locks at once (breaks hold and wait)
     */
    static class AllOrNothingStrategy {
        static class ResourceManager {
            private final java.util.Set<String> availableResources = 
                new java.util.HashSet<>();
            
            public ResourceManager(String... resources) {
                java.util.Collections.addAll(availableResources, resources);
            }
            
            public synchronized boolean acquireAll(String... resources) {
                // Check if all available
                for (String resource : resources) {
                    if (!availableResources.contains(resource)) {
                        return false;  // Can't get all
                    }
                }
                
                // Remove all (acquire)
                for (String resource : resources) {
                    availableResources.remove(resource);
                }
                
                return true;
            }
            
            public synchronized void releaseAll(String... resources) {
                for (String resource : resources) {
                    availableResources.add(resource);
                }
            }
        }
        
        /**
         * WHY IT WORKS:
         * - Acquire all locks atomically
         * - Or acquire none
         * - Breaks hold-and-wait
         */
    }
    
    /**
     * Comparison of strategies
     */
    public static void strategyComparison() {
        /**
         * ┌────────────────────┬──────────────┬─────────────┬─────────────┐
         * │ Strategy           │ Condition    │ Concurrency │ Complexity  │
         * │                    │ Broken       │             │             │
         * ├────────────────────┼──────────────┼─────────────┼─────────────┤
         * │ Lock Ordering      │ Circular     │ High        │ Low         │
         * │ tryLock + Timeout  │ Hold & Wait  │ High        │ Medium      │
         * │ Lock-free          │ Mutual Excl. │ Highest     │ High        │
         * │ Single Lock        │ Circular     │ Low         │ Very Low    │
         * │ All-or-Nothing     │ Hold & Wait  │ Medium      │ Medium      │
         * └────────────────────┴──────────────┴─────────────┴─────────────┘
         * 
         * RECOMMENDATIONS:
         * 
         * 1. Lock Ordering - Best for most cases
         *    - Simple to implement
         *    - Good concurrency
         *    - Works with synchronized and Lock
         * 
         * 2. tryLock - When lock ordering not possible
         *    - Handles arbitrary lock order
         *    - Requires ReentrantLock
         *    - Add backoff to prevent livelock
         * 
         * 3. Lock-free - Performance critical
         *    - Highest throughput
         *    - Complex implementation
         *    - Limited applicability
         * 
         * 4. Single Lock - Simple operations
         *    - When contention is low
         *    - Operations are very fast
         *    - Easy to reason about
         * 
         * 5. All-or-Nothing - Multiple resources
         *    - Known resource set upfront
         *    - Can enumerate all needed resources
         *    - May reduce concurrency
         */
    }
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== Lock Ordering ===");
        LockOrdering.demo();
    }
}
```

---

## 4. Livelock

### Definition and Examples

```java
/**
 * LIVELOCK
 * 
 * Threads are active but making no progress
 * Each thread keeps responding to the other
 */

public class LivelockExamples {
    
    /**
     * Classic livelock: Polite people problem
     */
    static class PolitePerson {
        private final String name;
        
        public PolitePerson(String name) {
            this.name = name;
        }
        
        public void passThrough(Hallway hallway, PolitePerson other) {
            while (hallway.isBlocked(this)) {
                System.out.println(name + ": You first, " + other.name);
                
                // Try to let other pass
                hallway.stepAside(this);
                
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    return;
                }
                
                // Check if can proceed
                if (!hallway.isBlocked(this)) {
                    break;
                }
                
                // Try again
                hallway.stepForward(this);
            }
            
            System.out.println(name + ": Finally passed!");
        }
    }
    
    static class Hallway {
        private PolitePerson person1;
        private PolitePerson person2;
        
        public synchronized void stepForward(PolitePerson person) {
            if (person == person1 || person1 == null) {
                person1 = person;
            } else {
                person2 = person;
            }
        }
        
        public synchronized void stepAside(PolitePerson person) {
            if (person == person1) {
                person1 = null;
            } else if (person == person2) {
                person2 = null;
            }
        }
        
        public synchronized boolean isBlocked(PolitePerson person) {
            return (person1 != null && person2 != null && 
                    (person == person1 || person == person2));
        }
    }
    
    public static void politePeopleDemo() throws InterruptedException {
        Hallway hallway = new Hallway();
        PolitePerson alice = new PolitePerson("Alice");
        PolitePerson bob = new PolitePerson("Bob");
        
        hallway.stepForward(alice);
        hallway.stepForward(bob);
        
        Thread t1 = new Thread(() -> alice.passThrough(hallway, bob));
        Thread t2 = new Thread(() -> bob.passThrough(hallway, alice));
        
        t1.start();
        t2.start();
        
        t1.join(5000);
        t2.join(5000);
        
        /**
         * OUTPUT:
         * Alice: You first, Bob
         * Bob: You first, Alice
         * Alice: You first, Bob
         * Bob: You first, Alice
         * ...
         * (LIVELOCK - both keep stepping aside)
         * 
         * CHARACTERISTICS:
         * - Threads are active (not blocked)
         * - CPU usage high
         * - No progress made
         * - Responding to each other in loop
         */
    }
    
    /**
     * Livelock with tryLock
     */
    static class TryLockLivelock {
        private final java.util.concurrent.locks.ReentrantLock lock1 = 
            new java.util.concurrent.locks.ReentrantLock();
        private final java.util.concurrent.locks.ReentrantLock lock2 = 
            new java.util.concurrent.locks.ReentrantLock();
        
        public void operation1() {
            while (true) {
                if (lock1.tryLock()) {
                    try {
                        if (lock2.tryLock()) {
                            try {
                                System.out.println("Operation1 succeeded");
                                return;
                            } finally {
                                lock2.unlock();
                            }
                        }
                    } finally {
                        lock1.unlock();  // Release and retry
                    }
                }
                
                System.out.println("Operation1 retry");
                // NO BACKOFF - immediate retry!
            }
        }
        
        public void operation2() {
            while (true) {
                if (lock2.tryLock()) {
                    try {
                        if (lock1.tryLock()) {
                            try {
                                System.out.println("Operation2 succeeded");
                                return;
                            } finally {
                                lock1.unlock();
                            }
                        }
                    } finally {
                        lock2.unlock();  // Release and retry
                    }
                }
                
                System.out.println("Operation2 retry");
                // NO BACKOFF - immediate retry!
            }
        }
        
        /**
         * LIVELOCK SCENARIO:
         * 1. T1 acquires lock1
         * 2. T2 acquires lock2
         * 3. T1 fails to get lock2, releases lock1
         * 4. T2 fails to get lock1, releases lock2
         * 5. Repeat forever
         * 
         * Both threads active but no progress!
         */
    }
    
    /**
     * Solution: Random backoff
     */
    static class LivelockSolution {
        private final java.util.concurrent.locks.ReentrantLock lock1 = 
            new java.util.concurrent.locks.ReentrantLock();
        private final java.util.concurrent.locks.ReentrantLock lock2 = 
            new java.util.concurrent.locks.ReentrantLock();
        private final java.util.Random random = new java.util.Random();
        
        public void operationWithBackoff() throws InterruptedException {
            int attempts = 0;
            
            while (attempts < 10) {
                if (lock1.tryLock()) {
                    try {
                        if (lock2.tryLock()) {
                            try {
                                System.out.println("Operation succeeded after " + 
                                    attempts + " attempts");
                                return;
                            } finally {
                                lock2.unlock();
                            }
                        }
                    } finally {
                        lock1.unlock();
                    }
                }
                
                // RANDOM BACKOFF - breaks synchronization
                long backoff = 10 + random.nextInt(100);
                Thread.sleep(backoff);
                attempts++;
            }
            
            throw new RuntimeException("Failed after " + attempts + " attempts");
        }
        
        /**
         * WHY IT WORKS:
         * - Random delays break synchronization
         * - Threads retry at different times
         * - Eventually one succeeds
         * - Exponential backoff even better
         */
    }
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== Polite People Livelock ===");
        politePeopleDemo();
    }
}
```

---

## 5. Thread Starvation and Fairness

### Starvation Scenarios

```java
/**
 * THREAD STARVATION
 * 
 * Thread unable to gain access to shared resources
 * Makes little or no progress
 */

import java.util.concurrent.locks.*;

public class StarvationExamples {
    
    /**
     * Starvation with thread priorities
     */
    static class PriorityStarvation {
        private final Object lock = new Object();
        private int counter = 0;
        
        public void runDemo() throws InterruptedException {
            // Low priority thread
            Thread lowPriority = new Thread(() -> {
                while (counter < 1000) {
                    synchronized (lock) {
                        counter++;
                        if (counter % 100 == 0) {
                            System.out.println("Low priority: " + counter);
                        }
                    }
                }
            }, "Low-Priority");
            lowPriority.setPriority(Thread.MIN_PRIORITY);
            
            // High priority threads
            Thread[] highPriority = new Thread[5];
            for (int i = 0; i < 5; i++) {
                highPriority[i] = new Thread(() -> {
                    while (counter < 1000) {
                        synchronized (lock) {
                            counter++;
                            if (counter % 100 == 0) {
                                System.out.println("High priority " + 
                                    Thread.currentThread().getName() + ": " + counter);
                            }
                        }
                    }
                }, "High-Priority-" + i);
                highPriority[i].setPriority(Thread.MAX_PRIORITY);
            }
            
            lowPriority.start();
            for (Thread t : highPriority) {
                t.start();
            }
            
            lowPriority.join();
            for (Thread t : highPriority) {
                t.join();
            }
            
            /**
             * TYPICAL OUTPUT:
             * High priority High-Priority-0: 100
             * High priority High-Priority-1: 200
             * High priority High-Priority-2: 300
             * ...
             * Low priority: 950  (rarely runs!)
             * 
             * STARVATION:
             * - Low priority thread starved
             * - High priority threads dominate
             * - Low priority makes little progress
             */
        }
    }
    
    /**
     * Starvation with non-fair locks
     */
    static class NonFairLockStarvation {
        private final ReentrantLock lock = new ReentrantLock(false);  // Non-fair
        private int counter = 0;
        
        public void runDemo() throws InterruptedException {
            Thread[] threads = new Thread[10];
            
            for (int i = 0; i < 10; i++) {
                final int id = i;
                threads[i] = new Thread(() -> {
                    for (int j = 0; j < 100; j++) {
                        lock.lock();
                        try {
                            counter++;
                            if (j == 0) {
                                System.out.println("Thread " + id + " first lock");
                            }
                        } finally {
                            lock.unlock();
                        }
                    }
                    System.out.println("Thread " + id + " completed");
                });
            }
            
            for (Thread t : threads) {
                t.start();
            }
            
            for (Thread t : threads) {
                t.join();
            }
            
            /**
             * POSSIBLE OUTPUT:
             * Thread 0 first lock
             * Thread 1 first lock
             * Thread 2 first lock
             * Thread 0 completed
             * Thread 1 completed
             * Thread 2 completed
             * Thread 3 first lock  (started much later!)
             * ...
             * 
             * STARVATION:
             * - Some threads complete quickly
             * - Others wait long time
             * - Non-fair lock allows barging
             */
        }
    }
    
    /**
     * Solution: Fair locks
     */
    static class FairLockSolution {
        private final ReentrantLock lock = new ReentrantLock(true);  // Fair!
        private int counter = 0;
        
        public void runDemo() throws InterruptedException {
            Thread[] threads = new Thread[10];
            long[] times = new long[10];
            
            for (int i = 0; i < 10; i++) {
                final int id = i;
                threads[i] = new Thread(() -> {
                    long start = System.currentTimeMillis();
                    
                    for (int j = 0; j < 100; j++) {
                        lock.lock();
                        try {
                            counter++;
                        } finally {
                            lock.unlock();
                        }
                    }
                    
                    times[id] = System.currentTimeMillis() - start;
                });
            }
            
            for (Thread t : threads) {
                t.start();
            }
            
            for (Thread t : threads) {
                t.join();
            }
            
            System.out.println("Fair lock times:");
            for (int i = 0; i < times.length; i++) {
                System.out.println("Thread " + i + ": " + times[i] + "ms");
            }
            
            /**
             * OUTPUT:
             * Fair lock times:
             * Thread 0: 45ms
             * Thread 1: 47ms
             * Thread 2: 46ms
             * Thread 3: 48ms
             * ...
             * 
             * FAIRNESS:
             * - All threads complete in similar time
             * - FIFO ordering
             * - No starvation
             * 
             * TRADEOFF:
             * - Lower throughput (10x slower than non-fair)
             * - But guarantees progress for all threads
             */
        }
    }
    
    /**
     * Reader starvation with write preference
     */
    static class ReaderStarvation {
        private final ReadWriteLock rwLock = new ReentrantReadWriteLock();
        private int data = 0;
        
        public void writeHeavyScenario() throws InterruptedException {
            // Many writers
            Thread[] writers = new Thread[10];
            for (int i = 0; i < 10; i++) {
                writers[i] = new Thread(() -> {
                    for (int j = 0; j < 100; j++) {
                        rwLock.writeLock().lock();
                        try {
                            data++;
                            Thread.sleep(1);  // Simulate work
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                        } finally {
                            rwLock.writeLock().unlock();
                        }
                    }
                });
            }
            
            // Few readers
            Thread[] readers = new Thread[2];
            for (int i = 0; i < 2; i++) {
                final int id = i;
                readers[i] = new Thread(() -> {
                    int reads = 0;
                    long start = System.currentTimeMillis();
                    
                    while (System.currentTimeMillis() - start < 5000) {
                        rwLock.readLock().lock();
                        try {
                            int value = data;
                            reads++;
                        } finally {
                            rwLock.readLock().unlock();
                        }
                    }
                    
                    System.out.println("Reader " + id + " completed " + reads + " reads");
                });
            }
            
            for (Thread t : writers) t.start();
            for (Thread t : readers) t.start();
            
            for (Thread t : writers) t.join();
            for (Thread t : readers) t.join();
            
            /**
             * READER STARVATION:
             * - Writers have preference
             * - Readers wait for writers
             * - Readers may starve with heavy writes
             * 
             * SOLUTION:
             * - Fair ReadWriteLock
             * - Or limit consecutive writes
             */
        }
    }
    
    /**
     * Detection: Monitoring thread progress
     */
    static class StarvationDetector {
        private final java.util.Map<Thread, Long> threadProgress = 
            new java.util.concurrent.ConcurrentHashMap<>();
        private final long starvationThreshold = 5000;  // 5 seconds
        
        public void recordProgress(Thread thread) {
            threadProgress.put(thread, System.currentTimeMillis());
        }
        
        public void checkForStarvation() {
            long now = System.currentTimeMillis();
            
            for (java.util.Map.Entry<Thread, Long> entry : threadProgress.entrySet()) {
                long lastProgress = entry.getValue();
                long timeSinceProgress = now - lastProgress;
                
                if (timeSinceProgress > starvationThreshold) {
                    System.err.println("WARNING: Thread " + 
                        entry.getKey().getName() + 
                        " may be starved (no progress for " + 
                        timeSinceProgress + "ms)");
                }
            }
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== Priority Starvation ===");
        new PriorityStarvation().runDemo();
        
        System.out.println("\n=== Non-Fair Lock ===");
        new NonFairLockStarvation().runDemo();
        
        System.out.println("\n=== Fair Lock Solution ===");
        new FairLockSolution().runDemo();
    }
}
```

---

## 6. Dining Philosophers Problem

### Classic Concurrency Problem

```java
/**
 * DINING PHILOSOPHERS PROBLEM
 * 
 * Classic problem demonstrating deadlock
 */

import java.util.concurrent.locks.*;

public class DiningPhilosophers {
    
    /**
     * Version 1: Deadlock-prone
     */
    static class Chopstick {
        private final int id;
        
        public Chopstick(int id) {
            this.id = id;
        }
        
        public int getId() {
            return id;
        }
    }
    
    static class PhilosopherDeadlock extends Thread {
        private final Chopstick left;
        private final Chopstick right;
        private final int id;
        
        public PhilosopherDeadlock(int id, Chopstick left, Chopstick right) {
            this.id = id;
            this.left = left;
            this.right = right;
        }
        
        @Override
        public void run() {
            try {
                while (true) {
                    think();
                    eat();
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        
        private void think() throws InterruptedException {
            System.out.println("Philosopher " + id + " is thinking");
            Thread.sleep(100);
        }
        
        private void eat() throws InterruptedException {
            synchronized (left) {
                System.out.println("Philosopher " + id + " picked up left chopstick");
                Thread.sleep(50);  // Increase chance of deadlock
                
                synchronized (right) {
                    System.out.println("Philosopher " + id + " picked up right chopstick");
                    System.out.println("Philosopher " + id + " is eating");
                    Thread.sleep(100);
                }
            }
        }
    }
    
    public static void deadlockDemo() throws InterruptedException {
        int numPhilosophers = 5;
        Chopstick[] chopsticks = new Chopstick[numPhilosophers];
        
        for (int i = 0; i < numPhilosophers; i++) {
            chopsticks[i] = new Chopstick(i);
        }
        
        PhilosopherDeadlock[] philosophers = new PhilosopherDeadlock[numPhilosophers];
        for (int i = 0; i < numPhilosophers; i++) {
            Chopstick left = chopsticks[i];
            Chopstick right = chopsticks[(i + 1) % numPhilosophers];
            philosophers[i] = new PhilosopherDeadlock(i, left, right);
        }
        
        for (PhilosopherDeadlock p : philosophers) {
            p.start();
        }
        
        Thread.sleep(5000);
        
        /**
         * DEADLOCK SCENARIO:
         * - Each philosopher picks up left chopstick
         * - All wait for right chopstick
         * - Circular wait: P0 → C1 → P1 → C2 → ... → P4 → C0 → P0
         * - Classic deadlock!
         */
    }
    
    /**
     * Solution 1: Resource ordering
     */
    static class PhilosopherOrdering extends Thread {
        private final Chopstick first;
        private final Chopstick second;
        private final int id;
        
        public PhilosopherOrdering(int id, Chopstick left, Chopstick right) {
            this.id = id;
            
            // Always acquire chopstick with lower ID first
            if (left.getId() < right.getId()) {
                this.first = left;
                this.second = right;
            } else {
                this.first = right;
                this.second = left;
            }
        }
        
        @Override
        public void run() {
            try {
                for (int i = 0; i < 10; i++) {
                    think();
                    eat();
                }
                System.out.println("Philosopher " + id + " finished");
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        
        private void think() throws InterruptedException {
            System.out.println("Philosopher " + id + " thinking");
            Thread.sleep(100);
        }
        
        private void eat() throws InterruptedException {
            synchronized (first) {
                synchronized (second) {
                    System.out.println("Philosopher " + id + " eating");
                    Thread.sleep(100);
                }
            }
        }
    }
    
    /**
     * Solution 2: Semaphore limiting
     */
    static class PhilosopherSemaphore extends Thread {
        private static java.util.concurrent.Semaphore semaphore;
        private final Chopstick left;
        private final Chopstick right;
        private final int id;
        
        public static void setSemaphore(int permits) {
            semaphore = new java.util.concurrent.Semaphore(permits);
        }
        
        public PhilosopherSemaphore(int id, Chopstick left, Chopstick right) {
            this.id = id;
            this.left = left;
            this.right = right;
        }
        
        @Override
        public void run() {
            try {
                for (int i = 0; i < 10; i++) {
                    think();
                    eat();
                }
                System.out.println("Philosopher " + id + " finished");
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        
        private void think() throws InterruptedException {
            System.out.println("Philosopher " + id + " thinking");
            Thread.sleep(100);
        }
        
        private void eat() throws InterruptedException {
            semaphore.acquire();  // Limit concurrent eaters
            try {
                synchronized (left) {
                    synchronized (right) {
                        System.out.println("Philosopher " + id + " eating");
                        Thread.sleep(100);
                    }
                }
            } finally {
                semaphore.release();
            }
        }
    }
    
    /**
     * Solution 3: tryLock with timeout
     */
    static class PhilosopherTryLock extends Thread {
        private final ReentrantLock left;
        private final ReentrantLock right;
        private final int id;
        
        public PhilosopherTryLock(int id, ReentrantLock left, ReentrantLock right) {
            this.id = id;
            this.left = left;
            this.right = right;
        }
        
        @Override
        public void run() {
            try {
                for (int i = 0; i < 10; i++) {
                    think();
                    while (!eat()) {
                        // Retry if couldn't eat
                        Thread.sleep(50);
                    }
                }
                System.out.println("Philosopher " + id + " finished");
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        
        private void think() throws InterruptedException {
            System.out.println("Philosopher " + id + " thinking");
            Thread.sleep(100);
        }
        
        private boolean eat() throws InterruptedException {
            if (left.tryLock(100, java.util.concurrent.TimeUnit.MILLISECONDS)) {
                try {
                    if (right.tryLock(100, java.util.concurrent.TimeUnit.MILLISECONDS)) {
                        try {
                            System.out.println("Philosopher " + id + " eating");
                            Thread.sleep(100);
                            return true;
                        } finally {
                            right.unlock();
                        }
                    }
                } finally {
                    left.unlock();
                }
            }
            return false;  // Couldn't get both locks
        }
    }
    
    /**
     * Demonstration of solutions
     */
    public static void orderingDemo() throws InterruptedException {
        int numPhilosophers = 5;
        Chopstick[] chopsticks = new Chopstick[numPhilosophers];
        
        for (int i = 0; i < numPhilosophers; i++) {
            chopsticks[i] = new Chopstick(i);
        }
        
        PhilosopherOrdering[] philosophers = new PhilosopherOrdering[numPhilosophers];
        for (int i = 0; i < numPhilosophers; i++) {
            Chopstick left = chopsticks[i];
            Chopstick right = chopsticks[(i + 1) % numPhilosophers];
            philosophers[i] = new PhilosopherOrdering(i, left, right);
        }
        
        for (PhilosopherOrdering p : philosophers) {
            p.start();
        }
        
        for (PhilosopherOrdering p : philosophers) {
            p.join();
        }
        
        System.out.println("All philosophers finished - no deadlock!");
    }
    
    public static void semaphoreDemo() throws InterruptedException {
        int numPhilosophers = 5;
        Chopstick[] chopsticks = new Chopstick[numPhilosophers];
        
        for (int i = 0; i < numPhilosophers; i++) {
            chopsticks[i] = new Chopstick(i);
        }
        
        // Only allow 4 philosophers to eat simultaneously
        PhilosopherSemaphore.setSemaphore(numPhilosophers - 1);
        
        PhilosopherSemaphore[] philosophers = new PhilosopherSemaphore[numPhilosophers];
        for (int i = 0; i < numPhilosophers; i++) {
            Chopstick left = chopsticks[i];
            Chopstick right = chopsticks[(i + 1) % numPhilosophers];
            philosophers[i] = new PhilosopherSemaphore(i, left, right);
        }
        
        for (PhilosopherSemaphore p : philosophers) {
            p.start();
        }
        
        for (PhilosopherSemaphore p : philosophers) {
            p.join();
        }
        
        System.out.println("All philosophers finished - no deadlock!");
    }
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== Ordering Solution ===");
        orderingDemo();
        
        System.out.println("\n=== Semaphore Solution ===");
        semaphoreDemo();
    }
}
```

---

## 7. Real-World Deadlock Debugging

### Production Scenarios

```java
/**
 * REAL-WORLD DEADLOCK DEBUGGING
 * 
 * Practical scenarios and solutions
 */

public class RealWorldDebugging {
    
    /**
     * Scenario 1: Database connection pool deadlock
     */
    static class ConnectionPoolDeadlock {
        /**
         * PROBLEM:
         * 
         * public void processOrder(Order order) {
         *     Connection conn1 = pool.getConnection();  // Get first connection
         *     try {
         *         updateInventory(conn1, order);
         *         
         *         Connection conn2 = pool.getConnection();  // Get second!
         *         try {
         *             updateAccounting(conn2, order);
         *         } finally {
         *             pool.releaseConnection(conn2);
         *         }
         *     } finally {
         *         pool.releaseConnection(conn1);
         *     }
         * }
         * 
         * DEADLOCK SCENARIO:
         * - Pool has 10 connections
         * - 10 threads call processOrder()
         * - Each gets first connection
         * - All wait for second connection
         * - Pool exhausted, DEADLOCK!
         * 
         * SOLUTION:
         * 
         * public void processOrder(Order order) {
         *     Connection conn = pool.getConnection();  // ONE connection
         *     try {
         *         updateInventory(conn, order);
         *         updateAccounting(conn, order);  // Reuse same connection
         *     } finally {
         *         pool.releaseConnection(conn);
         *     }
         * }
         * 
         * OR:
         * 
         * public void processOrder(Order order) {
         *     // Get all resources upfront
         *     List<Connection> conns = pool.getConnections(2);
         *     try {
         *         updateInventory(conns.get(0), order);
         *         updateAccounting(conns.get(1), order);
         *     } finally {
         *         pool.releaseConnections(conns);
         *     }
         * }
         */
    }
    
    /**
     * Scenario 2: Distributed deadlock
     */
    static class DistributedDeadlock {
        /**
         * PROBLEM: Microservices deadlock
         * 
         * Service A:
         *   synchronized (resourceX) {
         *       callServiceB();  // HTTP call
         *       synchronized (resourceY) {
         *           // work
         *       }
         *   }
         * 
         * Service B:
         *   synchronized (resourceY) {
         *       callServiceA();  // HTTP call
         *       synchronized (resourceX) {
         *           // work
         *       }
         *   }
         * 
         * DEADLOCK:
         * - Request to A holds resourceX, calls B
         * - Request to B holds resourceY, calls A
         * - Circular wait across services!
         * 
         * DETECTION:
         * - Thread dumps show threads blocked on HTTP calls
         * - Trace distributed transactions
         * - Look for circular dependencies in call graph
         * 
         * SOLUTION:
         * - Establish service call ordering
         * - Use timeouts on all external calls
         * - Implement circuit breaker pattern
         * - Avoid holding locks during external calls
         */
    }
    
    /**
     * Scenario 3: Spring @Transactional deadlock
     */
    static class SpringTransactionalDeadlock {
        /**
         * PROBLEM:
         * 
         * @Transactional
         * public void method1() {
         *     // Transaction opens DB connection and locks row A
         *     repo.updateRecordA();
         *     
         *     // Call another transactional method
         *     method2();  // Needs to lock row B
         * }
         * 
         * @Transactional
         * public void method2() {
         *     // Different transaction, different connection
         *     repo.updateRecordB();  // Locks row B
         *     
         *     // Try to update A
         *     repo.updateRecordA();  // Waits for row A lock!
         * }
         * 
         * DEADLOCK:
         * - Thread 1: method1() → locks A → calls method2() → waits for B
         * - Thread 2: method2() → locks B → tries A → waits for A
         * 
         * SOLUTION:
         * - Use same transaction (propagation = REQUIRED)
         * - Or explicit lock ordering in queries
         * - Add database deadlock detection
         */
    }
    
    /**
     * Debug checklist
     */
    public static void debugChecklist() {
        /**
         * DEADLOCK DEBUGGING CHECKLIST:
         * 
         * 1. IDENTIFY:
         *    □ Take thread dump (jstack, kill -3, VisualVM)
         *    □ Look for "Found 1 deadlock" message
         *    □ Note which threads are involved
         *    □ Note which objects/locks
         * 
         * 2. ANALYZE:
         *    □ Draw lock dependency graph
         *    □ Find circular wait
         *    □ Identify lock acquisition order
         *    □ Check if resource pools exhausted
         * 
         * 3. REPRODUCE:
         *    □ Create minimal test case
         *    □ Add logging to trace lock acquisition
         *    □ Use deadlock detector in test
         * 
         * 4. FIX:
         *    □ Apply lock ordering
         *    □ Or use tryLock() with timeout
         *    □ Or reduce lock scope
         *    □ Or redesign to avoid nested locks
         * 
         * 5. VERIFY:
         *    □ Run under load
         *    □ Monitor with deadlock detector
         *    □ Stress test with many threads
         * 
         * 6. PREVENT:
         *    □ Code review for lock patterns
         *    □ Document lock ordering
         *    □ Use static analysis tools
         *    □ Monitor production with JMX
         */
    }
    
    /**
     * Production monitoring
     */
    static class ProductionMonitoring {
        private final java.lang.management.ThreadMXBean threadMXBean = 
            java.lang.management.ManagementFactory.getThreadMXBean();
        
        public void monitorDeadlocks() {
            // Schedule periodic check
            java.util.concurrent.Executors.newScheduledThreadPool(1)
                .scheduleAtFixedRate(() -> {
                    long[] deadlocks = threadMXBean.findDeadlockedThreads();
                    
                    if (deadlocks != null) {
                        alertOps("DEADLOCK DETECTED");
                        takeThreadDump();
                        logDeadlockDetails(deadlocks);
                    }
                }, 0, 30, java.util.concurrent.TimeUnit.SECONDS);
        }
        
        private void alertOps(String message) {
            System.err.println("ALERT: " + message);
            // Send to monitoring system (Datadog, NewRelic, etc.)
        }
        
        private void takeThreadDump() {
            // Save thread dump for analysis
            System.err.println("Thread dump: jstack " + 
                java.lang.management.ManagementFactory.getRuntimeMXBean()
                    .getName().split("@")[0]);
        }
        
        private void logDeadlockDetails(long[] deadlocks) {
            java.lang.management.ThreadInfo[] infos = 
                threadMXBean.getThreadInfo(deadlocks);
            
            for (java.lang.management.ThreadInfo info : infos) {
                System.err.println("Deadlocked thread: " + info.getThreadName());
                System.err.println("  Waiting on: " + info.getLockName());
                System.err.println("  Owned by: " + info.getLockOwnerName());
            }
        }
    }
}
```

---

## Summary

### Quick Reference

**Deadlock Four Conditions:**

```
1. Mutual Exclusion - Resource held exclusively
2. Hold and Wait - Hold resource while waiting
3. No Preemption - Can't forcibly take resource
4. Circular Wait - Circular dependency chain

Break ANY ONE → No deadlock
```

**Detection:**

```bash
# Thread dump
jstack <pid>

# Or
kill -3 <pid>  # Unix
Ctrl+Break     # Windows

# Look for:
# "Found 1 deadlock"
# "waiting to lock"
# "which is held by"
```

**Prevention Strategies:**

```java
// 1. Lock ordering
synchronized (getLock(id1 < id2 ? id1 : id2)) {
    synchronized (getLock(id1 < id2 ? id2 : id1)) {
        // work
    }
}

// 2. tryLock with timeout
if (lock1.tryLock(1, TimeUnit.SECONDS)) {
    try {
        if (lock2.tryLock(1, TimeUnit.SECONDS)) {
            try {
                // work
            } finally { lock2.unlock(); }
        }
    } finally { lock1.unlock(); }
}

// 3. Single lock
synchronized (GLOBAL_LOCK) {
    // work
}
```

**Livelock Solution:**

```java
// Add random backoff
long backoff = 10 + random.nextInt(100);
Thread.sleep(backoff);
```

**Starvation Solutions:**

```java
// Fair locks
ReentrantLock lock = new ReentrantLock(true);

// Or limit priorities
// Or monitor thread progress
```

### Best Practices

1. ✅ **Always acquire locks in same order**
2. ✅ **Use tryLock() for dynamic lock order**
3. ✅ **Keep lock scope minimal**
4. ✅ **Don't call external code while holding locks**
5. ✅ **Monitor for deadlocks in production**
6. ✅ **Use fair locks when starvation possible**
7. ❌ **Don't hold multiple locks if avoidable**
8. ❌ **Don't nest synchronized blocks without ordering**
9. ❌ **Don't ignore thread priorities in critical sections**
10. ❌ **Don't hold locks during I/O or network calls**

---
