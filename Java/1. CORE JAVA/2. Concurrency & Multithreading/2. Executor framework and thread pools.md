# Java Executor Framework and Thread Pools

## Overview

The Executor framework provides a higher-level abstraction for managing threads, replacing manual thread creation with thread pools. This guide covers ThreadPoolExecutor configuration, different executor types, queue implementations, rejection policies, and work-stealing algorithms.

---

## 1. ThreadPoolExecutor Parameters

### Core Parameters Explained

```java
/**
 * THREADPOOLEXECUTOR ANATOMY
 * 
 * ThreadPoolExecutor(
 *     int corePoolSize,           // Minimum threads to keep alive
 *     int maximumPoolSize,        // Maximum threads allowed
 *     long keepAliveTime,         // Idle thread timeout
 *     TimeUnit unit,              // Time unit for keepAliveTime
 *     BlockingQueue<Runnable> workQueue,  // Task queue
 *     ThreadFactory threadFactory,        // Thread creation
 *     RejectedExecutionHandler handler    // Rejection policy
 * )
 */

import java.util.concurrent.*;

public class ThreadPoolParameters {
    
    /**
     * PARAMETER 1: corePoolSize
     * 
     * Minimum number of threads to keep alive, even if idle
     */
    public static void corePoolSizeDemo() {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            5,              // corePoolSize = 5
            10,             // maximumPoolSize
            60L,            // keepAliveTime
            TimeUnit.SECONDS,
            new LinkedBlockingQueue<>()
        );
        
        System.out.println("Core pool size: " + executor.getCorePoolSize());
        
        // Submit 3 tasks
        for (int i = 0; i < 3; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("Task " + taskId + " on " + 
                    Thread.currentThread().getName());
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }
        
        try {
            Thread.sleep(100);
            System.out.println("Active threads: " + executor.getActiveCount());
            // Output: Active threads: 3
            
            Thread.sleep(6000);
            System.out.println("Active threads after completion: " + 
                executor.getActiveCount());
            // Output: Active threads after completion: 3 (core threads stay alive)
            
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        executor.shutdown();
        
        /**
         * CORE POOL SIZE BEHAVIOR:
         * 
         * - Threads created up to corePoolSize
         * - Created on demand (not eagerly)
         * - Stay alive indefinitely (even if idle)
         * - New tasks use existing threads if available
         * - If all busy, new tasks queue up (until queue full)
         * 
         * WHEN TO INCREASE:
         * - High task arrival rate
         * - Tasks mostly I/O-bound
         * - Want consistent thread count
         * 
         * WHEN TO DECREASE:
         * - Low task arrival rate
         * - Want to conserve resources
         * - Tasks infrequent
         */
    }
    
    /**
     * PARAMETER 2: maximumPoolSize
     * 
     * Maximum number of threads allowed in pool
     */
    public static void maximumPoolSizeDemo() {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            2,              // corePoolSize
            5,              // maximumPoolSize = 5
            60L,            // keepAliveTime
            TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(3)  // Small queue!
        );
        
        // Submit 10 tasks
        for (int i = 0; i < 10; i++) {
            final int taskId = i;
            try {
                executor.submit(() -> {
                    System.out.println("Task " + taskId + " on " + 
                        Thread.currentThread().getName());
                    try {
                        Thread.sleep(2000);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                });
            } catch (RejectedExecutionException e) {
                System.out.println("Task " + taskId + " rejected!");
            }
        }
        
        try {
            Thread.sleep(100);
            System.out.println("Pool size: " + executor.getPoolSize());
            System.out.println("Active count: " + executor.getActiveCount());
            System.out.println("Queue size: " + executor.getQueue().size());
            
            /**
             * EXECUTION FLOW:
             * 
             * Tasks 0-1: Execute immediately (up to corePoolSize)
             * Tasks 2-4: Queue (queue capacity = 3)
             * Tasks 5-7: Create new threads (up to maximumPoolSize)
             * Tasks 8-9: Rejected (pool full, queue full)
             * 
             * Pool size: 5 (maximumPoolSize reached)
             * Active count: 5
             * Queue size: 3
             */
            
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        executor.shutdown();
        
        /**
         * MAXIMUM POOL SIZE BEHAVIOR:
         * 
         * - Threads created beyond corePoolSize ONLY if:
         *   1. All core threads busy AND
         *   2. Queue is full
         * 
         * - Extra threads (> corePoolSize) are temporary
         * - They die after keepAliveTime if idle
         * 
         * IMPORTANT: With unbounded queue (LinkedBlockingQueue()),
         * maximumPoolSize is IGNORED! Queue never fills, so extra
         * threads never created.
         */
    }
    
    /**
     * PARAMETER 3: keepAliveTime
     * 
     * How long excess threads (> corePoolSize) stay idle before terminating
     */
    public static void keepAliveTimeDemo() throws InterruptedException {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            2,              // corePoolSize
            5,              // maximumPoolSize
            5L,             // keepAliveTime = 5 seconds
            TimeUnit.SECONDS,
            new SynchronousQueue<>()  // Forces thread creation
        );
        
        // Submit 5 tasks (creates 5 threads)
        for (int i = 0; i < 5; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("Task " + taskId + " starting");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                System.out.println("Task " + taskId + " done");
            });
            Thread.sleep(10);  // Stagger submissions
        }
        
        Thread.sleep(2000);
        System.out.println("After tasks: " + executor.getPoolSize() + " threads");
        // Output: After tasks: 5 threads
        
        // Wait for keepAliveTime
        Thread.sleep(6000);
        System.out.println("After keepAliveTime: " + executor.getPoolSize() + " threads");
        // Output: After keepAliveTime: 2 threads (excess threads died)
        
        executor.shutdown();
        
        /**
         * KEEP ALIVE TIME BEHAVIOR:
         * 
         * - Applies to threads > corePoolSize
         * - Thread dies if idle for keepAliveTime
         * - Core threads normally kept alive forever
         * - Can apply to core threads with allowCoreThreadTimeOut(true)
         * 
         * TYPICAL VALUES:
         * - Short-lived tasks: 30-60 seconds
         * - Long-running tasks: 5-10 minutes
         * - Want fast shutdown: 0-10 seconds
         */
    }
    
    /**
     * Core thread timeout
     */
    public static void coreThreadTimeoutDemo() throws InterruptedException {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            5,              // corePoolSize
            5,              // maximumPoolSize
            5L,             // keepAliveTime
            TimeUnit.SECONDS,
            new LinkedBlockingQueue<>()
        );
        
        // Allow core threads to timeout
        executor.allowCoreThreadTimeOut(true);
        
        // Submit task
        executor.submit(() -> {
            System.out.println("Task running");
        });
        
        Thread.sleep(1000);
        System.out.println("Pool size: " + executor.getPoolSize());
        // Output: Pool size: 1
        
        // Wait for timeout
        Thread.sleep(6000);
        System.out.println("Pool size after timeout: " + executor.getPoolSize());
        // Output: Pool size after timeout: 0 (core thread died)
        
        executor.shutdown();
        
        /**
         * USE CASE:
         * 
         * allowCoreThreadTimeOut(true) when:
         * - Tasks infrequent
         * - Want to release all resources when idle
         * - Dynamic scaling down to zero
         * 
         * Default (false) when:
         * - Tasks frequent
         * - Want consistent thread count
         * - Avoid thread creation overhead
         */
    }
}
```

### Thread Pool Lifecycle

```java
/**
 * THREAD POOL STATES AND LIFECYCLE
 */

public class ThreadPoolLifecycle {
    
    /**
     * Thread pool states
     */
    public static void poolStates() {
        /**
         * RUNNING:    Accepts new tasks, processes queued tasks
         * SHUTDOWN:   No new tasks, but processes queued tasks
         * STOP:       No new tasks, doesn't process queued tasks, interrupts running tasks
         * TIDYING:    All tasks terminated, worker count is zero
         * TERMINATED: After terminated() hook completes
         * 
         * State transitions:
         * 
         * RUNNING → SHUTDOWN:  shutdown() called
         * RUNNING → STOP:      shutdownNow() called
         * SHUTDOWN → STOP:     shutdownNow() called
         * SHUTDOWN/STOP → TIDYING: Queue empty, worker count zero
         * TIDYING → TERMINATED: terminated() hook completes
         */
    }
    
    /**
     * Graceful shutdown
     */
    public static void gracefulShutdown() throws InterruptedException {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            2, 4, 60L, TimeUnit.SECONDS,
            new LinkedBlockingQueue<>()
        );
        
        // Submit tasks
        for (int i = 0; i < 10; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("Task " + taskId + " running");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    System.out.println("Task " + taskId + " interrupted");
                    Thread.currentThread().interrupt();
                }
                System.out.println("Task " + taskId + " done");
            });
        }
        
        // Initiate shutdown (no new tasks accepted)
        executor.shutdown();
        System.out.println("Shutdown initiated");
        
        // Wait for tasks to complete (with timeout)
        boolean terminated = executor.awaitTermination(30, TimeUnit.SECONDS);
        
        if (terminated) {
            System.out.println("All tasks completed");
        } else {
            System.out.println("Timeout, forcing shutdown");
            executor.shutdownNow();
        }
        
        /**
         * GRACEFUL SHUTDOWN PATTERN:
         * 
         * 1. executor.shutdown()           // Stop accepting new tasks
         * 2. executor.awaitTermination()   // Wait for tasks to complete
         * 3. executor.shutdownNow()        // Force shutdown if timeout
         * 
         * This is the RECOMMENDED pattern for production code
         */
    }
    
    /**
     * Immediate shutdown
     */
    public static void immediateShutdown() throws InterruptedException {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            2, 4, 60L, TimeUnit.SECONDS,
            new LinkedBlockingQueue<>()
        );
        
        // Submit tasks
        for (int i = 0; i < 10; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("Task " + taskId + " running");
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    System.out.println("Task " + taskId + " interrupted");
                    return;
                }
                System.out.println("Task " + taskId + " done");
            });
        }
        
        Thread.sleep(100);
        
        // Immediate shutdown
        System.out.println("Shutting down NOW");
        java.util.List<Runnable> notExecuted = executor.shutdownNow();
        
        System.out.println("Tasks not executed: " + notExecuted.size());
        // Running tasks get interrupted
        // Queued tasks returned
        
        executor.awaitTermination(5, TimeUnit.SECONDS);
        System.out.println("Shutdown complete");
        
        /**
         * shutdownNow() BEHAVIOR:
         * 
         * 1. Stops accepting new tasks
         * 2. Interrupts running tasks (best effort)
         * 3. Returns list of tasks that were never started
         * 
         * USE CASE:
         * - Emergency shutdown
         * - User cancellation
         * - Application exit
         */
    }
    
    /**
     * Try-with-resources pattern (Java 19+)
     */
    public static void tryWithResourcesPattern() {
        // Auto-closing executor (Java 19+)
        try (ExecutorService executor = Executors.newFixedThreadPool(4)) {
            for (int i = 0; i < 10; i++) {
                final int taskId = i;
                executor.submit(() -> {
                    System.out.println("Task " + taskId);
                });
            }
        }  // Auto-shutdown when exiting try block
        
        /**
         * ExecutorService implements AutoCloseable in Java 19+
         * 
         * close() behavior:
         * 1. shutdown()
         * 2. awaitTermination(1 day)
         * 3. shutdownNow() if not terminated
         * 
         * This is the MODERN way to use executors
         */
    }
}
```

---

## 2. ExecutorService Types

### Fixed Thread Pool

```java
/**
 * FIXED THREAD POOL
 * 
 * Fixed number of threads
 * Unbounded queue
 */

public class FixedThreadPoolDemo {
    
    /**
     * Basic usage
     */
    public static void basicUsage() {
        ExecutorService executor = Executors.newFixedThreadPool(4);
        
        // Equivalent to:
        // new ThreadPoolExecutor(4, 4, 0L, TimeUnit.MILLISECONDS,
        //                        new LinkedBlockingQueue<Runnable>());
        
        for (int i = 0; i < 10; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("Task " + taskId + " on " + 
                    Thread.currentThread().getName());
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }
        
        executor.shutdown();
        
        /**
         * CHARACTERISTICS:
         * 
         * - Fixed number of threads (nThreads)
         * - corePoolSize = maximumPoolSize = nThreads
         * - keepAliveTime = 0 (not applicable)
         * - Queue: LinkedBlockingQueue (unbounded)
         * 
         * BEHAVIOR:
         * 
         * - Creates nThreads threads on demand
         * - All threads stay alive (never timeout)
         * - Tasks queue if all threads busy
         * - Queue can grow indefinitely
         * 
         * BEST FOR:
         * 
         * ✓ Known, consistent workload
         * ✓ CPU-bound tasks (nThreads ≈ CPU cores)
         * ✓ Predictable resource usage
         * 
         * WATCH OUT:
         * 
         * ✗ Unbounded queue can cause OutOfMemoryError
         * ✗ Tasks can queue forever if threads are slow
         */
    }
    
    /**
     * CPU-bound tasks
     */
    public static void cpuBoundTasks() {
        int cores = Runtime.getRuntime().availableProcessors();
        ExecutorService executor = Executors.newFixedThreadPool(cores);
        
        System.out.println("Using " + cores + " threads for CPU-bound work");
        
        for (int i = 0; i < 20; i++) {
            final int taskId = i;
            executor.submit(() -> {
                // CPU-intensive work
                long result = 0;
                for (long j = 0; j < 1_000_000_000L; j++) {
                    result += j;
                }
                System.out.println("Task " + taskId + " result: " + result);
            });
        }
        
        executor.shutdown();
        
        /**
         * SIZING FOR CPU-BOUND:
         * 
         * Optimal: nThreads = nCPUs
         * 
         * Reason: More threads = more context switching, no benefit
         * 
         * If mixed workload: nThreads = nCPUs + 1 or 2
         * (extra threads compensate for occasional blocking)
         */
    }
    
    /**
     * I/O-bound tasks
     */
    public static void ioBoundTasks() {
        // I/O-bound: More threads than CPU cores
        ExecutorService executor = Executors.newFixedThreadPool(50);
        
        for (int i = 0; i < 100; i++) {
            final int taskId = i;
            executor.submit(() -> {
                try {
                    // Simulate I/O (database, network, file)
                    Thread.sleep(100);
                    System.out.println("Task " + taskId + " completed I/O");
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }
        
        executor.shutdown();
        
        /**
         * SIZING FOR I/O-BOUND:
         * 
         * Formula: nThreads = nCPUs × (1 + waitTime / computeTime)
         * 
         * Example:
         * - 8 CPUs
         * - 90% I/O wait, 10% compute
         * - waitTime/computeTime = 9
         * - nThreads = 8 × (1 + 9) = 80 threads
         * 
         * In practice: Start with 2-4x CPU cores, tune based on monitoring
         */
    }
}
```

### Cached Thread Pool

```java
/**
 * CACHED THREAD POOL
 * 
 * Unlimited threads (as needed)
 * No queue (SynchronousQueue)
 */

public class CachedThreadPoolDemo {
    
    /**
     * Basic usage
     */
    public static void basicUsage() {
        ExecutorService executor = Executors.newCachedThreadPool();
        
        // Equivalent to:
        // new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,
        //                        new SynchronousQueue<Runnable>());
        
        for (int i = 0; i < 100; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("Task " + taskId + " on " + 
                    Thread.currentThread().getName());
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }
        
        executor.shutdown();
        
        /**
         * CHARACTERISTICS:
         * 
         * - corePoolSize = 0 (no core threads)
         * - maximumPoolSize = Integer.MAX_VALUE (unlimited)
         * - keepAliveTime = 60 seconds
         * - Queue: SynchronousQueue (no capacity)
         * 
         * BEHAVIOR:
         * 
         * - Creates new thread for each task if all busy
         * - Reuses idle threads if available
         * - Threads die after 60 seconds idle
         * - Can create thousands of threads!
         * 
         * BEST FOR:
         * 
         * ✓ Many short-lived asynchronous tasks
         * ✓ Unpredictable task arrival rate
         * ✓ Tasks complete quickly
         * 
         * DANGEROUS FOR:
         * 
         * ✗ Long-running tasks (thread explosion)
         * ✗ High task arrival rate (resource exhaustion)
         * ✗ Production systems (unbounded threads)
         */
    }
    
    /**
     * Thread reuse demonstration
     */
    public static void threadReuseDemo() throws InterruptedException {
        ExecutorService executor = Executors.newCachedThreadPool();
        
        // Submit 5 quick tasks
        for (int i = 0; i < 5; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("Task " + taskId + " on " + 
                    Thread.currentThread().getName());
            });
        }
        
        Thread.sleep(100);
        
        // Submit 5 more tasks (reuses threads)
        for (int i = 5; i < 10; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("Task " + taskId + " on " + 
                    Thread.currentThread().getName());
            });
        }
        
        executor.shutdown();
        
        /**
         * OUTPUT (typical):
         * Task 0 on pool-1-thread-1
         * Task 1 on pool-1-thread-2
         * Task 2 on pool-1-thread-3
         * Task 3 on pool-1-thread-4
         * Task 4 on pool-1-thread-5
         * Task 5 on pool-1-thread-1  (reused!)
         * Task 6 on pool-1-thread-2  (reused!)
         * ...
         * 
         * Threads reused when available
         */
    }
    
    /**
     * Danger: Thread explosion
     */
    public static void threadExplosionDanger() {
        ExecutorService executor = Executors.newCachedThreadPool();
        
        // Submit 10,000 long-running tasks
        for (int i = 0; i < 10_000; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("Task " + taskId + " starting");
                try {
                    Thread.sleep(60_000);  // 1 minute!
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }
        
        // Now we have 10,000 threads!
        // Each thread: ~1MB stack = 10GB memory
        // Plus thread overhead, context switching
        // → System becomes unusable or crashes
        
        executor.shutdownNow();
        
        /**
         * LESSON: Never use CachedThreadPool for long-running tasks!
         * 
         * Use FixedThreadPool instead:
         * ExecutorService safe = Executors.newFixedThreadPool(100);
         */
    }
}
```

### Single Thread Executor

```java
/**
 * SINGLE THREAD EXECUTOR
 * 
 * One thread
 * Unbounded queue
 */

public class SingleThreadExecutorDemo {
    
    /**
     * Basic usage
     */
    public static void basicUsage() {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        
        // Equivalent to:
        // new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS,
        //                        new LinkedBlockingQueue<Runnable>());
        
        for (int i = 0; i < 10; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("Task " + taskId + " on " + 
                    Thread.currentThread().getName());
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }
        
        executor.shutdown();
        
        /**
         * OUTPUT:
         * Task 0 on pool-1-thread-1
         * Task 1 on pool-1-thread-1
         * Task 2 on pool-1-thread-1
         * ...
         * 
         * All tasks execute sequentially on same thread
         */
        
        /**
         * CHARACTERISTICS:
         * 
         * - Exactly one thread
         * - Tasks execute sequentially (FIFO)
         * - Queue: LinkedBlockingQueue (unbounded)
         * 
         * BEST FOR:
         * 
         * ✓ Tasks must execute in order
         * ✓ Need guaranteed sequential execution
         * ✓ Background processing thread
         * ✓ Event loop pattern
         * 
         * USE CASES:
         * 
         * - Logging
         * - Database writes (when order matters)
         * - Event processing
         * - State machine
         */
    }
    
    /**
     * Ordering guarantee
     */
    public static void orderingGuarantee() throws InterruptedException {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        
        java.util.concurrent.atomic.AtomicInteger counter = 
            new java.util.concurrent.atomic.AtomicInteger(0);
        
        for (int i = 0; i < 100; i++) {
            executor.submit(() -> {
                int value = counter.incrementAndGet();
                System.out.println(value);
            });
        }
        
        executor.shutdown();
        executor.awaitTermination(10, TimeUnit.SECONDS);
        
        /**
         * OUTPUT: Always 1, 2, 3, 4, ..., 100
         * 
         * Sequential execution guarantees ordering
         * No race conditions (single thread)
         */
    }
    
    /**
     * Failure recovery
     */
    public static void failureRecovery() {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        
        for (int i = 0; i < 5; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("Task " + taskId + " starting");
                
                if (taskId == 2) {
                    throw new RuntimeException("Task 2 failed!");
                }
                
                System.out.println("Task " + taskId + " done");
            });
        }
        
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        executor.shutdown();
        
        /**
         * OUTPUT:
         * Task 0 starting
         * Task 0 done
         * Task 1 starting
         * Task 1 done
         * Task 2 starting
         * (Exception logged)
         * Task 3 starting  (execution continues!)
         * Task 3 done
         * Task 4 starting
         * Task 4 done
         * 
         * Single thread replaced after uncaught exception
         * Executor continues with new thread
         */
    }
}
```

### Scheduled Thread Pool

```java
/**
 * SCHEDULED THREAD POOL
 * 
 * Execute tasks with delays or periodically
 */

public class ScheduledThreadPoolDemo {
    
    /**
     * Basic scheduling
     */
    public static void basicScheduling() throws InterruptedException {
        ScheduledExecutorService executor = 
            Executors.newScheduledThreadPool(2);
        
        // Schedule task with delay
        executor.schedule(() -> {
            System.out.println("Task executed after 2 seconds");
        }, 2, TimeUnit.SECONDS);
        
        Thread.sleep(3000);
        executor.shutdown();
        
        /**
         * schedule(Runnable, delay, unit)
         * 
         * - Executes task once after delay
         * - Returns ScheduledFuture
         * - Can be cancelled
         */
    }
    
    /**
     * Fixed rate scheduling
     */
    public static void fixedRateScheduling() throws InterruptedException {
        ScheduledExecutorService executor = 
            Executors.newScheduledThreadPool(1);
        
        executor.scheduleAtFixedRate(() -> {
            System.out.println("[Fixed Rate] Task at " + 
                System.currentTimeMillis());
            try {
                Thread.sleep(1500);  // Task takes 1.5 seconds
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }, 0, 1, TimeUnit.SECONDS);  // Every 1 second
        
        Thread.sleep(10_000);
        executor.shutdownNow();
        
        /**
         * scheduleAtFixedRate(Runnable, initialDelay, period, unit)
         * 
         * BEHAVIOR:
         * - First execution after initialDelay
         * - Subsequent executions every period
         * - If task takes longer than period, next task waits
         * - No overlap (tasks don't execute concurrently)
         * 
         * TIMING:
         * T=0:    Task starts
         * T=1s:   Task still running (started at 0s, takes 1.5s)
         * T=1.5s: Task ends, next task starts immediately
         * T=3s:   Task ends, next task starts immediately
         * T=4.5s: Task ends, wait until T=5s
         * T=5s:   Task starts (on schedule)
         * 
         * Fixed rate = consistent frequency (if tasks complete quickly)
         */
    }
    
    /**
     * Fixed delay scheduling
     */
    public static void fixedDelayScheduling() throws InterruptedException {
        ScheduledExecutorService executor = 
            Executors.newScheduledThreadPool(1);
        
        executor.scheduleWithFixedDelay(() -> {
            System.out.println("[Fixed Delay] Task at " + 
                System.currentTimeMillis());
            try {
                Thread.sleep(1500);  // Task takes 1.5 seconds
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }, 0, 1, TimeUnit.SECONDS);  // 1 second delay after completion
        
        Thread.sleep(10_000);
        executor.shutdownNow();
        
        /**
         * scheduleWithFixedDelay(Runnable, initialDelay, delay, unit)
         * 
         * BEHAVIOR:
         * - First execution after initialDelay
         * - Wait delay after task completes, then execute again
         * - Consistent gap between task completions
         * 
         * TIMING:
         * T=0:    Task starts
         * T=1.5s: Task ends, wait 1s
         * T=2.5s: Task starts
         * T=4s:   Task ends, wait 1s
         * T=5s:   Task starts
         * T=6.5s: Task ends, wait 1s
         * T=7.5s: Task starts
         * 
         * Fixed delay = consistent gap between executions
         */
    }
    
    /**
     * Comparison: Fixed Rate vs Fixed Delay
     */
    public static void compareScheduling() {
        /**
         * ┌──────────────────────┬────────────────────────┬────────────────────────┐
         * │                      │   scheduleAtFixedRate  │ scheduleWithFixedDelay │
         * ├──────────────────────┼────────────────────────┼────────────────────────┤
         * │ Delay measured from  │ Previous start time    │ Previous end time      │
         * │ If task is slow      │ Tasks bunch up         │ Gap stays consistent   │
         * │ Long-term drift      │ Tries to maintain rate │ Drifts over time       │
         * │ Best for             │ Fixed rate polling     │ Rate limiting          │
         * │ Example              │ Metrics collection     │ Retry mechanism        │
         * └──────────────────────┴────────────────────────┴────────────────────────┘
         * 
         * RULE OF THUMB:
         * 
         * Use scheduleAtFixedRate when:
         * - Want consistent frequency (e.g., every minute)
         * - Tasks usually complete quickly
         * - Example: Heartbeat, metrics
         * 
         * Use scheduleWithFixedDelay when:
         * - Want consistent gap between executions
         * - Task duration varies
         * - Example: Polling with backoff, batch processing
         */
    }
    
    /**
     * Cron-like scheduling
     */
    public static void cronLikeScheduling() {
        ScheduledExecutorService executor = 
            Executors.newScheduledThreadPool(1);
        
        // Calculate delay until next midnight
        java.time.LocalDateTime now = java.time.LocalDateTime.now();
        java.time.LocalDateTime nextMidnight = 
            now.toLocalDate().plusDays(1).atStartOfDay();
        long initialDelay = java.time.Duration.between(now, nextMidnight).getSeconds();
        
        // Schedule daily task at midnight
        executor.scheduleAtFixedRate(() -> {
            System.out.println("Daily task at " + java.time.LocalDateTime.now());
            // Daily maintenance, reports, etc.
        }, initialDelay, 24 * 60 * 60, TimeUnit.SECONDS);
        
        /**
         * For complex cron expressions, use:
         * - Spring @Scheduled
         * - Quartz Scheduler
         * - Custom solution with ScheduledExecutorService
         */
    }
}
```

---

## 3. BlockingQueue Implementations

### Queue Comparison

```java
/**
 * BLOCKING QUEUE IMPLEMENTATIONS
 */

public class BlockingQueueComparison {
    
    /**
     * Queue characteristics
     */
    public static void queueComparison() {
        /**
         * ┌────────────────────────┬──────────────┬──────────────┬─────────────┐
         * │ Queue Type             │ Bounded      │ Fairness     │ Performance │
         * ├────────────────────────┼──────────────┼──────────────┼─────────────┤
         * │ LinkedBlockingQueue    │ Optional     │ FIFO         │ Medium      │
         * │ ArrayBlockingQueue     │ Required     │ Optional     │ High        │
         * │ SynchronousQueue       │ N/A (0)      │ Optional     │ Highest     │
         * │ PriorityBlockingQueue  │ Unbounded    │ Priority     │ Low         │
         * │ DelayQueue             │ Unbounded    │ Delay-based  │ Low         │
         * └────────────────────────┴──────────────┴──────────────┴─────────────┘
         */
    }
}
```

### LinkedBlockingQueue

```java
/**
 * LINKED BLOCKING QUEUE
 * 
 * Optionally bounded FIFO queue
 * Linked nodes (like LinkedList)
 */

public class LinkedBlockingQueueDemo {
    
    /**
     * Unbounded queue (default)
     */
    public static void unboundedQueue() {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            2, 4, 60L, TimeUnit.SECONDS,
            new LinkedBlockingQueue<>()  // Unbounded!
        );
        
        // Submit 1000 tasks
        for (int i = 0; i < 1000; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("Task " + taskId);
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }
        
        // All 1000 tasks queued successfully
        // Pool size stays at 2 (corePoolSize)
        // Extra threads (up to maximumPoolSize) never created!
        
        executor.shutdown();
        
        /**
         * CHARACTERISTICS:
         * 
         * - Capacity: Integer.MAX_VALUE (unbounded)
         * - Separate locks for put/take (better concurrency)
         * - Lazy initialization of nodes
         * 
         * PROS:
         * 
         * ✓ Simple to use
         * ✓ Good concurrent performance
         * ✓ No task rejection (assuming memory available)
         * 
         * CONS:
         * 
         * ✗ Can grow indefinitely (OutOfMemoryError)
         * ✗ maximumPoolSize ignored (queue never fills)
         * ✗ High memory usage for many tasks
         * 
         * BEST FOR:
         * 
         * - FixedThreadPool (default choice)
         * - Known max workload
         * - Sufficient memory
         */
    }
    
    /**
     * Bounded queue
     */
    public static void boundedQueue() {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            2, 4, 60L, TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(10)  // Capacity = 10
        );
        
        // Submit 20 tasks
        for (int i = 0; i < 20; i++) {
            final int taskId = i;
            try {
                executor.submit(() -> {
                    System.out.println("Task " + taskId + " on " + 
                        Thread.currentThread().getName());
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                });
            } catch (RejectedExecutionException e) {
                System.out.println("Task " + taskId + " rejected");
            }
        }
        
        try {
            Thread.sleep(100);
            System.out.println("Pool size: " + executor.getPoolSize());
            System.out.println("Queue size: " + executor.getQueue().size());
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        executor.shutdown();
        
        /**
         * EXECUTION:
         * 
         * Tasks 0-1:  Execute (corePoolSize = 2)
         * Tasks 2-11: Queue (capacity = 10)
         * Tasks 12-13: Create threads (up to maximumPoolSize = 4)
         * Tasks 14-19: Rejected (pool full, queue full)
         * 
         * Pool size: 4
         * Queue size: 10
         */
    }
}
```

### ArrayBlockingQueue

```java
/**
 * ARRAY BLOCKING QUEUE
 * 
 * Bounded FIFO queue
 * Fixed-size array
 */

public class ArrayBlockingQueueDemo {
    
    /**
     * Basic usage
     */
    public static void basicUsage() {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            2, 4, 60L, TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(10)  // Must specify capacity
        );
        
        // Submit tasks
        for (int i = 0; i < 15; i++) {
            final int taskId = i;
            try {
                executor.submit(() -> {
                    System.out.println("Task " + taskId);
                });
            } catch (RejectedExecutionException e) {
                System.out.println("Task " + taskId + " rejected");
            }
        }
        
        executor.shutdown();
        
        /**
         * CHARACTERISTICS:
         * 
         * - Capacity: Fixed at construction
         * - Single lock for put/take (lower concurrency)
         * - Array pre-allocated
         * - Optional fairness
         * 
         * PROS:
         * 
         * ✓ Fixed memory footprint
         * ✓ Better cache locality (array vs linked nodes)
         * ✓ Predictable performance
         * 
         * CONS:
         * 
         * ✗ Lower concurrent throughput (single lock)
         * ✗ Must specify capacity upfront
         * ✗ Cannot grow
         */
    }
    
    /**
     * Fairness option
     */
    public static void fairnessOption() {
        // Fair queue (FIFO for waiting threads)
        ThreadPoolExecutor fairExecutor = new ThreadPoolExecutor(
            1, 1, 60L, TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(10, true)  // Fair = true
        );
        
        // Unfair queue (no ordering guarantee for waiting threads)
        ThreadPoolExecutor unfairExecutor = new ThreadPoolExecutor(
            1, 1, 60L, TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(10, false)  // Fair = false (default)
        );
        
        /**
         * FAIRNESS:
         * 
         * Fair (true):
         * - Threads access queue in FIFO order
         * - Prevents thread starvation
         * - Lower throughput (~50% slower)
         * 
         * Unfair (false):
         * - Threads compete for queue access
         * - Higher throughput
         * - Possible starvation
         * 
         * WHEN TO USE FAIR:
         * - Need strict ordering
         * - Prevent starvation
         * - Latency-sensitive
         * 
         * WHEN TO USE UNFAIR:
         * - Maximize throughput
         * - CPU-bound workload
         * - Default choice
         */
        
        fairExecutor.shutdown();
        unfairExecutor.shutdown();
    }
}
```

### SynchronousQueue

```java
/**
 * SYNCHRONOUS QUEUE
 * 
 * Zero capacity queue
 * Direct handoff
 */

public class SynchronousQueueDemo {
    
    /**
     * Basic usage
     */
    public static void basicUsage() {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            0, 10, 60L, TimeUnit.SECONDS,
            new SynchronousQueue<>()  // Zero capacity!
        );
        
        // Submit tasks
        for (int i = 0; i < 15; i++) {
            final int taskId = i;
            try {
                executor.submit(() -> {
                    System.out.println("Task " + taskId + " on " + 
                        Thread.currentThread().getName());
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                });
            } catch (RejectedExecutionException e) {
                System.out.println("Task " + taskId + " rejected");
            }
            
            try {
                Thread.sleep(10);  // Small delay between submissions
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        
        try {
            Thread.sleep(100);
            System.out.println("Pool size: " + executor.getPoolSize());
            System.out.println("Queue size: " + executor.getQueue().size());
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        executor.shutdown();
        
        /**
         * OUTPUT:
         * Pool size: 10 (maximumPoolSize)
         * Queue size: 0 (always zero!)
         * 
         * BEHAVIOR:
         * 
         * - No internal capacity
         * - Task handed off directly to thread
         * - If no available thread, create new (up to max)
         * - If max reached, reject
         * 
         * CHARACTERISTICS:
         * 
         * - Capacity: 0
         * - No queueing
         * - Immediate execution or rejection
         * - Used by CachedThreadPool
         * 
         * BEST FOR:
         * 
         * ✓ Want immediate execution
         * ✓ Dynamic thread creation
         * ✓ Short-lived tasks
         * ✓ CachedThreadPool pattern
         * 
         * AVOID FOR:
         * 
         * ✗ Want task queueing
         * ✗ Long-running tasks
         * ✗ High task arrival rate
         */
    }
    
    /**
     * Comparison with other queues
     */
    public static void comparisonDemo() throws InterruptedException {
        // Test 1: LinkedBlockingQueue (queues tasks)
        ThreadPoolExecutor linkedExecutor = new ThreadPoolExecutor(
            2, 2, 60L, TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(5)
        );
        
        for (int i = 0; i < 10; i++) {
            linkedExecutor.submit(() -> {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }
        
        Thread.sleep(100);
        System.out.println("LinkedBlockingQueue:");
        System.out.println("  Pool: " + linkedExecutor.getPoolSize());  // 2
        System.out.println("  Queue: " + linkedExecutor.getQueue().size());  // 5
        System.out.println("  (3 tasks rejected)");
        
        linkedExecutor.shutdownNow();
        
        // Test 2: SynchronousQueue (no queueing)
        ThreadPoolExecutor syncExecutor = new ThreadPoolExecutor(
            0, 10, 60L, TimeUnit.SECONDS,
            new SynchronousQueue<>()
        );
        
        for (int i = 0; i < 10; i++) {
            syncExecutor.submit(() -> {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }
        
        Thread.sleep(100);
        System.out.println("\nSynchronousQueue:");
        System.out.println("  Pool: " + syncExecutor.getPoolSize());  // 10
        System.out.println("  Queue: " + syncExecutor.getQueue().size());  // 0
        System.out.println("  (All tasks executing immediately)");
        
        syncExecutor.shutdownNow();
    }
}
```

---

## 4. RejectedExecutionHandler Strategies

### Handler Types

```java
/**
 * REJECTION POLICIES
 * 
 * What to do when pool and queue are full
 */

public class RejectionPolicies {
    
    /**
     * 1. AbortPolicy (default)
     */
    public static void abortPolicy() {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            1, 1, 60L, TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(2),
            new ThreadPoolExecutor.AbortPolicy()  // Default
        );
        
        // Submit 5 tasks (1 executing + 2 queued + 2 rejected)
        for (int i = 0; i < 5; i++) {
            final int taskId = i;
            try {
                executor.submit(() -> {
                    System.out.println("Task " + taskId + " running");
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                });
            } catch (RejectedExecutionException e) {
                System.out.println("Task " + taskId + " rejected: " + 
                    e.getMessage());
            }
        }
        
        executor.shutdown();
        
        /**
         * OUTPUT:
         * Task 0 running
         * Task 3 rejected: Task ... rejected from ...
         * Task 4 rejected: Task ... rejected from ...
         * Task 1 running
         * Task 2 running
         * 
         * BEHAVIOR:
         * - Throws RejectedExecutionException
         * - Caller must handle exception
         * 
         * BEST FOR:
         * - Want to know about rejections
         * - Can handle exceptions
         * - Critical tasks (shouldn't be rejected)
         */
    }
    
    /**
     * 2. CallerRunsPolicy
     */
    public static void callerRunsPolicy() {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            1, 1, 60L, TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(2),
            new ThreadPoolExecutor.CallerRunsPolicy()
        );
        
        // Submit 5 tasks
        for (int i = 0; i < 5; i++) {
            final int taskId = i;
            System.out.println("Submitting task " + taskId + " from " + 
                Thread.currentThread().getName());
            
            executor.submit(() -> {
                System.out.println("Task " + taskId + " running on " + 
                    Thread.currentThread().getName());
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }
        
        executor.shutdown();
        
        /**
         * OUTPUT:
         * Submitting task 0 from main
         * Task 0 running on pool-1-thread-1
         * Submitting task 1 from main
         * Submitting task 2 from main
         * Submitting task 3 from main
         * Task 3 running on main  (rejected, ran by caller!)
         * Submitting task 4 from main
         * Task 4 running on main  (rejected, ran by caller!)
         * Task 1 running on pool-1-thread-1
         * Task 2 running on pool-1-thread-1
         * 
         * BEHAVIOR:
         * - Rejected task runs in caller thread
         * - Provides throttling (caller blocked)
         * - No exception thrown
         * 
         * BEST FOR:
         * - Want graceful degradation
         * - Throttle fast producers
         * - Tasks can run anywhere
         * 
         * WATCH OUT:
         * - Caller thread blocked (might be main, web request, etc.)
         * - Can cause cascading slowdowns
         */
    }
    
    /**
     * 3. DiscardPolicy
     */
    public static void discardPolicy() {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            1, 1, 60L, TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(2),
            new ThreadPoolExecutor.DiscardPolicy()
        );
        
        // Submit 5 tasks
        for (int i = 0; i < 5; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("Task " + taskId + " running");
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }
        
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        executor.shutdown();
        
        /**
         * OUTPUT:
         * Task 0 running
         * Task 1 running
         * Task 2 running
         * 
         * Tasks 3 and 4 silently discarded!
         * 
         * BEHAVIOR:
         * - Rejected task silently discarded
         * - No exception
         * - No logging
         * 
         * BEST FOR:
         * - Best-effort processing
         * - Lossy workload (e.g., metrics, logs)
         * - Don't care about all tasks
         * 
         * DANGEROUS:
         * - Silent failures
         * - Hard to debug
         * - Use only when loss acceptable
         */
    }
    
    /**
     * 4. DiscardOldestPolicy
     */
    public static void discardOldestPolicy() {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            1, 1, 60L, TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(2),
            new ThreadPoolExecutor.DiscardOldestPolicy()
        );
        
        // Submit 5 tasks
        for (int i = 0; i < 5; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("Task " + taskId + " running");
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }
        
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        executor.shutdown();
        
        /**
         * OUTPUT (typical):
         * Task 0 running
         * Task 2 running  (Task 1 discarded!)
         * Task 4 running  (Task 3 discarded!)
         * 
         * BEHAVIOR:
         * - Removes oldest task from queue
         * - Adds new task to queue
         * - No exception
         * 
         * BEST FOR:
         * - Want latest data
         * - Priority to new tasks
         * - Real-time systems (stale data useless)
         * 
         * USE CASES:
         * - Live price feeds
         * - Sensor data
         * - UI updates
         */
    }
    
    /**
     * 5. Custom Policy
     */
    public static void customPolicy() {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            1, 1, 60L, TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(2),
            new RejectedExecutionHandler() {
                @Override
                public void rejectedExecution(Runnable r, 
                                              ThreadPoolExecutor executor) {
                    // Log rejection
                    System.err.println("Task rejected: " + r);
                    
                    // Could also:
                    // - Save to database
                    // - Send to backup queue
                    // - Trigger alert
                    // - Retry with backoff
                    // - Execute synchronously (like CallerRunsPolicy)
                }
            }
        );
        
        // Submit tasks
        for (int i = 0; i < 5; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("Task " + taskId);
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }
        
        executor.shutdown();
        
        /**
         * CUSTOM POLICY EXAMPLES:
         * 
         * 1. Log and discard:
         *    logger.error("Task rejected");
         * 
         * 2. Retry with backoff:
         *    retryQueue.add(task);
         *    scheduleRetry(task, delay);
         * 
         * 3. Block until space:
         *    executor.getQueue().put(r);  // Blocks
         * 
         * 4. Send to backup queue:
         *    backupQueue.offer(r);
         * 
         * 5. Metrics:
         *    rejectionCounter.increment();
         */
    }
}
```

---

## 5. ForkJoinPool and Work-Stealing

### ForkJoinPool Basics

```java
/**
 * FORKJOINPOOL
 * 
 * Specialized thread pool for divide-and-conquer algorithms
 * Work-stealing: Idle threads steal tasks from busy threads
 */

import java.util.concurrent.RecursiveTask;
import java.util.concurrent.RecursiveAction;
import java.util.concurrent.ForkJoinPool;

public class ForkJoinPoolDemo {
    
    /**
     * RecursiveTask (returns result)
     */
    static class SumTask extends RecursiveTask<Long> {
        private static final int THRESHOLD = 10_000;
        private final long[] array;
        private final int start;
        private final int end;
        
        public SumTask(long[] array, int start, int end) {
            this.array = array;
            this.start = start;
            this.end = end;
        }
        
        @Override
        protected Long compute() {
            int length = end - start;
            
            if (length <= THRESHOLD) {
                // Base case: compute directly
                long sum = 0;
                for (int i = start; i < end; i++) {
                    sum += array[i];
                }
                return sum;
            } else {
                // Recursive case: split into subtasks
                int mid = start + length / 2;
                
                SumTask leftTask = new SumTask(array, start, mid);
                SumTask rightTask = new SumTask(array, mid, end);
                
                // Fork left task (run asynchronously)
                leftTask.fork();
                
                // Compute right task (current thread)
                long rightResult = rightTask.compute();
                
                // Join left task (wait for result)
                long leftResult = leftTask.join();
                
                return leftResult + rightResult;
            }
        }
    }
    
    public static void recursiveTaskDemo() {
        // Create array
        long[] array = new long[100_000_000];
        for (int i = 0; i < array.length; i++) {
            array[i] = i + 1;
        }
        
        // Create ForkJoinPool
        ForkJoinPool pool = new ForkJoinPool();
        
        // Execute task
        long start = System.currentTimeMillis();
        SumTask task = new SumTask(array, 0, array.length);
        long result = pool.invoke(task);
        long elapsed = System.currentTimeMillis() - start;
        
        System.out.println("Sum: " + result);
        System.out.println("Time: " + elapsed + "ms");
        System.out.println("Parallelism: " + pool.getParallelism());
        
        pool.shutdown();
        
        /**
         * TYPICAL OUTPUT:
         * Sum: 5000000050000000
         * Time: 250ms
         * Parallelism: 8  (CPU cores)
         * 
         * Compare to sequential: ~1000ms
         * Speedup: 4x on 8-core machine
         */
    }
    
    /**
     * RecursiveAction (no result)
     */
    static class PrintTask extends RecursiveAction {
        private static final int THRESHOLD = 10;
        private final int start;
        private final int end;
        
        public PrintTask(int start, int end) {
            this.start = start;
            this.end = end;
        }
        
        @Override
        protected void compute() {
            int length = end - start;
            
            if (length <= THRESHOLD) {
                // Base case
                for (int i = start; i < end; i++) {
                    System.out.println(Thread.currentThread().getName() + 
                        ": " + i);
                }
            } else {
                // Recursive case
                int mid = start + length / 2;
                
                PrintTask leftTask = new PrintTask(start, mid);
                PrintTask rightTask = new PrintTask(mid, end);
                
                // Fork both tasks
                invokeAll(leftTask, rightTask);
            }
        }
    }
    
    public static void recursiveActionDemo() {
        ForkJoinPool pool = new ForkJoinPool();
        
        PrintTask task = new PrintTask(0, 50);
        pool.invoke(task);
        
        pool.shutdown();
        
        /**
         * RecursiveTask vs RecursiveAction:
         * 
         * RecursiveTask<V>:
         * - Returns result (type V)
         * - Use for computations (sum, max, search)
         * 
         * RecursiveAction:
         * - No return value (void)
         * - Use for side effects (print, write file)
         */
    }
}
```

### Work-Stealing Algorithm

```java
/**
 * WORK-STEALING EXPLAINED
 */

public class WorkStealingExplained {
    
    /**
     * How work-stealing works
     */
    public static void workStealingConcept() {
        /**
         * TRADITIONAL THREAD POOL:
         * 
         * - Single shared queue
         * - All threads compete for tasks
         * - Lock contention
         * 
         * ┌────────────────────────────────────────┐
         * │         Shared Task Queue              │
         * │  [T1] [T2] [T3] [T4] [T5] [T6] [T7]    │
         * └───────────┬────────────────────────────┘
         *             │
         *       ┌─────┴──────┬──────┬──────┐
         *       │            │      │      │
         *    Thread1     Thread2  Thread3  Thread4
         * 
         * Problem: Lock contention on shared queue
         * 
         * 
         * WORK-STEALING POOL:
         * 
         * - Each thread has its own deque (double-ended queue)
         * - Thread takes tasks from HEAD of own deque (LIFO)
         * - Idle thread steals from TAIL of other deques (FIFO)
         * - Minimal contention
         * 
         * Thread1 Deque:  [T1] [T2] [T3] ← head
         *                  ↓ steal
         * Thread2 Deque:  [T4] [T5] ← head
         * 
         * Thread3 Deque:  [] ← head (idle, steals from Thread1)
         * 
         * Thread4 Deque:  [T6] [T7] ← head
         * 
         * Benefits:
         * - Less contention (own queue vs shared)
         * - Better cache locality (related tasks)
         * - Load balancing (stealing from busy threads)
         */
    }
    
    /**
     * Fork/Join pattern
     */
    public static void forkJoinPattern() {
        /**
         * FORK/JOIN PATTERN:
         * 
         * 1. Fork: Split task into subtasks
         * 2. Process: Work on subtasks recursively
         * 3. Join: Combine results
         * 
         * Visual representation:
         * 
         *              Main Task
         *               /    \
         *           Fork      Fork
         *           /            \
         *      Subtask1       Subtask2
         *       /    \         /    \
         *      S1.1  S1.2    S2.1  S2.2
         *       |     |       |     |
         *    compute compute compute compute
         *       |     |       |     |
         *      Join  Join    Join  Join
         *        \    /         \    /
         *         Join           Join
         *           \            /
         *            \          /
         *             Final Result
         * 
         * IMPORTANT PATTERN:
         * 
         * SomeTask task = new SomeTask(...);
         * task.fork();              // Run asynchronously
         * OtherTask task2 = new OtherTask(...);
         * result2 = task2.compute(); // Run in current thread
         * result1 = task.join();     // Wait for forked task
         * return result1 + result2;
         * 
         * WHY THIS PATTERN?
         * - One subtask forked (async)
         * - One subtask computed directly (no thread creation)
         * - Efficient: No wasted thread for current task
         */
    }
    
    /**
     * Common pool
     */
    public static void commonPoolUsage() {
        // Get common ForkJoinPool
        ForkJoinPool commonPool = ForkJoinPool.commonPool();
        
        System.out.println("Parallelism: " + commonPool.getParallelism());
        System.out.println("Pool size: " + commonPool.getPoolSize());
        
        // Use common pool
        long sum = commonPool.invoke(new ForkJoinPoolDemo.SumTask(
            new long[100], 0, 100));
        
        /**
         * COMMON POOL:
         * 
         * - Shared ForkJoinPool for entire JVM
         * - Parallelism = CPU cores - 1
         * - Used by parallel streams
         * - Used by CompletableFuture (default)
         * 
         * PROS:
         * ✓ Shared resource (efficient)
         * ✓ Automatic sizing
         * ✓ Convenient
         * 
         * CONS:
         * ✗ Shared by all code (contention)
         * ✗ Can't configure
         * ✗ Long tasks block parallel streams
         * 
         * WHEN TO USE CUSTOM POOL:
         * - Long-running tasks
         * - Blocking I/O
         * - Need different parallelism
         * - Want isolation
         */
    }
}
```

---

## 6. Custom Thread Factories

### ThreadFactory Basics

```java
/**
 * CUSTOM THREAD FACTORIES
 * 
 * Control thread creation (names, priorities, daemon status, etc.)
 */

public class CustomThreadFactories {
    
    /**
     * Basic custom thread factory
     */
    public static void basicThreadFactory() {
        ThreadFactory factory = new ThreadFactory() {
            private final java.util.concurrent.atomic.AtomicInteger threadNumber = 
                new java.util.concurrent.atomic.AtomicInteger(1);
            
            @Override
            public Thread newThread(Runnable r) {
                Thread t = new Thread(r);
                t.setName("MyPool-" + threadNumber.getAndIncrement());
                t.setDaemon(false);
                t.setPriority(Thread.NORM_PRIORITY);
                return t;
            }
        };
        
        ExecutorService executor = Executors.newFixedThreadPool(4, factory);
        
        for (int i = 0; i < 10; i++) {
            executor.submit(() -> {
                System.out.println("Task on " + Thread.currentThread().getName());
            });
        }
        
        executor.shutdown();
        
        /**
         * OUTPUT:
         * Task on MyPool-1
         * Task on MyPool-2
         * Task on MyPool-3
         * Task on MyPool-4
         * Task on MyPool-1
         * ...
         * 
         * Custom names help with debugging!
         */
    }
    
    /**
     * Named thread factory
     */
    static class NamedThreadFactory implements ThreadFactory {
        private final String namePrefix;
        private final java.util.concurrent.atomic.AtomicInteger threadNumber = 
            new java.util.concurrent.atomic.AtomicInteger(1);
        private final boolean daemon;
        
        public NamedThreadFactory(String namePrefix, boolean daemon) {
            this.namePrefix = namePrefix;
            this.daemon = daemon;
        }
        
        @Override
        public Thread newThread(Runnable r) {
            Thread t = new Thread(r);
            t.setName(namePrefix + "-" + threadNumber.getAndIncrement());
            t.setDaemon(daemon);
            return t;
        }
    }
    
    public static void namedThreadFactoryDemo() {
        // Web request pool
        ExecutorService webPool = Executors.newFixedThreadPool(20, 
            new NamedThreadFactory("WebRequest", false));
        
        // Background tasks pool
        ExecutorService backgroundPool = Executors.newFixedThreadPool(5, 
            new NamedThreadFactory("Background", true));
        
        webPool.submit(() -> {
            System.out.println("Web request on " + Thread.currentThread().getName());
        });
        
        backgroundPool.submit(() -> {
            System.out.println("Background task on " + Thread.currentThread().getName());
        });
        
        webPool.shutdown();
        backgroundPool.shutdown();
        
        /**
         * BENEFITS:
         * 
         * - Easy debugging (thread dumps)
         * - Monitoring (which pool is busy?)
         * - Troubleshooting (identify problem threads)
         */
    }
    
    /**
     * Thread factory with exception handler
     */
    static class ExceptionHandlingThreadFactory implements ThreadFactory {
        private final String namePrefix;
        private final java.util.concurrent.atomic.AtomicInteger threadNumber = 
            new java.util.concurrent.atomic.AtomicInteger(1);
        
        public ExceptionHandlingThreadFactory(String namePrefix) {
            this.namePrefix = namePrefix;
        }
        
        @Override
        public Thread newThread(Runnable r) {
            Thread t = new Thread(r);
            t.setName(namePrefix + "-" + threadNumber.getAndIncrement());
            t.setDaemon(false);
            
            // Set uncaught exception handler
            t.setUncaughtExceptionHandler((thread, throwable) -> {
                System.err.println("Uncaught exception in " + thread.getName());
                throwable.printStackTrace();
                // Could also:
                // - Log to file
                // - Send alert
                // - Record metrics
            });
            
            return t;
        }
    }
    
    public static void exceptionHandlerDemo() {
        ExecutorService executor = Executors.newFixedThreadPool(2, 
            new ExceptionHandlingThreadFactory("Worker"));
        
        executor.submit(() -> {
            System.out.println("Task 1 running");
            throw new RuntimeException("Oops!");
        });
        
        executor.submit(() -> {
            System.out.println("Task 2 running normally");
        });
        
        executor.shutdown();
        
        /**
         * OUTPUT:
         * Task 1 running
         * Uncaught exception in Worker-1
         * java.lang.RuntimeException: Oops!
         *     at ...
         * Task 2 running normally
         * 
         * Without custom exception handler, exception would be silent!
         */
    }
    
    /**
     * Google Guava's ThreadFactoryBuilder
     */
    public static void guavaThreadFactoryBuilder() {
        /**
         * If using Google Guava:
         * 
         * ThreadFactory factory = new ThreadFactoryBuilder()
         *     .setNameFormat("MyPool-%d")
         *     .setDaemon(true)
         *     .setPriority(Thread.NORM_PRIORITY)
         *     .setUncaughtExceptionHandler((t, e) -> {
         *         logger.error("Exception in " + t.getName(), e);
         *     })
         *     .build();
         * 
         * ExecutorService executor = Executors.newFixedThreadPool(10, factory);
         * 
         * Much cleaner than custom implementation!
         */
    }
}
```

---

## 7. Thread Pool Sizing Formula

### Sizing Guidelines

```java
/**
 * THREAD POOL SIZING
 */

public class ThreadPoolSizing {
    
    /**
     * CPU-bound tasks
     */
    public static void cpuBoundSizing() {
        int cores = Runtime.getRuntime().availableProcessors();
        
        /**
         * FORMULA FOR CPU-BOUND TASKS:
         * 
         * optimalThreads = numberOfCPUs + 1
         * 
         * Reasoning:
         * - CPU-bound = thread always computing
         * - More threads = more context switching, no benefit
         * - +1 compensates for occasional page faults
         * 
         * Examples:
         * - 4 cores → 5 threads
         * - 8 cores → 9 threads
         * - 16 cores → 17 threads
         */
        
        int optimalThreads = cores + 1;
        ExecutorService executor = Executors.newFixedThreadPool(optimalThreads);
        
        System.out.println("CPU cores: " + cores);
        System.out.println("Optimal threads for CPU-bound: " + optimalThreads);
        
        executor.shutdown();
    }
    
    /**
     * I/O-bound tasks
     */
    public static void ioBoundSizing() {
        int cores = Runtime.getRuntime().availableProcessors();
        
        /**
         * FORMULA FOR I/O-BOUND TASKS:
         * 
         * optimalThreads = numberOfCPUs × (1 + waitTime / computeTime)
         * 
         * where:
         * - waitTime = time waiting for I/O
         * - computeTime = time doing actual computation
         * 
         * Examples:
         * 
         * 1. Database queries (90% I/O, 10% compute):
         *    waitTime/computeTime = 0.9 / 0.1 = 9
         *    8 cores × (1 + 9) = 80 threads
         * 
         * 2. REST API calls (95% I/O, 5% compute):
         *    waitTime/computeTime = 0.95 / 0.05 = 19
         *    8 cores × (1 + 19) = 160 threads
         * 
         * 3. File I/O (70% I/O, 30% compute):
         *    waitTime/computeTime = 0.7 / 0.3 = 2.33
         *    8 cores × (1 + 2.33) = 27 threads
         */
        
        // Example: 80% I/O, 20% compute
        double waitTime = 0.8;
        double computeTime = 0.2;
        int optimalThreads = (int)(cores * (1 + waitTime / computeTime));
        
        ExecutorService executor = Executors.newFixedThreadPool(optimalThreads);
        
        System.out.println("CPU cores: " + cores);
        System.out.println("Wait/Compute ratio: " + (waitTime / computeTime));
        System.out.println("Optimal threads for I/O-bound: " + optimalThreads);
        
        executor.shutdown();
    }
    
    /**
     * Measuring wait/compute ratio
     */
    public static void measuringRatio() throws Exception {
        /**
         * HOW TO MEASURE WAIT/COMPUTE RATIO:
         * 
         * 1. Profile with JFR or profiler
         * 2. Look at thread states:
         *    - RUNNABLE = computing
         *    - WAITING/TIMED_WAITING = I/O wait
         * 
         * 3. Calculate:
         *    waitTime = time in WAITING states
         *    computeTime = time in RUNNABLE state
         *    ratio = waitTime / computeTime
         * 
         * 4. Use formula:
         *    threads = cores × (1 + ratio)
         */
        
        // Example measurement
        long startCpu = getThreadCpuTime();
        long startWall = System.nanoTime();
        
        // Simulate I/O-bound task
        Thread.sleep(100);  // 100ms I/O
        long compute = 0;
        for (int i = 0; i < 10_000_000; i++) {
            compute += i;  // ~20ms compute
        }
        
        long endCpu = getThreadCpuTime();
        long endWall = System.nanoTime();
        
        long cpuTime = endCpu - startCpu;
        long wallTime = endWall - startWall;
        long waitTime = wallTime - cpuTime;
        
        System.out.println("CPU time: " + cpuTime / 1_000_000 + "ms");
        System.out.println("Wait time: " + waitTime / 1_000_000 + "ms");
        System.out.println("Ratio: " + (double)waitTime / cpuTime);
        
        /**
         * OUTPUT (approximate):
         * CPU time: 20ms
         * Wait time: 100ms
         * Ratio: 5.0
         * 
         * For 8 cores:
         * threads = 8 × (1 + 5) = 48
         */
    }
    
    private static long getThreadCpuTime() {
        java.lang.management.ThreadMXBean bean = 
            java.lang.management.ManagementFactory.getThreadMXBean();
        return bean.getCurrentThreadCpuTime();
    }
    
    /**
     * Mixed workload sizing
     */
    public static void mixedWorkloadSizing() {
        int cores = Runtime.getRuntime().availableProcessors();
        
        /**
         * MIXED WORKLOAD:
         * 
         * If workload has both CPU-bound and I/O-bound tasks:
         * 
         * Option 1: Separate pools
         * - CPU pool: cores + 1 threads
         * - I/O pool: cores × (1 + W/C) threads
         * 
         * Option 2: Single pool
         * - Use I/O formula (more threads)
         * - CPU tasks use more threads but okay
         * - I/O tasks get enough concurrency
         * 
         * Option 3: Dynamic sizing
         * - ThreadPoolExecutor with:
         *   - corePoolSize = cores + 1
         *   - maximumPoolSize = cores × (1 + W/C)
         *   - Bounded queue
         * - Adapts to workload
         */
        
        // Option 1: Separate pools
        ExecutorService cpuPool = Executors.newFixedThreadPool(cores + 1);
        ExecutorService ioPool = Executors.newFixedThreadPool(cores * 5);
        
        // CPU-bound task
        cpuPool.submit(() -> {
            // Heavy computation
        });
        
        // I/O-bound task
        ioPool.submit(() -> {
            // Database query
        });
        
        cpuPool.shutdown();
        ioPool.shutdown();
    }
    
    /**
     * Practical sizing recommendations
     */
    public static void practicalRecommendations() {
        int cores = Runtime.getRuntime().availableProcessors();
        
        /**
         * PRACTICAL GUIDELINES:
         * 
         * Web Server (mixed I/O and compute):
         * - Start with: cores × 10
         * - Monitor and tune
         * 
         * Batch Processing (CPU-bound):
         * - Use: cores or cores + 1
         * 
         * Microservice (mostly I/O):
         * - Start with: cores × 20
         * - Tune based on latency
         * 
         * Database Connection Pool:
         * - Formula: connections = cores × 2 + effectiveSpindleCount
         * - For cloud/SSD: cores × 2 (no spindles)
         * - Example: 8 cores → 16 connections
         * 
         * REMEMBER:
         * - These are starting points
         * - Always monitor and tune
         * - Load test under realistic conditions
         * - Watch metrics: CPU, latency, throughput
         */
        
        System.out.println("=== Sizing Recommendations ===");
        System.out.println("Cores: " + cores);
        System.out.println("CPU-bound: " + (cores + 1));
        System.out.println("Web server: " + (cores * 10));
        System.out.println("Microservice: " + (cores * 20));
        System.out.println("DB connections: " + (cores * 2));
    }
}
```

---

## Summary

### Quick Reference

**Executor Types:**

```java
// Fixed pool (bounded threads, unbounded queue)
Executors.newFixedThreadPool(10);

// Cached pool (unbounded threads, no queue)
Executors.newCachedThreadPool();

// Single thread (sequential execution)
Executors.newSingleThreadExecutor();

// Scheduled (delayed/periodic tasks)
Executors.newScheduledThreadPool(5);

// Work-stealing (divide-and-conquer)
new ForkJoinPool();
```

**ThreadPoolExecutor Parameters:**

- corePoolSize: Minimum threads
- maximumPoolSize: Maximum threads
- keepAliveTime: Idle thread timeout
- workQueue: Task queue
- threadFactory: Thread creation
- handler: Rejection policy

**Queue Types:**

- LinkedBlockingQueue: Optionally bounded, good concurrency
- ArrayBlockingQueue: Bounded, fixed memory, optional fairness
- SynchronousQueue: No capacity, direct handoff
- PriorityBlockingQueue: Priority ordering
- DelayQueue: Delayed execution

**Rejection Policies:**

- AbortPolicy: Throw exception (default)
- CallerRunsPolicy: Run in caller thread
- DiscardPolicy: Silent discard
- DiscardOldestPolicy: Discard oldest

**Thread Pool Sizing:**

- CPU-bound: cores + 1
- I/O-bound: cores × (1 + W/C)
- Web server: cores × 10
- Microservice: cores × 20

### Best Practices

1. ✅ Use ExecutorService over manual thread creation
2. ✅ Always shutdown executors (try-with-resources in Java 19+)
3. ✅ Set meaningful thread names (custom ThreadFactory)
4. ✅ Use bounded queues for production (prevent OOM)
5. ✅ Handle RejectedExecutionException
6. ✅ Monitor pool metrics (size, queue, rejections)
7. ✅ Separate pools for different workloads
8. ❌ Don't use CachedThreadPool for long-running tasks
9. ❌ Don't use unbounded queue with corePoolSize = maximumPoolSize
10. ❌ Don't forget to configure rejection policy

---
