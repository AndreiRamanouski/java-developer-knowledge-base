# Java CompletableFuture and Async Programming

## Overview

CompletableFuture is Java's powerful API for asynchronous programming, introduced in Java 8. It enables non-blocking, composable async operations with a clean, functional API. This guide covers creation, chaining, combination, error handling, and production patterns.


---

## 1. Creating CompletableFuture

### Basic Creation Methods

```java
/**
 * COMPLETABLEFUTURE CREATION
 * 
 * CompletableFuture represents a future result of an async computation
 * Can be completed manually or via async execution
 */

import java.util.concurrent.*;

public class CompletableFutureCreation {
    
    /**
     * Method 1: Manual completion
     */
    public static void manualCompletion() throws Exception {
        CompletableFuture<String> future = new CompletableFuture<>();
        
        // Complete in another thread
        new Thread(() -> {
            try {
                Thread.sleep(1000);
                future.complete("Result");  // Complete with value
            } catch (InterruptedException e) {
                future.completeExceptionally(e);  // Complete with exception
            }
        }).start();
        
        // Wait for result
        String result = future.get();  // Blocks until completed
        System.out.println("Result: " + result);
        
        /**
         * OUTPUT:
         * Result: Result
         * 
         * Manual completion gives full control but rarely needed
         * Most code uses supplyAsync/runAsync
         */
    }
    
    /**
     * Method 2: supplyAsync (with return value)
     */
    public static void supplyAsyncDemo() throws Exception {
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            System.out.println("Computing in: " + Thread.currentThread().getName());
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            return "Computed Result";
        });
        
        System.out.println("Doing other work in: " + Thread.currentThread().getName());
        
        String result = future.get();  // Blocks until ready
        System.out.println("Result: " + result);
        
        /**
         * OUTPUT:
         * Doing other work in: main
         * Computing in: ForkJoinPool.commonPool-worker-1
         * Result: Computed Result
         * 
         * supplyAsync():
         * - Executes Supplier<T> asynchronously
         * - Returns CompletableFuture<T>
         * - Uses ForkJoinPool.commonPool() by default
         * - Non-blocking: caller continues immediately
         */
    }
    
    /**
     * Method 3: runAsync (no return value)
     */
    public static void runAsyncDemo() throws Exception {
        CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
            System.out.println("Running in: " + Thread.currentThread().getName());
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println("Task completed");
        });
        
        System.out.println("Doing other work");
        
        future.get();  // Wait for completion
        System.out.println("All done");
        
        /**
         * OUTPUT:
         * Doing other work
         * Running in: ForkJoinPool.commonPool-worker-1
         * Task completed
         * All done
         * 
         * runAsync():
         * - Executes Runnable asynchronously
         * - Returns CompletableFuture<Void>
         * - Use when no return value needed
         * - Similar to supplyAsync but for side effects
         */
    }
    
    /**
     * Method 4: completedFuture (already completed)
     */
    public static void completedFutureDemo() throws Exception {
        CompletableFuture<String> future = 
            CompletableFuture.completedFuture("Immediate Result");
        
        String result = future.get();  // Returns immediately
        System.out.println("Result: " + result);
        
        /**
         * completedFuture():
         * - Creates already-completed future
         * - No async execution
         * - Useful for returning pre-computed values
         * - Common in caching scenarios
         * 
         * Example use case:
         * if (cache.containsKey(key)) {
         *     return CompletableFuture.completedFuture(cache.get(key));
         * } else {
         *     return CompletableFuture.supplyAsync(() -> compute(key));
         * }
         */
    }
    
    /**
     * Method 5: Custom executor
     */
    public static void customExecutorDemo() throws Exception {
        ExecutorService executor = Executors.newFixedThreadPool(4);
        
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            System.out.println("Running in: " + Thread.currentThread().getName());
            return "Result from custom pool";
        }, executor);  // Custom executor
        
        String result = future.get();
        System.out.println("Result: " + result);
        
        executor.shutdown();
        
        /**
         * OUTPUT:
         * Running in: pool-1-thread-1
         * Result: Result from custom pool
         * 
         * Custom executor when:
         * - Need control over thread pool
         * - Different pool for different workloads
         * - I/O-bound vs CPU-bound separation
         * - Avoid blocking common pool
         */
    }
    
    /**
     * Comparison: Blocking vs Async
     */
    public static void blockingVsAsync() throws Exception {
        // Blocking approach
        long start = System.currentTimeMillis();
        
        String result1 = fetchUserBlocking();
        String result2 = fetchOrdersBlocking();
        String result3 = fetchProductsBlocking();
        
        long blockingTime = System.currentTimeMillis() - start;
        System.out.println("Blocking time: " + blockingTime + "ms");
        
        // Async approach
        start = System.currentTimeMillis();
        
        CompletableFuture<String> user = CompletableFuture.supplyAsync(
            () -> fetchUserBlocking());
        CompletableFuture<String> orders = CompletableFuture.supplyAsync(
            () -> fetchOrdersBlocking());
        CompletableFuture<String> products = CompletableFuture.supplyAsync(
            () -> fetchProductsBlocking());
        
        // Wait for all
        CompletableFuture.allOf(user, orders, products).get();
        
        long asyncTime = System.currentTimeMillis() - start;
        System.out.println("Async time: " + asyncTime + "ms");
        
        /**
         * OUTPUT:
         * Blocking time: 3000ms  (1000 + 1000 + 1000)
         * Async time: 1000ms     (all parallel)
         * 
         * 3x speedup with async!
         */
    }
    
    private static String fetchUserBlocking() {
        sleep(1000);
        return "User data";
    }
    
    private static String fetchOrdersBlocking() {
        sleep(1000);
        return "Orders data";
    }
    
    private static String fetchProductsBlocking() {
        sleep(1000);
        return "Products data";
    }
    
    private static void sleep(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

---

## 2. Chaining Operations

### Transformation and Consumption

```java
/**
 * CHAINING COMPLETABLEFUTURE OPERATIONS
 * 
 * Build async pipelines with transformation, consumption, and execution
 */

public class CompletableFutureChaining {
    
    /**
     * thenApply - Transform result (returns value)
     */
    public static void thenApplyDemo() throws Exception {
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            System.out.println("1. Fetching user");
            return "User123";
        }).thenApply(userId -> {
            System.out.println("2. Processing: " + userId);
            return userId.toLowerCase();
        }).thenApply(userId -> {
            System.out.println("3. Formatting: " + userId);
            return "Welcome, " + userId;
        });
        
        String result = future.get();
        System.out.println("Final: " + result);
        
        /**
         * OUTPUT:
         * 1. Fetching user
         * 2. Processing: User123
         * 3. Formatting: user123
         * Final: Welcome, user123
         * 
         * thenApply(Function<T, R>):
         * - Takes result of previous stage
         * - Transforms to new value
         * - Returns CompletableFuture<R>
         * - Like Stream.map()
         * 
         * Signature: CompletableFuture<T> → Function<T,R> → CompletableFuture<R>
         */
    }
    
    /**
     * thenAccept - Consume result (no return value)
     */
    public static void thenAcceptDemo() throws Exception {
        CompletableFuture<Void> future = CompletableFuture.supplyAsync(() -> {
            return "Processing complete";
        }).thenAccept(result -> {
            System.out.println("Result: " + result);
            // Side effect: log, save to DB, send notification, etc.
        });
        
        future.get();  // Wait for completion
        
        /**
         * OUTPUT:
         * Result: Processing complete
         * 
         * thenAccept(Consumer<T>):
         * - Takes result of previous stage
         * - Performs side effect
         * - Returns CompletableFuture<Void>
         * - Terminal operation (no value returned)
         * 
         * Signature: CompletableFuture<T> → Consumer<T> → CompletableFuture<Void>
         */
    }
    
    /**
     * thenRun - Execute action (ignores result)
     */
    public static void thenRunDemo() throws Exception {
        CompletableFuture<Void> future = CompletableFuture.supplyAsync(() -> {
            return "Some result";
        }).thenRun(() -> {
            System.out.println("Cleanup or notification");
            // Doesn't have access to previous result
        });
        
        future.get();
        
        /**
         * OUTPUT:
         * Cleanup or notification
         * 
         * thenRun(Runnable):
         * - Ignores result of previous stage
         * - Just executes action after completion
         * - Returns CompletableFuture<Void>
         * - Use for cleanup, logging, notifications
         * 
         * Signature: CompletableFuture<T> → Runnable → CompletableFuture<Void>
         */
    }
    
    /**
     * Async variants: thenApplyAsync, thenAcceptAsync, thenRunAsync
     */
    public static void asyncVariantsDemo() throws Exception {
        ExecutorService executor = Executors.newFixedThreadPool(2);
        
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            System.out.println("Supply in: " + Thread.currentThread().getName());
            return "Data";
        }, executor).thenApplyAsync(data -> {
            System.out.println("Transform in: " + Thread.currentThread().getName());
            return data.toUpperCase();
        }, executor).thenAcceptAsync(result -> {
            System.out.println("Consume in: " + Thread.currentThread().getName());
            System.out.println("Result: " + result);
        }, executor);
        
        future.get();
        executor.shutdown();
        
        /**
         * OUTPUT:
         * Supply in: pool-1-thread-1
         * Transform in: pool-1-thread-2
         * Consume in: pool-1-thread-1
         * Result: DATA
         * 
         * SYNC vs ASYNC:
         * 
         * thenApply():      Runs in same thread as previous stage
         * thenApplyAsync(): Runs in different thread (from executor)
         * 
         * When to use async:
         * ✓ CPU-intensive transformation
         * ✓ Want parallel execution
         * ✓ Avoid blocking common pool
         * 
         * When to use sync:
         * ✓ Quick transformation
         * ✓ Minimize thread switches
         * ✓ Better performance for fast operations
         */
    }
    
    /**
     * Chaining example: User profile pipeline
     */
    public static void userProfilePipeline() throws Exception {
        CompletableFuture<String> profile = CompletableFuture
            // 1. Fetch user ID
            .supplyAsync(() -> {
                System.out.println("Fetching user ID...");
                sleep(100);
                return "user123";
            })
            // 2. Fetch user details
            .thenApply(userId -> {
                System.out.println("Fetching details for: " + userId);
                sleep(100);
                return new User(userId, "John Doe", "john@example.com");
            })
            // 3. Fetch user preferences
            .thenApply(user -> {
                System.out.println("Fetching preferences for: " + user.name);
                sleep(100);
                user.preferences = "Dark mode, Email notifications";
                return user;
            })
            // 4. Format profile
            .thenApply(user -> {
                System.out.println("Formatting profile...");
                return String.format("User: %s (%s) - %s", 
                    user.name, user.email, user.preferences);
            })
            // 5. Log result
            .thenApply(profile -> {
                System.out.println("Profile ready!");
                return profile;
            });
        
        System.out.println(profile.get());
        
        /**
         * OUTPUT:
         * Fetching user ID...
         * Fetching details for: user123
         * Fetching preferences for: John Doe
         * Formatting profile...
         * Profile ready!
         * User: John Doe (john@example.com) - Dark mode, Email notifications
         * 
         * Pipeline pattern:
         * - Each stage depends on previous
         * - Clean, readable code
         * - Easy to add/remove stages
         * - Better than nested callbacks
         */
    }
    
    static class User {
        String id;
        String name;
        String email;
        String preferences;
        
        User(String id, String name, String email) {
            this.id = id;
            this.name = name;
            this.email = email;
        }
    }
    
    private static void sleep(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

---

## 3. Combining Futures

### Parallel and Sequential Composition

```java
/**
 * COMBINING COMPLETABLEFUTURES
 * 
 * Combine multiple async operations: parallel, sequential, race conditions
 */

public class CombiningFutures {
    
    /**
     * thenCombine - Combine two independent futures
     */
    public static void thenCombineDemo() throws Exception {
        CompletableFuture<String> userFuture = CompletableFuture.supplyAsync(() -> {
            System.out.println("Fetching user...");
            sleep(1000);
            return "User: John";
        });
        
        CompletableFuture<String> ordersFuture = CompletableFuture.supplyAsync(() -> {
            System.out.println("Fetching orders...");
            sleep(1000);
            return "Orders: 5";
        });
        
        CompletableFuture<String> combined = userFuture.thenCombine(
            ordersFuture,
            (user, orders) -> {
                return user + ", " + orders;
            }
        );
        
        System.out.println(combined.get());
        
        /**
         * OUTPUT:
         * Fetching user...
         * Fetching orders...
         * (1 second later)
         * User: John, Orders: 5
         * 
         * thenCombine():
         * - Runs two futures in parallel
         * - Combines results with BiFunction
         * - Returns CompletableFuture<R>
         * - Waits for both to complete
         * 
         * Time: 1 second (parallel) vs 2 seconds (sequential)
         */
    }
    
    /**
     * thenCompose - Sequential composition (flat map)
     */
    public static void thenComposeDemo() throws Exception {
        CompletableFuture<String> result = CompletableFuture
            .supplyAsync(() -> {
                System.out.println("Fetching user ID...");
                sleep(500);
                return "user123";
            })
            .thenCompose(userId -> {
                // Fetch orders based on user ID
                return CompletableFuture.supplyAsync(() -> {
                    System.out.println("Fetching orders for: " + userId);
                    sleep(500);
                    return "Orders for " + userId + ": 10 items";
                });
            });
        
        System.out.println(result.get());
        
        /**
         * OUTPUT:
         * Fetching user ID...
         * Fetching orders for: user123
         * Orders for user123: 10 items
         * 
         * thenCompose():
         * - Sequential composition (second depends on first)
         * - Like flatMap in Stream API
         * - Avoids nested CompletableFutures
         * 
         * WRONG (nested futures):
         * CompletableFuture<CompletableFuture<String>> nested = 
         *     future.thenApply(id -> fetchOrders(id));
         * 
         * CORRECT (flat):
         * CompletableFuture<String> flat = 
         *     future.thenCompose(id -> fetchOrders(id));
         */
    }
    
    /**
     * thenCombine vs thenCompose
     */
    public static void combineVsCompose() {
        /**
         * ┌────────────────────┬───────────────────┬─────────────────────┐
         * │                    │   thenCombine     │   thenCompose       │
         * ├────────────────────┼───────────────────┼─────────────────────┤
         * │ Execution          │   Parallel        │   Sequential        │
         * │ Dependencies       │   Independent     │   Second depends    │
         * │                    │                   │   on first          │
         * │ Use case           │   Combine results │   Chain async ops   │
         * │ Like Stream API    │   N/A             │   flatMap           │
         * │ Performance        │   Faster (||)     │   Slower (→)        │
         * └────────────────────┴───────────────────┴─────────────────────┘
         * 
         * Example:
         * 
         * thenCombine - Fetch user AND orders (parallel)
         * thenCompose - Fetch user, THEN fetch their orders (sequential)
         */
    }
    
    /**
     * allOf - Wait for all futures
     */
    public static void allOfDemo() throws Exception {
        CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> {
            sleep(1000);
            return "Result 1";
        });
        
        CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> {
            sleep(1500);
            return "Result 2";
        });
        
        CompletableFuture<String> future3 = CompletableFuture.supplyAsync(() -> {
            sleep(800);
            return "Result 3";
        });
        
        long start = System.currentTimeMillis();
        
        // Wait for all to complete
        CompletableFuture<Void> allFutures = 
            CompletableFuture.allOf(future1, future2, future3);
        
        allFutures.get();  // Blocks until all complete
        
        long elapsed = System.currentTimeMillis() - start;
        System.out.println("All completed in: " + elapsed + "ms");
        
        // Get individual results
        System.out.println(future1.get());
        System.out.println(future2.get());
        System.out.println(future3.get());
        
        /**
         * OUTPUT:
         * All completed in: 1500ms  (slowest one)
         * Result 1
         * Result 2
         * Result 3
         * 
         * allOf():
         * - Waits for all futures to complete
         * - Returns CompletableFuture<Void> (no result!)
         * - Must get() individual futures for results
         * - Completes when slowest future completes
         * - If any fails, allOf fails
         */
    }
    
    /**
     * allOf - Collecting results
     */
    public static void allOfCollectResults() throws Exception {
        CompletableFuture<String>[] futures = new CompletableFuture[]{
            CompletableFuture.supplyAsync(() -> "A"),
            CompletableFuture.supplyAsync(() -> "B"),
            CompletableFuture.supplyAsync(() -> "C")
        };
        
        CompletableFuture<java.util.List<String>> allResults = 
            CompletableFuture.allOf(futures)
                .thenApply(v -> {
                    return java.util.Arrays.stream(futures)
                        .map(CompletableFuture::join)  // Get results
                        .collect(java.util.stream.Collectors.toList());
                });
        
        System.out.println("Results: " + allResults.get());
        
        /**
         * OUTPUT:
         * Results: [A, B, C]
         * 
         * Pattern for collecting all results:
         * 1. allOf() waits for all
         * 2. thenApply() collects results
         * 3. join() gets each result (non-blocking, already complete)
         */
    }
    
    /**
     * anyOf - Race condition (first to complete)
     */
    public static void anyOfDemo() throws Exception {
        CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> {
            sleep(1000);
            return "Slow service";
        });
        
        CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> {
            sleep(500);
            return "Fast service";
        });
        
        CompletableFuture<String> future3 = CompletableFuture.supplyAsync(() -> {
            sleep(1500);
            return "Very slow service";
        });
        
        long start = System.currentTimeMillis();
        
        CompletableFuture<Object> fastest = 
            CompletableFuture.anyOf(future1, future2, future3);
        
        Object result = fastest.get();
        long elapsed = System.currentTimeMillis() - start;
        
        System.out.println("Fastest result: " + result);
        System.out.println("Time: " + elapsed + "ms");
        
        /**
         * OUTPUT:
         * Fastest result: Fast service
         * Time: 500ms
         * 
         * anyOf():
         * - Returns first future to complete
         * - Returns CompletableFuture<Object>
         * - Other futures continue running (not cancelled!)
         * - Useful for timeouts, redundant requests
         * 
         * USE CASES:
         * - Multiple data sources (first wins)
         * - Timeout pattern
         * - Redundant requests for reliability
         */
    }
    
    /**
     * Real-world example: Product page
     */
    public static void productPageExample() throws Exception {
        String productId = "PROD123";
        
        // Parallel fetch: product, reviews, recommendations
        CompletableFuture<Product> productFuture = 
            CompletableFuture.supplyAsync(() -> fetchProduct(productId));
        
        CompletableFuture<java.util.List<Review>> reviewsFuture = 
            CompletableFuture.supplyAsync(() -> fetchReviews(productId));
        
        CompletableFuture<java.util.List<Product>> recommendationsFuture = 
            CompletableFuture.supplyAsync(() -> fetchRecommendations(productId));
        
        // Combine all results
        CompletableFuture<ProductPage> pageFuture = productFuture.thenCombine(
            reviewsFuture,
            (product, reviews) -> new ProductPage(product, reviews, null)
        ).thenCombine(
            recommendationsFuture,
            (page, recommendations) -> {
                page.recommendations = recommendations;
                return page;
            }
        );
        
        ProductPage page = pageFuture.get();
        System.out.println("Product page loaded: " + page.product.name);
        System.out.println("Reviews: " + page.reviews.size());
        System.out.println("Recommendations: " + page.recommendations.size());
        
        /**
         * PERFORMANCE:
         * 
         * Sequential: 3 seconds (1s + 1s + 1s)
         * Parallel: 1 second (all at once)
         * 
         * 3x speedup!
         */
    }
    
    static class Product {
        String id;
        String name;
        Product(String id, String name) {
            this.id = id;
            this.name = name;
        }
    }
    
    static class Review {
        String text;
        Review(String text) {
            this.text = text;
        }
    }
    
    static class ProductPage {
        Product product;
        java.util.List<Review> reviews;
        java.util.List<Product> recommendations;
        
        ProductPage(Product product, java.util.List<Review> reviews, 
                    java.util.List<Product> recommendations) {
            this.product = product;
            this.reviews = reviews;
            this.recommendations = recommendations;
        }
    }
    
    private static Product fetchProduct(String id) {
        sleep(1000);
        return new Product(id, "Product " + id);
    }
    
    private static java.util.List<Review> fetchReviews(String id) {
        sleep(1000);
        return java.util.Arrays.asList(
            new Review("Great!"),
            new Review("Love it!")
        );
    }
    
    private static java.util.List<Product> fetchRecommendations(String id) {
        sleep(1000);
        return java.util.Arrays.asList(
            new Product("REC1", "Related Product 1"),
            new Product("REC2", "Related Product 2")
        );
    }
    
    private static void sleep(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

---

## 4. Exception Handling

### Handling Failures in Async Code

```java
/**
 * EXCEPTION HANDLING IN COMPLETABLEFUTURE
 */

public class CompletableFutureExceptions {
    
    /**
     * exceptionally - Handle exception and provide fallback
     */
    public static void exceptionallyDemo() throws Exception {
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            System.out.println("Attempting risky operation...");
            if (Math.random() > 0.5) {
                throw new RuntimeException("Operation failed!");
            }
            return "Success";
        }).exceptionally(ex -> {
            System.out.println("Exception caught: " + ex.getMessage());
            return "Fallback value";
        });
        
        System.out.println("Result: " + future.get());
        
        /**
         * OUTPUT (if exception):
         * Attempting risky operation...
         * Exception caught: java.lang.RuntimeException: Operation failed!
         * Result: Fallback value
         * 
         * OUTPUT (if success):
         * Attempting risky operation...
         * Result: Success
         * 
         * exceptionally(Function<Throwable, T>):
         * - Called only if exception occurs
         * - Provides fallback value
         * - Recovers from exception
         * - Like catch block
         */
    }
    
    /**
     * handle - Handle both success and failure
     */
    public static void handleDemo() throws Exception {
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            if (Math.random() > 0.5) {
                throw new RuntimeException("Failed");
            }
            return "Success";
        }).handle((result, ex) -> {
            if (ex != null) {
                System.out.println("Error: " + ex.getMessage());
                return "Error handled";
            } else {
                System.out.println("Success: " + result);
                return "Processed: " + result;
            }
        });
        
        System.out.println("Result: " + future.get());
        
        /**
         * handle(BiFunction<T, Throwable, R>):
         * - Called for both success and failure
         * - Parameters: (result, exception)
         * - If success: result != null, exception == null
         * - If failure: result == null, exception != null
         * - Like finally but can transform result
         */
    }
    
    /**
     * whenComplete - Side effects without changing result
     */
    public static void whenCompleteDemo() throws Exception {
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            return "Result";
        }).whenComplete((result, ex) -> {
            if (ex != null) {
                System.out.println("Failed with: " + ex);
            } else {
                System.out.println("Completed with: " + result);
            }
            // Cannot change result or exception!
        });
        
        System.out.println("Result: " + future.get());
        
        /**
         * OUTPUT:
         * Completed with: Result
         * Result: Result
         * 
         * whenComplete(BiConsumer<T, Throwable>):
         * - Called for both success and failure
         * - CANNOT change result or exception
         * - Use for logging, metrics, cleanup
         * - Like finally block
         * 
         * handle vs whenComplete:
         * - handle: Can transform result/exception
         * - whenComplete: Side effects only
         */
    }
    
    /**
     * Exception propagation
     */
    public static void exceptionPropagation() throws Exception {
        CompletableFuture<String> future = CompletableFuture
            .supplyAsync(() -> {
                System.out.println("Stage 1");
                return "Data";
            })
            .thenApply(data -> {
                System.out.println("Stage 2");
                throw new RuntimeException("Stage 2 failed!");
            })
            .thenApply(data -> {
                System.out.println("Stage 3 (won't execute)");
                return data;
            })
            .exceptionally(ex -> {
                System.out.println("Caught: " + ex.getMessage());
                return "Recovered";
            });
        
        System.out.println("Result: " + future.get());
        
        /**
         * OUTPUT:
         * Stage 1
         * Stage 2
         * Caught: java.lang.RuntimeException: Stage 2 failed!
         * Result: Recovered
         * 
         * Stage 3 skipped (exception short-circuits pipeline)
         * 
         * EXCEPTION FLOW:
         * 1. Exception thrown in stage 2
         * 2. Remaining stages skipped
         * 3. First exception handler catches it
         * 4. Pipeline continues after handler
         */
    }
    
    /**
     * Multiple exception handlers
     */
    public static void multipleHandlers() throws Exception {
        CompletableFuture<String> future = CompletableFuture
            .supplyAsync(() -> {
                throw new RuntimeException("Error 1");
            })
            .exceptionally(ex -> {
                System.out.println("Handler 1: " + ex.getMessage());
                throw new RuntimeException("Error 2");  // Re-throw different exception
            })
            .exceptionally(ex -> {
                System.out.println("Handler 2: " + ex.getMessage());
                return "Final fallback";
            });
        
        System.out.println("Result: " + future.get());
        
        /**
         * OUTPUT:
         * Handler 1: java.lang.RuntimeException: Error 1
         * Handler 2: java.lang.RuntimeException: Error 2
         * Result: Final fallback
         * 
         * Exception handlers can:
         * - Recover (return value)
         * - Re-throw same exception
         * - Throw different exception
         * - Transform exception
         */
    }
    
    /**
     * Timeout handling
     */
    public static void timeoutHandling() throws Exception {
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            sleep(5000);  // Slow operation
            return "Result";
        });
        
        try {
            // Wait max 2 seconds
            String result = future.get(2, TimeUnit.SECONDS);
            System.out.println("Result: " + result);
        } catch (TimeoutException e) {
            System.out.println("Timeout! Operation too slow");
            future.cancel(true);  // Cancel the slow operation
        }
        
        /**
         * OUTPUT:
         * Timeout! Operation too slow
         * 
         * Timeout strategies:
         * 
         * 1. get(timeout) - Simple but blocks
         * 2. orTimeout() - Java 9+ (better!)
         * 3. completeOnTimeout() - Java 9+ (with default)
         */
    }
    
    /**
     * Java 9+ timeout methods
     */
    public static void java9Timeouts() throws Exception {
        // orTimeout - Fail with TimeoutException
        CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> {
            sleep(5000);
            return "Slow result";
        }).orTimeout(2, TimeUnit.SECONDS);  // Java 9+
        
        try {
            future1.get();
        } catch (Exception e) {
            System.out.println("orTimeout: " + e.getCause().getClass().getSimpleName());
        }
        
        // completeOnTimeout - Provide default value
        CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> {
            sleep(5000);
            return "Slow result";
        }).completeOnTimeout("Default value", 2, TimeUnit.SECONDS);  // Java 9+
        
        System.out.println("completeOnTimeout: " + future2.get());
        
        /**
         * OUTPUT:
         * orTimeout: TimeoutException
         * completeOnTimeout: Default value
         * 
         * orTimeout():
         * - Fails with TimeoutException
         * - Must handle exception
         * 
         * completeOnTimeout():
         * - Completes with default value
         * - Graceful degradation
         */
    }
    
    /**
     * Real-world example: API call with retry
     */
    public static void apiCallWithRetry() throws Exception {
        CompletableFuture<String> result = callApiWithRetry(3);
        System.out.println("Final result: " + result.get());
    }
    
    private static CompletableFuture<String> callApiWithRetry(int maxRetries) {
        return callApi()
            .exceptionally(ex -> {
                System.out.println("Attempt failed: " + ex.getMessage());
                if (maxRetries > 0) {
                    System.out.println("Retrying... (" + maxRetries + " left)");
                    return callApiWithRetry(maxRetries - 1).join();
                } else {
                    throw new RuntimeException("Max retries exceeded", ex);
                }
            });
    }
    
    private static CompletableFuture<String> callApi() {
        return CompletableFuture.supplyAsync(() -> {
            if (Math.random() > 0.7) {  // 30% success rate
                return "API Success";
            } else {
                throw new RuntimeException("API Error");
            }
        });
    }
    
    private static void sleep(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

---

## 5. Custom Executors with CompletableFuture

### Controlling Thread Pools

```java
/**
 * CUSTOM EXECUTORS FOR COMPLETABLEFUTURE
 */

public class CustomExecutors {
    
    /**
     * Default behavior (common pool)
     */
    public static void defaultBehavior() {
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            System.out.println("Thread: " + Thread.currentThread().getName());
            System.out.println("Parallelism: " + 
                ForkJoinPool.commonPool().getParallelism());
            return "Result";
        });
        
        /**
         * OUTPUT:
         * Thread: ForkJoinPool.commonPool-worker-1
         * Parallelism: 7  (CPU cores - 1)
         * 
         * Default executor: ForkJoinPool.commonPool()
         * 
         * PROS:
         * ✓ Shared resource (efficient)
         * ✓ Automatic sizing
         * ✓ No setup needed
         * 
         * CONS:
         * ✗ Shared by all code
         * ✗ Blocking tasks affect parallel streams
         * ✗ Can't configure
         */
    }
    
    /**
     * Custom executor for I/O-bound tasks
     */
    public static void ioBoundExecutor() throws Exception {
        // I/O-bound: many threads
        ExecutorService ioExecutor = Executors.newFixedThreadPool(50,
            r -> {
                Thread t = new Thread(r);
                t.setName("IO-Pool-" + t.getId());
                return t;
            });
        
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            System.out.println("Thread: " + Thread.currentThread().getName());
            sleep(1000);  // Simulate I/O
            return "I/O Result";
        }, ioExecutor);
        
        System.out.println(future.get());
        
        ioExecutor.shutdown();
        
        /**
         * USE CASE:
         * - Database queries
         * - HTTP requests
         * - File I/O
         * - Any blocking operations
         * 
         * SIZING:
         * cores × (1 + waitTime / computeTime)
         * For 90% I/O: 8 cores × 10 = 80 threads
         */
    }
    
    /**
     * Custom executor for CPU-bound tasks
     */
    public static void cpuBoundExecutor() throws Exception {
        int cores = Runtime.getRuntime().availableProcessors();
        
        // CPU-bound: fewer threads
        ExecutorService cpuExecutor = Executors.newFixedThreadPool(cores,
            r -> {
                Thread t = new Thread(r);
                t.setName("CPU-Pool-" + t.getId());
                return t;
            });
        
        CompletableFuture<Long> future = CompletableFuture.supplyAsync(() -> {
            System.out.println("Thread: " + Thread.currentThread().getName());
            
            // CPU-intensive work
            long result = 0;
            for (long i = 0; i < 1_000_000_000L; i++) {
                result += i;
            }
            return result;
        }, cpuExecutor);
        
        System.out.println("Result: " + future.get());
        
        cpuExecutor.shutdown();
        
        /**
         * USE CASE:
         * - Image processing
         * - Encryption/decryption
         * - Data compression
         * - Mathematical computations
         * 
         * SIZING:
         * cores or cores + 1
         */
    }
    
    /**
     * Separate executors for different stages
     */
    public static void separateExecutors() throws Exception {
        ExecutorService ioPool = Executors.newFixedThreadPool(50);
        ExecutorService cpuPool = Executors.newFixedThreadPool(
            Runtime.getRuntime().availableProcessors());
        
        CompletableFuture<String> result = CompletableFuture
            // I/O stage: Fetch data
            .supplyAsync(() -> {
                System.out.println("Fetch in: " + Thread.currentThread().getName());
                sleep(1000);
                return "Raw Data";
            }, ioPool)
            // CPU stage: Process data
            .thenApplyAsync(data -> {
                System.out.println("Process in: " + Thread.currentThread().getName());
                return data.toUpperCase();  // CPU work
            }, cpuPool)
            // I/O stage: Save result
            .thenApplyAsync(processed -> {
                System.out.println("Save in: " + Thread.currentThread().getName());
                sleep(500);
                return "Saved: " + processed;
            }, ioPool);
        
        System.out.println(result.get());
        
        ioPool.shutdown();
        cpuPool.shutdown();
        
        /**
         * OUTPUT:
         * Fetch in: pool-1-thread-1
         * Process in: pool-2-thread-1
         * Save in: pool-1-thread-2
         * Saved: RAW DATA
         * 
         * BENEFITS:
         * - I/O pool not blocked by CPU work
         * - CPU pool not wasted on I/O wait
         * - Optimal resource utilization
         */
    }
    
    /**
     * Virtual threads (Java 19+)
     */
    public static void virtualThreadExecutor() throws Exception {
        /**
         * Virtual threads: Perfect for CompletableFuture!
         */
        
        // Create virtual thread executor
        ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();
        
        // Spawn thousands of async tasks
        CompletableFuture<?>[] futures = new CompletableFuture[10_000];
        
        for (int i = 0; i < 10_000; i++) {
            futures[i] = CompletableFuture.supplyAsync(() -> {
                sleep(1000);  // I/O wait
                return "Result";
            }, executor);
        }
        
        // Wait for all
        CompletableFuture.allOf(futures).get();
        System.out.println("All 10,000 tasks completed!");
        
        executor.shutdown();
        
        /**
         * VIRTUAL THREADS + COMPLETABLEFUTURE:
         * 
         * - 10,000 concurrent tasks
         * - Minimal memory (<1GB)
         * - No thread pool sizing needed
         * - Perfect for I/O-bound async work
         * 
         * Platform threads: Would need 10GB+ memory!
         */
    }
    
    /**
     * Executor for all async methods
     */
    public static void executorForAllMethods() throws Exception {
        ExecutorService executor = Executors.newFixedThreadPool(4);
        
        CompletableFuture<String> result = CompletableFuture
            .supplyAsync(() -> "Start", executor)
            .thenApplyAsync(s -> s + " -> Stage1", executor)
            .thenApplyAsync(s -> s + " -> Stage2", executor)
            .thenApplyAsync(s -> s + " -> End", executor);
        
        System.out.println(result.get());
        
        executor.shutdown();
        
        /**
         * OUTPUT:
         * Start -> Stage1 -> Stage2 -> End
         * 
         * IMPORTANT:
         * - Must specify executor for each async method
         * - Sync methods (thenApply) use same thread as previous stage
         * - Async methods (thenApplyAsync) can switch threads
         */
    }
    
    private static void sleep(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

---

## 6. Avoiding Blocking Operations

### Non-Blocking Patterns

```java
/**
 * AVOIDING BLOCKING IN COMPLETABLEFUTURE
 */

public class AvoidingBlocking {
    
    /**
     * PROBLEM: Blocking with get()
     */
    public static void blockingGetProblem() throws Exception {
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            sleep(2000);
            return "Result";
        });
        
        // ❌ BAD: Blocks caller thread
        String result = future.get();
        System.out.println(result);
        
        // While blocked, caller can't do anything!
        // Defeats purpose of async programming
    }
    
    /**
     * SOLUTION: Use callbacks instead of get()
     */
    public static void nonBlockingSolution() {
        CompletableFuture.supplyAsync(() -> {
            sleep(2000);
            return "Result";
        }).thenAccept(result -> {
            // ✓ GOOD: Non-blocking callback
            System.out.println("Received: " + result);
            // Process result here
        });
        
        System.out.println("Main thread continues immediately");
        
        // Give futures time to complete
        sleep(3000);
        
        /**
         * OUTPUT:
         * Main thread continues immediately
         * (2 seconds later)
         * Received: Result
         * 
         * Caller thread not blocked!
         */
    }
    
    /**
     * ANTI-PATTERN: Blocking in async callbacks
     */
    public static void blockingInCallback() throws Exception {
        CompletableFuture<String> result = CompletableFuture
            .supplyAsync(() -> {
                return "User data";
            })
            .thenApply(user -> {
                // ❌ BAD: Blocking call in async context
                try {
                    String orders = fetchOrdersBlocking(user);  // Blocks thread!
                    return user + ", " + orders;
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            });
        
        System.out.println(result.get());
        
        /**
         * PROBLEM:
         * - Async thread blocked waiting for I/O
         * - Thread wasted (could handle other tasks)
         * - Reduces throughput
         * 
         * IMPACT:
         * - Common pool blocked
         * - Affects parallel streams
         * - Other CompletableFutures delayed
         */
    }
    
    /**
     * SOLUTION: Chain async operations
     */
    public static void chainingAsyncOperations() throws Exception {
        CompletableFuture<String> result = CompletableFuture
            .supplyAsync(() -> {
                return "User data";
            })
            .thenCompose(user -> {
                // ✓ GOOD: Return CompletableFuture (non-blocking)
                return fetchOrdersAsync(user);
            })
            .thenApply(orders -> {
                return "Combined: " + orders;
            });
        
        System.out.println(result.get());
        
        /**
         * BENEFITS:
         * - No thread blocked
         * - Better throughput
         * - Proper async chaining
         */
    }
    
    /**
     * ANTI-PATTERN: join() in loop
     */
    public static void joinInLoop() {
        java.util.List<String> userIds = 
            java.util.Arrays.asList("user1", "user2", "user3", "user4", "user5");
        
        // ❌ BAD: Sequential with join()
        long start = System.currentTimeMillis();
        
        for (String userId : userIds) {
            CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
                sleep(1000);
                return "Data for " + userId;
            });
            
            String result = future.join();  // Blocks!
            System.out.println(result);
        }
        
        long elapsed = System.currentTimeMillis() - start;
        System.out.println("Time: " + elapsed + "ms");
        
        /**
         * OUTPUT:
         * Data for user1
         * Data for user2
         * Data for user3
         * Data for user4
         * Data for user5
         * Time: 5000ms  (sequential!)
         * 
         * Each join() blocks, serializing the work
         */
    }
    
    /**
     * SOLUTION: Parallel collection then wait
     */
    public static void parallelThenWait() {
        java.util.List<String> userIds = 
            java.util.Arrays.asList("user1", "user2", "user3", "user4", "user5");
        
        // ✓ GOOD: Start all, then wait for all
        long start = System.currentTimeMillis();
        
        java.util.List<CompletableFuture<String>> futures = userIds.stream()
            .map(userId -> CompletableFuture.supplyAsync(() -> {
                sleep(1000);
                return "Data for " + userId;
            }))
            .collect(java.util.stream.Collectors.toList());
        
        // Wait for all to complete
        CompletableFuture<Void> allFutures = CompletableFuture.allOf(
            futures.toArray(new CompletableFuture[0]));
        
        allFutures.join();  // Single wait point
        
        // Collect results
        futures.forEach(f -> System.out.println(f.join()));
        
        long elapsed = System.currentTimeMillis() - start;
        System.out.println("Time: " + elapsed + "ms");
        
        /**
         * OUTPUT:
         * Data for user1
         * Data for user2
         * Data for user3
         * Data for user4
         * Data for user5
         * Time: 1000ms  (parallel!)
         * 
         * 5x speedup!
         */
    }
    
    /**
     * PROBLEM: Blocking I/O in common pool
     */
    public static void blockingIOInCommonPool() {
        // ❌ BAD: Blocking I/O on common pool
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            // Blocks common pool thread!
            sleep(5000);  // Simulate blocking I/O
            return "Result";
        });
        
        /**
         * IMPACT:
         * - Common pool thread blocked for 5 seconds
         * - Other CompletableFutures wait
         * - Parallel streams affected
         * - Reduced concurrency
         */
    }
    
    /**
     * SOLUTION: Use separate executor for blocking I/O
     */
    public static void separateExecutorForBlocking() throws Exception {
        ExecutorService ioExecutor = Executors.newFixedThreadPool(50);
        
        // ✓ GOOD: Blocking I/O on dedicated pool
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            sleep(5000);  // Blocking I/O
            return "Result";
        }, ioExecutor);  // Custom executor
        
        System.out.println(future.get());
        
        ioExecutor.shutdown();
        
        /**
         * BENEFITS:
         * - Common pool not affected
         * - I/O pool sized for blocking work
         * - Better isolation
         */
    }
    
    /**
     * Best practice: Non-blocking composition
     */
    public static void nonBlockingComposition() throws Exception {
        // Fetch user, then orders, then recommendations
        // All non-blocking!
        
        CompletableFuture<String> result = fetchUserAsync("user123")
            .thenCompose(user -> fetchOrdersAsync(user))
            .thenCompose(orders -> fetchRecommendationsAsync(orders))
            .thenApply(recommendations -> {
                return "Final result: " + recommendations;
            });
        
        // Only block once at the end (if needed)
        System.out.println(result.get());
        
        // Or better: Don't block at all!
        result.thenAccept(finalResult -> {
            System.out.println(finalResult);
        });
        
        sleep(5000);  // Give time to complete
    }
    
    private static String fetchOrdersBlocking(String user) throws Exception {
        Thread.sleep(1000);
        return "Orders for " + user;
    }
    
    private static CompletableFuture<String> fetchOrdersAsync(String user) {
        return CompletableFuture.supplyAsync(() -> {
            sleep(1000);
            return "Orders for " + user;
        });
    }
    
    private static CompletableFuture<String> fetchUserAsync(String userId) {
        return CompletableFuture.supplyAsync(() -> {
            sleep(500);
            return "User: " + userId;
        });
    }
    
    private static CompletableFuture<String> fetchRecommendationsAsync(String orders) {
        return CompletableFuture.supplyAsync(() -> {
            sleep(500);
            return "Recommendations based on " + orders;
        });
    }
    
    private static void sleep(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

---

## 7. Real-World Patterns

### Production-Ready Examples

```java
/**
 * REAL-WORLD COMPLETABLEFUTURE PATTERNS
 */

public class RealWorldPatterns {
    
    /**
     * Pattern 1: Timeout with fallback
     */
    public static void timeoutWithFallback() throws Exception {
        CompletableFuture<String> primary = CompletableFuture.supplyAsync(() -> {
            sleep(5000);  // Slow service
            return "Primary result";
        });
        
        CompletableFuture<String> fallback = CompletableFuture.supplyAsync(() -> {
            sleep(500);  // Fast cache
            return "Cached result";
        });
        
        // Race: Use whichever completes first
        CompletableFuture<String> result = 
            CompletableFuture.anyOf(primary, fallback)
                .thenApply(r -> (String) r);
        
        System.out.println("Result: " + result.get());
        
        /**
         * OUTPUT:
         * Result: Cached result
         * 
         * USE CASE:
         * - Try database, fallback to cache
         * - Try primary API, fallback to backup
         * - Timeout pattern
         */
    }
    
    /**
     * Pattern 2: Scatter-gather
     */
    public static void scatterGather() throws Exception {
        // Query multiple data sources in parallel
        CompletableFuture<java.util.List<String>> db1 = 
            CompletableFuture.supplyAsync(() -> {
                sleep(1000);
                return java.util.Arrays.asList("DB1-Record1", "DB1-Record2");
            });
        
        CompletableFuture<java.util.List<String>> db2 = 
            CompletableFuture.supplyAsync(() -> {
                sleep(1200);
                return java.util.Arrays.asList("DB2-Record1", "DB2-Record2");
            });
        
        CompletableFuture<java.util.List<String>> db3 = 
            CompletableFuture.supplyAsync(() -> {
                sleep(800);
                return java.util.Arrays.asList("DB3-Record1", "DB3-Record2");
            });
        
        // Combine all results
        CompletableFuture<java.util.List<String>> allResults = 
            CompletableFuture.allOf(db1, db2, db3)
                .thenApply(v -> {
                    java.util.List<String> combined = new java.util.ArrayList<>();
                    combined.addAll(db1.join());
                    combined.addAll(db2.join());
                    combined.addAll(db3.join());
                    return combined;
                });
        
        System.out.println("Combined results: " + allResults.get());
        
        /**
         * OUTPUT:
         * Combined results: [DB1-Record1, DB1-Record2, DB2-Record1, 
         *                    DB2-Record2, DB3-Record1, DB3-Record2]
         * 
         * Time: 1200ms (slowest) vs 3000ms (sequential)
         * 
         * USE CASE:
         * - Distributed search
         * - Aggregating from multiple microservices
         * - Parallel database queries
         */
    }
    
    /**
     * Pattern 3: Circuit breaker
     */
    static class CircuitBreaker {
        private final int threshold;
        private final long resetTimeout;
        private int failureCount = 0;
        private long lastFailureTime = 0;
        private boolean open = false;
        
        public CircuitBreaker(int threshold, long resetTimeout) {
            this.threshold = threshold;
            this.resetTimeout = resetTimeout;
        }
        
        public <T> CompletableFuture<T> execute(
                java.util.function.Supplier<CompletableFuture<T>> supplier) {
            
            if (open && System.currentTimeMillis() - lastFailureTime < resetTimeout) {
                return CompletableFuture.failedFuture(
                    new RuntimeException("Circuit breaker is OPEN"));
            }
            
            return supplier.get()
                .whenComplete((result, ex) -> {
                    if (ex != null) {
                        failureCount++;
                        lastFailureTime = System.currentTimeMillis();
                        
                        if (failureCount >= threshold) {
                            open = true;
                            System.out.println("Circuit breaker OPENED");
                        }
                    } else {
                        failureCount = 0;
                        open = false;
                    }
                });
        }
    }
    
    public static void circuitBreakerDemo() throws Exception {
        CircuitBreaker breaker = new CircuitBreaker(3, 5000);
        
        for (int i = 0; i < 10; i++) {
            final int attempt = i;
            
            CompletableFuture<String> result = breaker.execute(() -> 
                CompletableFuture.supplyAsync(() -> {
                    if (attempt < 5) {
                        throw new RuntimeException("Service unavailable");
                    }
                    return "Success";
                })
            );
            
            result.exceptionally(ex -> {
                System.out.println("Attempt " + attempt + ": " + ex.getMessage());
                return null;
            });
            
            sleep(100);
        }
        
        sleep(1000);
        
        /**
         * Pattern prevents cascading failures:
         * - After N failures, circuit opens
         * - Requests fail fast (don't wait)
         * - Circuit closes after timeout
         */
    }
    
    /**
     * Pattern 4: Retry with exponential backoff
     */
    public static CompletableFuture<String> retryWithBackoff(
            java.util.function.Supplier<CompletableFuture<String>> supplier,
            int maxRetries,
            long initialDelay) {
        
        return supplier.get()
            .exceptionally(ex -> {
                if (maxRetries > 0) {
                    System.out.println("Retry in " + initialDelay + "ms");
                    sleep(initialDelay);
                    return retryWithBackoff(supplier, maxRetries - 1, 
                        initialDelay * 2).join();
                } else {
                    throw new RuntimeException("Max retries exceeded", ex);
                }
            });
    }
    
    public static void retryDemo() throws Exception {
        java.util.concurrent.atomic.AtomicInteger attempts = 
            new java.util.concurrent.atomic.AtomicInteger(0);
        
        CompletableFuture<String> result = retryWithBackoff(() -> 
            CompletableFuture.supplyAsync(() -> {
                int attempt = attempts.incrementAndGet();
                System.out.println("Attempt " + attempt);
                
                if (attempt < 3) {
                    throw new RuntimeException("Temporary failure");
                }
                return "Success on attempt " + attempt;
            }), 
            5,     // max retries
            100    // initial delay
        );
        
        System.out.println(result.get());
        
        /**
         * OUTPUT:
         * Attempt 1
         * Retry in 100ms
         * Attempt 2
         * Retry in 200ms
         * Attempt 3
         * Success on attempt 3
         * 
         * Exponential backoff: 100ms, 200ms, 400ms, 800ms, 1600ms
         */
    }
    
    /**
     * Pattern 5: Bulkhead (resource isolation)
     */
    public static void bulkheadPattern() throws Exception {
        // Separate executors for different services
        ExecutorService userServicePool = Executors.newFixedThreadPool(10);
        ExecutorService orderServicePool = Executors.newFixedThreadPool(20);
        ExecutorService paymentServicePool = Executors.newFixedThreadPool(5);
        
        // User service failure doesn't affect others
        CompletableFuture<String> userFuture = CompletableFuture.supplyAsync(() -> {
            // User service work
            return "User data";
        }, userServicePool);
        
        CompletableFuture<String> orderFuture = CompletableFuture.supplyAsync(() -> {
            // Order service work
            return "Order data";
        }, orderServicePool);
        
        CompletableFuture<String> paymentFuture = CompletableFuture.supplyAsync(() -> {
            // Payment service work
            return "Payment data";
        }, paymentServicePool);
        
        // Combine results
        CompletableFuture<String> result = userFuture.thenCombine(orderFuture, 
            (user, order) -> user + ", " + order)
            .thenCombine(paymentFuture, 
                (combined, payment) -> combined + ", " + payment);
        
        System.out.println(result.get());
        
        userServicePool.shutdown();
        orderServicePool.shutdown();
        paymentServicePool.shutdown();
        
        /**
         * BENEFITS:
         * - Service failures isolated
         * - Resource allocation per service
         * - Better control over concurrency
         * - Prevents cascade failures
         */
    }
    
    /**
     * Pattern 6: Caching with CompletableFuture
     */
    static class AsyncCache<K, V> {
        private final java.util.concurrent.ConcurrentHashMap<K, CompletableFuture<V>> cache = 
            new java.util.concurrent.ConcurrentHashMap<>();
        
        public CompletableFuture<V> get(K key, 
                java.util.function.Function<K, CompletableFuture<V>> loader) {
            
            return cache.computeIfAbsent(key, k -> {
                System.out.println("Cache miss for: " + key);
                return loader.apply(k)
                    .whenComplete((result, ex) -> {
                        if (ex != null) {
                            // Remove failed computation from cache
                            cache.remove(k);
                        }
                    });
            });
        }
    }
    
    public static void cachingDemo() throws Exception {
        AsyncCache<String, String> cache = new AsyncCache<>();
        
        // First call: cache miss
        CompletableFuture<String> result1 = cache.get("user123", userId -> 
            CompletableFuture.supplyAsync(() -> {
                sleep(1000);
                return "Data for " + userId;
            })
        );
        
        // Second call: cache hit (same CompletableFuture)
        CompletableFuture<String> result2 = cache.get("user123", userId -> 
            CompletableFuture.supplyAsync(() -> {
                sleep(1000);
                return "Data for " + userId;
            })
        );
        
        System.out.println("Same instance: " + (result1 == result2));
        System.out.println(result1.get());
        System.out.println(result2.get());  // Instant (already completed)
        
        /**
         * OUTPUT:
         * Cache miss for: user123
         * Same instance: true
         * Data for user123
         * Data for user123
         * 
         * BENEFITS:
         * - Deduplicate concurrent requests
         * - Only one fetch per key
         * - Subsequent requests get same CompletableFuture
         */
    }
    
    private static void sleep(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

---

## Summary

### Quick Reference

**Creating CompletableFuture:**

```java
// Async with return value
CompletableFuture.supplyAsync(() -> compute());

// Async without return value
CompletableFuture.runAsync(() -> doWork());

// With custom executor
CompletableFuture.supplyAsync(() -> compute(), executor);

// Already completed
CompletableFuture.completedFuture(value);
```

**Chaining Operations:**

```java
// Transform (Function<T, R>)
.thenApply(result -> transform(result))

// Consume (Consumer<T>)
.thenAccept(result -> consume(result))

// Execute (Runnable)
.thenRun(() -> doSomething())

// Async variants
.thenApplyAsync(...)
.thenAcceptAsync(...)
.thenRunAsync(...)
```

**Combining Futures:**

```java
// Parallel combination
future1.thenCombine(future2, (r1, r2) -> combine(r1, r2))

// Sequential composition
future.thenCompose(result -> fetchMore(result))

// Wait for all
CompletableFuture.allOf(f1, f2, f3)

// First to complete
CompletableFuture.anyOf(f1, f2, f3)
```

**Exception Handling:**

```java
// Provide fallback
.exceptionally(ex -> fallbackValue)

// Handle both success and failure
.handle((result, ex) -> ...)

// Side effects only
.whenComplete((result, ex) -> ...)

// Timeout (Java 9+)
.orTimeout(2, TimeUnit.SECONDS)
.completeOnTimeout(defaultValue, 2, TimeUnit.SECONDS)
```

### Method Comparison

|Method|Input|Output|Use Case|
|---|---|---|---|
|thenApply|Function<T,R>|CompletableFuture<R>|Transform|
|thenAccept|Consumer<T>|CompletableFuture<Void>|Side effect|
|thenRun|Runnable|CompletableFuture<Void>|Just execute|
|thenCombine|BiFunction|CompletableFuture<R>|Parallel combine|
|thenCompose|Function returning CF|CompletableFuture<R>|Sequential chain|
|exceptionally|Function<Throwable,T>|CompletableFuture<T>|Error recovery|
|handle|BiFunction<T,Throwable,R>|CompletableFuture<R>|Handle both|

### Best Practices

1. ✅ Use async methods for I/O-bound operations
2. ✅ Chain operations instead of blocking with get()
3. ✅ Use custom executors for blocking I/O
4. ✅ Handle exceptions with exceptionally/handle
5. ✅ Use allOf/anyOf for multiple futures
6. ✅ Avoid blocking common pool (use dedicated executor)
7. ❌ Don't call get() in the middle of chain
8. ❌ Don't use blocking calls in async callbacks
9. ❌ Don't ignore exceptions
10. ❌ Don't join() in loops (start all, then wait for all)

### Performance Tips

**Parallel vs Sequential:**

- 3 independent 1-second operations:
    - Sequential: 3 seconds
    - Parallel (CompletableFuture): 1 second
    - **3x speedup!**

**Avoid Blocking:**

```java
// ❌ BAD: 5 seconds total
for (String id : ids) {
    CompletableFuture.supplyAsync(() -> fetch(id)).join();
}

// ✅ GOOD: 1 second total
List<CF<String>> futures = ids.stream()
    .map(id -> CompletableFuture.supplyAsync(() -> fetch(id)))
    .collect(toList());
CompletableFuture.allOf(futures.toArray(new CF[0])).join();
```

---
