# Java Synchronizers

## Overview

Synchronizers are high-level concurrency utilities that coordinate thread execution. This guide covers CountDownLatch, CyclicBarrier, Semaphore, Phaser, and Exchanger - essential tools for building concurrent applications.


---

## 1. CountDownLatch - One-Time Events

### Basic Usage

```java
/**
 * COUNTDOWNLATCH
 * 
 * One-time synchronization barrier
 * Threads wait until count reaches zero
 */

import java.util.concurrent.*;

public class CountDownLatchBasics {
    
    /**
     * Basic countdown
     */
    public static void basicDemo() throws InterruptedException {
        int workers = 3;
        CountDownLatch latch = new CountDownLatch(workers);
        
        System.out.println("Starting workers...");
        
        // Start worker threads
        for (int i = 0; i < workers; i++) {
            final int workerId = i;
            new Thread(() -> {
                try {
                    System.out.println("Worker " + workerId + " starting");
                    Thread.sleep(1000 + workerId * 500);
                    System.out.println("Worker " + workerId + " finished");
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    latch.countDown();  // Decrement count
                }
            }).start();
        }
        
        System.out.println("Main thread waiting for workers...");
        latch.await();  // Wait until count reaches 0
        System.out.println("All workers finished!");
        
        /**
         * OUTPUT:
         * Starting workers...
         * Main thread waiting for workers...
         * Worker 0 starting
         * Worker 1 starting
         * Worker 2 starting
         * Worker 0 finished
         * Worker 1 finished
         * Worker 2 finished
         * All workers finished!
         * 
         * CHARACTERISTICS:
         * - Count initialized at construction
         * - countDown() decrements count
         * - await() blocks until count reaches 0
         * - One-time use (cannot reset)
         */
    }
    
    /**
     * How it works internally
     */
    public static void internalStructure() {
        /**
         * COUNTDOWNLATCH INTERNALS:
         * 
         * private static final class Sync extends AbstractQueuedSynchronizer {
         *     Sync(int count) {
         *         setState(count);
         *     }
         *     
         *     public int tryAcquireShared(int acquires) {
         *         return (getState() == 0) ? 1 : -1;
         *     }
         *     
         *     public boolean tryReleaseShared(int releases) {
         *         for (;;) {
         *             int c = getState();
         *             if (c == 0)
         *                 return false;
         *             int nextc = c - 1;
         *             if (compareAndSetState(c, nextc))
         *                 return nextc == 0;
         *         }
         *     }
         * }
         * 
         * OPERATIONS:
         * 
         * await():
         * - Check if count == 0
         * - If yes, return immediately
         * - If no, park thread in wait queue
         * 
         * countDown():
         * - Decrement count (CAS)
         * - If count becomes 0, wake all waiting threads
         * 
         * Built on AbstractQueuedSynchronizer (AQS)
         */
    }
}
```

### Real-World Examples

```java
/**
 * COUNTDOWNLATCH REAL-WORLD EXAMPLES
 */

public class CountDownLatchExamples {
    
    /**
     * Example 1: Application startup coordination
     */
    static class ApplicationStartup {
        private final CountDownLatch latch = new CountDownLatch(3);
        
        public void start() throws InterruptedException {
            System.out.println("Starting application...");
            
            // Start services concurrently
            new Thread(this::startDatabase, "Database").start();
            new Thread(this::startCache, "Cache").start();
            new Thread(this::startWebServer, "WebServer").start();
            
            // Wait for all services to be ready
            latch.await();
            System.out.println("All services ready - Application started!");
        }
        
        private void startDatabase() {
            try {
                System.out.println("Database: Initializing...");
                Thread.sleep(2000);
                System.out.println("Database: Ready");
                latch.countDown();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        
        private void startCache() {
            try {
                System.out.println("Cache: Initializing...");
                Thread.sleep(1000);
                System.out.println("Cache: Ready");
                latch.countDown();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        
        private void startWebServer() {
            try {
                System.out.println("WebServer: Initializing...");
                Thread.sleep(1500);
                System.out.println("WebServer: Ready");
                latch.countDown();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
    
    public static void startupDemo() throws InterruptedException {
        ApplicationStartup app = new ApplicationStartup();
        app.start();
        
        /**
         * OUTPUT:
         * Starting application...
         * Database: Initializing...
         * Cache: Initializing...
         * WebServer: Initializing...
         * Cache: Ready
         * WebServer: Ready
         * Database: Ready
         * All services ready - Application started!
         * 
         * USE CASE:
         * - Ensure all dependencies ready before processing requests
         * - Parallel initialization
         * - Coordinated startup
         */
    }
    
    /**
     * Example 2: Race start signal
     */
    static class RaceController {
        public void startRace(int runners) throws InterruptedException {
            CountDownLatch startSignal = new CountDownLatch(1);
            CountDownLatch finishLine = new CountDownLatch(runners);
            
            // Create runners
            for (int i = 0; i < runners; i++) {
                final int runnerId = i + 1;
                new Thread(() -> {
                    try {
                        System.out.println("Runner " + runnerId + " ready");
                        startSignal.await();  // Wait for start signal
                        
                        // Run!
                        long runTime = (long)(Math.random() * 3000 + 2000);
                        Thread.sleep(runTime);
                        
                        System.out.println("Runner " + runnerId + " finished");
                        finishLine.countDown();
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }).start();
            }
            
            // Wait for all runners to be ready
            Thread.sleep(1000);
            
            System.out.println("\nOn your marks... Get set... GO!");
            startSignal.countDown();  // Release all runners at once
            
            // Wait for all runners to finish
            finishLine.await();
            System.out.println("\nRace complete!");
        }
    }
    
    public static void raceDemo() throws InterruptedException {
        RaceController race = new RaceController();
        race.startRace(5);
        
        /**
         * OUTPUT:
         * Runner 1 ready
         * Runner 2 ready
         * Runner 3 ready
         * Runner 4 ready
         * Runner 5 ready
         * 
         * On your marks... Get set... GO!
         * Runner 3 finished
         * Runner 1 finished
         * Runner 5 finished
         * Runner 2 finished
         * Runner 4 finished
         * 
         * Race complete!
         * 
         * PATTERN:
         * - All threads wait at same point
         * - Single countDown() releases all
         * - Common in testing, benchmarks
         */
    }
    
    /**
     * Example 3: Timeout handling
     */
    public static void timeoutDemo() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(3);
        
        // Start 2 workers (3rd never starts)
        for (int i = 0; i < 2; i++) {
            final int id = i;
            new Thread(() -> {
                try {
                    Thread.sleep(1000);
                    System.out.println("Worker " + id + " done");
                    latch.countDown();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }).start();
        }
        
        // Wait with timeout
        boolean completed = latch.await(3, TimeUnit.SECONDS);
        
        if (completed) {
            System.out.println("All workers completed");
        } else {
            System.out.println("Timeout! Remaining count: " + latch.getCount());
        }
        
        /**
         * OUTPUT:
         * Worker 0 done
         * Worker 1 done
         * Timeout! Remaining count: 1
         * 
         * await(timeout, unit):
         * - Returns true if count reached 0
         * - Returns false if timeout
         * - Useful for preventing indefinite waits
         */
    }
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== Startup Demo ===");
        startupDemo();
        
        System.out.println("\n=== Race Demo ===");
        raceDemo();
        
        System.out.println("\n=== Timeout Demo ===");
        timeoutDemo();
    }
}
```

---

## 2. CyclicBarrier - Recurring Synchronization

### Basic Usage

```java
/**
 * CYCLICBARRIER
 * 
 * Reusable synchronization point
 * Threads wait until all parties arrive
 */

public class CyclicBarrierBasics {
    
    /**
     * Basic barrier
     */
    public static void basicDemo() throws InterruptedException {
        int parties = 3;
        CyclicBarrier barrier = new CyclicBarrier(parties, () -> {
            System.out.println("All parties arrived - barrier action running");
        });
        
        // Start worker threads
        for (int i = 0; i < parties; i++) {
            final int workerId = i;
            new Thread(() -> {
                try {
                    System.out.println("Worker " + workerId + " doing work");
                    Thread.sleep(1000 + workerId * 500);
                    System.out.println("Worker " + workerId + " waiting at barrier");
                    
                    barrier.await();  // Wait for all parties
                    
                    System.out.println("Worker " + workerId + " continuing");
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }).start();
        }
        
        Thread.sleep(5000);
        
        /**
         * OUTPUT:
         * Worker 0 doing work
         * Worker 1 doing work
         * Worker 2 doing work
         * Worker 0 waiting at barrier
         * Worker 1 waiting at barrier
         * Worker 2 waiting at barrier
         * All parties arrived - barrier action running
         * Worker 0 continuing
         * Worker 1 continuing
         * Worker 2 continuing
         * 
         * CHARACTERISTICS:
         * - All threads wait at barrier
         * - When last thread arrives, all released
         * - Optional barrier action runs once per cycle
         * - Reusable (can cycle multiple times)
         */
    }
    
    /**
     * Multiple cycles
     */
    public static void multipleCycles() throws InterruptedException {
        int parties = 3;
        CyclicBarrier barrier = new CyclicBarrier(parties, () -> {
            System.out.println("=== Barrier tripped ===");
        });
        
        for (int i = 0; i < parties; i++) {
            final int workerId = i;
            new Thread(() -> {
                try {
                    for (int cycle = 1; cycle <= 3; cycle++) {
                        System.out.println("Worker " + workerId + " - Cycle " + cycle);
                        Thread.sleep(500);
                        barrier.await();
                    }
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }).start();
        }
        
        Thread.sleep(5000);
        
        /**
         * OUTPUT:
         * Worker 0 - Cycle 1
         * Worker 1 - Cycle 1
         * Worker 2 - Cycle 1
         * === Barrier tripped ===
         * Worker 0 - Cycle 2
         * Worker 1 - Cycle 2
         * Worker 2 - Cycle 2
         * === Barrier tripped ===
         * Worker 0 - Cycle 3
         * Worker 1 - Cycle 3
         * Worker 2 - Cycle 3
         * === Barrier tripped ===
         * 
         * REUSABLE:
         * - Barrier resets automatically
         * - Can be used multiple times
         * - Unlike CountDownLatch (one-time)
         */
    }
    
    /**
     * How it works internally
     */
    public static void internalStructure() {
        /**
         * CYCLICBARRIER INTERNALS:
         * 
         * private final ReentrantLock lock = new ReentrantLock();
         * private final Condition trip = lock.newCondition();
         * private final int parties;
         * private final Runnable barrierCommand;
         * private int count;  // Number of parties still waiting
         * 
         * AWAIT ALGORITHM:
         * 
         * lock.lock();
         * try {
         *     int index = --count;
         *     
         *     if (index == 0) {  // Last thread to arrive
         *         if (barrierCommand != null)
         *             barrierCommand.run();
         *         count = parties;  // Reset for next cycle
         *         trip.signalAll();  // Wake all waiting threads
         *         return 0;
         *     }
         *     
         *     // Not last thread, wait
         *     while (count != parties) {
         *         trip.await();
         *     }
         * } finally {
         *     lock.unlock();
         * }
         * 
         * Built on ReentrantLock + Condition
         */
    }
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== Basic Demo ===");
        basicDemo();
        
        System.out.println("\n=== Multiple Cycles ===");
        multipleCycles();
    }
}
```

### Real-World Examples

```java
/**
 * CYCLICBARRIER REAL-WORLD EXAMPLES
 */

public class CyclicBarrierExamples {
    
    /**
     * Example 1: Parallel matrix multiplication
     */
    static class ParallelMatrixMultiplier {
        private final int[][] matrixA;
        private final int[][] matrixB;
        private final int[][] result;
        private final int size;
        private final int threads;
        
        public ParallelMatrixMultiplier(int[][] a, int[][] b, int threads) {
            this.matrixA = a;
            this.matrixB = b;
            this.size = a.length;
            this.result = new int[size][size];
            this.threads = threads;
        }
        
        public int[][] multiply() throws InterruptedException, BrokenBarrierException {
            CyclicBarrier barrier = new CyclicBarrier(threads, () -> {
                System.out.println("Phase complete");
            });
            
            int rowsPerThread = size / threads;
            
            // Create worker threads
            Thread[] workers = new Thread[threads];
            for (int i = 0; i < threads; i++) {
                final int startRow = i * rowsPerThread;
                final int endRow = (i == threads - 1) ? size : (i + 1) * rowsPerThread;
                
                workers[i] = new Thread(() -> {
                    try {
                        // Compute assigned rows
                        for (int row = startRow; row < endRow; row++) {
                            for (int col = 0; col < size; col++) {
                                int sum = 0;
                                for (int k = 0; k < size; k++) {
                                    sum += matrixA[row][k] * matrixB[k][col];
                                }
                                result[row][col] = sum;
                            }
                        }
                        
                        // Wait for all threads to complete
                        barrier.await();
                    } catch (InterruptedException | BrokenBarrierException e) {
                        e.printStackTrace();
                    }
                });
                workers[i].start();
            }
            
            // Wait for all workers
            for (Thread worker : workers) {
                worker.join();
            }
            
            return result;
        }
    }
    
    public static void matrixMultiplicationDemo() throws InterruptedException, BrokenBarrierException {
        int size = 100;
        int[][] a = new int[size][size];
        int[][] b = new int[size][size];
        
        // Initialize matrices
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                a[i][j] = i + j;
                b[i][j] = i - j;
            }
        }
        
        ParallelMatrixMultiplier multiplier = new ParallelMatrixMultiplier(a, b, 4);
        
        long start = System.currentTimeMillis();
        int[][] result = multiplier.multiply();
        long elapsed = System.currentTimeMillis() - start;
        
        System.out.println("Matrix multiplication completed in " + elapsed + "ms");
        
        /**
         * USE CASE:
         * - Parallel computation with synchronization points
         * - All workers must complete phase before next phase
         * - Barrier ensures coordination
         */
    }
    
    /**
     * Example 2: MapReduce-style processing
     */
    static class MapReduceProcessor {
        private final int workers;
        private final CyclicBarrier mapBarrier;
        private final CyclicBarrier reduceBarrier;
        private final java.util.List<Integer> data;
        private final java.util.List<Integer>[] partialResults;
        private int finalResult = 0;
        
        @SuppressWarnings("unchecked")
        public MapReduceProcessor(java.util.List<Integer> data, int workers) {
            this.data = data;
            this.workers = workers;
            this.partialResults = new java.util.List[workers];
            
            // Barrier after map phase
            this.mapBarrier = new CyclicBarrier(workers, () -> {
                System.out.println("Map phase complete");
            });
            
            // Barrier after reduce phase
            this.reduceBarrier = new CyclicBarrier(workers, () -> {
                System.out.println("Reduce phase complete");
                // Final aggregation
                finalResult = 0;
                for (java.util.List<Integer> partial : partialResults) {
                    if (partial != null) {
                        for (int val : partial) {
                            finalResult += val;
                        }
                    }
                }
            });
        }
        
        public int process() throws InterruptedException {
            int chunkSize = data.size() / workers;
            
            Thread[] threads = new Thread[workers];
            for (int i = 0; i < workers; i++) {
                final int workerId = i;
                final int start = i * chunkSize;
                final int end = (i == workers - 1) ? data.size() : (i + 1) * chunkSize;
                
                threads[i] = new Thread(() -> {
                    try {
                        // Map phase
                        java.util.List<Integer> mapped = new java.util.ArrayList<>();
                        for (int j = start; j < end; j++) {
                            mapped.add(data.get(j) * 2);  // Map function
                        }
                        
                        mapBarrier.await();  // Wait for all map tasks
                        
                        // Reduce phase
                        partialResults[workerId] = mapped;
                        
                        reduceBarrier.await();  // Wait for all reduce tasks
                        
                    } catch (InterruptedException | BrokenBarrierException e) {
                        e.printStackTrace();
                    }
                });
                threads[i].start();
            }
            
            for (Thread thread : threads) {
                thread.join();
            }
            
            return finalResult;
        }
    }
    
    public static void mapReduceDemo() throws InterruptedException {
        java.util.List<Integer> data = new java.util.ArrayList<>();
        for (int i = 1; i <= 1000; i++) {
            data.add(i);
        }
        
        MapReduceProcessor processor = new MapReduceProcessor(data, 4);
        int result = processor.process();
        
        System.out.println("MapReduce result: " + result);
        System.out.println("Expected: " + (1000 * 1001));  // Sum of 1..1000 doubled
        
        /**
         * OUTPUT:
         * Map phase complete
         * Reduce phase complete
         * MapReduce result: 1001000
         * Expected: 1001000
         * 
         * TWO-PHASE PROCESSING:
         * - Phase 1: Map (transform data)
         * - Barrier
         * - Phase 2: Reduce (aggregate results)
         * - Barrier
         */
    }
    
    public static void main(String[] args) throws InterruptedException, BrokenBarrierException {
        System.out.println("=== Matrix Multiplication ===");
        matrixMultiplicationDemo();
        
        System.out.println("\n=== MapReduce ===");
        mapReduceDemo();
    }
}
```

---

## 3. Semaphore - Resource Limiting

### Basic Usage

```java
/**
 * SEMAPHORE
 * 
 * Controls access to limited resources
 * Maintains a set of permits
 */

public class SemaphoreBasics {
    
    /**
     * Basic semaphore
     */
    public static void basicDemo() throws InterruptedException {
        Semaphore semaphore = new Semaphore(2);  // 2 permits
        
        // Start 5 threads (but only 2 can run at once)
        for (int i = 0; i < 5; i++) {
            final int threadId = i;
            new Thread(() -> {
                try {
                    System.out.println("Thread " + threadId + " waiting for permit");
                    semaphore.acquire();  // Acquire permit (blocks if none available)
                    
                    System.out.println("Thread " + threadId + " got permit");
                    Thread.sleep(2000);  // Use resource
                    System.out.println("Thread " + threadId + " releasing permit");
                    
                    semaphore.release();  // Release permit
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }).start();
        }
        
        Thread.sleep(12000);
        
        /**
         * OUTPUT:
         * Thread 0 waiting for permit
         * Thread 1 waiting for permit
         * Thread 2 waiting for permit
         * Thread 3 waiting for permit
         * Thread 4 waiting for permit
         * Thread 0 got permit
         * Thread 1 got permit
         * (2 seconds)
         * Thread 0 releasing permit
         * Thread 1 releasing permit
         * Thread 2 got permit
         * Thread 3 got permit
         * (2 seconds)
         * Thread 2 releasing permit
         * Thread 3 releasing permit
         * Thread 4 got permit
         * ...
         * 
         * CHARACTERISTICS:
         * - Limits concurrent access
         * - acquire() decrements permits (blocks if 0)
         * - release() increments permits
         * - Not tied to specific thread (can acquire in one, release in another)
         */
    }
    
    /**
     * tryAcquire with timeout
     */
    public static void tryAcquireDemo() throws InterruptedException {
        Semaphore semaphore = new Semaphore(1);
        
        // Thread 1 acquires permit
        semaphore.acquire();
        System.out.println("Permit acquired");
        
        // Thread 2 tries to acquire with timeout
        boolean acquired = semaphore.tryAcquire(1, TimeUnit.SECONDS);
        
        if (acquired) {
            System.out.println("Acquired permit");
            semaphore.release();
        } else {
            System.out.println("Could not acquire permit within timeout");
        }
        
        semaphore.release();
        
        /**
         * OUTPUT:
         * Permit acquired
         * Could not acquire permit within timeout
         * 
         * tryAcquire():
         * - tryAcquire() - immediate, returns boolean
         * - tryAcquire(timeout, unit) - waits up to timeout
         * - Useful for preventing indefinite blocking
         */
    }
    
    /**
     * Fair vs non-fair
     */
    public static void fairnessDemo() throws InterruptedException {
        // Non-fair (default)
        Semaphore nonFair = new Semaphore(1, false);
        
        // Fair (FIFO)
        Semaphore fair = new Semaphore(1, true);
        
        /**
         * NON-FAIR:
         * - Faster (no ordering overhead)
         * - Threads may jump queue
         * - Possible starvation
         * 
         * FAIR:
         * - FIFO ordering
         * - No starvation
         * - Slightly slower
         * 
         * Similar to ReentrantLock fairness
         */
    }
    
    /**
     * How it works internally
     */
    public static void internalStructure() {
        /**
         * SEMAPHORE INTERNALS:
         * 
         * abstract static class Sync extends AbstractQueuedSynchronizer {
         *     Sync(int permits) {
         *         setState(permits);
         *     }
         *     
         *     final int nonfairTryAcquireShared(int acquires) {
         *         for (;;) {
         *             int available = getState();
         *             int remaining = available - acquires;
         *             if (remaining < 0 ||
         *                 compareAndSetState(available, remaining))
         *                 return remaining;
         *         }
         *     }
         *     
         *     protected final boolean tryReleaseShared(int releases) {
         *         for (;;) {
         *             int current = getState();
         *             int next = current + releases;
         *             if (compareAndSetState(current, next))
         *                 return true;
         *         }
         *     }
         * }
         * 
         * Built on AbstractQueuedSynchronizer (AQS)
         * Uses CAS for permit count
         */
    }
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== Basic Demo ===");
        basicDemo();
        
        System.out.println("\n=== TryAcquire Demo ===");
        tryAcquireDemo();
    }
}
```

### Real-World Examples

```java
/**
 * SEMAPHORE REAL-WORLD EXAMPLES
 */

public class SemaphoreExamples {
    
    /**
     * Example 1: Connection pool
     */
    static class ConnectionPool {
        private final Semaphore available;
        private final java.util.Queue<Connection> connections;
        
        public ConnectionPool(int size) {
            available = new Semaphore(size, true);  // Fair
            connections = new java.util.concurrent.ConcurrentLinkedQueue<>();
            
            // Initialize pool
            for (int i = 0; i < size; i++) {
                connections.offer(new Connection("Connection-" + i));
            }
        }
        
        public Connection getConnection() throws InterruptedException {
            available.acquire();  // Wait for available connection
            return connections.poll();
        }
        
        public void returnConnection(Connection conn) {
            connections.offer(conn);
            available.release();
        }
        
        static class Connection {
            private final String id;
            
            Connection(String id) {
                this.id = id;
            }
            
            public void execute(String query) {
                System.out.println(id + " executing: " + query);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
            
            @Override
            public String toString() {
                return id;
            }
        }
    }
    
    public static void connectionPoolDemo() throws InterruptedException {
        ConnectionPool pool = new ConnectionPool(3);  // Pool of 3 connections
        
        // 10 clients trying to use pool
        CountDownLatch latch = new CountDownLatch(10);
        
        for (int i = 0; i < 10; i++) {
            final int clientId = i;
            new Thread(() -> {
                try {
                    System.out.println("Client " + clientId + " requesting connection");
                    ConnectionPool.Connection conn = pool.getConnection();
                    System.out.println("Client " + clientId + " got " + conn);
                    
                    conn.execute("SELECT * FROM table");
                    
                    System.out.println("Client " + clientId + " returning " + conn);
                    pool.returnConnection(conn);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    latch.countDown();
                }
            }).start();
        }
        
        latch.await();
        System.out.println("All clients served");
        
        /**
         * OUTPUT:
         * Client 0 requesting connection
         * Client 1 requesting connection
         * ...
         * Client 0 got Connection-0
         * Client 1 got Connection-1
         * Client 2 got Connection-2
         * (others waiting)
         * Connection-0 executing: SELECT * FROM table
         * Connection-1 executing: SELECT * FROM table
         * Connection-2 executing: SELECT * FROM table
         * Client 0 returning Connection-0
         * Client 3 got Connection-0
         * ...
         * 
         * USE CASE:
         * - Database connection pools
         * - Thread pools
         * - Any limited resource pool
         */
    }
    
    /**
     * Example 2: Rate limiter
     */
    static class RateLimiter {
        private final Semaphore semaphore;
        private final int maxPermits;
        private final long refillIntervalMs;
        
        public RateLimiter(int permitsPerSecond) {
            this.maxPermits = permitsPerSecond;
            this.semaphore = new Semaphore(permitsPerSecond);
            this.refillIntervalMs = 1000 / permitsPerSecond;
            
            // Refill permits periodically
            startRefillThread();
        }
        
        private void startRefillThread() {
            new Thread(() -> {
                while (true) {
                    try {
                        Thread.sleep(refillIntervalMs);
                        
                        // Add permit if not at max
                        if (semaphore.availablePermits() < maxPermits) {
                            semaphore.release();
                        }
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            }, "Refill-Thread").start();
        }
        
        public boolean tryAcquire() {
            return semaphore.tryAcquire();
        }
        
        public void acquire() throws InterruptedException {
            semaphore.acquire();
        }
    }
    
    public static void rateLimiterDemo() throws InterruptedException {
        RateLimiter limiter = new RateLimiter(5);  // 5 requests per second
        
        // Try to make 20 requests
        for (int i = 0; i < 20; i++) {
            final int requestId = i;
            new Thread(() -> {
                try {
                    limiter.acquire();
                    System.out.println("Request " + requestId + " processed at " + 
                        System.currentTimeMillis());
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }).start();
            
            Thread.sleep(100);
        }
        
        Thread.sleep(5000);
        
        /**
         * OUTPUT:
         * Request 0 processed at 1234567890100
         * Request 1 processed at 1234567890200
         * Request 2 processed at 1234567890300
         * Request 3 processed at 1234567890400
         * Request 4 processed at 1234567890500
         * (wait ~200ms for refill)
         * Request 5 processed at 1234567890700
         * ...
         * 
         * USE CASE:
         * - API rate limiting
         * - Throttling requests
         * - Resource usage control
         */
    }
    
    /**
     * Example 3: Parking lot
     */
    static class ParkingLot {
        private final Semaphore spaces;
        private final int capacity;
        
        public ParkingLot(int capacity) {
            this.capacity = capacity;
            this.spaces = new Semaphore(capacity, true);
        }
        
        public boolean park(String car) throws InterruptedException {
            System.out.println(car + " trying to park");
            
            if (spaces.tryAcquire(2, TimeUnit.SECONDS)) {
                System.out.println(car + " parked. Spaces available: " + 
                    spaces.availablePermits());
                return true;
            } else {
                System.out.println(car + " could not find space (timeout)");
                return false;
            }
        }
        
        public void leave(String car) {
            spaces.release();
            System.out.println(car + " left. Spaces available: " + 
                spaces.availablePermits());
        }
    }
    
    public static void parkingLotDemo() throws InterruptedException {
        ParkingLot lot = new ParkingLot(3);
        
        // Cars arriving
        for (int i = 0; i < 6; i++) {
            final String car = "Car-" + i;
            new Thread(() -> {
                try {
                    if (lot.park(car)) {
                        Thread.sleep(3000);  // Parked for 3 seconds
                        lot.leave(car);
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }).start();
            
            Thread.sleep(500);
        }
        
        Thread.sleep(8000);
        
        /**
         * USE CASE:
         * - Limited physical resources
         * - Capacity management
         * - Queue management
         */
    }
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== Connection Pool ===");
        connectionPoolDemo();
        
        System.out.println("\n=== Rate Limiter ===");
        rateLimiterDemo();
        
        System.out.println("\n=== Parking Lot ===");
        parkingLotDemo();
    }
}
```

---

## 4. Phaser - Dynamic Parties

### Basic Usage

```java
/**
 * PHASER
 * 
 * Flexible multi-phase synchronization
 * Dynamic number of parties
 */

public class PhaserBasics {
    
    /**
     * Basic phaser
     */
    public static void basicDemo() throws InterruptedException {
        Phaser phaser = new Phaser(3);  // 3 parties
        
        for (int i = 0; i < 3; i++) {
            final int workerId = i;
            new Thread(() -> {
                System.out.println("Worker " + workerId + " phase 0");
                phaser.arriveAndAwaitAdvance();  // Phase 0 → 1
                
                System.out.println("Worker " + workerId + " phase 1");
                phaser.arriveAndAwaitAdvance();  // Phase 1 → 2
                
                System.out.println("Worker " + workerId + " phase 2");
                phaser.arriveAndAwaitAdvance();  // Phase 2 → 3
                
                System.out.println("Worker " + workerId + " done");
            }).start();
        }
        
        Thread.sleep(5000);
        
        /**
         * OUTPUT:
         * Worker 0 phase 0
         * Worker 1 phase 0
         * Worker 2 phase 0
         * Worker 0 phase 1
         * Worker 1 phase 1
         * Worker 2 phase 1
         * Worker 0 phase 2
         * Worker 1 phase 2
         * Worker 2 phase 2
         * Worker 0 done
         * Worker 1 done
         * Worker 2 done
         * 
         * CHARACTERISTICS:
         * - Multi-phase synchronization
         * - All parties advance through phases together
         * - Phase number tracks progress
         */
    }
    
    /**
     * Dynamic parties
     */
    public static void dynamicPartiesDemo() throws InterruptedException {
        Phaser phaser = new Phaser(1);  // Start with 1 (main thread)
        
        System.out.println("Starting with " + phaser.getRegisteredParties() + " parties");
        
        for (int i = 0; i < 3; i++) {
            final int workerId = i;
            
            phaser.register();  // Dynamically add party
            System.out.println("Registered worker " + workerId + 
                ", parties: " + phaser.getRegisteredParties());
            
            new Thread(() -> {
                System.out.println("Worker " + workerId + " working");
                phaser.arriveAndAwaitAdvance();
                System.out.println("Worker " + workerId + " done");
                
                phaser.arriveAndDeregister();  // Remove from phaser
            }).start();
            
            Thread.sleep(500);
        }
        
        System.out.println("Main thread arriving");
        phaser.arriveAndAwaitAdvance();
        System.out.println("Phase 0 complete");
        
        Thread.sleep(1000);
        System.out.println("Final parties: " + phaser.getRegisteredParties());
        
        /**
         * OUTPUT:
         * Starting with 1 parties
         * Registered worker 0, parties: 2
         * Worker 0 working
         * Registered worker 1, parties: 3
         * Worker 1 working
         * Registered worker 2, parties: 4
         * Worker 2 working
         * Main thread arriving
         * Phase 0 complete
         * Worker 0 done
         * Worker 1 done
         * Worker 2 done
         * Final parties: 1
         * 
         * DYNAMIC:
         * - register() adds party
         * - arriveAndDeregister() removes party
         * - Unlike CyclicBarrier (fixed parties)
         */
    }
    
    /**
     * Phaser termination
     */
    public static void terminationDemo() {
        Phaser phaser = new Phaser(3) {
            @Override
            protected boolean onAdvance(int phase, int registeredParties) {
                System.out.println("Phase " + phase + " completed, parties: " + 
                    registeredParties);
                return phase >= 2 || registeredParties == 0;  // Terminate after phase 2
            }
        };
        
        for (int i = 0; i < 3; i++) {
            final int workerId = i;
            new Thread(() -> {
                while (!phaser.isTerminated()) {
                    System.out.println("Worker " + workerId + " phase " + 
                        phaser.getPhase());
                    phaser.arriveAndAwaitAdvance();
                }
                System.out.println("Worker " + workerId + " detected termination");
            }).start();
        }
        
        /**
         * onAdvance():
         * - Called when last party arrives
         * - Return true to terminate phaser
         * - Can implement custom phase logic
         */
    }
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== Basic Demo ===");
        basicDemo();
        
        System.out.println("\n=== Dynamic Parties ===");
        dynamicPartiesDemo();
        
        System.out.println("\n=== Termination ===");
        terminationDemo();
        Thread.sleep(2000);
    }
}
```

### Real-World Examples

```java
/**
 * PHASER REAL-WORLD EXAMPLES
 */

public class PhaserExamples {
    
    /**
     * Example 1: Iterative algorithm with phases
     */
    static class IterativeComputation {
        private final Phaser phaser;
        private final int workers;
        private final double[][] data;
        private final int iterations;
        
        public IterativeComputation(int workers, int size, int iterations) {
            this.workers = workers;
            this.data = new double[size][size];
            this.iterations = iterations;
            this.phaser = new Phaser(workers);
            
            // Initialize data
            for (int i = 0; i < size; i++) {
                for (int j = 0; j < size; j++) {
                    data[i][j] = Math.random();
                }
            }
        }
        
        public void compute() throws InterruptedException {
            Thread[] threads = new Thread[workers];
            int rowsPerWorker = data.length / workers;
            
            for (int i = 0; i < workers; i++) {
                final int workerId = i;
                final int startRow = i * rowsPerWorker;
                final int endRow = (i == workers - 1) ? data.length : 
                    (i + 1) * rowsPerWorker;
                
                threads[i] = new Thread(() -> {
                    for (int iter = 0; iter < iterations; iter++) {
                        // Compute phase
                        for (int row = startRow; row < endRow; row++) {
                            for (int col = 0; col < data[row].length; col++) {
                                data[row][col] = Math.sqrt(data[row][col] + 0.001);
                            }
                        }
                        
                        // Synchronize after each iteration
                        phaser.arriveAndAwaitAdvance();
                    }
                });
                threads[i].start();
            }
            
            for (Thread thread : threads) {
                thread.join();
            }
            
            System.out.println("Computation complete after " + iterations + 
                " iterations");
        }
    }
    
    public static void iterativeComputationDemo() throws InterruptedException {
        IterativeComputation comp = new IterativeComputation(4, 100, 10);
        
        long start = System.currentTimeMillis();
        comp.compute();
        long elapsed = System.currentTimeMillis() - start;
        
        System.out.println("Time: " + elapsed + "ms");
        
        /**
         * USE CASE:
         * - Iterative algorithms (Jacobi, Gauss-Seidel)
         * - Simulations with time steps
         * - Any multi-phase computation
         */
    }
    
    /**
     * Example 2: Pipeline processing
     */
    static class Pipeline {
        private final Phaser phaser;
        
        public Pipeline(int stages) {
            this.phaser = new Phaser(stages);
        }
        
        public void process(String data) {
            // Stage 1: Parse
            new Thread(() -> {
                String parsed = "parsed(" + data + ")";
                System.out.println("Stage 1: " + parsed);
                phaser.arriveAndAwaitAdvance();
            }).start();
            
            // Stage 2: Validate
            new Thread(() -> {
                phaser.arriveAndAwaitAdvance();  // Wait for stage 1
                String validated = "validated(...)";
                System.out.println("Stage 2: " + validated);
                phaser.arriveAndAwaitAdvance();
            }).start();
            
            // Stage 3: Process
            new Thread(() -> {
                phaser.arriveAndAwaitAdvance();  // Wait for stage 2
                String processed = "processed(...)";
                System.out.println("Stage 3: " + processed);
                phaser.arriveAndAwaitAdvance();
            }).start();
        }
    }
    
    public static void pipelineDemo() throws InterruptedException {
        Pipeline pipeline = new Pipeline(3);
        pipeline.process("input-data");
        
        Thread.sleep(2000);
        
        /**
         * OUTPUT:
         * Stage 1: parsed(input-data)
         * Stage 2: validated(...)
         * Stage 3: processed(...)
         * 
         * USE CASE:
         * - Multi-stage pipelines
         * - ETL processes
         * - Data processing workflows
         */
    }
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== Iterative Computation ===");
        iterativeComputationDemo();
        
        System.out.println("\n=== Pipeline ===");
        pipelineDemo();
    }
}
```

---

## 5. Exchanger - Thread Pairs

### Basic Usage and Examples

```java
/**
 * EXCHANGER
 * 
 * Thread pair synchronization
 * Exchange data between two threads
 */

public class ExchangerExamples {
    
    /**
     * Basic exchanger
     */
    public static void basicDemo() throws InterruptedException {
        Exchanger<String> exchanger = new Exchanger<>();
        
        // Thread 1
        new Thread(() -> {
            try {
                String data1 = "Data from Thread 1";
                System.out.println("Thread 1 offering: " + data1);
                
                String received = exchanger.exchange(data1);
                System.out.println("Thread 1 received: " + received);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
        
        // Thread 2
        new Thread(() -> {
            try {
                Thread.sleep(1000);  // Simulate work
                
                String data2 = "Data from Thread 2";
                System.out.println("Thread 2 offering: " + data2);
                
                String received = exchanger.exchange(data2);
                System.out.println("Thread 2 received: " + received);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
        
        Thread.sleep(3000);
        
        /**
         * OUTPUT:
         * Thread 1 offering: Data from Thread 1
         * Thread 2 offering: Data from Thread 2
         * Thread 1 received: Data from Thread 2
         * Thread 2 received: Data from Thread 1
         * 
         * CHARACTERISTICS:
         * - Synchronizes exactly two threads
         * - Both threads block until partner arrives
         * - Exchange data atomically
         */
    }
    
    /**
     * Example: Producer-Consumer with buffers
     */
    static class BufferedProducerConsumer {
        private final Exchanger<java.util.List<Integer>> exchanger = 
            new Exchanger<>();
        
        public void run() {
            // Producer
            new Thread(() -> {
                java.util.List<Integer> currentBuffer = new java.util.ArrayList<>();
                
                try {
                    for (int i = 0; i < 100; i++) {
                        currentBuffer.add(i);
                        
                        // When buffer full, exchange with consumer
                        if (currentBuffer.size() == 10) {
                            System.out.println("Producer filled buffer, exchanging...");
                            currentBuffer = exchanger.exchange(currentBuffer);
                            System.out.println("Producer got empty buffer back");
                        }
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }, "Producer").start();
            
            // Consumer
            new Thread(() -> {
                java.util.List<Integer> currentBuffer = new java.util.ArrayList<>();
                
                try {
                    for (int i = 0; i < 10; i++) {
                        System.out.println("Consumer waiting for full buffer...");
                        currentBuffer = exchanger.exchange(currentBuffer);
                        
                        System.out.println("Consumer processing: " + currentBuffer);
                        Thread.sleep(500);  // Simulate processing
                        
                        currentBuffer.clear();  // Empty buffer for reuse
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }, "Consumer").start();
        }
    }
    
    public static void producerConsumerDemo() throws InterruptedException {
        new BufferedProducerConsumer().run();
        Thread.sleep(8000);
        
        /**
         * OUTPUT:
         * Consumer waiting for full buffer...
         * Producer filled buffer, exchanging...
         * Consumer processing: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
         * Producer got empty buffer back
         * Producer filled buffer, exchanging...
         * Consumer waiting for full buffer...
         * Consumer processing: [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
         * ...
         * 
         * USE CASE:
         * - Double buffering
         * - Producer fills buffer while consumer processes
         * - Efficient buffer reuse
         */
    }
    
    /**
     * Example: Genetic algorithm
     */
    static class GeneticAlgorithm {
        private final Exchanger<String> exchanger = new Exchanger<>();
        
        public void run() {
            // Population 1
            new Thread(() -> {
                String chromosome = "AAAA";
                try {
                    for (int generation = 0; generation < 5; generation++) {
                        System.out.println("Pop1 Gen" + generation + ": " + chromosome);
                        
                        // Evolve
                        chromosome = mutate(chromosome);
                        
                        // Exchange best chromosomes
                        String partner = exchanger.exchange(chromosome);
                        chromosome = crossover(chromosome, partner);
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }).start();
            
            // Population 2
            new Thread(() -> {
                String chromosome = "TTTT";
                try {
                    for (int generation = 0; generation < 5; generation++) {
                        System.out.println("Pop2 Gen" + generation + ": " + chromosome);
                        
                        // Evolve
                        chromosome = mutate(chromosome);
                        
                        // Exchange best chromosomes
                        String partner = exchanger.exchange(chromosome);
                        chromosome = crossover(chromosome, partner);
                        
                        Thread.sleep(500);
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }).start();
        }
        
        private String mutate(String chromosome) {
            // Simple mutation
            return chromosome.substring(0, 1) + 
                (Math.random() > 0.5 ? "A" : "T") + 
                chromosome.substring(2);
        }
        
        private String crossover(String c1, String c2) {
            // Simple crossover
            return c1.substring(0, 2) + c2.substring(2);
        }
    }
    
    public static void geneticAlgorithmDemo() throws InterruptedException {
        new GeneticAlgorithm().run();
        Thread.sleep(3000);
        
        /**
         * USE CASE:
         * - Genetic algorithms (population exchange)
         * - Parallel simulations
         * - Cross-pollination of solutions
         */
    }
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== Basic Demo ===");
        basicDemo();
        
        System.out.println("\n=== Producer-Consumer ===");
        producerConsumerDemo();
        
        System.out.println("\n=== Genetic Algorithm ===");
        geneticAlgorithmDemo();
    }
}
```

---

## 6. Use Case Comparison

### Decision Guide

```java
/**
 * SYNCHRONIZER SELECTION GUIDE
 */

public class SynchronizerComparison {
    
    public void comparisonTable() {
        /**
         * ┌──────────────────┬───────────────┬──────────────┬─────────────────┐
         * │ Synchronizer     │ Parties       │ Reusable     │ Best For        │
         * ├──────────────────┼───────────────┼──────────────┼─────────────────┤
         * │ CountDownLatch   │ Fixed         │ No           │ One-time events │
         * │ CyclicBarrier    │ Fixed         │ Yes          │ Recurring sync  │
         * │ Semaphore        │ N/A (permits) │ Yes          │ Resource limit  │
         * │ Phaser           │ Dynamic       │ Yes          │ Multi-phase     │
         * │ Exchanger        │ 2 only        │ Yes          │ Thread pairs    │
         * └──────────────────┴───────────────┴──────────────┴─────────────────┘
         */
    }
    
    public void useCaseGuide() {
        /**
         * USE COUNTDOWNLATCH WHEN:
         * 
         * ✓ Waiting for multiple tasks to complete
         * ✓ One-time coordination
         * ✓ Application startup
         * ✓ Test coordination
         * 
         * EXAMPLE:
         * - Wait for all services to initialize
         * - Wait for all threads to finish
         * - Race start signal
         * 
         * 
         * USE CYCLICBARRIER WHEN:
         * 
         * ✓ Iterative algorithms
         * ✓ Recurring synchronization points
         * ✓ Fixed number of parties
         * ✓ Need barrier action
         * 
         * EXAMPLE:
         * - Matrix multiplication phases
         * - Parallel simulations
         * - MapReduce stages
         * 
         * 
         * USE SEMAPHORE WHEN:
         * 
         * ✓ Limiting concurrent access
         * ✓ Resource pooling
         * ✓ Rate limiting
         * ✓ Throttling
         * 
         * EXAMPLE:
         * - Connection pools
         * - Thread pools
         * - API rate limiting
         * - Parking lots
         * 
         * 
         * USE PHASER WHEN:
         * 
         * ✓ Dynamic number of parties
         * ✓ Multi-phase operations
         * ✓ Parties can join/leave
         * ✓ Complex synchronization
         * 
         * EXAMPLE:
         * - Iterative computations
         * - Fork/join style tasks
         * - Tiered phaser hierarchies
         * 
         * 
         * USE EXCHANGER WHEN:
         * 
         * ✓ Exactly two threads
         * ✓ Bidirectional data exchange
         * ✓ Buffer swapping
         * ✓ Pipeline stages
         * 
         * EXAMPLE:
         * - Producer-consumer buffers
         * - Genetic algorithms
         * - Double buffering
         */
    }
    
    public void performanceComparison() {
        /**
         * PERFORMANCE CHARACTERISTICS:
         * 
         * CountDownLatch:
         * - await(): O(1) if count is 0, else blocks
         * - countDown(): O(1) CAS operation
         * - Very lightweight
         * 
         * CyclicBarrier:
         * - await(): O(1) + lock acquisition
         * - Slightly heavier than CountDownLatch
         * - Barrier action adds overhead
         * 
         * Semaphore:
         * - acquire(): O(1) CAS or blocking
         * - release(): O(1) CAS
         * - Fair mode: FIFO queue (slower)
         * 
         * Phaser:
         * - arrive*(): O(1) but most complex
         * - Supports tiering (tree structure)
         * - More overhead than others
         * 
         * Exchanger:
         * - exchange(): Blocks until partner
         * - Optimized for two threads
         * - Spin-wait optimization
         */
    }
    
    /**
     * Code examples comparison
     */
    public void codeComparison() throws Exception {
        int workers = 3;
        
        // CountDownLatch
        CountDownLatch latch = new CountDownLatch(workers);
        // workers do work
        latch.countDown();  // Each worker
        latch.await();      // Main thread waits
        
        // CyclicBarrier
        CyclicBarrier barrier = new CyclicBarrier(workers);
        // workers do work
        barrier.await();    // Each worker waits
        // All released together, can reuse
        
        // Semaphore
        Semaphore semaphore = new Semaphore(workers);
        semaphore.acquire();  // Get permit
        // use resource
        semaphore.release();  // Return permit
        
        // Phaser
        Phaser phaser = new Phaser(workers);
        phaser.arriveAndAwaitAdvance();  // Wait at phase boundary
        // Can have multiple phases
        
        // Exchanger
        Exchanger<String> exchanger = new Exchanger<>();
        String data = exchanger.exchange("my data");  // Swap with partner
    }
}
```

---

## Summary

### Quick Reference

**CountDownLatch:**

```java
CountDownLatch latch = new CountDownLatch(3);

// Workers
latch.countDown();  // Decrement count

// Main thread
latch.await();  // Wait until count = 0

// With timeout
boolean done = latch.await(5, TimeUnit.SECONDS);
```

**CyclicBarrier:**

```java
CyclicBarrier barrier = new CyclicBarrier(3, () -> {
    System.out.println("Barrier action");
});

// Each worker
barrier.await();  // Wait for all parties

// Reusable for multiple cycles
```

**Semaphore:**

```java
Semaphore semaphore = new Semaphore(5);  // 5 permits

semaphore.acquire();  // Get permit (blocks if none)
try {
    // Use resource
} finally {
    semaphore.release();  // Return permit
}

// Non-blocking
if (semaphore.tryAcquire(1, TimeUnit.SECONDS)) {
    // Got permit
}
```

**Phaser:**

```java
Phaser phaser = new Phaser(3);  // 3 parties

// Each party
phaser.arriveAndAwaitAdvance();  // Wait at phase boundary

// Dynamic
phaser.register();  // Add party
phaser.arriveAndDeregister();  // Remove party
```

**Exchanger:**

```java
Exchanger<Buffer> exchanger = new Exchanger<>();

// Thread 1
Buffer myBuffer = fullBuffer;
Buffer emptyBuffer = exchanger.exchange(myBuffer);

// Thread 2
Buffer myBuffer = emptyBuffer;
Buffer fullBuffer = exchanger.exchange(myBuffer);
```

### Best Practices

1. ✅ Use CountDownLatch for one-time coordination
2. ✅ Use CyclicBarrier for iterative algorithms
3. ✅ Use Semaphore for resource pools (always release in finally!)
4. ✅ Use Phaser for dynamic parties or complex multi-phase
5. ✅ Use Exchanger for efficient buffer swapping
6. ✅ Handle InterruptedException properly
7. ✅ Use timeout variants to prevent indefinite blocking
8. ❌ Don't reuse CountDownLatch (use CyclicBarrier instead)
9. ❌ Don't forget to release semaphore permits
10. ❌ Don't use Exchanger for >2 threads

### Common Patterns

**Application Startup:**

```java
CountDownLatch startupLatch = new CountDownLatch(3);
startDatabase().thenRun(startupLatch::countDown);
startCache().thenRun(startupLatch::countDown);
startWebServer().thenRun(startupLatch::countDown);
startupLatch.await();
```

**Connection Pool:**

```java
Semaphore available = new Semaphore(maxConnections);
Connection conn = getConnection() {
    available.acquire();
    return pool.get();
}
void release(Connection conn) {
    pool.put(conn);
    available.release();
}
```

**Parallel Computation:**

```java
CyclicBarrier barrier = new CyclicBarrier(workers);
for (phase = 0; phase < iterations; phase++) {
    doWork();
    barrier.await();  // Synchronize after each phase
}
```

---

